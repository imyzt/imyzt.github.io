<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="">
<meta name="description" content="分享我的技术和生活">
<meta name="theme-color" content="">
<title>MySQL Explain 详解 | 杨镇涛的一亩三分地</title>
<link rel="shortcut icon" href="/favicon.ico?v=1758599657093">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/pisces.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/github.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



  <meta name="description" content="MySQL Explain 详解" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>杨镇涛的一亩三分地</span>
            </a>  
          
        </div>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://imyzt.top/post/mysql-explain-xiang-jie/">
      MySQL Explain 详解
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2022-02-27</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>25分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>5279<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <p>详细讲解每一列的作用，当做字典查看。</p>
<h1 id="前置知识">前置知识</h1>
<h2 id="半连接">半连接</h2>
<h2 id="子查询物化">子查询物化</h2>
<h2 id="索引合并">索引合并</h2>
<h1 id="table">table</h1>
<p>无论查询语句中包含多少张表，最终都会转换为对单表的访问，所以EXPLAIN语句输出的每条记录都对应着对单表的访问方法，<strong>也即table列代表着表名</strong>。</p>
<h2 id="普通单表">普通单表</h2>
<pre><code>mysql&gt; explain select * from s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<h2 id="普通连接查询">普通连接查询</h2>
<pre><code>mysql&gt; explain select * from s1 join s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL                                  |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
2 rows in set, 1 warning (0.00 sec)
</code></pre>
<h1 id="id">id</h1>
<p>查询语句中，为每个select分配一个唯一id，当语句中包含多个select时（union、子查询），id的大小表示不同select的查询先后顺序。<br>
当id相同table不同时（一般出现在连接语句），在前面的表示驱动表，在后面的是被驱动表。</p>
<h2 id="普通单id">普通单id</h2>
<pre><code>mysql&gt; explain select * from s1 where key1 = 'a';
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<h2 id="复杂连接语句">复杂连接语句</h2>
<p>语句中，id相同，s1是驱动表，s2是被驱动表。</p>
<pre><code>mysql&gt; explain select * from s1 join s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL                                  |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
2 rows in set, 1 warning (0.00 sec)
</code></pre>
<p>语句中，id不同，表示MySQL先查询s1，后查询s2。</p>
<pre><code>mysql&gt; explain select * from s1 where key1 in (select id from s2) or key2 = 'b';
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key2      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where |
|  2 | SUBQUERY    | s2    | NULL       | index | PRIMARY       | idx_key2 | 5       | NULL | 10143 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
2 rows in set, 2 warnings (0.01 sec)
</code></pre>
<h2 id="语句优化子查询转连接">语句优化（子查询转连接）</h2>
<p>虽然语句属于子查询，理应分配2个id，但是执行计划看出来只有id=1，因为在MySQL优化器将这种明显可以转换为连接查询优化速度的语句改写为连接查询了。<br>
可以通过后面的<code>show warnings ;</code>语句查看code=1003的优化过程。</p>
<pre><code>mysql&gt; explain select * from s1 where key1 in (select id from s2 where key1 = 'b');
+----+-------------+-------+------------+------+------------------+----------+---------+-------+-------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys    | key      | key_len | ref   | rows  | filtered | Extra                                              |
+----+-------------+-------+------------+------+------------------+----------+---------+-------+-------+----------+----------------------------------------------------+
|  1 | SIMPLE      | s2    | NULL       | ref  | PRIMARY,idx_key1 | idx_key1 | 303     | const |     1 |   100.00 | Using index                                        |
|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1         | NULL     | NULL    | NULL  | 10143 |    10.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+------------------+----------+---------+-------+-------+----------+----------------------------------------------------+
2 rows in set, 3 warnings (0.00 sec)

mysql&gt; show warnings ;
| Level   | Code | Message
| Note    | 1003 | select 此处省略一堆查询列节省篇幅 from `xiaohaizi`.`s2` join `xiaohaizi`.`s1` where ((`xiaohaizi`.`s2`.`key1` = 'b') and (`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`id`)) |
3 rows in set (0.00 sec)
</code></pre>
<h2 id="去重临时表">去重临时表</h2>
<p>当语句使用union对结果进行合并时，会使用临时表对结果进行去重。所以生成一个id=null的结果集。<br>
当使用union all时，因为不需要对结果进行去重，故不会产生NULL记录。</p>
<pre><code>mysql&gt; explain select * from s1 union select * from s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL            |
| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
3 rows in set, 1 warning (0.02 sec)

mysql&gt; mysql&gt; explain select * from s1 union all select * from s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
2 rows in set, 1 warning (0.01 sec)
</code></pre>
<h1 id="select_type">select_type</h1>
<p>MySQL为每个select关键字代表的小查询都定义了一个名为select_type的属性，只要知道了小查询的select_type属性，也就知道了这个小查询在大查询中的角色。</p>
<h2 id="simple">SIMPLE</h2>
<p>查询语句中不包含union或者子查询，就是简单的查询就是<code>SIMPLE</code>。</p>
<pre><code>mysql&gt; explain select * from s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; explain select * from s1 join s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL                                  |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
2 rows in set, 1 warning (0.01 sec)
</code></pre>
<h2 id="primary">PRIMARY</h2>
<p>对于union/union all/或者子查询等大查询来说，是有多个小查询组合而来的，最左边的那个查询就是<code>PRIMARY</code>。</p>
<pre><code>mysql&gt; explain select * from s1 union all select * from s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
2 rows in set, 1 warning (0.01 sec)
</code></pre>
<h2 id="union">UNION</h2>
<p>对于union/union all/或者子查询等大查询来说，是有多个小查询组合而来的，除最左边的那个查询是<code>PRIMARY</code>外，其余所有小查询都是<code>UNION</code>，执行计划同上。</p>
<h2 id="union-result">UNION RESULT</h2>
<p>MySQL选择使用临时表来完成UNION查询的去重工作，针对此临时表select_type就是<code>UNION RESULT</code>，执行计划同「去重临时表」章节。</p>
<h2 id="subquery">SUBQUERY</h2>
<p>如果包含子查询的语句<strong>不能转换为对应的半连接形式</strong>，<strong>并且该子查询是不相关子查询</strong>，而且查询优化器决定采用<strong>子查询物化</strong>的方案来执行该子查询时，select_type就是<code>SUBQUERY</code>。</p>
<pre><code>mysql&gt; explain select * from s1 where key1 in (select key2 from s2) or key3 = 'b';
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where |
|  2 | SUBQUERY    | s2    | NULL       | index | idx_key2      | idx_key2 | 5       | NULL | 10143 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
2 rows in set, 1 warning (0.01 sec)
</code></pre>
<h2 id="dependent-subquery">DEPENDENT SUBQUERY</h2>
<p>如果包含子查询的查询语句不能转换为对应的半连接形式，并且该子查询被查询优化器转换为相关子查询的形式，则该子查询的第一个select关键字代表的那个查询的select_type就是<code>DEPENDENT SUBQUERY</code>。<br>
select_type=<code>DEPENDENT SUBQUERY</code>的子查询可能会被执行多次。</p>
<pre><code>mysql&gt; explain select * from s1 where key1 in (select key2 from s2 where s1.key2 = s2.key2) or key3 = 'b';
+----+--------------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+--------------------------+
| id | select_type        | table | partitions | type   | possible_keys | key      | key_len | ref               | rows  | filtered | Extra                    |
+----+--------------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+--------------------------+
|  1 | PRIMARY            | s1    | NULL       | ALL    | idx_key3      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where              |
|  2 | DEPENDENT SUBQUERY | s2    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | xiaohaizi.s1.key2 |     1 |   100.00 | Using where; Using index |
+----+--------------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+--------------------------+
2 rows in set, 2 warnings (0.01 sec)
</code></pre>
<h2 id="dependent-union">DEPENDENT UNION</h2>
<p>在包含union或union all的大查询中，如果各个小查询都依赖外层查询，则除了最左边的小查询<code>select_type=DEPENDENT SUBQUERY</code>外，其余小查询都是<code>DEPENDENT UNION</code>。</p>
<pre><code>mysql&gt; explain select * from s1 where key1 in (select key2 from s2 union select key3 from s2 union select key1 from s2) or key3 = 'b';
+----+--------------------+--------------+------------+------+---------------+----------+---------+------+-------+----------+--------------------------+
| id | select_type        | table        | partitions | type | possible_keys | key      | key_len | ref  | rows  | filtered | Extra                    |
+----+--------------------+--------------+------------+------+---------------+----------+---------+------+-------+----------+--------------------------+
|  1 | PRIMARY            | s1           | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where              |
|  2 | DEPENDENT SUBQUERY | s2           | NULL       | ref  | idx_key2      | idx_key2 | 5       | func |     1 |   100.00 | Using where; Using index |
|  3 | DEPENDENT UNION    | s2           | NULL       | ref  | idx_key3      | idx_key3 | 303     | func |     1 |   100.00 | Using index              |
|  4 | DEPENDENT UNION    | s2           | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |     1 |   100.00 | Using index              |
| NULL | UNION RESULT       | &lt;union2,3,4&gt; | NULL       | ALL  | NULL          | NULL     | NULL    | NULL |  NULL |     NULL | Using temporary          |
+----+--------------------+--------------+------------+------+---------------+----------+---------+------+-------+----------+--------------------------+
5 rows in set, 1 warning (0.01 sec)
</code></pre>
<h2 id="derived">DERIVED</h2>
<p>在包含派生表的查询中，如果是以物化派生表的方式执行查询，则派生表对应的子查询的<code>select_type=DERIVED</code>。</p>
<pre><code>mysql&gt; explain select * from (select key1, count(*) as total from s2  group by key1) t where total &gt; 1;
+----+-------------+------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
| id | select_type | table      | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 10143 |    33.33 | Using where |
|  2 | DERIVED     | s2         | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 10143 |   100.00 | Using index |
+----+-------------+------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
</code></pre>
<h2 id="materialized">MATERIALIZED</h2>
<p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询，该子查询对应的select_type=<code>MATERIALIZED</code>。</p>
<p>第三条记录的select_type=MATERIALIZED，说明优化器将子查询先转换为物化表，执行计划的前两条记录的id都=1，说明这两条记录对应的表进行的是连接查询。<br>
<strong>第二条记录的table列的值是<subquery2>，说明该表其实就是执行计划中id为2对应的子查询执行之后产生的物化表，然后再将s1和该物化表进行连接查询。</strong></p>
<pre><code>mysql&gt; explain select * from s1 where key1 in (select key1 from s2);
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+-------------------+-------+----------+-------------+
| id | select_type  | table       | partitions | type   | possible_keys       | key                 | key_len | ref               | rows  | filtered | Extra       |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1            | NULL                | NULL    | NULL              | 10143 |   100.00 | Using where |
|  1 | SIMPLE       | &lt;subquery2&gt; | NULL       | eq_ref | &lt;auto_distinct_key&gt; | &lt;auto_distinct_key&gt; | 303     | xiaohaizi.s1.key1 |     1 |   100.00 | NULL        |
|  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1            | idx_key1            | 303     | NULL              | 10143 |   100.00 | Using index |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+-------------------+-------+----------+-------------+
3 rows in set, 1 warning (0.01 sec)
</code></pre>
<h2 id="uncacheable-subquery-uncacheable-union">UNCACHEABLE SUBQUERY、UNCACHEABLE UNION</h2>
<ul>
<li>UNCACHEABLE SUBQUERY：对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）</li>
<li>UNCACHEABLE UNION：UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY）</li>
</ul>
<h1 id="partitions">partitions</h1>
<p>版本5.7以前，该项是explain partitions显示的选项，5.7以后成为了默认选项。该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。</p>
<h1 id="type">type</h1>
<p>表示单表的访问方法，最为核心的字段之一。</p>
<h2 id="system">system</h2>
<p>当表只有一条记录且该表的存储引擎为MyISAM、MEMORY时，为<code>SYSTEM</code>。</p>
<h2 id="const">const</h2>
<p>根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法为<code>const</code>。</p>
<h2 id="eq_ref">eq_ref</h2>
<p>执行连接查询时，如果<strong>被驱动表</strong>是通过主键或者不允许存储NULL值的唯一二级索引列等值匹配的方式进行访问的（如果该主键或者不允许存储NULL值的唯一二级索引是联合索引，则所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref。</p>
<pre><code>mysql&gt; explain select * from s1 join s2 where s1.id = s2.id; --通过主键索引访问s2
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+-------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows  | filtered | Extra |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+-------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 10143 |   100.00 | NULL  |
|  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |     1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+-------+----------+-------+
2 rows in set, 1 warning (0.00 sec)

mysql&gt; explain select * from s1 join s2 on s1.key2 = s2.key2; --通过唯一二级索引访问s2
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | ALL    | idx_key2      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where |
|  1 | SIMPLE      | s2    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | xiaohaizi.s1.key2 |     1 |   100.00 | NULL        |
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)

mysql&gt; explain select * from s1 join s2 on s1.key2 = s2.key3; --通过唯一二级索引访问s1，注意这里是s1做被驱动表！！
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-----------------------+
| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref               | rows  | filtered | Extra                 |
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-----------------------+
|  1 | SIMPLE      | s2    | NULL       | ALL    | idx_key3      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where           |
|  1 | SIMPLE      | s1    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | xiaohaizi.s2.key3 |     1 |   100.00 | Using index condition |
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-----------------------+
2 rows in set, 2 warnings (0.00 sec)
</code></pre>
<h2 id="ref">ref</h2>
<p>当通过普通二级索引列与常量进行等值匹配的方式来查询某个表时，对该表的访问方法就可能是ref。</p>
<pre><code>mysql&gt; explain select * from s1 join s2 on s1.key3 = s2.key3;
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where |
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key3      | idx_key3 | 303     | xiaohaizi.s2.key3 |     1 |   100.00 | NULL        |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
</code></pre>
<h2 id="fulltext">fulltext</h2>
<p>全文索引。</p>
<h2 id="ref_or_null">ref_or_null</h2>
<p>当对普通二级索引列进行等值匹配<strong>且该索引列的值也可以是NULL值</strong>时，记为ref_or_null。</p>
<pre><code>mysql&gt; explain select * from s1 where key1 = 'a' or key1 is null;
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | s1    | NULL       | ref_or_null | idx_key1      | idx_key1 | 303     | const |    2 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.01 sec)
</code></pre>
<h2 id="index_merge">index_merge</h2>
<p>一般情况下只会为单个索引生成扫描区间，但当在某些场景下可以使用Intersection、union、sort-union进行索引合并。</p>
<pre><code>mysql&gt; explain select * from s1 where key1 = 'a' or key3 = 'b';
+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |
+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |
+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
1 row in set, 1 warning (0.01 sec)
</code></pre>
<h2 id="unique_subquery">unique_subquery</h2>
<p>类似于两表连接中被驱动表的eq_ref访问方法。针对一些包含in子查询的查询语句。如果查询优化器决定将in子查询转换为exists子查询，而且子查询<strong>在转换后可以使用主键或唯一二级索引进行等值匹配</strong>，记为<code>unique_subquery</code>。</p>
<pre><code>mysql&gt; explain select * from s1 where common_field in (select id「这里主键/唯一二级索引是核心」 from s2 where s1.common_field = s2.common_field ) or key3 = 'b';
+----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+
| id | select_type        | table | partitions | type            | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |
+----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+
|  1 | PRIMARY            | s1    | NULL       | ALL             | idx_key3      | NULL    | NULL    | NULL | 10143 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | s2    | NULL       | unique_subquery | PRIMARY       | PRIMARY | 4       | func |     1 |    10.00 | Using where |
+----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+
2 rows in set, 2 warnings (0.01 sec)
</code></pre>
<h2 id="index_subquery">index_subquery</h2>
<p>类似于unique_subquery，只不过在访问子查询中的表时使用的是普通的索引。</p>
<pre><code>mysql&gt; explain select * from s1 where common_field in (select key3「这里是普通索引」 from s2 where s1.common_field = s2.common_field ) or key3 = 'b';
+----+--------------------+-------+------------+----------------+---------------+----------+---------+------+-------+----------+-------------+
| id | select_type        | table | partitions | type           | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
+----+--------------------+-------+------------+----------------+---------------+----------+---------+------+-------+----------+-------------+
|  1 | PRIMARY            | s1    | NULL       | ALL            | idx_key3      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | s2    | NULL       | index_subquery | idx_key3      | idx_key3 | 303     | func |     1 |    10.00 | Using where |
+----+--------------------+-------+------------+----------------+---------------+----------+---------+------+-------+----------+-------------+
2 rows in set, 2 warnings (0.00 sec)
</code></pre>
<h2 id="range">range</h2>
<p>如果使用索引获取某些单点扫描区间的记录，那么就可能使用到range访问方法。</p>
<pre><code>mysql&gt; explain select * from s1 where key3 in ('a','b','c','abc');
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | s1    | NULL       | range | idx_key3      | idx_key3 | 303     | NULL |    4 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<h2 id="index">index</h2>
<p>当可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index。</p>
<ul>
<li>InnoDB特殊的点：当我们需要执行全表扫描，并且需要对主键进行排序时，type列的值也是index。</li>
</ul>
<pre><code>mysql&gt; explain select key_part2 from s1 where key_part2 = 'ab';
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | s1    | NULL       | index | idx_key_part  | idx_key_part | 909     | NULL | 10143 |    10.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<h2 id="all">all</h2>
<p>全表扫描。</p>
<h1 id="possible_keys-key">possible_keys、key</h1>
<ul>
<li>possible_keys：可能使用的索引。</li>
<li>key：实际用到的索引。</li>
</ul>
<p>注意点：</p>
<ul>
<li>possible_keys当type=index时显示为空，此时key展示的是实际使用的索引。</li>
<li>possible_keys不是越多越好，越多查询优化器在计算查询成本时花费的时间就越长，尽可能删除用不到的索引。</li>
</ul>
<h1 id="key_len">key_len</h1>
<p>表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。<strong>在不损失精确性的情况下，长度越短越好</strong>。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，<strong>即key_len是根据表定义计算而得</strong>，不是通过表内检索出来的。</p>
<h1 id="ref-2">ref</h1>
<p>当访问方法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery中的其中一个时，<strong>ref列展示的就是与索引列进行等值匹配的东西是什么</strong>。</p>
<ol>
<li>常量，即右侧的值<code>'1'</code>为常量。</li>
</ol>
<pre><code>mysql&gt; explain select * from s1 where id = '1';
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<ol start="2">
<li>某个列，比如下面s2作为被驱动表时，s2的type=ref，ref=xiaohaizi.s1.key1</li>
</ol>
<pre><code>mysql&gt; explain select * from s1 join s2 on s1.key1 = s2.key1;
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 12242 |   100.00 | Using where |
|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |     1 |   100.00 | NULL        |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
</code></pre>
<ol start="3">
<li>某个函数，比如下面s2作为被驱动表时，s2的type=ref，ref=func表示进行了函数操作。</li>
</ol>
<pre><code>mysql&gt; explain select * from s1 join s2 on s1.key1 = upper(s2.key1);
+----+-------------+-------+------------+------+---------------+----------+---------+------+-------+----------+-----------------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows  | filtered | Extra                 |
+----+-------------+-------+------------+------+---------------+----------+---------+------+-------+----------+-----------------------+
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 12558 |   100.00 | NULL                  |
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |     1 |   100.00 | Using index condition |
+----+-------------+-------+------------+------+---------------+----------+---------+------+-------+----------+-----------------------+
2 rows in set, 1 warning (0.00 sec)
</code></pre>
<h1 id="rows">rows</h1>
<ul>
<li>在查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表该表的估算行数。</li>
<li>如果使用索引来执行查询，执行计划的rows列就代表预计扫描的索引记录行数。</li>
</ul>
<pre><code>mysql&gt; explain select * from s1 where key1 &gt; 'z';
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
</code></pre>
<h1 id="filtered">filtered</h1>
<p>计算MySQL驱动表扇出的一种策略。</p>
<ul>
<li>如果使用全表扫描执行单表查询，那么计算驱动表扇出时需要估计出全部搜索条件的记录到底有多少条。</li>
<li>如果使用索引来执行单表查询，<strong>那么计算驱动表扇出时需要估计出满足形成索引扫描区间的搜索条件外，还满足其他搜索条件的记录有多少条。</strong></li>
</ul>
<p>在单表查询时没太大意义，在连表查询时对估算执行次数有帮助。</p>
<p>下表中，s1做驱动表，s2做被驱动表，s1的filtered=10，rows=12242，12242* 10%=1224.2，s2的filtered=100，rows=1，表示还要对被驱动表执行答曰1224次查询。</p>
<pre><code>mysql&gt; explain select * from s1 join s2 on s1.key1 = s2.key1 where s1.common_field = 'a';
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 12242 |    10.00 | Using where |
|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |     1 |   100.00 | NULL        |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
2 rows in set, 1 warning (0.01 sec)
</code></pre>
<h1 id="extra">Extra</h1>
<p>展示额外信息时使用，比较多，此处按照书中描述，只记录常出现的内容。</p>
<h2 id="no-tables-used">No tables used</h2>
<p>当查询语句中没有FROM子句时，会提示。比如<code>SELECT 1</code>之类。</p>
<h2 id="impossible-where">Impossible WHERE</h2>
<p>查询语句的WHERE子句永远为FALSE时，会提示。比如<code>SELECT * FROM s1 WHERE 1 &lt;&gt; 1</code>。</p>
<h2 id="no-matching-minmax-row">No matching min/max row</h2>
<p>当查询列表处有MIN或MAX聚集函数，但是没有记录符合WHERE子句中的搜索条件时，会提示。比如<code>SELECT min(key1) FROM s1 WHERE key1 = '一个不存在的值'</code>。</p>
<h2 id="using-index">Using index</h2>
<p>使用覆盖索引执行查询时，<strong>不用回表</strong>，会提示。比如<code>SELECT key1 FROM s1 WHERE key1 = 'a'</code>。</p>
<h2 id="using-index-condition">Using index condition</h2>
<p>搜索条件中虽然出现了索引列，但却不能充当边界条件来形成扫描区间，<strong>也就是说不能用来减少需要扫描的记录数量</strong>，会提示。<br>
比如：<code>SELECT * FROM s1 WHERE key1 &gt; 'z' AND key1 LIKE '%a'</code>，其中的<code>key1 &gt; 'z'</code>可以用来形成扫描区间，但是<code>key1 LIKE '%a'</code>却不能。<br>
即索引覆盖（索引下推）达成条件。<br>
只对于二级索引有效，对于二级索引等值判断不生效（这时Extra=NULL），对于主键索引不生效（直接查数据）。</p>
<h2 id="using-where">Using where</h2>
<p>当某个搜索条件需要在server层进行判断时，在Extra列会提示，比如索引覆盖没有达成的情况。<br>
<code>SELECT * FROM s1 WHERE key1 = 'a' AND common_field = 'a'</code>，由于comon_field无法在引擎层判断，只能通过key1形成扫描区间后，在server层判断。</p>
<h2 id="using-join-bufferblock-nested-loop">Using join buffer（Block Nested Loop）</h2>
<p>在连接过程中，当被驱动表不能有效的利用索引加快访问速度时，MySQL会分配一块JoinBuffer内存块来加快查询速度，基于块的嵌套循环算法执行连接查询。</p>
<h2 id="using-intersect-using-union和using-sort_union">Using intersect(...)、Using union(...)和Using sort_union(...)</h2>
<ul>
<li>intersect：准备使用Intersection索引合并的方式执行查询，括号中包含需要合并的索引名称。</li>
<li>union：准备使用union索引合并方式执行查询。</li>
<li>sort_union：准备使用Sort-Union索引合并的方式执行查询。</li>
</ul>
<h2 id="zero_limit">zero_limit</h2>
<p>当Limit子句参数为0时，会提示。</p>
<h2 id="using-filesort">Using filesort</h2>
<p>对结果集中记录进行排序时，使用索引则不会出现，但很多情况无法使用索引进行排序，则会出现filesort。</p>
<h2 id="using-temporary">Using temporary</h2>
<p>MySQL利用临时表完成去重、排序时。<br>
比如DISTINCT、GROUP BY、UNION等子句查询过程中如无法使用索引则会提示。</p>
<h2 id="start-temporaryend-temporary">Start temporary，End temporary</h2>
<p>子查询时，查询优化器会优先尝试将IN子查询转换为半连接。半连接有很多种策略，当选择Duplicate Weedout时，也就是通过建立临时表来为外城查询中的记录进行去重操作时，驱动表查询执行计划的Extra列将显示Start temporary，被驱动表则会显示End temporary。</p>
<h2 id="loosescan">LooseScan</h2>
<p>在将IN子查询转换为半连接时，如果采用的是LooseScan执行策略，则驱动表执行计划的Extra列就显示LooseScan提示。</p>
<h2 id="firstmatchtable_name">FirstMatch(table_name)</h2>
<p>在将IN子查询转换为半连接时，如果采用的是FirstMatch执行策略，则被驱动表执行计划的Extra列就显示FirstMatch提示。</p>
<h1 id="建表和1w条数据">建表和1w条数据</h1>
<h2 id="表">表</h2>
<pre><code>CREATE TABLE s1 (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;

CREATE TABLE s2 (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
</code></pre>
<h2 id="插入数据">插入数据</h2>
<pre><code>
delimiter $
create procedure insertNData(n int)
begin
    declare total int default 0;
    declare num int default 1;
    while total &lt;= n
        do
            set total = total + 1;
            set num = num + 1;
            INSERT INTO xiaohaizi.s1 (id, key1, key2, key3, key_part1, key_part2, key_part3, common_field)
            VALUES (null, substring(md5(rand()), 1, 10), floor(rand() * 100000000), substring(md5(rand()), 1, 10),
                    substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10),
                    substring(md5(rand()), 1, 10));
            INSERT INTO xiaohaizi.s2 (id, key1, key2, key3, key_part1, key_part2, key_part3, common_field)
            VALUES (null, substring(md5(rand()), 1, 10), floor(rand() * 100000000), substring(md5(rand()), 1, 10),
                    substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10),
                    substring(md5(rand()), 1, 10));
        end while;
    select count(*) from xiaohaizi.s1;
end $

call insertNData(10000) $


</code></pre>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://imyzt.top/post/mysql-explain-xiang-jie/" title="MySQL Explain 详解">https://imyzt.top/post/mysql-explain-xiang-jie/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="老版本ikbc c87 win(option)在Mac无法使用问题解决方案" href="https://imyzt.top/post/lao-ban-ben-ikbc-c87-winoptionzai-mac-wu-fa-shi-yong-wen-ti-jie-jue-fang-an/">老版本ikbc c87 win(option)在Mac无法使用问题解决方案</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="老版本ikbc c87 win(option)在Mac无法使用问题解决方案" href="https://imyzt.top/post/lao-ban-ben-ikbc-c87-winoptionzai-mac-wu-fa-shi-yong-wen-ti-jie-jue-fang-an/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="MySQL单表/连接访问方法" href="https://imyzt.top/post/mysql-dan-biao-lian-jie-fang-wen-fang-fa/">MySQL单表/连接访问方法</a>
        <a class="nav-mobile-next" title="MySQL单表/连接访问方法" href="https://imyzt.top/post/mysql-dan-biao-lian-jie-fang-wen-fang-fa/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '8c8c4510f7772ba5faa4',
    clientSecret: 'ac9076bf38b8c0145a974b50f3361d432c46deda',
    repo: 'imyzt.github.io',
    owner: 'imyzt',
    admin: ['imyzt'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/imyzt" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    <div class="bg-img">
      <img src="" />
    </div>
  
  
  
    

  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = ''
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mcp-chu-ti-yan-trae-jie-ru-mysql-mcp-server/"" data-c="
          &lt;p&gt;关于 &lt;code&gt;MCP&lt;/code&gt; 是什么就不在此赘述，可以看这篇文章：&lt;a href=&#34;https://docs.trae.com.cn/ide/model-context-protocol&#34;&gt;模型上下文协议（MCP）&lt;br&gt;
&lt;/a&gt;，目前 &lt;code&gt;Trae&lt;/code&gt; 已经支持 &lt;code&gt;MCP&lt;/code&gt;，网上还没有什么教程，本文记录下自己安装的过程。&lt;/p&gt;
&lt;h1 id=&#34;1-首先安装-trae-海外版&#34;&gt;1. 首先安装 Trae 海外版&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.trae.ai/&#34;&gt;https://www.trae.ai/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-在-chat-中通过-唤起-添加智能体&#34;&gt;2. 在 &lt;code&gt;Chat&lt;/code&gt; 中通过 &lt;code&gt;@&lt;/code&gt; 唤起: &lt;code&gt;添加智能体&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;按照下面的步骤添加一个 &lt;code&gt;MCP Server&lt;/code&gt;，此处以 &lt;code&gt;MySQL MCP Server&lt;/code&gt; 为例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imyzt.top/post-images/1749265319195.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1749265326233.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1749265331930.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1749265337881.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-根据-mysql-mcp-server-的-github-page-页面安装依赖&#34;&gt;3. 根据 MySQL MCP Server 的 Github Page 页面安装依赖&lt;/h1&gt;
&lt;p&gt;安装完成后，点击上图预览，即可打开Github查看该MCP Server的安装教程。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1749265511011.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;官方使用 &lt;code&gt;pip install mysql-mcp-server&lt;/code&gt; 进行安装，但我安装老是失败，通过搜索issue，发现也有类似的情况， &lt;a href=&#34;https://github.com/designcomputer/mysql_mcp_server/issues/33&#34;&gt;issue&lt;/a&gt; 建议使用 &lt;code&gt;uv pip install mysql-mcp-server&lt;/code&gt; 进行安装，我切换为 &lt;code&gt;uv&lt;/code&gt; 之后就安装成功了。&lt;/p&gt;
&lt;h1 id=&#34;4-配置-mcp-server&#34;&gt;4. 配置 MCP Server&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://imyzt.top/post-images/1749265854609.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击编辑按钮，因为我们使用的是 &lt;code&gt;uv&lt;/code&gt; 安装的 &lt;code&gt;MySQL MCP Server&lt;/code&gt;，所以需要将下面的JSON替换掉官方的默认JSON，然后替换自己的数据库信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;mcpServers&amp;quot;: {
    &amp;quot;MySQL Server&amp;quot;: {
      &amp;quot;command&amp;quot;: &amp;quot;uvx&amp;quot;,
      &amp;quot;args&amp;quot;: [
        &amp;quot;--from&amp;quot;,
        &amp;quot;mysql-mcp-server&amp;quot;,
        &amp;quot;mysql_mcp_server&amp;quot;
      ],
      &amp;quot;env&amp;quot;: {
        &amp;quot;MYSQL_DATABASE&amp;quot;: &amp;quot;dbname&amp;quot;,
        &amp;quot;MYSQL_HOST&amp;quot;: &amp;quot;host&amp;quot;,
        &amp;quot;MYSQL_PASSWORD&amp;quot;: &amp;quot;password&amp;quot;,
        &amp;quot;MYSQL_PORT&amp;quot;: &amp;quot;3306&amp;quot;,
        &amp;quot;MYSQL_USER&amp;quot;: &amp;quot;username&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-使用mcp&#34;&gt;5. 使用MCP&lt;/h1&gt;
&lt;p&gt;配置上面的信息后，就可以在 Chat 中和 MCP 进行对话了，他会协助我们查询数据库。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1749266042790.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1749266277703.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">MCP初体验，Trae接入MySQL MCP Server</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/zai-idea-zhong-guan-li-he-jian-ting-arthas-ying-yong/"" data-c="
          &lt;p&gt;近期和arthas-idea-plugin插件社区沟通，为插件贡献了部分功能，下文为全文转载：&lt;br&gt;
原文链接：&lt;a href=&#34;https://www.yuque.com/arthas-idea-plugin/help/oo75vhvqs6n9gof8?singleDoc#&#34;&gt;《在IDEA中管理和监听arthas应用》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arthas idea plugin&lt;/code&gt; 插件方便了我们使用 &lt;code&gt;Arthas&lt;/code&gt;，对于命令不熟悉同学也可以快速上手排查问题。但是当一个应用有多个实例时，为了监听某一个请求我们通常会打开多个浏览器窗口来启动监听，使用起来多少有点不方便。故扩展了在 &lt;code&gt;IDEA&lt;/code&gt; 内部直接监听的功能。社区内相关 Issue：&lt;a href=&#34;https://github.com/WangJi92/arthas-idea-plugin/issues/92&#34;&gt;https://github.com/WangJi92/arthas-idea-plugin/issues/92&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果团队的工作模式是进入宿主机手动启动&lt;code&gt;Arthas&lt;/code&gt;命令来监听本机应用，那么该插件并不能帮助到这部分用户。插件适用的工作模式是使用&lt;code&gt;Tunnel-Server&lt;/code&gt;和&lt;code&gt;arthas-spring-boot-starter&lt;/code&gt;，将应用注册到&lt;code&gt;Tunnel-Server&lt;/code&gt;且应用部署了多个实例，每次执行监听需要去多个机器监听的痛点场景。&lt;/p&gt;
&lt;h2 id=&#34;插件特性&#34;&gt;插件特性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;基于 &lt;code&gt;arthas idea plugin&lt;/code&gt;，不打断原插件的使用流程，润物细无声。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;IDEA&lt;/code&gt; 内直连 &lt;code&gt;Tunnel-Server&lt;/code&gt;，无需打开浏览器，代码异常可快速定位行号。&lt;/li&gt;
&lt;li&gt;同时连接单应用多实例，无需拷贝命令后打开多个浏览器窗口监听。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;配置插件&#34;&gt;配置插件&lt;/h2&gt;
&lt;h3 id=&#34;添加arthas-tunnel-server地址&#34;&gt;添加Arthas Tunnel-Server地址&lt;/h3&gt;
&lt;p&gt;点击Add按钮，添加&lt;code&gt;Tunnel-Server&lt;/code&gt;(插件不校验地址的正确性，请保证填写的地址准确无误）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Name：可根据自己的情况命名&lt;/li&gt;
&lt;li&gt;TunnelAddress：HTTP服务器地址，插件通过&lt;code&gt;Tunnel-Server&lt;/code&gt;的Web端口获取信息，根据服务器部署填写HTTP/HTTPS协议&lt;/li&gt;
&lt;li&gt;WsAddress：Socket服务器地址，插件和&lt;code&gt;Tunnel-Server Web&lt;/code&gt;端原理一致，伪装成&lt;code&gt;Socket&lt;/code&gt;客户端获取信息和发送指令，根据服务器部署填写WS/WSS协议&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1728813373952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;从列表中删除tunnel-server&#34;&gt;从列表中删除Tunnel-Server&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;选中待删除的行，点击删除即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1728813400527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;直接修改单元格配置&#34;&gt;直接修改单元格配置&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;点击Apply或OK后生效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1728813427232.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;命令窗口打开选择&#34;&gt;命令窗口打开选择&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可选择弹出命令发送窗口，如果不勾选则此功能不会启用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://imyzt.top/post-images/1728813447318.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1728813466340.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用插件&#34;&gt;使用插件&lt;/h2&gt;
&lt;h3 id=&#34;1-选择待监听的应用执行监听&#34;&gt;1. 选择待监听的应用，执行监听&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;选择 NameServer 用以切换环境（Tunnel-Server）&lt;/li&gt;
&lt;li&gt;选择 App 用以切换应用&lt;/li&gt;
&lt;li&gt;选择 Agent 用以切换实例（可选all agents来监听所有实例）&lt;br&gt;
📢：当App/Agent未出现可选项时，请检查配置的TunnelAddress地址是否正确。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1728813504156.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;工具栏介绍&#34;&gt;工具栏介绍&lt;/h3&gt;
&lt;h4 id=&#34;重启rerun&#34;&gt;重启（Rerun）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;类似于 watch、trace 等指令，一般通过 -n 指定了执行几次，如果执行完毕，可以通过此按钮重新开始一次监听。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;调整命令modify&#34;&gt;调整命令（Modify）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;类似于 watch、trace 等指令，假如一开始 -x 的深度不够，需要调整时使用，或监听某些参数时，需要调整SpEL表达式时可以使用。&lt;br&gt;
📢：如需要调整监听的方法或切换其它指令时，建议重新开始而非通过此按钮，操作会更顺畅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;停止stop&#34;&gt;停止（Stop）&lt;/h4&gt;
&lt;p&gt;立即停止监听，类似于 Web UI 上面的 Ctrl+C。&lt;/p&gt;
&lt;h4 id=&#34;清空输出面板clear-all&#34;&gt;清空输出面板（Clear ALL）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;清空输出面板，不会停止监听。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;演示&#34;&gt;演示&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1728813572945.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;执行自定义指令&#34;&gt;执行自定义指令&lt;/h3&gt;
&lt;h4 id=&#34;执行过程中调整其他指令&#34;&gt;执行过程中调整其他指令&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;插件保留了用户自定义输入的入口，可以用于拷贝 Get All Available Command处拷贝的指令。&lt;br&gt;
通过键盘 ↑ ↓键，可以快速切换历史已执行的指令。&lt;br&gt;
回车或点击按钮 Exec 可执行指令。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1728813603660.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;直接执行自定义指令&#34;&gt;直接执行自定义指令&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;为方便直接拷贝指令发送至多个实例执行，在右键菜单注册了 OpenArthasTerminal 用于打开一个空白的对话窗口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://imyzt.top/post-images/1728813642897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1728813647297.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;异常定位行号&#34;&gt;异常定位行号&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1728813654738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;部署tunnel-server&#34;&gt;部署Tunnel-Server&lt;/h2&gt;
&lt;p&gt;在大部分单机的场景下，我们可能直接在机器上运行 java -jar arthas-boot.jar 来运行一个单机版的 Arthas 来监听应用，但在微服务架构下，一个服务可能部署了多个实例，分布在不同的机器上，再登录到机器上挨个运行单机版就较为不便了。&lt;br&gt;
官方也考虑到了这种情况，所以也提供了对应的解决方案，那就是 Arthas Tunnel-Server，下文摘自官网：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过 Arthas Tunnel Server/Client 来远程管理/连接多个 Agent。&lt;br&gt;
比如，在流式计算里，Java 进程可以是在不同的机器启动的，想要使用 Arthas 去诊断会比较麻烦，因为用户通常没有机器的权限，即使登陆机器也分不清是哪个 Java 进程。&lt;br&gt;
在这种情况下，可以使用 Arthas Tunnel Server/Client。&lt;br&gt;
参考:&lt;br&gt;
● 1: Web Console&lt;br&gt;
● 2: Arthas Spring Boot Starter&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;下载并部署-tunnel-server&#34;&gt;下载并部署 Tunnel-Server&lt;/h3&gt;
&lt;p&gt;下载Tunnel-Server（https://github.com/alibaba/arthas/releases），因为Server本身也是一个 jar 包，所以可以直接通过命令启动。&lt;br&gt;
具体细节见官方文档：&lt;a href=&#34;https://arthas.aliyun.com/doc/tunnel.html#tunnel-server-%E7%9A%84%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2&#34;&gt;arthas 官网&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;java -Darthas.enable-detail-pages=true -jar ~/.arthas/arthas-tunnel-server.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1728813731283.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;默认情况下，Arthas Tunnel-Server 的 web 端口是8080，arthas agent连接的端口是7777。&lt;/p&gt;
&lt;h3 id=&#34;启动应用并连接至tunnel-server&#34;&gt;启动应用并连接至Tunnel-Server&lt;/h3&gt;
&lt;p&gt;通常情况下，我们是通过 &lt;code&gt; java -jar arthas-boot.jar&lt;/code&gt; 启动一个 &lt;code&gt;Arthas&lt;/code&gt; 应用来监听本机的 &lt;code&gt;Java&lt;/code&gt; 应用。但如果我们是使用 &lt;code&gt;SpringBoot&lt;/code&gt; 来构建应用，那么更推荐使用 &lt;code&gt;Arthas Spring Boot Starter&lt;/code&gt;（只支持SpringBoot2.+） ，应用启动后，&lt;code&gt;Spring&lt;/code&gt; 会启动 &lt;code&gt;Arthas&lt;/code&gt;，并且 &lt;code&gt;Arrach&lt;/code&gt; 自身的进程。&lt;/p&gt;
&lt;h4 id=&#34;jar-jar-连接-tunnel-server&#34;&gt;jar -jar 连接 tunnel-server&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;java -jar arthas-boot.jar --tunnel-server &#39;ws://127.0.0.1:7777/ws&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;springboot-starter-连接-tunnel-server&#34;&gt;SpringBoot Starter 连接 tunnel-server&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;创建一个SpringBoot的Demo应用。&lt;/li&gt;
&lt;li&gt;引入 Starter 的依赖（当前最新版本 4.0.0）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.taobao.arthas&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;arthas-spring-boot-starter&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;再在 application.properties 文件中指定几个参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;arthas.http-port=0
arthas.telnet-port=0
arthas.app-name=${spring.application.name}-${spring.profiles.active}
arthas.tunnel-server=ws://127.0.0.1:7777/ws
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;启动应用，发现日志中有如下参数就说明配置完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;2024-09-21T23:11:48.536+08:00  INFO 90583 --- [arthas-terminal-demo] [           main] c.a.arthas.spring.ArthasConfiguration    : Arthas agent start success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;tunnel-server的管理页面&#34;&gt;Tunnel-Server的管理页面&lt;/h3&gt;
&lt;p&gt;完成上面的两个步骤之后，打开浏览器访问 http://localhost:8080/apps.html，就可以看到下面的内容了，最终实现在浏览器中监听应用。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1728813863049.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1728813866629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1728813870329.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;建议&#34;&gt;建议&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Tunnel-Server 具备较高权限，官方不建议部署到公网可访问的地址上。&lt;/li&gt;
&lt;li&gt;Tunnel-Server 为内部诊断工具，没有开发对应的权限控制能力，需注意风险。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;工作原理&#34;&gt;工作原理&lt;/h2&gt;
&lt;p&gt;插件主要通过Tunnel-Server Web UI所使用的接口，将其利用起来在IDEA中使用，仅使用其三个接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/api/tunnelApps&lt;/code&gt; 获取所有App&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/api/tunnelAgentInfo?app=&lt;/code&gt; 获取App的所有Agent&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ws?method=connectArthas&amp;amp;id=&amp;amp;targetServer=&lt;/code&gt; 通过WS连接tunnel-server实时通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整体的交互流程如下序列图：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1728813920966.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;其它&lt;br&gt;
目前仅支持部分常用菜单，其它菜单在 IDEA 内呈现不够优雅或无法满足，故未做支持。&lt;br&gt;
支持的菜单列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;watch&lt;/li&gt;
&lt;li&gt;trace&lt;/li&gt;
&lt;li&gt;stack&lt;/li&gt;
&lt;li&gt;sc&lt;/li&gt;
&lt;li&gt;sm&lt;/li&gt;
&lt;li&gt;getstatic&lt;/li&gt;
&lt;li&gt;jad&lt;/li&gt;
&lt;li&gt;thread&lt;/li&gt;
&lt;li&gt;monitor&lt;/li&gt;
&lt;li&gt;vmoption&lt;br&gt;
对于不支持的菜单，其中部分也可以通过【执行自定义指令】自行拷贝执行，当然，后续也可以考虑补充部分菜单。&lt;/li&gt;
&lt;/ul&gt;
">在IDEA中管理和监听arthas应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/false-sharing/"" data-c="
          &lt;p&gt;在阅读VIVO的博客&lt;a href=&#34;https://mp.weixin.qq.com/s/YKZ1n5O30nowOrfmjMcmOw&#34;&gt;高性能无锁队列 Disruptor 核心原理分析及其在i主题业务中的应用&lt;/a&gt;的时候，了解到 &lt;code&gt;Disruptor&lt;/code&gt; 高性能的核心原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空间预分配&lt;/li&gt;
&lt;li&gt;避免伪共享&lt;/li&gt;
&lt;li&gt;无锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中 &lt;strong&gt;伪共享&lt;/strong&gt; 的概念之前没有了解过，故特地了解学习了下，主要涉及到一些基础的概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU的分级缓存机制&lt;/li&gt;
&lt;li&gt;volatile的内存可见性&lt;/li&gt;
&lt;li&gt;Java long类型/Long类型的字节大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;众所周知，CPU在读取内存中的数据时，并不是读取的直接内存，而是从L1/L2/L3缓存中读取数据，而读取缓存也并非按&lt;code&gt;1字节&lt;/code&gt;的读取，而是按照&lt;code&gt;缓存行&lt;/code&gt;(通常64字节)一块一块的读取，以此来提高读取效率。&lt;/p&gt;
&lt;p&gt;周所也周知，现代计算机都是多核CPU在运行，线程都会被分配CPU来执行，所以线程内的变量数据是需要读取到CPU Cache中才能够对CPU可见的，为了解决内存在CPU1中修改后CPU2不可见（脏读）的问题，在Java中有设计变量修饰符&lt;code&gt;volatile&lt;/code&gt;来修饰变量，以此来实现数据在多个CPU之间不会产生脏读问题，内存在任何一个CPU上发生修改后，在其他CPU上均不可用而丢弃重新从内存中获取。&lt;/p&gt;
&lt;p&gt;当然，也正是因为以上设计，带来了一些预期外的结果（不是问题或bug），如下代码所示：&lt;/p&gt;
&lt;p&gt;对于下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FalseSharing {
    public static void main(String[] args) throws InterruptedException {
        int num = 100000000;
        Pointer pointer1 = new Pointer();
        long start = System.currentTimeMillis();
        Thread t1 = new Thread(() -&amp;gt; {
            for(int i = 0; i &amp;lt; num; i++){
                pointer1.x++;
            }
        });
        Thread t2 = new Thread(() -&amp;gt; {
            for(int i = 0; i &amp;lt; num; i++){
                pointer1.y++;
            }
        });
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(&amp;quot;pointer1=&amp;quot; + (System.currentTimeMillis() - start));
    }
}

class Pointer {
    volatile long x;
    volatile long y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码在我的电脑上执行，&lt;code&gt;需要3.5秒+&lt;/code&gt;，多次执行亦然如此，而我们只需稍作调整，改成如下代码，则只需要&lt;code&gt;0.5秒左右&lt;/code&gt;即可执行完毕，这是为何？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FalseSharing {

    public static void main(String[] args) throws InterruptedException {
        int num = 100000000;
        Pointer2 pointer2 = new Pointer2();
        long start2 = System.currentTimeMillis();
        Thread t3 = new Thread(() -&amp;gt; {
            for(int i = 0; i &amp;lt; num; i++){
                pointer2.x++;
            }
        });
        Thread t4 = new Thread(() -&amp;gt; {
            for(int i = 0; i &amp;lt; num; i++){
                pointer2.y++;
            }
        });
        t3.start();
        t4.start();
        t3.join();
        t4.join();
        System.out.println(&amp;quot;pointer2=&amp;quot; + (System.currentTimeMillis() - start2));
    }
}

class Pointer2 {
    volatile long x;
    // long p1, p2, p3, p4, p5, p6, p7;
    Long z1, z2; long z3;
    volatile long y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上现象对应的机制，正是因为缓存行的设计。&lt;/p&gt;
&lt;p&gt;在上面的代码中，包含了线程t1/t2（t3和t4等同）两组线程，分别对x和y进行累加操作，看似是两个线程（CPU在分别对两块内存中的变量执行累加），但是因为CPU是以缓存行的方式读取内存，&lt;code&gt;Pointer1&lt;/code&gt;中的x和y在内存中时相邻的两块内存，Java的基本数据类型&lt;code&gt;long类型，占用8字节&lt;/code&gt;，所以x和y(加起来16字节)被放到同一个缓存行了，当CPU1对x做了修改后，CPU2读取到y时发现，对应&lt;strong&gt;缓存行已经失效&lt;/strong&gt;了，所以不得不重新从内存中重新读取数据，从而导致了效率降低。&lt;/p&gt;
&lt;p&gt;而我们下面给出的代码，&lt;code&gt;Pointer2&lt;/code&gt;的x和y变量间，被塞了两组变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;long p1, p2, p3, p4, p5, p6, p7; --long类型,占用8个字节, 8*7=56&lt;/li&gt;
&lt;li&gt;Long z1, z2; long z3; --包装Long类型,根据计算机不同有所不同,在我电脑上占用24字节, 24+24+8=56&lt;br&gt;
两组变量任何一组都可以解决伪共享的问题，之所以塞两组变量，都是为了验证缓存行的存在和解决方案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方案一直接使用&lt;code&gt;7个基本数据类型&lt;/code&gt;，占用了56个字节，加上x变量自身，刚好占用一个完整的缓存行64字节，y只能在另一个缓存行了。&lt;br&gt;
方案二使用了&lt;code&gt;2组包装数据类型，1组基本数据类型&lt;/code&gt;，加起来依旧占用的是56个字节，依旧能将一个缓存行占满，解决缓存行失效问题。&lt;/p&gt;
&lt;p&gt;通过对这块的学习，对基础知识又做了一个巩固，造火箭的知识又增加了。🤡&lt;/p&gt;
&lt;p&gt;博文参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;美团：&lt;a href=&#34;https://tech.meituan.com/2016/11/18/disruptor.html&#34;&gt;高性能队列——Disruptor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;VIVO：&lt;a href=&#34;https://mp.weixin.qq.com/s/YKZ1n5O30nowOrfmjMcmOw&#34;&gt;高性能无锁队列 Disruptor 核心原理分析及其在i主题业务中的应用&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实操代码：&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/blob/master/framework-in-java/disruptor-demo/src/main/java/top/imyzt/learning/disruptor/FalseSharing.java&#34;&gt;FalseSharing&lt;/a&gt;&lt;/p&gt;
">False-Sharing</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-events-shi-yong-xiang-jie/"" data-c="
          &lt;p&gt;此篇文章主要用于讲解使用Spring进行编码时，核心与非核心代码解耦合常用的观察者模式&lt;code&gt;@EventListener&lt;/code&gt;的使用方法，以及不常用的&lt;code&gt;@TransactionalEventListener&lt;/code&gt;的使用场景和注意事项。&lt;/p&gt;
&lt;h1 id=&#34;常规情况&#34;&gt;常规情况&lt;/h1&gt;
&lt;p&gt;在我们常规的业务开发中，有很多场景都会使用到观察者模式来解耦合，将非核心流程剥离到主流程之外，提高代码的可读性，举例：用户注册流程，当用户注册完成之后，需要给用户发送一个注册成功的短信通知，核心流程是存储用户信息，次要流程是发送短信通知。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722759866465.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于本文主要是用来介绍SpringEvent的使用，所以另外的方案就不做介绍了，接下来让我们来初始化一个项目来模拟这部分业务代码的实现：&lt;/p&gt;
&lt;p&gt;对于这样一个流程，我们常规的设计方案有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计一个有界队列线程池，将发送短信流程提交给异步线程执行。&lt;/li&gt;
&lt;li&gt;使用SpringEvent，发布用户注册成功事件，由监听器执行（也可以选择执行线程）。&lt;/li&gt;
&lt;li&gt;使用MQ，由消费者负责执行。（最重，最稳妥的方案）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;entity&#34;&gt;Entity&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    @TableId(type = IdType.ASSIGN_ID)
    private String id;
    private String username;
    private String address;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;service&#34;&gt;Service&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService extends IService&amp;lt;User&amp;gt; {
    String addUser(String username, String address);
}

public class UserServiceImpl extends ServiceImpl&amp;lt;UserMapper, User&amp;gt; implements UserService {

    private final ApplicationContext applicationContext;
    @Override
    @Transactional(rollbackFor = Exception.class)
    public String addUser(String username, String address) {
        User user = User.builder().username(username).address(address).build();
        log.info(&amp;quot;添加用户开始&amp;quot;);
        super.save(user);
        log.info(&amp;quot;添加用户成功, 发送事件开始&amp;quot;);
        applicationContext.publishEvent(new AddUserEvent(this, user));
        log.info(&amp;quot;添加用户成功, 发送事件结束&amp;quot;);
        return user.getId();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;listener&#34;&gt;Listener&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserListener {
    @EventListener(AddUserEvent.class)
    public void addHandler(AddUserEvent event) {
        User user = event.getUser();
        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 Normal, user={}&amp;quot;, user.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;controller&#34;&gt;Controller&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;user&amp;quot;)
public class UserController {
    private final UserService userService;
    @PostMapping(&amp;quot;/add&amp;quot;)
    public String add(String username, String address) {
        return userService.addUser(username, address);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;db&#34;&gt;DB&lt;/h3&gt;
&lt;p&gt;ORM框架我们使用Mybatis-Plus，数据库我们使用db2作为临时数据库，目前没有数据。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722760277166.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2024-08-04 16:31:45.590  INFO 55648 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户开始
Creating a new SqlSession
Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]
JDBC Connection [HikariProxyConnection@1603671607 wrapping conn0: url=jdbc:h2:~/mydb user=ROOT] will be managed by Spring
==&amp;gt;  Preparing: INSERT INTO user ( id, username, address ) VALUES ( ?, ?, ? )
==&amp;gt; Parameters: 1820014751548219393(String), yzt(String), shenzhen(String)
&amp;lt;==    Updates: 1
Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]
2024-08-04 16:31:45.705  INFO 55648 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件开始
2024-08-04 16:31:45.708  INFO 55648 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 Normal, user=User(id=1820014751548219393, username=yzt, address=shenzhen)
2024-08-04 16:31:45.709  INFO 55648 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件结束
Transaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]
Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]
Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;再次查看数据&#34;&gt;再次查看数据&lt;/h3&gt;
&lt;p&gt;select * from user;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;USERNAME&lt;/th&gt;
&lt;th&gt;ADDRESS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1820014751548219393&lt;/td&gt;
&lt;td&gt;yzt&lt;/td&gt;
&lt;td&gt;shenzhen&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;(1 row, 2 ms)&lt;/p&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;为了更好的呈现执行过程，上面的代码没有添加异步，通过上面的代码日志，可以看到整个过程大概如下图所示&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722760898291.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;一般我们的业务编码都是使用&lt;code&gt;@EventListener&lt;/code&gt;来实现，在正常情况下不会有什么问题。但是在某些特殊场景下，可能会出现预期之外的结果。&lt;/p&gt;
&lt;h1 id=&#34;场景2事务异常&#34;&gt;场景2，事务异常&lt;/h1&gt;
&lt;p&gt;上面我们演示的更多是业务正常的情况，但通常情况下，添加用户不仅仅只有这么简单的业务，在存储之后，可能还有其他的业务，比如为邀请人结算奖励之类（举例），那么流程长了之后总会有异常的可能，比如我们用&lt;code&gt;address=shanghai&lt;/code&gt;来模拟业务异常：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserServiceImpl extends ServiceImpl&amp;lt;UserMapper, User&amp;gt; implements UserService {
    private final ApplicationContext applicationContext;
    @Override
    @Transactional(rollbackFor = Exception.class)
    public String addUser(String username, String address) {
        User user = User.builder().username(username).address(address).build();
        log.info(&amp;quot;添加用户开始&amp;quot;);
        super.save(user);
        log.info(&amp;quot;添加用户成功, 发送事件开始&amp;quot;);
        applicationContext.publishEvent(new AddUserEvent(this, user));
        log.info(&amp;quot;添加用户成功, 发送事件结束&amp;quot;);
        
        // 模拟异常场景
        if (address.equals(&amp;quot;shanghai&amp;quot;)) {
            throw new RuntimeException(&amp;quot;rollback&amp;quot;);
        }
        return user.getId();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次查看日志&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2024-08-04 16:47:30.838  INFO 55648 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户开始
Creating a new SqlSession
Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7900e41a]
JDBC Connection [HikariProxyConnection@1080868530 wrapping conn0: url=jdbc:h2:~/mydb user=ROOT] will be managed by Spring
==&amp;gt;  Preparing: INSERT INTO user ( id, username, address ) VALUES ( ?, ?, ? )
==&amp;gt; Parameters: 1820018715891113985(String), yzt1(String), shanghai(String)
&amp;lt;==    Updates: 1
Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7900e41a]
2024-08-04 16:47:30.839  INFO 55648 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件开始
2024-08-04 16:47:30.840  INFO 55648 --- [nio-8080-exec-7] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 Normal, user=User(id=1820018715891113985, username=yzt1, address=shanghai)
2024-08-04 16:47:30.840  INFO 55648 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件结束
Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7900e41a]
Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7900e41a]
2024-08-04 16:47:30.842 ERROR 55648 --- [nio-8080-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: rollback] with root cause

java.lang.RuntimeException: rollback
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为下游的异常，导致事务并没有成功提交，但是前面的事件监听器已经被执行了，此时数据库未正确写入用户，但是短信已经发送出去了，在业务上肯定是不可接受的。&lt;br&gt;
&lt;strong&gt;当然也可以说&lt;/strong&gt;，把注册用户成功事件放到代码的最后面，这当然也是一种方案，但始终无法做到最完美的&lt;strong&gt;一致性&lt;/strong&gt;问题，因为用户最终事务提交还是有可能失败（超时、重复写入等）。&lt;br&gt;
&lt;strong&gt;或者说&lt;/strong&gt;，将注册成功事件放到事务注解的外部，在确保事务提交之后，再发送事件，就像之前将的Redis的分布式锁解锁一样 &lt;a href=&#34;https://imyzt.top/post/shi-yong-redis-shi-xian-fen-bu-shi-suo-de-keng/#3-%E4%BA%8B%E5%8A%A1%E6%9C%AA%E6%8F%90%E4%BA%A4%E9%94%81%E5%B0%B1%E9%87%8A%E6%94%BE%E4%BA%86&#34;&gt;使用Redis实现分布式锁的坑#3-事务未提交锁就释放了&lt;/a&gt;，这种方案固然可以，但体现到业务代码上，就需要再另一个被Spring代理了的bean上来操作，比较麻烦。&lt;/p&gt;
&lt;p&gt;其实Spring是为这种场景提供了解决方案的，那就是&lt;code&gt;@TransactionalEventListener&lt;/code&gt;，通过注解的名称就可以看出来，他是为了解决事务问题来提供的注解，它的使用和&lt;code&gt;@EventListener&lt;/code&gt;完全一致，只是多了一个参数&lt;code&gt;phase&lt;/code&gt;，共有4个选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TransactionPhase.AFTER_COMMIT，事务提交之后&lt;/li&gt;
&lt;li&gt;TransactionPhase.BEFORE_COMMIT，事务提交之前&lt;/li&gt;
&lt;li&gt;TransactionPhase.AFTER_COMPLETION，事务完成之后&lt;/li&gt;
&lt;li&gt;TransactionPhase.AFTER_ROLLBACK，事务回滚之后&lt;br&gt;
通过名称可以很直观的看到他的作用，接下来我们添加5个事件监听器，分别来看看他们具体的执行时机：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserListener {

    @EventListener(AddUserEvent.class)
    public void addHandler(AddUserEvent event) {
        User user = event.getUser();
        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 Normal, user={}&amp;quot;, user.toString());
    }

    @TransactionalEventListener(value = AddUserEvent.class, phase = TransactionPhase.AFTER_COMMIT)
    public void addHandlerAfterCommit(AddUserEvent event) {
        User user = event.getUser();
        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 AFTER_COMMIT, user={}&amp;quot;, user.toString());
    }

    @TransactionalEventListener(value = AddUserEvent.class, phase = TransactionPhase.BEFORE_COMMIT)
    public void addHandlerBeforeCommit(AddUserEvent event) {
        User user = event.getUser();
        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 BEFORE_COMMIT, user={}&amp;quot;, user.toString());
    }

    @TransactionalEventListener(value = AddUserEvent.class, phase = TransactionPhase.AFTER_COMPLETION)
    public void addHandlerAfterCompletion(AddUserEvent event) {
        User user = event.getUser();
        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 AFTER_COMPLETION, user={}&amp;quot;, user.toString());
    }

    @TransactionalEventListener(value = AddUserEvent.class, phase = TransactionPhase.AFTER_ROLLBACK)
    public void addHandlerAfterRollback(AddUserEvent event) {
        User user = event.getUser();
        log.info(&amp;quot;添加用户事务执行失败, AFTER_ROLLBACK, user={}&amp;quot;, user.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;执行一次成功的写入看看日志&#34;&gt;执行一次成功的写入，看看日志。&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2024-08-04 17:02:09.069  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户开始
Creating a new SqlSession
Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]
JDBC Connection [HikariProxyConnection@879009595 wrapping conn0: url=jdbc:h2:~/mydb user=ROOT] will be managed by Spring
==&amp;gt;  Preparing: INSERT INTO user ( id, username, address ) VALUES ( ?, ?, ? )
==&amp;gt; Parameters: 1820022399454720001(String), yzt1(String), shenzhen(String)
&amp;lt;==    Updates: 1
Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]
2024-08-04 17:02:09.070  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件开始
2024-08-04 17:02:09.070  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 Normal, user=User(id=1820022399454720001, username=yzt1, address=shenzhen)
2024-08-04 17:02:09.071  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件结束
Transaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]
2024-08-04 17:02:09.071  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 BEFORE_COMMIT, user=User(id=1820022399454720001, username=yzt1, address=shenzhen)
Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]
Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]
2024-08-04 17:02:09.072  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 AFTER_COMMIT, user=User(id=1820022399454720001, username=yzt1, address=shenzhen)
2024-08-04 17:02:09.072  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 AFTER_COMPLETION, user=User(id=1820022399454720001, username=yzt1, address=shenzhen)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;再执行一次失败的写入看看日志&#34;&gt;再执行一次失败的写入，看看日志：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2024-08-04 17:09:30.720  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户开始
Creating a new SqlSession
Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4ef5b6da]
JDBC Connection [HikariProxyConnection@566058297 wrapping conn0: url=jdbc:h2:~/mydb user=ROOT] will be managed by Spring
==&amp;gt;  Preparing: INSERT INTO user ( id, username, address ) VALUES ( ?, ?, ? )
==&amp;gt; Parameters: 1820024251877470209(String), yzt1(String), shanghai(String)
&amp;lt;==    Updates: 1
Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4ef5b6da]
2024-08-04 17:09:30.722  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件开始
2024-08-04 17:09:30.722  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 Normal, user=User(id=1820024251877470209, username=yzt1, address=shanghai)
2024-08-04 17:09:30.722  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件结束
Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4ef5b6da]
Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4ef5b6da]
2024-08-04 17:09:30.723  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 AFTER_COMPLETION, user=User(id=1820024251877470209, username=yzt1, address=shanghai)
2024-08-04 17:09:30.723  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.demos.listener.UserListener      : 添加用户事务执行失败, AFTER_ROLLBACK, user=User(id=1820024251877470209, username=yzt1, address=shanghai)
2024-08-04 17:09:30.725 ERROR 56859 --- [nio-8080-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: rollback] with root cause

java.lang.RuntimeException: rollback

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;执行流程&#34;&gt;执行流程&lt;/h3&gt;
&lt;p&gt;通过上面的日志可以看到整个执行过程如下图所示：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722762788539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;由此可知，有了&lt;code&gt;@TransactionalEventListener&lt;/code&gt;，我们不用确定事务的提交时机以及是否成功，只需要编写对应的监听器处理器，并指定执行时事务的时机即可在正确的时间点被调用，这一切都是Spring的AOP在帮我们处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TransactionalApplicationListenerMethodAdapter&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onApplicationEvent(ApplicationEvent event) {
    if (TransactionSynchronizationManager.isSynchronizationActive() &amp;amp;&amp;amp;
            TransactionSynchronizationManager.isActualTransactionActive()) {
        TransactionSynchronizationManager.registerSynchronization(
                new TransactionalApplicationListenerSynchronization&amp;lt;&amp;gt;(event, this, this.callbacks));
    }
    else if (this.annotation.fallbackExecution()) {
        if (this.annotation.phase() == TransactionPhase.AFTER_ROLLBACK &amp;amp;&amp;amp; logger.isWarnEnabled()) {
            logger.warn(&amp;quot;Processing &amp;quot; + event + &amp;quot; as a fallback execution on AFTER_ROLLBACK phase&amp;quot;);
        }
        processEvent(event);
    }
    else {
        // No transactional event execution at all
        if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;No transaction is active - skipping &amp;quot; + event);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有事务在进行中，就将其监听器处理器先放到&lt;code&gt;TransactionSynchronizationManager&lt;/code&gt;注册一个同步队列，在事务执行到对应的阶段，再回调每个监听了对应阶段的事务处理器。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;AbstractPlatformTransactionManager#processCommit&lt;/code&gt;中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {
    if (status.isNewSynchronization()) {
        TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly());
    }
}
protected final void triggerBeforeCompletion(DefaultTransactionStatus status) {
    if (status.isNewSynchronization()) {
        TransactionSynchronizationUtils.triggerBeforeCompletion();
    }
}
private void triggerAfterCommit(DefaultTransactionStatus status) {
    if (status.isNewSynchronization()) {
        TransactionSynchronizationUtils.triggerAfterCommit();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;小结-2&#34;&gt;小结&lt;/h1&gt;
&lt;p&gt;通过本篇文章，我们大致了解了&lt;code&gt;@TransactionalEventListener&lt;/code&gt;注解的使用场景和注意事项，也了解了其大概的实现原理，其实SpringEvent的相关源码看起来非常容易，只要稍微看过Spring相关源码，并且对SpringAOP相关逻辑了解的，就可以很容易的看懂，因为他的调用过程没那么多弯弯绕绕，只要看着&lt;code&gt;applicationContext.publishEvent&lt;/code&gt;方法一直往下盯，很快就能够看完整个的执行过程。&lt;/p&gt;
&lt;p&gt;本篇博客对应的源码，希望能对你有所帮助：&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-boot-events&#34;&gt;spring-boot-events&lt;/a&gt;&lt;/p&gt;
">Spring Events使用和问题分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/dang-spring-duo-ceng-qian-tao-shi-wu-yu-dao-mybatis-plus-de-savebatch/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;事情的起因还要从 &lt;code&gt;Transaction rolled back because it has been marked as rollback-only] with root cause&lt;/code&gt; 说起，公司的一个业务，Kafka Consumer消费了来自上游的消息处理并写入数据，整个逻辑很复杂，由最外层的方法注解 &lt;code&gt;@Transactional(rollbackFor = Exception.class)&lt;/code&gt; 来保证整个过程数据的一致性，但其中有一个业务不需要事务保证，所以&lt;strong&gt;前人&lt;/strong&gt;写了一个 &lt;code&gt;try catch&lt;/code&gt; 来防止子业务流异常阻断全局事务的提交。简化后大概类似于这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class ServiceA {

    @Resource
    private ServiceB serviceB;
    @Resource
    private CompanyService companyService;

    /**
     * 模拟消费外部的消息, 调用者A
     */
    @Transactional(rollbackFor = Exception.class)
    public void test(String username) {
        // 1. 首先保存自己的数据, 模拟业务操作
        Company company = new Company();
        company.setName(&amp;quot;家里蹲&amp;quot;);
        company.setAddress(&amp;quot;localhost&amp;quot;);
        companyService.save(company);

        // 2. 然后调用Spring的代理方法B
        serviceB.doBusiness(username);
    }
}

@Service
public class ServiceB {

    @Resource
    private UserService userService;

    @Transactional(rollbackFor = Exception.class)
    public void doBusiness(String username) {
        // 3. 这里还有一系列事务操作, 但和这次问题无关, 就不放这里干扰了
        try {
            User user = new User();
            user.setUsername(username);
            user.setAddress(&amp;quot;shenzhen&amp;quot;);
            // 4. 罪魁祸首的代码, 此处前人为了不干扰主逻辑, catch了异常
            // 为了达到&amp;quot;以为的&amp;quot;异常不干扰外部事务
            userService.saveBatch(Collections.singletonList(user));
        } catch (DuplicateKeyException e) {
            // 5. 此处有日志 log.error(&amp;quot;xxx业务异常&amp;quot;, e)
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的代码看起来平平无奇，按照“常规”理解，&lt;strong&gt;代码块4&lt;/strong&gt;位置的流程异常，不会干扰&lt;strong&gt;代码块1、3&lt;/strong&gt;处的事务提交，达到编写者的目的。&lt;/p&gt;
&lt;p&gt;但如果是这么简单，我也不会有这次问题的排查过程，也不会有这篇笔记了...&lt;/p&gt;
&lt;h1 id=&#34;现象&#34;&gt;现象&lt;/h1&gt;
&lt;p&gt;我们从日志监控注意到，&lt;strong&gt;代码块5&lt;/strong&gt;有频繁的异常，并且&lt;strong&gt;代码块1、3&lt;/strong&gt;的数据最终并未写入成功，通过MySQL追踪事务发现，1、3处的语句执行后，均被&lt;code&gt;rollback&lt;/code&gt;了。&lt;br&gt;
这就引出了前言中的问题分析来了，在没有确认问题出现在&lt;strong&gt;代码块4&lt;/strong&gt;时，还在找哪些地方有异常可能造成回滚，但通过跟踪程序日志发现，1、3处被回滚的数据，基本都发生在代码块5的日志打印出来之后，并且程序中也发现了下面的异常：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only
.......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Transaction rolled back because it has been marked as rollback-only&lt;/strong&gt;，说明事务被标记为只能回滚，并且根据行号（上述堆栈未标注业务行号）推断出，是发生代码块2处，调用&lt;code&gt;doBusiness&lt;/code&gt;方法发生了回滚。&lt;/p&gt;
&lt;h1 id=&#34;分析&#34;&gt;分析&lt;/h1&gt;
&lt;p&gt;我们都知道，Spring本身没有事务，只有数据库有事务，Spring提供&lt;code&gt;@Transactional&lt;/code&gt;以及事务传播机制，只是利用数据库给我们提供的 &lt;code&gt;begin/commit/rollback&lt;/code&gt; 来结合 Spring AOP 实现的&lt;strong&gt;统一事务管理&lt;/strong&gt;，通过 &lt;code&gt;PlatformTransactionManager&lt;/code&gt; 工具类来实现对事务的管理。（这方面网上优秀的博客太多了，就不细讲了，相信每一个Spring Boy都熟知）&lt;/p&gt;
&lt;p&gt;那么，结合对Spring事务管理器和AOP的理解，我们画一张图来理解上面这个“嵌套事务”的过程。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722091980572.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;结合流程图来分析，按“常理”理解的话，&lt;code&gt;catch&lt;/code&gt; 了 &lt;code&gt;userService.saveBatch&lt;/code&gt;，内部的异常就不会造成外面的回滚，因为异常“被”吞了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但实则不然&lt;/strong&gt;，Spring事务管理器采用的是 &lt;strong&gt;标记位Savepoint&lt;/strong&gt; 方法，只要被事务管理器感知到了异常出现，就会将当前线程的事务标记成为&lt;code&gt;rollbackOnly&lt;/code&gt;状态，后面的事务再想提交就不行了。这也就导致了&lt;code&gt;ServiceB.doBusiness&lt;/code&gt;方法在“想要”提交事务时，发现了事务已经被标记了，就抛出了&lt;code&gt;UnexpectedRollbackException&lt;/code&gt;异常，该异常进一步的造成了&lt;code&gt;ServiceA.test&lt;/code&gt;方法的代理类检测到了异常，&lt;code&gt;ServiceA.test&lt;/code&gt;的代理类也开始处理回滚，进一步造成了整个 &lt;code&gt;Kafka Consumer&lt;/code&gt;的事务造成了回滚。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1722092797622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;源码&#34;&gt;源码&lt;/h1&gt;
&lt;p&gt;通过搜索“Transaction rolled back because it has been marked as rollback-only”异常，可以很快定位到异常流程在源码中的位置，&lt;code&gt;org.springframework.transaction.support.AbstractPlatformTransactionManager#processRollback&lt;/code&gt;&lt;br&gt;
而通过跟踪该方法的调用方，可以很快定位到&lt;code&gt;org.springframework.transaction.support.AbstractPlatformTransactionManager#commit&lt;/code&gt;方法，该方法正印证我们上方的 &lt;code&gt;ServiceB.doBusiness&lt;/code&gt;想要 &lt;code&gt;commit&lt;/code&gt;的时候，&lt;code&gt;defStatus.isGlobalRollbackOnly()&lt;/code&gt;检测到当前事务已经被标记了&lt;code&gt;rollbackOnly&lt;/code&gt;(&lt;code&gt;org.springframework.transaction.support.ResourceHolderSupport#rollbackOnly&lt;/code&gt;)&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1722094564627.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;解决&#34;&gt;解决&lt;/h1&gt;
&lt;p&gt;其实该问题在分析之初，大家并没有定位到是因为&lt;code&gt;userService.saveBatch()&lt;/code&gt;上面有Mybatis-Plus加的&lt;code&gt;@Transactional&lt;/code&gt;注解干扰到 &lt;code&gt;catch&lt;/code&gt; 异常这么顺利，而是都在怀疑：为什么我catch了，还把我上层的事务给回滚了！后面虽然怀疑到&lt;code&gt;userService.saveBatch()&lt;/code&gt;的事务注解了，又觉得 &lt;code&gt;try&lt;/code&gt; 里面的事务，不会影响到外层（没有想到标记位rollbackOnly这里），后面又想到是不是可以在&lt;code&gt;ServiceB.doBusiness()&lt;/code&gt;上调整事务传播机制为&lt;code&gt;Propagation.REQUIRES_NEW&lt;/code&gt;，但其实都是徒劳，因为始终都已经被Mybatis-Plus的&lt;code&gt;@Transactional&lt;/code&gt;标记为&lt;code&gt;rollbackOnly&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用无事务注解的&lt;code&gt;save()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;改用&lt;code&gt;Db.saveBatch&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;改用异步线程（切换了事务管理器）处理 try 中的流程&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;p&gt;下面这篇文章，在我们排查问题的过程中，给了很大的帮助，帮我们确定了问题的方向：&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/github_38592071/article/details/131950392&#34;&gt;告警：MyBatis-Plus中慎用@Transactional注解，坑的差点被开了...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于是否可以取消&lt;code&gt;saveBatch&lt;/code&gt;方法上事务注解的讨论，可以看Mybatis-Plus官方的issue区：&lt;br&gt;
（3.5.7之后，取消了IService，都使用Mapper方法，彻底解决.......）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/baomidou/mybatis-plus/issues/6333&#34;&gt;建议取消数据层的saveBatch等方法的@Transactional注解，交由业务层自行管理 #6333&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/baomidou/mybatis-plus/issues/5108&#34;&gt;saveBatch下的事务问题&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我新建了一个工程，用来复现该问题：&lt;br&gt;
&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/error-case-analysis/adoptopenjdk-poi-crash-demo&#34;&gt;复现定位Spring多层嵌套事务问题&lt;/a&gt;&lt;/p&gt;
">当Spring多层嵌套事务遇到Mybatis-Plus的saveBatch</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-group-by-yin-shi-pai-xu/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;在MySQL的老版本（MySQL5.7及以前）中， &lt;code&gt;GROUP BY xxx&lt;/code&gt; 等同于 &lt;code&gt;GROUP BY xxx ORDER BY xxx&lt;/code&gt;，在 &lt;code&gt;GROUP BY&lt;/code&gt; 的同时，会自带排序的效果。包括也可以手动排序 &lt;code&gt;GROUP BY xxx DESC&lt;/code&gt;，等同于 &lt;code&gt;GROUP BY xxx ORDER BY xxx DESC&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;MySQL8.0 版本删除了隐式排序，包括显示排序也报错。在升级到MySQL8.0之后，由于缺少了隐式排序，可能会造成查询结果返回的顺序不稳定，造成结果不满足预期。&lt;/p&gt;
&lt;h1 id=&#34;问题现象&#34;&gt;问题现象&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;aliyun PolarDB MySQL 版 8.0.1.1.40版本，在DMS查询时，&lt;strong&gt;返回的顺序稳定&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在程序JDBC查询时（连接的集群地址），返回的结果多次查询顺序不一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于我们使用的是PolarDB 8.0+，首先开始怀疑是不是aliyun做了什么操作，查到他们的更新日志：https://help.aliyun.com/zh/polardb/polardb-for-mysql/polardb-for-mysql-8-0-1，发现他们在8.0版本中，将隐式排序的功能又加了回来，那么更进一步证明问题出现在数据库层面了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1721315576799.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;有了上面的分析和更新日志，我们又进行了接下来的几次测试，进一步缩小问题范围，定位问题的根本原因。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过MySQL命令行，连接到集群地址，返回的结果多次查询顺序不一致。&lt;/li&gt;
&lt;li&gt;通过MySQL命令行，连接到主节点地址，&lt;strong&gt;返回的顺序稳定&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;通过MySQL命令行，连接到只读从节点地址，返回的结果多次查询顺序不一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过咨询aliyun工程师，了解到DMS默认是直连主库的，结合上述三个执行结果来看，似乎问题出现在了从库，当请求从从库执行来看，顺序总是不一致。&lt;/p&gt;
&lt;p&gt;有了上述的结论，通过进一步咨询aliyun的工程师，最终定位到问题是因为其中有台从库开启了并行查询，导致了返回顺序会存在多次查询不一致的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imyzt.top/post-images/1721489241076.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1721489235249.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;虽然最终定位到了原因是并行查询导致的问题，但是我还是认为，既然aliyun的版本公告中已经说明了加回了 &lt;code&gt;GROUP BY&lt;/code&gt; 隐式排序功能，那么不管是并行查询还是什么原因，就算是在 MySQL Server层进行汇总排序，也需要保证最终结果和预期一致，否则会造成使用方的预期不满足。&lt;br&gt;
其次，对于隐式排序肯定不能进行依赖，还是回归到程序上，不论什么情况肯定不能依赖于约定俗成的一些功能，应该强依赖自己写下的指令，比如手动指定 &lt;code&gt;ORDER BY&lt;/code&gt;  比事后去分析还是好很多。但整个过程还是学习到不少东西，还是有一定收获的。&lt;/p&gt;
&lt;h1 id=&#34;扩展&#34;&gt;扩展&lt;/h1&gt;
&lt;h2 id=&#34;旧版本为什么会有排序&#34;&gt;旧版本为什么会有排序？&lt;/h2&gt;
&lt;p&gt;因为要对数据进行分组的话，本身也会对分组前的数据进行排序，降低数据复杂度，所以原始数据本身就已经有序了。&lt;br&gt;
其次，如果是 &lt;code&gt;GROUP BY&lt;/code&gt; 的一个索引字段，那么索引字段本身是 B+ Trree，本身也是有序的，且平时 &lt;code&gt;GROUP BY&lt;/code&gt;的字段大概率是有索引的（否则效率太低了），所以绝大部分情况下，旧版本的 &lt;code&gt;GROUP BY&lt;/code&gt; 就为我们保留了排序。&lt;/p&gt;
&lt;h2 id=&#34;为什么要删除隐式排序&#34;&gt;为什么要删除隐式排序？&lt;/h2&gt;
&lt;p&gt;会造成预期外的结果，比如没有明确指定&lt;/p&gt;
">MySQL GROUP BY 隐式排序</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/springboot-33-neo4j-51-java17-jie-ru-jiao-cheng/"" data-c="
          &lt;p&gt;官方文档： &lt;a href=&#34;https://docs.spring.io/spring-data/neo4j/docs/current-SNAPSHOT/reference/html/&#34;&gt;Spring Data Neo4j&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于官方文档，基本就能完成基本的接入，Neo4j的版本很乱，如果使用SpringBoot2.+的话，一定要注意Neo4j Server的版本与Driver的匹配关系，否则很容易踩坑。 由于我不是生产使用，直接用官方最新反倒是没遇到此类问题，但网上对于这个问题遇到的很多。&lt;/p&gt;
&lt;h1 id=&#34;简单接入&#34;&gt;简单接入&lt;/h1&gt;
&lt;p&gt;写了几个单测，看了下流程，得益于SpringBoot-Data的封装，和操作MongoDB、MySQL等关系型数据库基本无异，使用过程很丝滑。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
    public void readAll() {
        List&amp;lt;Person&amp;gt; personList = personRepository.findAll();
        Assert.isTrue(!personList.isEmpty(), &amp;quot;isEmpty&amp;quot;);
    }

    @Test
    public void delById() {
        personRepository.findById(71L).ifPresent(person -&amp;gt; {
            System.out.println(&amp;quot;before delete: &amp;quot; + person.getName());
        });
        personRepository.deleteById(71L);
        Person person = personRepository.findById(71L).orElse(null);
        System.out.println(&amp;quot;after delete: &amp;quot; + person);
    }

    @Test
    public void save() {
        Person person = new Person();
        person.setName(&amp;quot;人参果树&amp;quot;);
        personRepository.save(person);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;findAll&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719738560721.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;delById&lt;br&gt;
删除前：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719738566977.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
删除后：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719738573248.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;saveOne&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719738577960.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;关系的创建&#34;&gt;关系的创建&lt;/h1&gt;
&lt;p&gt;对于节点的基本查询，由于其结构类似于结构性，和结构性数据库查询无异，但是对于N4o4j特殊的关系结构，就有一些不一样了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
@Repository
public interface PersonRepository extends Neo4jRepository&amp;lt;Person, Long&amp;gt; {

    Person findByName(String name);

    /**
     * 创建人物关系
     * @param from 源
     * @param relation 关系
     * @param to 目标
     */
    @Query(&amp;quot;match (n:person {name: $from}),(m:person {name: $to}) &amp;quot; +
            &amp;quot;create (n)-[:西游人物关系{relation:$relation}]-&amp;gt;(m)&amp;quot;)
    void createRelation(String from, String relation, String to);
}


@SpringBootTest
public class PersonRelationShipRepositoryTest {
    @Resource
    private PersonRepository personRepository;
    @Test
    public void addRelation() {
        Person personYangjian = personRepository.findByName(&amp;quot;杨戬&amp;quot;);
        Person person2 = new Person();
        person2.setName(&amp;quot;玉鼎真人&amp;quot;);
        PersonRelationShip relationShip = new PersonRelationShip();
        relationShip.setChild(person2);
        relationShip.setRelation(&amp;quot;师傅&amp;quot;);
        personYangjian.getPersonRelationShips().add(relationShip);
        personRepository.save(personYangjian);
    }
    @Test
    public void addRelation2() {
        personRepository.createRelation(&amp;quot;玉皇大帝&amp;quot;, &amp;quot;妻子&amp;quot;, &amp;quot;王母娘娘&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建关系第一种方式&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719748762850.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建关系第二种方式&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719748767396.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;坑&#34;&gt;坑&lt;/h1&gt;
&lt;h2 id=&#34;坑1&#34;&gt;坑1&lt;/h2&gt;
&lt;p&gt;spring-boot-data 3.+的很多注解都改变了，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在老版本中标注节点使用的是&lt;code&gt;@NodeEntity&lt;/code&gt;，新版本被替换为&lt;code&gt;@Node(labels = &amp;quot;person&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在老版本中，关系的表述是在关系对象中通过&lt;code&gt;@RelationshipEntity&lt;/code&gt;、&lt;code&gt;@StartNode&lt;/code&gt;、&lt;code&gt;@EndNode&lt;/code&gt;来描述，在新版这些都没有了。取而代之的是在源对象中补充属性&lt;code&gt;@Relationship(type = &amp;quot;师傅&amp;quot;, direction = Relationship.Direction.OUTGOING)&lt;/code&gt;来描述关系。&lt;br&gt;
老关系：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data
@RelationshipEntity(type = &amp;quot;xxx&amp;quot;)
public class PersonRelationShip {
    @Id
    @GeneratedValue
    private Long id;
    @StartNode
    private Person parent;
    @TargetNode
    private Person child;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新关系：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Node(labels = &amp;quot;person&amp;quot;)
@Data
public class Person {
    @Id
    @GeneratedValue
    private Long id;
    @Property
    private String name;
    @Relationship(type = &amp;quot;师傅&amp;quot;, direction = Relationship.Direction.OUTGOING)
    private List&amp;lt;PersonRelationShip&amp;gt; personRelationShips;
}
@Data
@RelationshipProperties
public class PersonRelationShip {
    @Id
    @GeneratedValue
    private Long id;
    @TargetNode
    private Person child;
    @Property
    private String relation;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;坑2&#34;&gt;坑2&lt;/h2&gt;
&lt;p&gt;spring-boot-data 3.+的&lt;code&gt;@Query&lt;/code&gt;中想要获取参数，需要使用 &lt;code&gt;$fieldName&lt;/code&gt;，而不是 &lt;code&gt;{0}&lt;/code&gt; 的方式，如果自己写的时候一定要注意。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
    * 创建人物关系
    * @param from 源
    * @param relation 关系
    * @param to 目标
    */
@Query(&amp;quot;match (n:person {name: $from}),(m:person {name: $to}) &amp;quot; +
        &amp;quot;create (n)-[:西游人物关系{relation:$relation}]-&amp;gt;(m)&amp;quot;)
void createRelation(String from, String relation, String to);
&lt;/code&gt;&lt;/pre&gt;
">SpringBoot 3.3 + Neo4j 5.1 + Java17 接入教程</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/shi-yong-cloudflare-jia-su-github-pages/"" data-c="
          &lt;p&gt;之前就有了解过Cloudflare，但是一直没有去实践，最近了解到它提供了免费的CDN可以加速，所以想找个教程按流程试一下，一个是确实Github Pages访问太慢了（虽说Cloudflare在国内也没有节点...但聊胜于无），另一个主要是也可以学习拓展下知识。其实使用起来整个过程还是挺简单的，基本无脑操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册Cloudflare的账号，填写你的域名，交给它托管（打开官网，点击就送）&lt;/li&gt;
&lt;li&gt;拷贝Cloudflare提供的DNS解析，替换你的域名服务商提供的解析（我使用的aliyun，在域名-管理-DNS解析）处可替换&lt;/li&gt;
&lt;li&gt;等待几分钟，即可失效。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面的步骤更像是把大象放进冰箱的步骤，过于简单，主要是网络上针对此流程提供的优秀博客数不胜数，没必要再产生一篇重复的内容，并且文章也主要是用于记录自己接入的过程和遇到的坑。&lt;/p&gt;
&lt;p&gt;我看的博客是： &lt;a href=&#34;https://www.jun997.xyz/2022/05/18/62ef741104da.html&#34;&gt;使用cdn加速Github Pages的访问速度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;跟着这个博客基本就可以把域名完成托管，整个过程主要是遇到一个坑，在配置完成之后，发现本来通过aliyun解析的网站还能打开，托管之后反倒是打不开了，Chrome提示“重定向的次数过多”，这一步主要是因为解析配置的问题，可以登陆Cloudflare，然后再SSL/TLS菜单里调整下面的配置即可：&lt;br&gt;
原本选中的是“灵活的”，调整为“严谨”即可。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719579571878.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">使用Cloudflare加速Github Pages</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/neo4j-chang-yong-han-shu/"" data-c="
          &lt;h1 id=&#34;字符串函数&#34;&gt;字符串函数&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;match (n:Lianhuachi) where n.name = &#39;去种田的向凹凸&#39; return n.name,substring(n.name, 0,3)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1719414420545.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;aggregation聚合函数&#34;&gt;AGGREGATION聚合函数&lt;/h1&gt;
&lt;p&gt;和普通SQL一致的含义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;match (n:Lianhuachi) return count(n),max(n.age),min(n.age),avg(n.age),sum(n.age)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1719414601279.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;关系函数&#34;&gt;关系函数&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;match (x)-[n:`莲花池人物关系`]-&amp;gt;(y) return id(n),n
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1719414748513.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;备份&#34;&gt;备份&lt;/h1&gt;
&lt;p&gt;Neo4j 官方文档： &lt;a href=&#34;https://neo4j.com/docs/operations-manual/current/backup-restore/modes/&#34;&gt;Backup modes&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;➜  bin ./neo4j-admin database dump neo4j --to-path=/tmp
2024-06-26 15:24:15.414+0000 INFO  [o.n.c.d.DumpCommand] Starting dump of database &#39;neo4j&#39;
Done: 37 files, 2.993MiB processed.
2024-06-26 15:24:19.338+0000 INFO  [o.n.c.d.DumpCommand] Dump completed successfully


➜  bin ll /tmp/ |grep &amp;quot;neo4j.dump&amp;quot;
-rw-r--r--  1 imyzt   wheel   305K Jun 26 23:24 neo4j.dump

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;恢复&#34;&gt;恢复&lt;/h1&gt;
&lt;p&gt;Neo4j 官方文档： &lt;a href=&#34;https://neo4j.com/docs/operations-manual/current/backup-restore/restore-dump/&#34;&gt;Restore a database dump&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  bin ./neo4j-admin database load --from-path=/tmp/ neo4j --overwrite-destination=true
Done: 37 files, 2.993MiB processed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，数据恢复了过来。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719735796053.png&#34; alt=&#34;neo4j_restore&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Neo4j常用函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/neo-chang-yong-ming-ling-er/"" data-c="
          &lt;h1 id=&#34;unique约束&#34;&gt;UNIQUE约束&lt;/h1&gt;
&lt;p&gt;避免重复时使用（姓名、身份证不能重复）&lt;/p&gt;
&lt;h2 id=&#34;旧版本&#34;&gt;旧版本&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;create constraint on (n:Lianhuachi) assert n.name is unique
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;新版本&#34;&gt;新版本&lt;/h2&gt;
&lt;p&gt;如果再执行上面的语法时报错，说明你使用的是新版本的Neo4j，变更了命令语法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;create constraint uniq_name for (n:Lianhuachi) require n.name is unique
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在加了唯一索引后，可以看到，在添加重复数据时会报错：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719409875933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;删除唯一约束&#34;&gt;删除唯一约束&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;drop constraint uniq_name 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，在删除之后再进行添加，是可以添加进去的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;create (n:Lianhuachi {name: &amp;quot;我是野农&amp;quot;, &amp;quot;field&amp;quot;: &amp;quot;test&amp;quot;}) return n
match (n:Lianhuachi {name: &amp;quot;我是野农&amp;quot;&amp;quot;}) return n
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1719410056076.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;distinct去重&#34;&gt;distinct去重&lt;/h1&gt;
&lt;p&gt;和SQL一致，对内容进行去重&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;match (n:Lianhuachi) return distinct(n.name)
&lt;/code&gt;&lt;/pre&gt;
">Neo常用命令 二</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-ai/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;当一开始听说Spring-AI项目时是很懵的，什么？Spring开始训练模型了？不应该啊，Java还能卷模型赛道了吗？...&lt;br&gt;
打开官网了解了下，才知道原来是缝合怪：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring AI is an application framework for AI engineering. Its goal is to apply to the AI domain Spring ecosystem design principles such as portability and modular design and promote using POJOs as the building blocks of an application to the AI domain.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官网地址：&lt;a href=&#34;https://spring.io/projects/spring-ai&#34;&gt;https://spring.io/projects/spring-ai&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;换言之就是虽然Java不能卷算法，但是我可以提供一套封装来让你们调用模型提供的API服务，众所周知，我的抽象封装能力还是很强的。你看你们现在这么多厂商提供服务，不得需要一个统一的门面来减少接入成本嘛...&lt;/p&gt;
&lt;p&gt;官网列举了目前国外主流的平台：&lt;br&gt;
&lt;strong&gt;Chat Models&lt;/strong&gt;&lt;br&gt;
OpenAI&lt;br&gt;
Azure Open AI&lt;br&gt;
Amazon Bedrock&lt;br&gt;
Cohere&#39;s Command&lt;br&gt;
AI21 Labs&#39; Jurassic-2&lt;br&gt;
Meta&#39;s LLama 2&lt;br&gt;
Amazon&#39;s Titan&lt;br&gt;
Google Vertex AI Palm&lt;br&gt;
Google Gemini&lt;br&gt;
HuggingFace - access thousands of models, including those from Meta such as Llama2&lt;br&gt;
Ollama - run AI models on your local machine&lt;br&gt;
MistralAI&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Text-to-image Models&lt;/strong&gt;&lt;br&gt;
OpenAI with DALL-E&lt;br&gt;
StabilityAI&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Transcription (audio to text) Models&lt;/strong&gt;&lt;br&gt;
OpenAI&lt;br&gt;
... 数不胜数，更何况还有很多国内大厂开源的模型。&lt;/p&gt;
&lt;p&gt;所以Spring提供了一套统一的封装门面，其他的厂商也可以基于门面来实现自己的Client，比如Alibaba就接入了&lt;code&gt;com.alibaba.cloud.ai.tongyi.chat.TongYiChatClient&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这就引申出了本博客，记录了下我接入Spring-Ai（OpenAI）、Spring-Ai-Alibaba（TongYi）的过程。&lt;/p&gt;
&lt;h1 id=&#34;接入spring-ai&#34;&gt;接入Spring-Ai&lt;/h1&gt;
&lt;p&gt;Spring-Ai的接入相对简单，因为最新的&lt;code&gt;start.spring.io&lt;/code&gt;已经维护了&lt;code&gt;OpenAI&lt;/code&gt;的依赖包，在IDEA使用&lt;code&gt;Spring-Initializr&lt;/code&gt;即可完成初始化。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1718893769472.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;完成Gradle的初始化之后，得到了一个标准的Spring项目，只需要做一个简单的配置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;spring.application.name=spring-ai-demo
# 生成结果多样性参数，值在0~2之间，值越大越随机越小越固定，但就算为0也会有随机性
spring.ai.openai.chat.temperature=0.7
spring.ai.chat.client.enabled=true
# 如果你需要代理的话
spring.ai.openai.base-url=https://api.xty.app
# 填写自己的key
spring.ai.openai.api-key=${OPENAI_API_KEY}
# 填写你需要使用的模型（也可以使用时代码指定）
spring.ai.openai.chat.options.model=gpt-3.5-turbo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来只需要编写一个Java的控制器，来接收HTTP请求，就可以完成对OpenAI的对话。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2024/06/19
 * @description AI 入口
 */
@RestController
@RequestMapping
public class AiController {

    @Resource
    private ChatClient chatClient;

    @GetMapping(&amp;quot;/ai/chat&amp;quot;)
    Map&amp;lt;String, Object&amp;gt; chat(@RequestParam String question) {
        ChatClient.ChatClientRequest.CallPromptResponseSpec call = chatClient.prompt(new Prompt(question)).call();
        return Map.of(&amp;quot;question&amp;quot;, question, &amp;quot;answer&amp;quot;, call.chatResponse());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整体接入还是比较简单的，但是这里踩了一个坑，不知道是我引入的版本比较新还是什么缘故，它的&lt;code&gt;ChatClient&lt;/code&gt; Bean 竟然没有自动注册！所以我还手动注册了一个Bean，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public ChatClient chatClient(@Autowired OpenAiChatModel openAiChatModel) {
    return ChatClient.builder(openAiChatModel).build();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-ai-demo/spring-ai-demo&#34;&gt;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-ai-demo/spring-ai-demo&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;spring-ai-alibaba&#34;&gt;Spring-Ai-Alibaba&lt;/h1&gt;
&lt;p&gt;OpenAI由于API-KEY的费用蛮高，虽然完成了代码的接入，但是最终我还是没有购买它的API...所以又看了国内的厂商，目前主要是Alibaba完成了Spring-Ai的接入，整体接入其实也很简单，建议首先看一遍&lt;a href=&#34;https://sca.aliyun.com/docs/2023/user-guide/ai/quick-start/&#34;&gt;官网的例子&lt;/a&gt;，接下来可以跟着步骤走一下试试。&lt;/p&gt;
&lt;h1 id=&#34;创建项目引入依赖&#34;&gt;创建项目，引入依赖&lt;/h1&gt;
&lt;p&gt;首先完成一个普通SpringBootWeb项目创建，然后引入Alibaba-Ai的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-ai&amp;lt;/artifactId&amp;gt;
        &amp;lt;exclusions&amp;gt;
            &amp;lt;exclusion&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-ai-core&amp;lt;/artifactId&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.ai&amp;lt;/groupId&amp;gt;
            &amp;lt;/exclusion&amp;gt;
        &amp;lt;/exclusions&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;io.springboot.ai&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-ai-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

&amp;lt;/dependencies&amp;gt;

&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-alibaba-dependencies&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2023.0.1.0&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的内容，我把无关紧要的依赖去除了，只保留了核心部分，其中有一个关键点是&lt;code&gt;exclusions&lt;/code&gt;了&lt;code&gt;spring-ai-core&lt;/code&gt;，因为Alibaba引入的版本太老了。改为自己重新引入最新的版本，其他的和官方文档无差别。&lt;/p&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;spring:
  application:
    name: spring-ai-alibaba-demo
  cloud:
    ai:
      tongyi:
        api-key: ${TONGYI_KEY}
        images:
         enabled: true
        chat:
          enabled: true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编写控制器&#34;&gt;编写控制器&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Slf4j
@RestController
@RequestMapping
public class AiController {

    @Resource
    private ChatClient chatClient;
    @Resource
    private ImageClient imageClient;

    @GetMapping(&amp;quot;/ai/chat&amp;quot;)
    public String chat(@RequestParam String question) {
        ChatResponse call = chatClient.call(new Prompt(question));
        return call.getResult().getOutput().getContent();
    }

    @GetMapping(&amp;quot;/ai/aigc&amp;quot;)
    public String aigc(@RequestParam String question) {
        ImageResponse call = imageClient.call(new ImagePrompt(question));
        return call.getResult().getOutput().getUrl();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成上面的步骤，基本就完成了接入，在&lt;code&gt;postman&lt;/code&gt;上面输入地址，就可以进行测试了。因为通义不仅有chat，还可以文生图，所以我完成下演示：&lt;/p&gt;
&lt;h3 id=&#34;文生文&#34;&gt;文生文&lt;/h3&gt;
&lt;p&gt;（质量不予置评）&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1718894828906.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;文生图&#34;&gt;文生图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1718894931102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Spring-Ai-Alibaba还提供了一些示例，在他们的&lt;a href=&#34;https://github.com/alibaba/spring-cloud-alibaba/tree/2023.x/spring-cloud-alibaba-examples/ai-example/spring-cloud-ai-example&#34;&gt;官方Github&lt;/a&gt;上，可以参考。&lt;br&gt;
官方还提供了一个简单的HTML来进行页面展示，也可以自己跑一下看看，最终效果如下：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1718895254096.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;代码-2&#34;&gt;代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-ai-alibaba-demo/spring-ai-alibaba-demo&#34;&gt;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-ai-alibaba-demo/spring-ai-alibaba-demo&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考博客&#34;&gt;参考博客&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/xiezhr/p/18251683#!comments&#34;&gt;阿里也出手了！Spring CloudAlibaba AI问世了 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/jingzh/p/18235636&#34;&gt;AI框架之Spring AI与Spring Cloud Alibaba AI使用讲解 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Spring AI</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-new-future-cds/"" data-c="
          &lt;p&gt;什么是CDS？CDS即 &lt;code&gt;Class-Data Sharing&lt;/code&gt;，类数据共享功能，该功能可以减少Java应用程序的启动时间和内存占用。&lt;/p&gt;
&lt;p&gt;类数据共享功能有助于减少多个Java虚拟机之间的启动时间和内存占用，从JDK12开始，默认的CDS归档文件和JDK二进制文件预先打包，我是用的JDK为OpenJDK &lt;code&gt;OpenJDK 64-Bit Server VM Zulu17.42+19-CA (build 17.0.7+7-LTS, mixed mode, sharing)&lt;/code&gt;，是支持CDS的。&lt;/p&gt;
&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;
&lt;h2 id=&#34;训练应用程序&#34;&gt;训练应用程序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先初始化一个标准的SpringBoot应用，使用 &lt;code&gt;SpringBoot-3.3.0&lt;/code&gt; + &lt;code&gt;Java17&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   │   └── top
│   │   │       └── imyzt
│   │   │           └── learning
│   │   │               └── cds
│   │   │                   └── Java12NewFuturesCdsApplication.java
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class Java12NewFuturesCdsApplication {
    public static void main(String[] args) {
        SpringApplication.run(Java12NewFuturesCdsApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;将其执行&lt;code&gt;Maven&lt;/code&gt;打包成&lt;code&gt;jar&lt;/code&gt;文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;➜  mvn package -DskipTests=true
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;执行训练命令&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;➜  cd target
➜  target ✗ java -Djarmode=tools -jar java12-new-futures-cds-0.0.1-SNAPSHOT.jar extract --destination application  
➜  cd application
➜  application ✗ java -XX:ArchiveClassesAtExit=application.jsa -Dspring.context.exit=onRefresh -jar java12-new-futures-cds-0.0.1-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;训练完成后，&lt;code&gt;application&lt;/code&gt;目录下，生成了一系列文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;➜  application git:(master) ✗ tree
.
├── application.jsa
├── java12-new-futures-cds-0.0.1-SNAPSHOT.jar
└── lib
    ├── jackson-annotations-2.17.1.jar
    ├── jackson-core-2.17.1.jar
    ├── jackson-databind-2.17.1.jar
    ├── jackson-datatype-jdk8-2.17.1.jar
    ├── jackson-datatype-jsr310-2.17.1.jar
    ├── jackson-module-parameter-names-2.17.1.jar
    ├── jakarta.annotation-api-2.1.1.jar
    ├── jul-to-slf4j-2.0.13.jar
    ├── log4j-api-2.23.1.jar
    ├── log4j-to-slf4j-2.23.1.jar
    ├── logback-classic-1.5.6.jar
    ├── logback-core-1.5.6.jar
    ├── micrometer-commons-1.13.0.jar
    ├── micrometer-observation-1.13.0.jar
    ├── slf4j-api-2.0.13.jar
    ├── snakeyaml-2.2.jar
    ├── spring-aop-6.1.8.jar
    ├── spring-beans-6.1.8.jar
    ├── spring-boot-3.3.0.jar
    ├── spring-boot-autoconfigure-3.3.0.jar
    ├── spring-boot-jarmode-tools-3.3.0.jar
    ├── spring-context-6.1.8.jar
    ├── spring-core-6.1.8.jar
    ├── spring-expression-6.1.8.jar
    ├── spring-jcl-6.1.8.jar
    ├── spring-web-6.1.8.jar
    ├── spring-webmvc-6.1.8.jar
    ├── tomcat-embed-core-10.1.24.jar
    ├── tomcat-embed-el-10.1.24.jar
    └── tomcat-embed-websocket-10.1.24.jar
1 directory, 32 files
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;使用训练的缓存，在启动应用程序时，补充&lt;code&gt;-XX:SharedArchiveFile&lt;/code&gt;参数即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;➜  application ✗ java -XX:SharedArchiveFile=application.jsa -jar java12-new-futures-cds-0.0.1-SNAPSHOT.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动日志：&lt;br&gt;
Started Java12NewFuturesCdsApplication in &lt;strong&gt;2.262 seconds&lt;/strong&gt; (process running for 2.805)&lt;/p&gt;
&lt;p&gt;对比不使用CDS缓存的启动日志：&lt;br&gt;
Started Java12NewFuturesCdsApplication in &lt;strong&gt;4.464 seconds&lt;/strong&gt; (process running for 5.341)&lt;/p&gt;
&lt;p&gt;可以看出来，尽管只是一个空项目，但是相同配置情况下启动速度都有倍增。&lt;/p&gt;
&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;
&lt;p&gt;从上面的测试可以看出来，项目的启动速度是有成本的效率增长的，但同时也存在弊端，就是每次应用程序发生变更时，需要冲洗进行jsa文件的训练。&lt;/p&gt;
&lt;p&gt;不管是native-jar还是CDS，都是Java在云原生时代解决应用启动过程慢的探索，在应用的自动扩容领域，还是有不少的应用场景。&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/pRzztgb_lnob552QM_3ixA&#34;&gt;Spring Boot 3.3.0 新特性| 使用 CDS 优化启动时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/use-D/p/17206585.html&#34;&gt;CDS即Class-Data Sharing&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">Java New Future CDS</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-yi-bu-chu-shi-hua/"" data-c="
          &lt;p&gt;在Spring6.2版本后，支持了异步初始化。&lt;br&gt;
什么是异步初始化？见名知意，就是将Spring项目的初始化过程中的Bean通过异步加载的方式提高启动速度。&lt;br&gt;
在业务系统中通常启动不会特别耗时，但也可以将系统启动过程中需要耗时初始化的Bean通过异步将其并行初始化，节省部分启动时间。本文作为学习Why哥文章之后的简单使用记录。&lt;/p&gt;
&lt;h1 id=&#34;模拟初始化bean耗时&#34;&gt;模拟初始化Bean耗时&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;ABean&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Slf4j
public class TestABean {
    @SneakyThrows
    public TestABean() {
        log.info(&amp;quot;A Bean开始初始化&amp;quot;);
        TimeUnit.SECONDS.sleep(5);
        log.info(&amp;quot;A Bean初始化完成&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;BBean&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Slf4j
public class TestBBean {
    @SneakyThrows
    public TestBBean() {
        log.info(&amp;quot;B Bean开始初始化&amp;quot;);
        TimeUnit.SECONDS.sleep(6);
        log.info(&amp;quot;B Bean初始化完成&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;配置类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class RegisterConfiguration {
    @Bean
    public TestABean testABean() {
        return new TestABean();
    }
    @Bean
    public TestBBean testBBean() {
        return new TestBBean();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;启动类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Slf4j
@ComponentScan(&amp;quot;top.imyzt.learning.spring.startup&amp;quot;)
public class Application {
    public static void main(String[] args) {
        StopWatch stopWatch = new StopWatch(&amp;quot;Spring启动&amp;quot;);
        stopWatch.start();
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Application.class);
        stopWatch.stop();
        System.out.println(stopWatch.prettyPrint());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;启动日志&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;21:39:33.658 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;testABean&#39;
21:39:33.663 [main] INFO top.imyzt.learning.spring.startup.core.TestABean - A Bean开始初始化
21:39:38.667 [main] INFO top.imyzt.learning.spring.startup.core.TestABean - A Bean初始化完成
21:39:38.669 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;testBBean&#39;
21:39:38.670 [main] INFO top.imyzt.learning.spring.startup.core.TestBBean - B Bean开始初始化
21:39:44.673 [main] INFO top.imyzt.learning.spring.startup.core.TestBBean - B Bean初始化完成
StopWatch &#39;Spring启动&#39;: 11.555947229 seconds
------------------------------------------
Seconds       %       Task name
------------------------------------------
11.55594723   100%    
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;小结&lt;br&gt;
可以看到，在常规情况下，A和B Bean是串行初始化的，整个初始化耗时11.5s。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;异步初始化&#34;&gt;异步初始化&lt;/h1&gt;
&lt;p&gt;在Spring6.2版本中，&lt;code&gt;@Bean&lt;/code&gt;注解引入了一个新的属性：&lt;code&gt;bootstrap&lt;/code&gt;，默认&lt;code&gt;Bean.Bootstrap.DEFAULT&lt;/code&gt;时为串行初始化，当指定为&lt;code&gt;Bean.Bootstrap.BACKGROUND&lt;/code&gt;时，Spring会尝试异步初始化该Bean，但是需要配置一个名为&lt;code&gt;bootstrapExecutor&lt;/code&gt;的线程池，用作异步初始化时所需的线程。&lt;br&gt;
只需要将配置类稍作修改，就可以将指定的Bean进行异步初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class RegisterConfiguration {

    @Bean(bootstrap = Bean.Bootstrap.BACKGROUND)
    public TestABean testABean() {
        return new TestABean();
    }

    @Bean(bootstrap = Bean.Bootstrap.BACKGROUND)
    public TestBBean testBBean() {
        return new TestBBean();
    }

    @Bean()
    public Executor bootstrapExecutor() {
        return new ThreadPoolExecutor(2, 10, 1, TimeUnit.MINUTES, new ArrayBlockingQueue&amp;lt;&amp;gt;(1024));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们再查看启动效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-log&#34;&gt;21:53:49.023 [pool-1-thread-1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;testABean&#39;
21:53:49.024 [pool-1-thread-1] INFO top.imyzt.learning.spring.startup.core.TestABean - A Bean开始初始化
21:53:49.025 [pool-1-thread-2] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;testBBean&#39;
21:53:49.026 [pool-1-thread-2] INFO top.imyzt.learning.spring.startup.core.TestBBean - B Bean开始初始化
21:53:54.029 [pool-1-thread-1] INFO top.imyzt.learning.spring.startup.core.TestABean - A Bean初始化完成
21:53:55.031 [pool-1-thread-2] INFO top.imyzt.learning.spring.startup.core.TestBBean - B Bean初始化完成
StopWatch &#39;Spring启动&#39;: 6.740055683 seconds
-----------------------------------------
Seconds       %       Task name
-----------------------------------------
6.740055683   100%    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到启动时间从11.5s降为6.7s，效果十分显著，在部分需要依赖外部或已知需要耗时初始化的Bean，可以通过此方法进行优化。“我可以不用，你不能没有”。&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/FVHURjv5QZ3oYW4n8-kpLw&#34;&gt;13年过去了，Spring官方竟然真的支持Bean的异步初始化了！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-async-startup&#34;&gt;博客对应代码&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">Spring 异步初始化</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/fei-jing-tai-nei-bu-lei-chi-you-wai-bu-lei-de-yin-yong/"" data-c="
          &lt;p&gt;在分析&lt;code&gt;内存泄漏&lt;/code&gt;领域的问题时，时常会提到的就是&lt;strong&gt;非静态内部类持有外部类的引用&lt;/strong&gt;导致的内存泄漏，因为内部类持有了外部类的引用，导致垃圾回收器无法回收外部类对象，久而久之就会存在内存泄漏的隐患。&lt;/p&gt;
&lt;p&gt;我们在使用非静态内部类的时候，并不是说我们不手动编码引用外部类对象属性就不存在引用关系，实际上这层关系是通过隐式引用来实现的。&lt;/p&gt;
&lt;h1 id=&#34;静态内部类持有外部类的引用&#34;&gt;静态内部类持有外部类的引用&lt;/h1&gt;
&lt;p&gt;我们写一个非静态内部类对象示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2024/05/13
 * @description 非静态内部类,匿名持有外部类的引用
 */
public class NonStaticInnerClazz {
    private final String name;
    public NonStaticInnerClazz(String name) {
        this.name = name;
    }
    public class Inner {
        public void print() {
            System.out.println(name);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到javac之后的代码中，第九行方法形参将外部类&lt;code&gt;NonStaticInnerClazz&lt;/code&gt;传入给了内部类的&lt;code&gt;this.this$0&lt;/code&gt;属性进行引用。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1715606537329.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;非静态内部类无法引用外部类的属性&#34;&gt;非静态内部类无法引用外部类的属性&lt;/h1&gt;
&lt;p&gt;而非静态内部类则没有这种情况。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2024/05/13
 * @description 静态内部类,无法引用外部类的属性
 */
public class StaticInnerClazz {
    private final String name;
    public StaticInnerClazz(String name) {
        this.name = name;
    }
    public static class Inner2 {
        public void print2() {
            // Non-static field &#39;name&#39; cannot be referenced from a static context
            // System.out.println(name);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1715606551056.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;其他非静态内部类引用的情况&#34;&gt;其他非静态内部类引用的情况&lt;/h1&gt;
&lt;p&gt;而其他非静态内部类的情况也有类似的问题：&lt;br&gt;
编写测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2024/05/13
 * @description 描述信息
 */
public class NonStaticFieldClazz {
    // 成员变量-匿名内部类的非static实例
    private Inner3 inner3_1 = new Inner3() {
        private Integer field_111;
    };
    // 成员变量-非静态内部类的非static实例
    private Inner3 inner3_2 = new Inner3();
    public void print() {
        // 局部变量-匿名内部类的非static实例
        Inner3 inner3_3 = new Inner3() {
            private Integer field_333;
        };
        // 局部变量-非静态内部类的非static实例
        Inner3 inner3_4 = new Inner3();
    }
    public class Inner3 {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-成员变量-匿名内部类的非static实例&#34;&gt;1. 成员变量-匿名内部类的非static实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class NonStaticFieldClazz$1 extends NonStaticFieldClazz.Inner3 {
    private Integer field_111;
    NonStaticFieldClazz$1(NonStaticFieldClazz var1) {
        super(var1);
        this.this$0 = var1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-局部变量-匿名内部类的非static实例&#34;&gt;2. 局部变量-匿名内部类的非static实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class NonStaticFieldClazz$2 extends NonStaticFieldClazz.Inner3 {
    private Integer field_333;
    NonStaticFieldClazz$2(NonStaticFieldClazz var1) {
        super(var1);
        this.this$0 = var1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-局部变量和成员变量的非static内部类的非static实例&#34;&gt;3. 局部变量和成员变量的非static内部类的非static实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NonStaticFieldClazz$Inner3 {
    public NonStaticFieldClazz$Inner3(NonStaticFieldClazz var1) {
        this.this$0 = var1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/whurs/article/details/103231427&#34;&gt;内存泄漏-内部类持有外部类引用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">非静态内部类持有外部类的引用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/neo4j-chang-yong-ming-ling/"" data-c="
          &lt;h1 id=&#34;where&#34;&gt;WHERE&lt;/h1&gt;
&lt;p&gt;可以类似于SQL的写法来实现，首先通过&lt;code&gt;match&lt;/code&gt;将节点查询出来(n,m)，然后通过&lt;code&gt;WHERE&lt;/code&gt;将数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;match (n:Lianhuachi),(m:Lianhuachi) where n.name = &#39;去种田的向凹凸&#39; and m.name = &amp;quot;向云朵&amp;quot;
return id(n),n.name,id(m),m.name
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;match (n:Lianhuachi {name: &amp;quot;去种田的向凹凸&amp;quot;}),(m:Lianhuachi {name: &amp;quot;向云朵&amp;quot;})
return id(n),n.name,id(m),m.name
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;delete-删除节点&#34;&gt;DELETE-删除节点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;删除节点（如果节点存在关系时，是无法删除的）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;match (n: Person {name: &amp;quot;xxx&amp;quot;}) delete n
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;删除关系&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;match (n: Person {name: &amp;quot;小红&amp;quot;})-[r]-&amp;gt;(m: Person {name: &amp;quot;小明&amp;quot;}) delete r
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;remove-删除属性&#34;&gt;REMOVE-删除属性&lt;/h1&gt;
&lt;h2 id=&#34;首先在student和person标签创建1一个节点&#34;&gt;首先，在student和person标签创建1一个节点&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cql&#34;&gt;create (n:student:person {name: &amp;quot;张三&amp;quot;, age: 18}) return n
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查询节点&#34;&gt;查询节点&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MATCH (n:person) where n.name = &amp;quot;张三&amp;quot; RETURN n LIMIT 25&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1715301497013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;MATCH (n:student) RETURN n LIMIT 25&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1715301490854.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;删除标签中的节点&#34;&gt;删除标签中的节点&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MATCH (n:person) where n.name = &amp;quot;张三&amp;quot; remove n&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;删除标签中节点的属性&#34;&gt;删除标签中节点的属性&lt;/h2&gt;
&lt;p&gt;删除前，age=18 &lt;code&gt;MATCH (n:student) where n.name = &amp;quot;张三&amp;quot; return n&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1715301732611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
删除后，age无了 &lt;code&gt;MATCH (n:student) where n.name = &amp;quot;张三&amp;quot; remove n.age return n&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1715301781763.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改标签中节点的属性&#34;&gt;修改标签中节点的属性&lt;/h2&gt;
&lt;p&gt;修改后，age回来了 &lt;code&gt;MATCH (n:student) where n.name = &amp;quot;张三&amp;quot; set n.age=18 return n&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1715301862819.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
给榜首增加一个属性 &lt;code&gt;match (n:Lianhuachi {name: &amp;quot;我是野农&amp;quot;}) set n.title = &#39;虾米榜榜首&#39; return n&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1719409420804.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;order-by-排序&#34;&gt;ORDER BY - 排序&lt;/h1&gt;
&lt;p&gt;补充测试数据&lt;br&gt;
&lt;code&gt;create (n:student {name: &amp;quot;张三&amp;quot;, age: 18}),(m:student {name: &amp;quot;李四&amp;quot;, age: 22}) return n,m&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;match (n:student) return id(n), n.name,n.age order by n.age desc &lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id(n)&lt;/th&gt;
&lt;th&gt;n.name&lt;/th&gt;
&lt;th&gt;n.age&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;&amp;quot;李四&amp;quot;&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;&amp;quot;张三&amp;quot;&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;null-null属性&#34;&gt;NULL - NULL属性&lt;/h1&gt;
&lt;p&gt;查询&lt;code&gt;name&lt;/code&gt;属性不为空的节点&lt;br&gt;
&lt;code&gt;match (n:student) where n.name is not null return n.name,n.label&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n.name&lt;/th&gt;
&lt;th&gt;n.label&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;quot;张三&amp;quot;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;quot;李四&amp;quot;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;查询&lt;code&gt;sex&lt;/code&gt;属性为空的节点&lt;br&gt;
&lt;code&gt;match (n:student) where n.sex is null return n.name,n.label&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n.name&lt;/th&gt;
&lt;th&gt;n.label&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;quot;张三&amp;quot;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;quot;李四&amp;quot;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;给&lt;strong&gt;张三&lt;/strong&gt;设置&lt;code&gt;sex&lt;/code&gt;属性，注意&lt;code&gt;where&lt;/code&gt;在前，&lt;code&gt;set&lt;/code&gt;在后，和&lt;code&gt;MySQL&lt;/code&gt;等相反&lt;br&gt;
&lt;code&gt;match (n:student)  where n.name=&#39;张三&#39; set n.sex=&#39;男&#39; return n.name,n.sex,n.age&lt;/code&gt;&lt;br&gt;
查询结果：&lt;code&gt;match (n:student) return n&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1715526279128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;in-查询多个&#34;&gt;IN - 查询多个&lt;/h1&gt;
&lt;p&gt;查询&lt;code&gt;name&lt;/code&gt;等于张三或李四的人：&lt;br&gt;
&lt;code&gt;match (n:student) where n.name in [&amp;quot;张三&amp;quot;, &amp;quot;李四&amp;quot;] return n&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;索引&#34;&gt;索引&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://neo4j.com/docs/cypher-manual/current/indexes/search-performance-indexes/managing-indexes/&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;旧版本&#34;&gt;旧版本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建索引：&lt;br&gt;
&lt;code&gt;create index on :节点 (属性)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除索引：&lt;br&gt;
&lt;code&gt;drop index on :节点(属性)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新版本5或更高版本&#34;&gt;新版本(5或更高版本)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建索引：&lt;br&gt;
缺省索引名称：&lt;br&gt;
&lt;code&gt;CREATE INDEX [index_name（可缺省）] FOR (n:person) ON (n.name)&lt;/code&gt;&lt;br&gt;
指定索引名称：&lt;br&gt;
&lt;code&gt;create index index_test for (n:person) on (n.name)&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Added 1 index, completed after 992 ms.&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询所有索引：&lt;br&gt;
&lt;code&gt;show indexes&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;state&lt;/th&gt;
&lt;th&gt;populationPercent&lt;/th&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;entityType&lt;/th&gt;
&lt;th&gt;labelsOrTypes&lt;/th&gt;
&lt;th&gt;properties&lt;/th&gt;
&lt;th&gt;indexProvider&lt;/th&gt;
&lt;th&gt;owningConstraint&lt;/th&gt;
&lt;th&gt;lastRead&lt;/th&gt;
&lt;th&gt;readCount&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;quot;index_343aff4e&amp;quot;&lt;/td&gt;
&lt;td&gt;&amp;quot;ONLINE&amp;quot;&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;&amp;quot;LOOKUP&amp;quot;&lt;/td&gt;
&lt;td&gt;&amp;quot;NODE&amp;quot;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;&amp;quot;token-lookup-1.0&amp;quot;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;&amp;quot;2024-05-18T13:26:33.878000000Z&amp;quot;&lt;/td&gt;
&lt;td&gt;571&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&amp;quot;index_a302cc54&amp;quot;&lt;/td&gt;
&lt;td&gt;&amp;quot;ONLINE&amp;quot;&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;&amp;quot;RANGE&amp;quot;&lt;/td&gt;
&lt;td&gt;&amp;quot;NODE&amp;quot;&lt;/td&gt;
&lt;td&gt;[&amp;quot;person&amp;quot;]&lt;/td&gt;
&lt;td&gt;[&amp;quot;name&amp;quot;]&lt;/td&gt;
&lt;td&gt;&amp;quot;range-1.0&amp;quot;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;quot;index_f7700477&amp;quot;&lt;/td&gt;
&lt;td&gt;&amp;quot;ONLINE&amp;quot;&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;&amp;quot;LOOKUP&amp;quot;&lt;/td&gt;
&lt;td&gt;&amp;quot;RELATIONSHIP&amp;quot;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;&amp;quot;token-lookup-1.0&amp;quot;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;&amp;quot;2024-05-10T00:48:00.395000000Z&amp;quot;&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;删除索引：&lt;br&gt;
&lt;code&gt;drop index index_a302cc54&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Removed 1 index, completed after 5 ms.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
">Neo4j 常用命令 一</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/shi-yong-neo4j-jian-li-lian-hua-chi-ren-wu-guan-xi-tu-he-xin-ren-wu-jian-ban/"" data-c="
          &lt;p&gt;最近关注了沅陵的莲花池，整个村子都是钓鱼佬，人均up主，基本都是沾亲带故的，错综复杂，恰逢正在学习Neo4j，可以借此机会将人物关系通过图谱的方式呈现出来。&lt;/p&gt;
&lt;h1 id=&#34;人物标签创建&#34;&gt;人物标签创建&lt;/h1&gt;
&lt;p&gt;首先将人物关系建立出来，利用&lt;code&gt;create&lt;/code&gt;来创建效率实在太低了 ，所以决定采用数据导入的方式。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;点击查看莲花池人物详情&lt;/summary&gt;
&lt;div&gt;
  去种田的向凹凸  
  &lt;div&gt;
    小白兔的胡萝卜甜（冉甜）
  &lt;/div&gt;
  &lt;div&gt;
    向云朵
  &lt;/div&gt;
  &lt;div&gt;
    我是野农
  &lt;/div&gt;
  &lt;div&gt;
    画燕儿
  &lt;/div&gt;
  &lt;div&gt;
    向鹿鸣
  &lt;/div&gt;
  &lt;div&gt;
    路人阿丙X
  &lt;/div&gt;
  &lt;div&gt;
    大明星（冉蜜）
  &lt;/div&gt;
  &lt;div&gt;
    向偶然
  &lt;/div&gt;
  &lt;div&gt;
    荷塘星星
  &lt;/div&gt;
  &lt;div&gt;
    向尘俊
  &lt;/div&gt;
  &lt;div&gt;
    向星言
  &lt;/div&gt;
  &lt;div&gt;
    多肉葡萄肉多多
  &lt;/div&gt;
  &lt;div&gt;
    白叔
  &lt;/div&gt;
  &lt;div&gt;
    播音哥
  &lt;/div&gt;
  &lt;div&gt;
    三叔
  &lt;/div&gt;
  &lt;div&gt;
    丹宝
  &lt;/div&gt;
  &lt;div&gt;
    守山人阿亮
  &lt;/div&gt;
&lt;/div&gt;  
&lt;/details&gt;
&lt;p&gt;导入数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;load csv from &amp;quot;file:///莲花池人物.csv&amp;quot; as line 
create (:Lianhuachi {name: line[0]})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终效果图：&lt;br&gt;
&lt;code&gt;MATCH (n:Lianhuachi) RETURN n LIMIT 25&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1713798289894.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;人物关系标签创建&#34;&gt;人物关系标签创建&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt;莲花池人物关系（简版）&lt;/summary&gt;
  &lt;div&gt;小白兔的胡萝卜甜（冉甜）,丈夫,去种田的向凹凸&lt;/div&gt;
  &lt;div&gt;去种田的向凹凸,妻子,小白兔的胡萝卜甜（冉甜）&lt;/div&gt;
  &lt;div&gt;小白兔的胡萝卜甜（冉甜）,女儿,向云朵&lt;/div&gt;
  &lt;div&gt;去种田的向凹凸,女儿,向云朵&lt;/div&gt;
  &lt;div&gt;画燕儿,丈夫,我是野农&lt;/div&gt;
  &lt;div&gt;我是野农,妻子,画燕儿&lt;/div&gt;
  &lt;div&gt;画燕儿,儿子,向鹿鸣&lt;/div&gt;
  &lt;div&gt;我是野农,儿子,向鹿鸣&lt;/div&gt;
  &lt;div&gt;大明星（冉蜜）,丈夫,路人阿丙X&lt;/div&gt;
  &lt;div&gt;路人阿丙X,妻子,大明星（冉蜜）&lt;/div&gt;
  &lt;div&gt;大明星（冉蜜）,女儿,向偶然&lt;/div&gt;
  &lt;div&gt;路人阿丙X,女儿,向偶然&lt;/div&gt;
  &lt;div&gt;多肉葡萄肉多多,丈夫,荷塘星星&lt;/div&gt;
  &lt;div&gt;荷塘星星,妻子,多肉葡萄肉多多&lt;/div&gt;
  &lt;div&gt;荷塘星星,儿子,向尘俊&lt;/div&gt;
  &lt;div&gt;多肉葡萄肉多多,儿子,向尘俊&lt;/div&gt;
  &lt;div&gt;荷塘星星,女儿,向星言&lt;/div&gt;
  &lt;div&gt;多肉葡萄肉多多,女儿,向星言&lt;/div&gt;
  &lt;div&gt;向星言,亲哥,向尘俊&lt;/div&gt;
  &lt;div&gt;向尘俊,亲妹,向星言&lt;/div&gt;
  &lt;div&gt;荷塘星星,父亲,三叔&lt;/div&gt;
  &lt;div&gt;三叔,儿子,荷塘星星&lt;/div&gt;
  &lt;div&gt;荷塘星星,表哥,守山人阿亮&lt;/div&gt;
  &lt;div&gt;守山人阿亮,表弟,荷塘星星&lt;/div&gt;
  &lt;div&gt;我是野农,亲弟,路人阿丙X&lt;/div&gt;
  &lt;div&gt;路人阿丙X,亲哥,我是野农&lt;/div&gt;
  &lt;div&gt;我是野农,钓友,去种田的向凹凸&lt;/div&gt;
  &lt;div&gt;去种田的向凹凸,钓友,我是野农&lt;/div&gt;
  &lt;div&gt;去种田的向凹凸,同村,荷塘星星&lt;/div&gt;
  &lt;div&gt;我是野农,钓友,荷塘星星&lt;/div&gt;
  &lt;div&gt;荷塘星星,钓友,我是野农&lt;/div&gt;
  &lt;div&gt;去种田的向凹凸,同村,荷塘星星&lt;/div&gt;
&lt;/details&gt;
&lt;p&gt;导入数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;load csv from &amp;quot;file:///莲花池人物关系.csv&amp;quot; as line 
create (n:LianhuachiRelation {from: line[0], relation: line[1], to: line[2]})
return n.from, n.relation, n.to
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终效果：&lt;br&gt;
&lt;code&gt;MATCH (n:LianhuachiRelation) RETURN n.from, n.relation, n.to&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1714056955094.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;借助人物关系标签创建人物关系&#34;&gt;借助人物关系标签，创建人物关系&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;match (f:Lianhuachi),(r:LianhuachiRelation),(t:Lianhuachi) where f.name=r.from and t.name=r.to
create (f)-[rr:莲花池人物关系 {relation: r.relation}]-&amp;gt;(t)
return f.name, rr.relation, t.name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终效果：&lt;br&gt;
&lt;code&gt;MATCH p=()-[r:&lt;/code&gt;莲花池人物关系&lt;code&gt;]-&amp;gt;() RETURN p LIMIT 25&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1714057384358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;查询人物关系&#34;&gt;查询人物关系&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;match (n:Lianhuachi {name: &amp;quot;向云朵&amp;quot;}),(m:LianhuachiRelation) where m.from=&#39;向云朵&#39;
    return n.name, m.relation, m.to
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1713968908751.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;在现有的基础上补充人物关系&#34;&gt;在现有的基础上，补充人物关系&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;match (n:Lianhuachi{name:&amp;quot;大明星（冉蜜）&amp;quot;}),(m:Lianhuachi{name:&amp;quot;小白兔的胡萝卜甜（冉甜）&amp;quot;})
create (n)-[r:`莲花池人物关系`{relation:&amp;quot;亲姐&amp;quot;}]-&amp;gt;(m)

match (n:Lianhuachi{name:&amp;quot;大明星（冉蜜）&amp;quot;}),(m:Lianhuachi{name:&amp;quot;小白兔的胡萝卜甜（冉甜）&amp;quot;})
create (m)-[r:`莲花池人物关系`{relation:&amp;quot;亲妹&amp;quot;}]-&amp;gt;(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1714204509855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;删除重建人物关系&#34;&gt;删除重建人物关系&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;MATCH (n:Lianhuachi {name:&amp;quot;去种田的向凹凸&amp;quot;})-[r:`莲花池人物关系` {relation: &amp;quot;钓友&amp;quot;}]-&amp;gt;(m:Lianhuachi {name:&amp;quot;我是野农&amp;quot;})
delete r
MATCH (n:Lianhuachi {name:&amp;quot;我是野农&amp;quot;})-[r:`莲花池人物关系` {relation: &amp;quot;钓友&amp;quot;}]-&amp;gt;(m:Lianhuachi {name:&amp;quot;去种田的向凹凸&amp;quot;})
delete r

MATCH (n:Lianhuachi {name:&amp;quot;去种田的向凹凸&amp;quot;}),(m:Lianhuachi {name:&amp;quot;我是野农&amp;quot;})
create (n)-[r2:`莲花池人物关系` {relation: &amp;quot;表哥&amp;quot;}]-&amp;gt;(m)
create (m)-[r3:`莲花池人物关系` {relation: &amp;quot;表弟&amp;quot;}]-&amp;gt;(n)
 return r2.relation,r3.relation
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1715004118846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">使用Neo4j建立莲花池人物关系图（核心人物，简版）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java8-shi-yong-suntoolsjavadoc-du-qu-zhu-shi-xin-xi/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;项目需要整理所有依赖的外部Feign调用，整理成一份文档，类似于：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;远程接口&lt;/th&gt;
&lt;th&gt;调用位置&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;xxx/zzz&lt;/td&gt;
&lt;td&gt;top.imyzt.xxx#methodName&lt;/td&gt;
&lt;td&gt;用作xxx&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;方案&#34;&gt;方案&lt;/h1&gt;
&lt;p&gt;因为项目过多，且依赖的外部服务接口众多，不想一个个去整理，故想直接读取所有的Feign接口，直接扫描出方法注释，将上述表格完成。&lt;/p&gt;
&lt;p&gt;Java是编译型语言，当代码从&lt;code&gt;.java&lt;/code&gt;编译成&lt;code&gt;.class&lt;/code&gt;后，代码中的注释将会清空，所以说，项目打包之后，就无法再进行注释的解析了，所以反射等方案不可行，通过在Google搜索，发现了&lt;code&gt;com.sun.tools.javadoc.Main&lt;/code&gt;工具类，可以直接读取文件的形式读取&lt;code&gt;.java&lt;/code&gt;文件，然后解析其中的各类注释信息，使用起来也很简单，下面举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 类注释
 * @author imyzt
 * @date 2024/04/10
 */
public class Demo {

    /**
     * 方法注释
     */
    public void demo() {

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是一个简单的带注释的类，通过sun公司的工具类，可以直接读取：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Doclet {
    public static Logger logger = LoggerFactory.getLogger(Doclet.class);

    private static RootDoc rootDoc;
    private final String clsFilePath;

    public static boolean start(RootDoc root) {
        rootDoc = root;
        return true;
    }

    public Doclet(String clsFilePath) {
        this.clsFilePath = clsFilePath;
    }

    public void exec() {
        com.sun.tools.javadoc.Main.execute(
                new String[]{&amp;quot;-doclet&amp;quot;, Doclet.class.getName(),
                        &amp;quot;-docletpath&amp;quot;, Doclet.class.getResource(&amp;quot;/&amp;quot;).getPath(),
                        &amp;quot;-encoding&amp;quot;, &amp;quot;utf-8&amp;quot;,
                        clsFilePath});
        ClassDoc[] classes = rootDoc.classes();

        if (classes == null || classes.length == 0) {
            logger.warn(clsFilePath + &amp;quot; 无ClassDoc信息&amp;quot;);
            return;
        }

        ClassDoc classDoc = classes[0];
        // 获取类的名称
        System.err.println(&amp;quot;类名：&amp;quot; + classDoc.name());
        // 获取类的注释
        String classComment = Reflect.on(classDoc).field(&amp;quot;documentation&amp;quot;).get().toString();
        System.err.println(&amp;quot;类注释：&amp;quot; + classComment);
        // 获取属性名称和注释
        for (FieldDoc field : classDoc.fields(false)) {
            System.err.printf(&amp;quot;属性名：%s, 属性类型：%s, 注释：%s%n&amp;quot;, field.name(), field.type().typeName(), field.commentText());
        }

        for (MethodDoc method : classDoc.methods(false)) {
            System.err.printf(&amp;quot;方法名：%s, 方法返回类型：%s, 注释：%s%n&amp;quot;, method.name(), method.returnType().typeName(), method.commentText());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终的运行效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CommentReader {

    public static void main(String[] args) {
        Doclet doclet = new Doclet(&amp;quot;/Users/.../java-reader-classormethod-comment/src/main/java/top/imyzt/learing/readercomment/Demo.java&amp;quot;);
        doclet.exec();
        // 正在构造 Javadoc 信息...
        // 类名：Demo
        // 类注释： 类注释
        //  @author imyzt
        //  @date 2024/04/10
        //
        // 方法名：demo, 方法返回类型：void, 注释：方法注释
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这个工具类，可以快速的读取，解析各类注释信息，进行资料的整理。&lt;br&gt;
工具类还有很多其他的API，网上资料也很多，这里只是记录做一个备忘，具体的使用时进行Google搜索即可。&lt;/p&gt;
&lt;h1 id=&#34;示例代码&#34;&gt;示例代码&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/framework-in-java/java-reader-classormethod-comment&#34;&gt;java-reader-classormethod-comment&lt;/a&gt;&lt;/p&gt;
">Java8 使用sun.tools.javadoc 读取注释信息</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/neo4j-shi-yong/"" data-c="
          &lt;ul&gt;
&lt;li&gt;图数据模型：与关系型数据库使用表格存储数据不同，图数据库通过节点（Node）和关系（Relationship）来表示数据和它们之间的联系。&lt;/li&gt;
&lt;li&gt;节点：代表实体，如人、地点、物品等。&lt;/li&gt;
&lt;li&gt;关系：定义节点之间的连接，可以有方向和属性。&lt;/li&gt;
&lt;li&gt;属性：节点和关系的附加信息，如人的姓名、年龄等。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE (person1:Person {name: &#39;Alice&#39;, age: 30})
CREATE (person2:Person {name: &#39;Bob&#39;, age: 25})
CREATE (person1)-[:KNOWS]-&amp;gt;(person2)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;person1/person2：节点&lt;/li&gt;
&lt;li&gt;Person：标签&lt;/li&gt;
&lt;li&gt;name/age：属性&lt;/li&gt;
&lt;li&gt;KNOWS：关系&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;导入数据&#34;&gt;导入数据&lt;/h1&gt;
&lt;p&gt;通过GPT，生成《西游记》的人物关系图和人物名单，案例数据如下：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1713108314033.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;将文件放置于Neo4j的&lt;code&gt;Home/import&lt;/code&gt;目录下，然后执行导入命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;load csv from &amp;quot;file:///西游记.csv&amp;quot; as line
create (:xiyouRelation {from:line[1], relation:line[3],to:line[0]})

load csv from &amp;quot;file:///人物.csv&amp;quot; as line
create (:person {name:line[0]})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;match (person) return person&lt;/code&gt;，查看数据：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1713108420084.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;创建人物和关系&#34;&gt;创建人物和关系&lt;/h1&gt;
&lt;p&gt;创建人物和关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;创建人物
create (:student {name: &#39;小明&#39;}),(:student {name : &#39;小红&#39;}),(:student {name: &#39;小李&#39;})
创建人物关系，并且返回人物关系
match (n:student {name: &#39;小明&#39;}),(m:student {name: &#39;小红&#39;})
create (n)-[r:同学]-&amp;gt;(m) return n.name,type(r),m.name
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1713194179719.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;显示人物关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;MATCH p=()-[r:`同学`]-&amp;gt;() RETURN p LIMIT 25
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1713194172638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;删除标签&#34;&gt;删除标签&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;match (n:LianhuachiPerson)
detach delete n
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1713795379714.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;删除关系&#34;&gt;删除关系&lt;/h1&gt;
&lt;p&gt;命令：&lt;br&gt;
&lt;code&gt;match (n)-[r:&lt;/code&gt;西游人物关系&lt;code&gt;]-(s) delete r&lt;/code&gt;&lt;br&gt;
结果：&lt;br&gt;
&lt;code&gt;Deleted 18 relationships, completed after 6 ms.&lt;/code&gt;&lt;/p&gt;
">Neo4j 使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/hua-shi/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://imyzt.top/post-images/1711466708760.jpg&#34; alt=&#34;花&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1711466753884.jpg&#34; alt=&#34;花&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;-- 2024-03-24 摄于荷兰花卉小镇&lt;/p&gt;
">花市</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/ye-wu-luo-ji-bian-pai-cuo-wu-and-ttl-qian-kao-bei-dao-zhi-can-shu-diu-shi-wen-ti/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在DDD项目中，为了方便参数的传递，通常会使用&lt;code&gt;ThreadLocal&lt;/code&gt;来保存一个&lt;code&gt;对象&lt;/code&gt;来实现对参数的跨方法传递，避免通过形参的形式传递。在内部项目中，有一个项目使用的是 alibaba开源的 &lt;code&gt;transmittable-thread-local&lt;/code&gt;来存储参数，新建了一个上下文对象（&lt;code&gt;AbilityContext.java&lt;/code&gt;），使用&lt;code&gt;HashMap&lt;/code&gt;来临时存储和获取参数。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;AbilityContext 示例&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AbilityContext {
    private static final ThreadLocal&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; CONTEXT = new TransmittableThreadLocal&amp;lt;&amp;gt;();

    private AbilityContext() {
    }

    /**
     * 初始化上下文
     */
    public static void initContext() {
        Map&amp;lt;String, Object&amp;gt; con = CONTEXT.get();
        if (con == null) {
            CONTEXT.set(new HashMap&amp;lt;&amp;gt;(8));
        } else {
            CONTEXT.get().clear();
        }
    }

    /**
     * 清除上下文
     */
    public static void clearContext() {
        CONTEXT.remove();
    }

    public static Map&amp;lt;String, Object&amp;gt; getInnerMap() {
        return CONTEXT.get();
    }

    /**
     * 获取上下文内容
     */
    public static &amp;lt;T&amp;gt; T getValue(String key) {
        Map&amp;lt;String, Object&amp;gt; con = CONTEXT.get();
        if (con == null) {
            return null;
        }
        return (T) con.get(key);
    }

    /**
     * 设置上下文参数
     */
    public static void putValue(String key, Object value) {
        Map&amp;lt;String, Object&amp;gt; con = CONTEXT.get();
        if (con == null) {
            CONTEXT.set(new HashMap&amp;lt;&amp;gt;(8));
            con = CONTEXT.get();
        }
        con.put(key, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id=&#34;项目情况介绍&#34;&gt;项目情况介绍&lt;/h2&gt;
&lt;p&gt;通常来说，DDD项目的基本流程是由&lt;code&gt;interface-&amp;gt;application&lt;/code&gt;，中间封装一层来集中处理上下文的初始化和清空动作，如下图：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1709967464622.png&#34; alt=&#34;ddd&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;在正常情况下，上述流程可以正确的完成参数的写入和获取，但是，在项目运行过程中遇到了一个bug，正常写入参数后，偶现性（低频）获取值为NULL，导致程序出错，示例代码如下（隐去业务代码，重新写的伪代码）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其中&lt;code&gt;demo()&lt;/code&gt;方法为当时复现的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;demo2()&lt;/code&gt;为伪代码，是业务代码中调用了另一个&lt;code&gt;application&lt;/code&gt;，假设其逻辑和&lt;code&gt;demo()&lt;/code&gt;方法一致的业务代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Slf4j
public class AlibabaTtlWrongUsageExampleApplication {

    public static void main(String[] args) {
        demo(i);
    }

    private static void demo(int idx) {
        // 初始化
        AbilityContext.initContext();
        // 赋业务值
        AbilityContext.putValue(&amp;quot;main&amp;quot;, &amp;quot;mainValue&amp;quot;);

        // 这里简化了代码，实际上经过了很多层业务代码调用后才出现了此方法
        ThreadUtil.execute(() -&amp;gt; {
            execute-&amp;gt;demo2();
        });

        // do something

        // 主线程再次获取业务值(偶现为null)
        String value = AbilityContext.getValue(&amp;quot;main&amp;quot;);
        if (Objects.isNull(value)) {
            log.warn(&amp;quot;lastGetNullValue, idx={}&amp;quot;, idx);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码运行设置了一个&lt;code&gt;key=main&lt;/code&gt;，值为&lt;code&gt;mainValue&lt;/code&gt;。在下方&lt;code&gt;AbilityContext.getValue(&amp;quot;main&amp;quot;)&lt;/code&gt;偶现获取==NULL。&lt;/p&gt;
&lt;h2 id=&#34;展开分析&#34;&gt;展开分析&lt;/h2&gt;
&lt;p&gt;当时在分析的开始有推测是业务代码中参数被重新赋值为NULL，但通过对后续业务代码逐行查看，并没有找到重新赋值的逻辑。&lt;br&gt;
在深入业务代码分析的过程中，发现主流程中有一个异步方法调用（&lt;code&gt;ThreadUtil.execute()&lt;/code&gt;），再次调用了另一个&lt;strong&gt;领域服务&lt;/strong&gt;（这是不符合DDD规范的！），而&lt;strong&gt;领域服务的入口都会&lt;code&gt;AbilityContext.initContext()&lt;/code&gt;的逻辑&lt;/strong&gt;，通过这个线索 ，继续展开了深入分析。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1709970122111.png&#34; alt=&#34;ddd&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;编码者的初衷可能是想到&lt;strong&gt;异步线程已经脱离了当前线程，再次调用 &lt;code&gt;initContext()&lt;/code&gt;方法是初始化了一个新的对象上下文&lt;/strong&gt;，&lt;strong&gt;但是&lt;/strong&gt;由于项目使用的是 &lt;code&gt;alibaba TTL&lt;/code&gt;，能够实现跨线程的传递，所以在子线程中依旧能拿到父线程的&lt;code&gt;HashMap&lt;/code&gt;。并且&lt;strong&gt;TTL默认是使用的浅拷贝对象&lt;/strong&gt;。由于&lt;code&gt;initContext()&lt;/code&gt;中，调用了&lt;code&gt;HashMap.clear()&lt;/code&gt;方法，&lt;strong&gt;相当于将父线程的&lt;code&gt;HashMap&lt;/code&gt;给清空了！&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过比对父子线程的hashCode值确定为同一对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 主线程获取hashCode
final int hashCode = AbilityContext.getInnerMap().hashCode();
ThreadUtil.execute(() -&amp;gt; {
    // 子线程对比hashCode
    log.info(&amp;quot;{}, ThreadUtil hashCode={}&amp;quot;, idx, AbilityContext.getInnerMap().hashCode() == hashCode);
    // 子线程再次初始化(错误的根源)
    AbilityContext.initContext();
    // do something
});
14:42:28.198 [pool-1-thread-26] INFO top.imyzt.learning.caseanalysis.ttl.AlibabaTtlWrongUsageExampleApplication -- 25, ThreadUtil hashCode=true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;持续分析&#34;&gt;持续分析&lt;/h2&gt;
&lt;p&gt;有了上述的线索，基本把问题原因找到了，&lt;strong&gt;但是为什么是偶现的呢&lt;/strong&gt;？&lt;br&gt;
因为使用了异步线程，而线程的调度由操作系统的线程调度算法来决定，并不是一定保证顺序的，所以只要当操作系统优先调度异步线程，那么&lt;code&gt;HashMap&lt;/code&gt;就被清空了，如果主线程优先往下走，那么就能够获取到完整的&lt;code&gt;HashMap&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;至此，问题分析就告一段落了，整个过程中涉及到 TTL值的父子线程传递、对象浅拷贝、线程的调度，还涉及到了DDD的不规范逻辑编排，整个分析下来花费了一上午的时间，收获还是很大的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alibaba/transmittable-thread-local&#34;&gt;transmittable-thread-local&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alibaba/transmittable-thread-local/issues/111&#34;&gt;TransmittableThreadLocal的传递只有浅拷贝吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://redspider.gitbook.io/concurrent/di-yi-pian-ji-chu-pian/3#id-3.2-xian-cheng-de-you-xian-ji&#34;&gt;线程的优先级&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我将源代码上传了&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/error-case-analysis/alibaba-ttl-wrong-usage-example&#34;&gt;GitHub&lt;/a&gt;，如果你想在本地调试运行上述案例，可以下载到本地调试，有问题可以评论区沟通。&lt;/p&gt;
">业务逻辑编排错误 & TTL浅拷贝导致参数丢失问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/shi-yong-redis-shi-xian-fen-bu-shi-suo-de-keng/"" data-c="
          &lt;p&gt;分布式锁的关键在于对单一资源的竞争。获得资源的实例将继续执行，其余实例要么退出（互斥锁），要么等待（阻塞锁）。&lt;br&gt;
实现分布式锁的方案有很多，既可以直接使用&lt;code&gt;MySQL&lt;/code&gt;作为分布式锁（例如&lt;code&gt;xxl-job&lt;/code&gt;），也可以利用&lt;code&gt;ZooKeeper&lt;/code&gt;、&lt;code&gt;Redis&lt;/code&gt;等。&lt;br&gt;
在基于&lt;code&gt;Spring Cloud&lt;/code&gt;的业务系统中，一般都会引入&lt;code&gt;Redis&lt;/code&gt;作为分布式缓存中间件，因此更多的人会选择使用&lt;code&gt;Redis&lt;/code&gt;来实现分布式锁。本文将介绍使用&lt;code&gt;Redis&lt;/code&gt;作为分布式锁时常见的问题和解决方法。&lt;/p&gt;
&lt;h1 id=&#34;1-没有使用原子操作指令&#34;&gt;1. 没有使用原子操作指令&lt;/h1&gt;
&lt;h2 id=&#34;错误写法&#34;&gt;错误写法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    Boolean tryLock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue);
    stringRedisTemplate.expire(lockKey, Duration.ofSeconds(expireTime));
    if (!tryLock) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述操作通常出现在新手阶段，在写入锁对象时，没有考虑到原子性问题。在&lt;code&gt;Redis&lt;/code&gt;中有提供&lt;code&gt;SET NX PX&lt;/code&gt;指令，支持在设置锁的同时指定过期时间，并且支持原子性判断&lt;code&gt;key&lt;/code&gt;是否已存在。&lt;/p&gt;
&lt;p&gt;NX 和 PX 是 Redis 命令中用于设置 key 的两个选项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NX: 当指定 NX 选项时，只有在 key 不存在的情况下才会设置 key 的值。如果 key 已经存在，则不进行任何操作。&lt;/li&gt;
&lt;li&gt;PX: PX 选项用于设置 key 的过期时间（以毫秒为单位）。例如，PX 10000 表示在 10 秒后将 key 设置为过期状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;正确写法&#34;&gt;正确写法：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Boolean tryLock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, expireTime, TimeUnit.MILLISECONDS);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-释放了别人的锁&#34;&gt;2. 释放了别人的锁&lt;/h1&gt;
&lt;h2 id=&#34;错误写法-2&#34;&gt;错误写法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try {
    Boolean tryLock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, expireTime, TimeUnit.MILLISECONDS);
    if (!tryLock) {
        return;
    }

    // do something
    } finally {
    stringRedisTemplate.delete(lockKey);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在加锁的过程中，没有设定唯一值作为&lt;code&gt;Value&lt;/code&gt;存储到Redis中，在释放时，不判断直接对锁进行释放。其二，将获取锁的代码放在了&lt;code&gt;try&lt;/code&gt;代码块中。&lt;/p&gt;
&lt;p&gt;在上述代码中存在两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不该执行到&lt;code&gt;finlly&lt;/code&gt;代码块：A请求获得了锁正在执行业务代码，而B请求没有获得锁，但是因为获取锁的代码在&lt;code&gt;try&lt;/code&gt;代码块中，导致&lt;code&gt;finally&lt;/code&gt;一定会执行，B请求就会将A请求的锁释放，而如果A请求依旧未执行完毕，此时C请求过来时，&lt;strong&gt;则C请求错误的拿到了锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;不该删除别人的锁：在删除锁时，应该判断自己是否是上锁人，由于多次执行&lt;code&gt;Redis&lt;/code&gt;指令不具备原子性，所以一般是交由&lt;code&gt;LUA&lt;/code&gt;脚本来实现的。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1]
    then
        return redis.call(&#39;del&#39;, KEYS[1])
    else
        return 0
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;正确写法-2&#34;&gt;正确写法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;提前将LUA脚本载入到&lt;code&gt;Redis&lt;/code&gt;服务端&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;script = new DefaultRedisScript&amp;lt;&amp;gt;();
script.setResultType(Long.class);
script.setScriptSource(new ResourceScriptSource(new ClassPathResource(&amp;quot;release_lock.lua&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;获取和释放锁示例&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Boolean tryLock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, expireTime, TimeUnit.MILLISECONDS);
if (!tryLock) {
    return;
}
try {

    // do something
} finally {
    ArrayList&amp;lt;String&amp;gt; keys = new ArrayList&amp;lt;&amp;gt;();
    keys.add(context.getLockKey());
    stringRedisTemplate.execute(this.script, keys, context.getLockValue());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-事务未提交锁就释放了&#34;&gt;3. 事务未提交锁就释放了&lt;/h1&gt;
&lt;h2 id=&#34;错误代码&#34;&gt;错误代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
    * 事务内获取分布式锁
    */
@Transactional(rollbackFor = Exception.class)
public void saveUserWithDistributedLock(String name) {

    String lockKey = &amp;quot;lock_key:&amp;quot; + name;
    RedisLock.LockContext lockContext = redisLock.tryLock(lockKey, 10000L);
    if (!lockContext.getTryLock()) {
        // printLog(&amp;quot;没拿到锁&amp;quot;);
        return;
    }

    printLog(&amp;quot;拿到锁了&amp;quot; + lockKey);

    try {
        this.save(name);
    } finally {
        redisLock.release(lockContext);
        printLog(&amp;quot;释放锁了&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MySQL常规情况下是&lt;code&gt;RR&lt;/code&gt;的隔离级别，只有等到事务提交数据才对其他事务可见，存在**“读视图”&lt;strong&gt;，在上述的代码中，A请求拿到了锁执行了业务代码，执行到&lt;code&gt;redisLock.release&lt;/code&gt;时将锁释放了，但Spring的&lt;code&gt;@Transactional&lt;/code&gt;依赖的是AOP，其需要等到方法执行完毕才会提交事务，在这个临界点，B请求可以正常拿到锁，但是A请求的事务还未提交，B请求的&lt;/strong&gt;读视图**中还未查询到A请求提交的数据，最终造成了数据的不一致性。&lt;/p&gt;
&lt;h2 id=&#34;正确代码&#34;&gt;正确代码&lt;/h2&gt;
&lt;p&gt;正确的情况是在另一个方法中获取到锁之后，再调用包含事务的业务代码。此时需要注意SpringAOP在本方法内代理失效的问题，通常需要新建一个Service来处理。&lt;/p&gt;
&lt;h1 id=&#34;业务代码执行超过锁过期时间&#34;&gt;业务代码执行超过锁过期时间&lt;/h1&gt;
&lt;h2 id=&#34;错误代码-2&#34;&gt;错误代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Domain-Service
public void save(String name) {

    String lockKey = &amp;quot;lock_key:&amp;quot; + name;
    RedisLock.LockContext lockContext = redisLock.tryLock(lockKey, 10000L);
    if (!lockContext.getTryLock()) {
        printLog(&amp;quot;没拿到锁&amp;quot;);
        return;
    }

    printLog(&amp;quot;拿到锁了&amp;quot; + lockKey);
    try {
        userService.save(name);
    } finally {
        redisLock.release(lockContext);
        printLog(&amp;quot;释放锁了&amp;quot;);
    }
}

// UserService
@Transactional(rollbackFor = Exception.class)
public void save(String name) {

    List&amp;lt;User&amp;gt; users = userRepository.findUsersByName(name);
    if (CollUtil.isNotEmpty(users)) {
        printLog(&amp;quot;已经写入, 不再写入&amp;quot; + users);
        return;
    }

    // 业务保存模拟执行很慢
    TimeUnit.SECONDS.sleep(70);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，锁对象只有10s的时间，但是业务代码执行却需要70s，A请求虽然拿到了锁，此时后续10秒其他请求均无法获取锁，但是从第11秒开始的请求将可以拿到锁，而此时A请求还未执行完毕，此时开始出现错误的获取锁，最终造成数据的不一致。&lt;/p&gt;
&lt;h2 id=&#34;正确写法-3&#34;&gt;正确写法&lt;/h2&gt;
&lt;p&gt;参考&lt;code&gt;Redisson&lt;/code&gt;的&lt;code&gt;WatchDog&lt;/code&gt;机制，另外开辟线程每隔 10s 就给还未执行完毕的 &lt;code&gt;Key&lt;/code&gt; 自动续期 30s，保证业务代码能够安全的执行完毕再自行释放锁对象。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// watch dog
Executors.newScheduledThreadPool(1).scheduleAtFixedRate(() -&amp;gt; {
    if (!LOCK_CONTEXTS.isEmpty()) {
        for (LockContext lockContext : LOCK_CONTEXTS) {
            // 如果执行线程还未释放锁, 续期30s(模拟Redisson)
            stringRedisTemplate.expire(lockContext.getLockKey(), Duration.ofSeconds(30));
            Long expire = stringRedisTemplate.getExpire(lockContext.getLockKey());
            log.info(&amp;quot;WatchDog, expire 30s, lockKey={}, ttl={}&amp;quot;, lockContext.getLockKey(), expire);
        }
    }
        }, 0,
        // 10秒检测一次
        10, TimeUnit.SECONDS);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;p&gt;分布式锁的错误还有很多，本篇主要是自己在工作过程中遇到的一些坑，着重介绍新手阶段在编写分布式锁时遇到的比较基础的问题，后面有空再进行其他场景的逐个介绍。&lt;/p&gt;
&lt;p&gt;本文参考：&lt;a href=&#34;https://juejin.cn/post/7011503283768393736&#34;&gt;聊聊redis分布式锁的8大坑&lt;/a&gt;&lt;br&gt;
本文代码：&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/in-action/redis-lua-distributed-lock&#34;&gt;redis-lua-distributed-lock&lt;/a&gt;&lt;/p&gt;
">使用Redis实现分布式锁的坑</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/cuo-yong-hashedwheeltimer-dao-zhi-de-oom-wen-ti/"" data-c="
          &lt;p&gt;事件中心在私有化环境下，只要server一启动过几秒就oom，查看日志是 &lt;code&gt;Failed to create a thread: retVal -1073741830, errno 11&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;异常堆栈：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Caused by: java.lang.OutOfMemoryError: Failed to create a thread: retVal -1073741830, errno 11   
    at java.lang.Thread.startImpl(Native Method) 
    at java.lang.Thread.start(Thread.java:993) 
    at io.netty.util.HashedWheelTimer.start(HashedWheelTimer.java:366) 
    at io.netty.util.HashedWheelTimer.newTimeout(HashedWheelTimer.java:447) 
    at 业务调用代码省略
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在标品环境下没有问题，在其他KA客户上也没有问题&lt;br&gt;
通过对日志的分析，最终发现是事件中心的延迟消息代码存在缺陷，使用了&lt;code&gt;Netty&lt;/code&gt;的&lt;code&gt;HashedWheelTimer&lt;/code&gt;，但是语法存在问题，理论上应该是new一个&lt;code&gt;HashedWheelTimer&lt;/code&gt;来处理所有时间延迟，但是错用程每次new一个新的&lt;code&gt;HashedWheelTimer&lt;/code&gt;，&lt;code&gt;HashedWheelTimer&lt;/code&gt;内部每次都会new一个新的线程来处理做调度，一个线程占用1MB，最终内存资源被耗尽。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;io.netty.util.HashedWheelTimer#HashedWheelTimer&lt;/code&gt;源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public HashedWheelTimer(
    ThreadFactory threadFactory,
    long tickDuration, TimeUnit unit, int ticksPerWheel, boolean leakDetection,
    long maxPendingTimeouts, Executor taskExecutor) {

    checkNotNull(threadFactory, &amp;quot;threadFactory&amp;quot;);
    checkNotNull(unit, &amp;quot;unit&amp;quot;);
    checkPositive(tickDuration, &amp;quot;tickDuration&amp;quot;);
    checkPositive(ticksPerWheel, &amp;quot;ticksPerWheel&amp;quot;);
    this.taskExecutor = checkNotNull(taskExecutor, &amp;quot;taskExecutor&amp;quot;);

    // Normalize ticksPerWheel to power of two and initialize the wheel.
    wheel = createWheel(ticksPerWheel);
    mask = wheel.length - 1;

    // Convert tickDuration to nanos.
    long duration = unit.toNanos(tickDuration);

    // Prevent overflow.
    if (duration &amp;gt;= Long.MAX_VALUE / wheel.length) {
        throw new IllegalArgumentException(String.format(
                &amp;quot;tickDuration: %d (expected: 0 &amp;lt; tickDuration in nanos &amp;lt; %d&amp;quot;,
                tickDuration, Long.MAX_VALUE / wheel.length));
    }

    if (duration &amp;lt; MILLISECOND_NANOS) {
        logger.warn(&amp;quot;Configured tickDuration {} smaller then {}, using 1ms.&amp;quot;,
                    tickDuration, MILLISECOND_NANOS);
        this.tickDuration = MILLISECOND_NANOS;
    } else {
        this.tickDuration = duration;
    }

    // 每次都new一个线程来处理
    workerThread = threadFactory.newThread(worker);

    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(this) : null;

    this.maxPendingTimeouts = maxPendingTimeouts;

    if (INSTANCE_COUNTER.incrementAndGet() &amp;gt; INSTANCE_COUNT_LIMIT &amp;amp;&amp;amp;
        WARNED_TOO_MANY_INSTANCES.compareAndSet(false, true)) {
        reportTooManyInstances();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为标品和其他KA使用的是阿里云RocketMQ，此客户使用的是自建的开源版RocketMQ，开源RocketMQ是没有自定义时长的延迟消息的，所以我们自己实现了一套时间轮来实现任意时长的延迟消息，当小于60s的延迟消息会丢入我们的时间轮来处理延迟投递，当时此客户的环境中有大量的60s内的延迟消息，导致一启动就会崩溃。&lt;br&gt;
不过在RocketMQ5.0也支持任意时长了。&lt;/p&gt;
">错用HashedWheelTimer导致的OOM问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/circuitbreak-dao-zhi-threadlocal-can-shu-diu-shi-wen-ti/"" data-c="
          &lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;p&gt;使用&lt;code&gt;OpenFeign&lt;/code&gt;时，通常会实现&lt;code&gt;RequestInterceptor&lt;/code&gt;接口来自定义&lt;code&gt;FeignConfiguration&lt;/code&gt;，&lt;code&gt;OpenFeign&lt;/code&gt;暴露了&lt;code&gt;feign.RequestTemplate&lt;/code&gt;信息，给到我们在发送请求前自定义参数信息的扩展点。&lt;/p&gt;
&lt;p&gt;在分布式系统中，通常会将本服务的信息（&lt;code&gt;UserInfo&lt;/code&gt;、&lt;code&gt;RequestId&lt;/code&gt;）透传至下游服务，从而实现分布式链路追踪等功能，对于像用户信息等，在Web系统中通常使用 &lt;code&gt;ThreadLocal&lt;/code&gt; 来存储信息，在自定义的&lt;code&gt;FeignConfiguration&lt;/code&gt;中获取&lt;code&gt;ThreadLocal&lt;/code&gt;再塞入到&lt;code&gt;feign.RequestTemplate&lt;/code&gt;中，实现向下游服务的传递，示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FeignConfiguration implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate template) {
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        String userId = SubjectContext.get().getUserId();
        if (null != attributes) {
            HttpServletRequest request = attributes.getRequest();
            template.header(&amp;quot;token&amp;quot;, request.getHeader(&amp;quot;TOKEN&amp;quot;));
            template.header(&amp;quot;userId&amp;quot;, userId);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单的Context示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SubjectContext {
    protected static ThreadLocal&amp;lt;UserInfo&amp;gt; subjectContext = new ThreadLocal();
    public static void remove() {
        subjectContext.remove();
    }
    public static void set(UserInfo uerInfo) {
        subjectContext.set(uerInfo);
    }
    public static UserInfo get() {
        return (UserInfo)subjectContext.get();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;出现错误&#34;&gt;出现错误&lt;/h1&gt;
&lt;p&gt;上述代码在常规情况下，是能够按照预期执行的。&lt;/p&gt;
&lt;p&gt;但是最近项目引入了&lt;code&gt;CircuitBreaker&lt;/code&gt;作为服务熔断的断路器之后，上述代码在执行到&lt;code&gt;SubjectContext.get()&lt;/code&gt;时，会抛出空指针，拿不到用户信息。&lt;/p&gt;
&lt;p&gt;通过分析&lt;code&gt;CircuitBreaker&lt;/code&gt;的源码，最终定位到代码出现在&lt;code&gt;Resilience4JCircuitBreaker&lt;/code&gt;内部，在&lt;code&gt;Resilience4JCircuitBreaker&lt;/code&gt;中有一个&lt;code&gt;public &amp;lt;T&amp;gt; T run(Supplier&amp;lt;T&amp;gt; toRun, Function&amp;lt;Throwable, T&amp;gt; fallback)&lt;/code&gt;方法，方法入参的&lt;code&gt;toRun&lt;/code&gt;就是封装过的我们定义的Feign接口，其包装过程在&lt;code&gt;FeignCircuitBreakerInvocationHandler#asSupplier&lt;/code&gt;代码中，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Supplier&amp;lt;Object&amp;gt; asSupplier(final Method method, final Object[] args) {
    final RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
    return () -&amp;gt; {
        try {
            RequestContextHolder.setRequestAttributes(requestAttributes);
            // 执行我们的真正方法
            return dispatch.get(method).invoke(args);
        }
        catch (RuntimeException throwable) {
            throw throwable;
        }
        catch (Throwable throwable) {
            throw new RuntimeException(throwable);
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spring Cloud CircuitBreaker Resilience4j 提供了两种实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 Semaphores 的 SemaphoreBulkhead。&lt;/li&gt;
&lt;li&gt;一个 FixedThreadPoolBulkhead，它使用一个有界队列和一个固定的线程池。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认情况下，Spring Cloud CircuitBreaker Resilience4j 使用 &lt;code&gt;FixedThreadPoolBulkhead&lt;/code&gt;。要修改默认行为以使用 &lt;code&gt;SemaphoreBulkhead&lt;/code&gt;，请将属性 &lt;code&gt;spring.cloud.circuitbreaker.resilience4j.enableSemaphoreDefaultBulkhead&lt;/code&gt; 设为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;正是由于上述原因，默认将我们的FeignConfiguration提交给了线程池，由于我们使用的是&lt;code&gt;ThreadLocal&lt;/code&gt;导致&lt;strong&gt;线程本地变量&lt;/strong&gt;没有向子线程传递，在执行FeignConfiguration时子线程无法拿到&lt;code&gt;Context&lt;/code&gt;信息，最终导致程序的报错。&lt;/p&gt;
&lt;h1 id=&#34;解决办法&#34;&gt;解决办法&lt;/h1&gt;
&lt;p&gt;通过分析源码我们发现，执行任务的线程池&lt;code&gt;Resilience4JCircuitBreaker#executorService&lt;/code&gt;是由外部传递过来进行初始化的，调用方在&lt;code&gt;Resilience4JCircuitBreakerFactory#create(java.lang.String, java.lang.String, java.util.concurrent.ExecutorService)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Resilience4JCircuitBreakerFactory&lt;/code&gt;中发现，是由本实例在&lt;code&gt;create&lt;/code&gt;方法被调用时传入的本类的成员变量，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;private ExecutorService executorService = Executors.newCachedThreadPool();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private ConcurrentHashMap&amp;lt;String, ExecutorService&amp;gt; executorServices = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1706198428487.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而我们在没有定义自定义Feign Group时，默认使用的就是&lt;code&gt;executorService&lt;/code&gt;，在本类中有一个&lt;code&gt;Resilience4JCircuitBreakerFactory#configureExecutorService&lt;/code&gt;方法专门保留了外部传入自定义线程池的扩展，我们可以自己实现创建一个支持传递&lt;code&gt;Context&lt;/code&gt;到子线程的线程池，即可将参数向下传递，比如像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configurable
@AllArgsConstructor
public class CircuitBreakerConfiguration implements ApplicationRunner {

    private final Resilience4JCircuitBreakerFactory factory;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {

        ContextThreadPoolExecutor contextThreadPoolExecutor = 
                new ContextThreadPoolExecutor(2, 5, 1, TimeUnit.MINUTES, new ArrayBlockingQueue&amp;lt;&amp;gt;(1024));

        // **change ThreadPoolExecutor**
        factory.configureExecutorService(contextThreadPoolExecutor);
    }
    
    public static class ContextThreadPoolExecutor extends ThreadPoolExecutor {

        public ContextThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) {
            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
        }

        public void execute(Runnable command) {
            super.execute(wrap(command));
        }

        private static Runnable wrap(Runnable runnable) {
            **SubjectContext context = SubjectContext.getContext();**
            return () -&amp;gt; {
                // 将参数向下传递
                **SubjectContext.setContext(context);**
                try {
                    runnable.run();
                } finally {
                    **SubjectContext.clear();**
                }
            };
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;p&gt;上述的方案只解决了没有自定义Group的情况，官方在自定义Group的情况下是没有保留扩展位的，所以给官方提了一个MR并且已成功合并到主分支，如下：&lt;br&gt;
&lt;a href=&#34;https://github.com/spring-cloud/spring-cloud-circuitbreaker/pull/181&#34;&gt;Customizable groupExecutorService #180&lt;/a&gt;&lt;/p&gt;
">CircuitBreak导致ThreadLocal参数丢失问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/idea-chang-yong-cha-jian/"" data-c="
          &lt;h1 id=&#34;编码类&#34;&gt;编码类&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Generate All Getter And Setter 如其名&lt;/li&gt;
&lt;li&gt;AceJump 快速将光标导航到编辑器中可见的任何位置,ctrl+,然后输入字符，进行高亮定位&lt;/li&gt;
&lt;li&gt;GsonFormat 将JSONObject格式的String 解析成实体。&lt;/li&gt;
&lt;li&gt;Lombok 针对模型对象精简代码&lt;/li&gt;
&lt;li&gt;MybatisCodeHelperPro 通过方法名来生成sql，全自动提示，自动检测&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;工具类&#34;&gt;工具类&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;any-rule 可以搜索正则表达式&lt;/li&gt;
&lt;li&gt;CamelCase 变量名转驼峰&lt;/li&gt;
&lt;li&gt;Jrebel 快速实现热部署，跳过了构建和部署的过程，可以省去大量的部署用的时间。&lt;/li&gt;
&lt;li&gt;jrebel-mybatisplus-extension 热部署中mybatis的扩展，他的功能就是配合 Jrebel 一起使用，修改 mybatis 的 mapper.xml 文件不用重启项目&lt;/li&gt;
&lt;li&gt;CodeGlance 显示代码地图插件,进行语法突出显示&lt;/li&gt;
&lt;li&gt;RestfulToolKit 可以搜索接口&lt;/li&gt;
&lt;li&gt;POJO TO JSON 将pojo类转换为json&lt;/li&gt;
&lt;li&gt;Translation 翻译插件&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;maven类&#34;&gt;Maven类&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Maven Helper 依赖冲突分析利器&lt;/li&gt;
&lt;li&gt;Maven Dependency Helper Maven中央仓库搜索&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;规范类&#34;&gt;规范类&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;P3C 编码规范的一个插件，高亮提示违规代码&lt;/li&gt;
&lt;li&gt;SonarLint 打开文件的时候自动进行代码审查&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;提效类&#34;&gt;提效类&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Key Promoter X 在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代，此插件会进行提示&lt;/li&gt;
&lt;li&gt;POJO TO JSON 将pojo类转换为json&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;装修类&#34;&gt;装修类&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Nyan Progress Bar 漂亮的进度条&lt;/li&gt;
&lt;li&gt;Rainbow Brackets 配对括号相同颜色，并且实现选中区域代码高亮的功能&lt;/li&gt;
&lt;/ol&gt;
">IDEA 常用插件</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/idea-2023-fei-chang-yong-pei-zhi/"" data-c="
          &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置文件全部使用UTF-8&lt;br&gt;
&lt;code&gt;Editor-File Encodings&lt;/code&gt;，将所有内容均设置为UTF-8。&lt;br&gt;
&lt;code&gt;Create UTF-8 files&lt;/code&gt; 选择 &lt;code&gt;with NO BOM&lt;/code&gt;，避免在创建文件前3个字节来标志为UTF-8文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数提示&lt;br&gt;
默认情况下，是没有参数提示的，需要手动开启。&lt;br&gt;
&lt;code&gt;Editor-General-Code Completion-Parameter Info&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1704534882953.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1704534890065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释默认在当前缩进&lt;br&gt;
默认情况下，自动补全注释是在最前面，可以通过：&lt;br&gt;
&lt;code&gt;Editor-Code Style-Java(其它语言位置类似)-Code Generation-Comment Code&lt;/code&gt;按如下图配置进行处理。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1704535032674.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果配置的内容，在新项目不生效，则注意此处&lt;br&gt;
除了字体样式字体大小外，其它的配置IDEA官方认为，每个项目在创建时，可能都需要一些不同的配置，所以有很多内容都是跨项目不生效的（Maven、文件格式等），需要在此处配置（点进去和Settings一模一样，但是对应的是Next Project（新项目）的配置）&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1704535443448.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
"> IDEA 2023 非常用配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/shi-yong-highlightjs-rang-gridea-zhi-chi-dai-ma-gao-liang/"" data-c="
          &lt;p&gt;Gridea的Lemon主题，默认不支持代码高亮，需要自己补充。目前开源的&lt;code&gt;highlight.js&lt;/code&gt;正合适。记录下处理的过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开官网，挑选自己喜欢的风格&lt;br&gt;
&lt;a href=&#34;https://highlightjs.org/examples&#34;&gt;highlightjs.org/examples&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找一个CDN托管网站，避免走自己的小油管，这里推荐bootcdn（这么多年了，还是如此坚挺）&lt;br&gt;
&lt;a href=&#34;https://www.bootcdn.cn/highlight.js/&#34;&gt;www.bootcdn.cn/highlight.js&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将上述找到的代码，应用在自己主题下的&lt;code&gt;post.ejs&lt;/code&gt;的 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 代码块中。&lt;br&gt;
1.&lt;br&gt;
&lt;code&gt;~/Gridea/themes/gridea-theme-lemon&lt;/code&gt;，找到自己的主题目录，&lt;code&gt;gridea-theme-lemon&lt;/code&gt;是我的&lt;code&gt;Lemon&lt;/code&gt;主题目录。&lt;br&gt;
2. 编辑&lt;code&gt;post.ejs&lt;/code&gt;文件，&lt;code&gt;vim templates/post.ejs&lt;/code&gt;&lt;br&gt;
3. 在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中补充如下代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;&amp;lt;link href=&amp;quot;https://cdn.bootcdn.net/ajax/libs/highlight.js/11.8.0/styles/此处选择自己喜欢的主题.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;      
&lt;/code&gt;&lt;/pre&gt;
">使用highlightjs让Gridea支持代码高亮</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-20~21-xin-te-xing/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;Java 20没有发布重要的新特性，本文以Java21版本为主。&lt;br&gt;
Java 21 是新的LTS版本，其中发布了众多新的特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;字符串模板预览版&#34;&gt;字符串模板（预览版）&lt;/h1&gt;
&lt;h2 id=&#34;使用官方的str-fmt&#34;&gt;使用官方的STR、FMT&lt;/h2&gt;
&lt;p&gt;支持通过&lt;code&gt;STR&lt;/code&gt;、&lt;code&gt;FMT&lt;/code&gt;来实现字符串拼接，可以自定义模板处理器组织字符串输出形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

import static java.util.FormatProcessor.FMT;

/**
 * @author imyzt
 * @date 2023/12/19
 * @description 模板字符串
 */
public class TemplateString {

    public static void main(String[] args) {

        String str = &amp;quot;world&amp;quot;;
        String result = STR.&amp;quot;hello \{str}&amp;quot;;
        System.out.println(result);
        System.out.println(STR);

        String name = &amp;quot;yzt&amp;quot;;
        String[] blogAddress = {&amp;quot;imyzt.top&amp;quot;, &amp;quot;blog.imyzt.top&amp;quot;};
        String text = FMT.&amp;quot;&amp;quot;&amp;quot;
                My name is \{name}
                My blog address is \{blogAddress[0].toUpperCase()}, \{blogAddress[1].toLowerCase()}&amp;quot;&amp;quot;&amp;quot;;
        System.out.println(text);

        System.out.println(STR.&amp;quot;\{Math.random()}&amp;quot;);
        System.out.println(STR.&amp;quot;\{Integer.MAX_VALUE}&amp;quot;);
        System.out.println(STR.&amp;quot;\{index++}, \{++index}&amp;quot;);

        //hello world
        //java.lang.StringTemplate$$Lambda/0x00000001260457f0@33c7353a
        //My name is yzt
        //My blog address is IMYZT.TOP, blog.imyzt.top
        //0.9361799484353136
        //2147483647
        //现在的时间是: 2023-12-20
        //0, 2
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自定义stringtemplate&#34;&gt;自定义StringTemplate&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
import java.util.Iterator;

/**
 * @author imyzt
 * @date 2023/12/20
 * @description 自定义StringTemplate
 */
public class CustomTemplate {

    public static void main(String[] args) {

        var INTER = StringTemplate.Processor.of((StringTemplate st) -&amp;gt; {
            StringBuilder sb = new StringBuilder();
            Iterator&amp;lt;String&amp;gt; fragments = st.fragments().iterator();
            for (Object value : st.values()) {
                sb.append(fragments.next());
                sb.append(value);
            }
            sb.append(fragments.next());
            return sb.toString();
        });

        String name = &amp;quot;yzt&amp;quot;;
        int index = 0;
        String text = INTER.&amp;quot;&amp;quot;&amp;quot;
                {
                &amp;quot;name&amp;quot;:\{name},
                &amp;quot;index&amp;quot;:\{++index}
                }
                &amp;quot;&amp;quot;&amp;quot;;
        System.out.println(text);
        //{
        //&amp;quot;name&amp;quot;:yzt,
        //&amp;quot;index&amp;quot;:1
        //}
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;record-patterns&#34;&gt;Record Patterns&lt;/h1&gt;
&lt;p&gt;记录模式更强大了，支持直接在表达式中创建和使用。还支持嵌套&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/19
 * @description 记录模式
 */
public class RecordPatterns {

    public static void main(String[] args) {

        Object p = new Point(1, 2);
        if (p instanceof Point(int x, int y)) {
            System.out.println(x + y);
        }

        Object w = new Window(new Point(1, 2), 3);
        if (w instanceof Window(Point(int x, int y), int z)) {
            System.out.println(x + y + z);
        }

    }
}
record Point(int x, int y) {}
record Window(Point p, int z) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;scopedvalue&#34;&gt;ScopedValue&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt;是一个隐藏的方法参数，只有方法可以访问&lt;code&gt;ScopedValue&lt;/code&gt;，它可以让两个方法传递参数时&lt;strong&gt;无需声明形参&lt;/strong&gt;（对于Web项目中传递用户信息是非常场景的操作）&lt;/p&gt;
&lt;h2 id=&#34;threadlocal的问题&#34;&gt;ThreadLocal的问题&lt;/h2&gt;
&lt;p&gt;通常对于上述场景，都会采用&lt;code&gt;ThreadLocal&lt;/code&gt;来解决，但是由于&lt;code&gt;ThreadLocal&lt;/code&gt;在设计上的瑕疵，导致一直有以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存泄露，在使用完&lt;code&gt;ThreadLocal&lt;/code&gt;之后，若没有调用&lt;code&gt;remove&lt;/code&gt;方法，会出现内存泄漏。&lt;/li&gt;
&lt;li&gt;增加开销，在具有继承关系的线程中，子线程需要为父线程中&lt;code&gt;ThreadLocal&lt;/code&gt;里面的数据分配内存&lt;/li&gt;
&lt;li&gt;不是不可变对象，在方法中可以随意调用&lt;code&gt;set&lt;/code&gt;方法篡改。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随着虚拟线程的到来，内存泄漏问题不用担心了，因为虚拟线程会很快的终止，此时会自动删除&lt;code&gt;ThreadLocal&lt;/code&gt;中的数据，这样就不用调用&lt;code&gt;remove&lt;/code&gt;方法了。&lt;br&gt;
但是虚拟线程的数量是非常多的，假如有上百万个虚拟线程都要拷贝一份&lt;code&gt;ThreadLocal&lt;/code&gt;中的变量（问题2），&lt;span style=&#34;color: red&#34;&gt;内存将会被严重的浪费掉&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;示例代码中通过模拟一个“送礼物”的场景，来演示&lt;code&gt;ScopedValue&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;giveGift&lt;/code&gt; 方法中，将礼物送出，是500元&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;receiveMiddleMan&lt;/code&gt; 方法模拟中间人抽成的场景，抽成后送出仅 200元&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;receiveGift&lt;/code&gt; 方法中 ，对 &lt;code&gt;ScopedValue&lt;/code&gt; 进行获取，得到的就是200元&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但整个过程中，中间人 &lt;code&gt;receiveMiddleMan&lt;/code&gt; 在送出前后获取到的信息都是 500元，这正是 &lt;code&gt;Scope&lt;/code&gt; 的含义，&lt;strong&gt;修改只在本作用域（方法）中生效&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/20
 * @description ScopedValue
 */
public class ScopedValueTest {

    private static final ScopedValue&amp;lt;String&amp;gt; GIFT = ScopedValue.newInstance();

    public static void main(String[] args) {

        ScopedValueTest test = new ScopedValueTest();
        test.giveGift();
        //中间人开始: 500
        //收礼物: 200
        //中间人结束: 500
    }

    private void giveGift() {
        ScopedValue.where(GIFT, &amp;quot;500&amp;quot;).run(this::receiveMiddleMan);
    }

    private void receiveMiddleMan() {
        System.out.println(STR.&amp;quot;中间人开始: \{GIFT.get()}&amp;quot;);
        ScopedValue.where(GIFT, &amp;quot;200&amp;quot;).run(this::receiveGift);
        System.out.println(STR.&amp;quot;中间人结束: \{GIFT.get()}&amp;quot;);
    }

    private void receiveGift() {
        System.out.println(STR.&amp;quot;收礼物: \{GIFT.get()}&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;switch-又升级了支持when关键字了&#34;&gt;Switch 又升级了，支持when关键字了&lt;/h1&gt;
&lt;p&gt;switch 可谓是升级升级再升级，我还是在用 if/else 啊。&lt;br&gt;
从12开始，一路升级。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持 &lt;code&gt;-&amp;gt;&lt;/code&gt; 表达式（Java 12）&lt;/li&gt;
&lt;li&gt;支持返回值（Java 12）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;case&lt;/code&gt;支持单行写多个条件（Java 12）&lt;/li&gt;
&lt;li&gt;新增&lt;code&gt;yield&lt;/code&gt;关键字返回&lt;code&gt;switch&lt;/code&gt;的值（Java 12）&lt;/li&gt;
&lt;li&gt;引入模式匹配（Java 15）&lt;/li&gt;
&lt;li&gt;这回又新增了一个&lt;code&gt;when&lt;/code&gt;关键字（都快改成SQL了） （Java 21）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.aliyun.com/article/1357316&#34;&gt;Java switch升级之路&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/20
 * @description Switch 又升级了~, 这次支持when关键字了
 */
public class SwitchFuture {

    void main() {

        var str = &amp;quot;yes&amp;quot;;

        var result = switch (str) {
            case null -&amp;gt; &amp;quot;空对象&amp;quot;;
            case String s
                    when &amp;quot;yes&amp;quot;.equals(s) -&amp;gt; {
                System.out.println(&amp;quot;确定&amp;quot;);
                yield &amp;quot;字符串的Yes&amp;quot;;
            }
            case String s
                    when &amp;quot;no&amp;quot;.equals(s) -&amp;gt; {
                System.out.println(&amp;quot;取消&amp;quot;);
                yield &amp;quot;字符串的No&amp;quot;;
            }
            default -&amp;gt; &amp;quot;default&amp;quot;;
        };

        System.out.println(result);
        //确定
        //字符串的Yes
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;简化了main方法注意看上一个章节的main方法&#34;&gt;简化了main方法（注意看上一个章节的main方法）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Class声明和强制的public访问修饰符是必须的。当用在外部组件定义良好的接口封装代码单元时，它们很有用。但在这个小例子中，它们毫无意义。&lt;/li&gt;
&lt;li&gt;String[]参数主要用于将代码与外部组件（在本例中为操作系统的shell，接收命令传入的参数）连接。它在这里很神秘且无用，尤其是它从未被使用过。&lt;/li&gt;
&lt;li&gt;static修饰符是Java类和对象模型的一部分。对于新手来说，这不仅是神秘的，而且是有害的：要添加更多可以调用和使用的方法或字段，学​​生必须要么将它们全部声明（传播一种既不常见也不是好习惯的用法），或者就要面对是否有static修饰的区别问题，并学习如何实例化对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;未命名模式和变量go和我有点像&#34;&gt;未命名模式和变量（Go：和我有点像）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/21
 * @description 像golang学习, 支持不使用的变量不命名了
 */
public class UnnamedVariable {

    void main() {

        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(&amp;quot;first&amp;quot;);
        list.add(&amp;quot;last&amp;quot;);

        try {
            System.out.println(STR.&amp;quot;first -&amp;gt; \{list.getFirst()}&amp;quot;);
            System.out.println(STR.&amp;quot;last -&amp;gt; \{list.getLast()}&amp;quot;);
            System.out.println(&amp;quot;try&amp;quot;);
        } catch (Exception _) {
            System.out.println(&amp;quot;异常了, 但是我没有 Exception&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;有序集合&#34;&gt;有序集合&lt;/h1&gt;
&lt;h2 id=&#34;sequenced-collections&#34;&gt;Sequenced Collections&lt;/h2&gt;
&lt;p&gt;Sequenced Collections引入了三个新接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SequencedCollection&lt;/li&gt;
&lt;li&gt;SequencedMap&lt;/li&gt;
&lt;li&gt;SequencedSet&lt;br&gt;
接口都附带了一些新方法，可以提高操作集合的效率。比如：&lt;code&gt;java.util.SequencedCollection#reversed&lt;/code&gt;等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;集合补充了获取收尾元素的方法hutool当我不存在&#34;&gt;集合补充了获取收尾元素的方法（hutool：当我不存在？）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&amp;quot;first&amp;quot;);
list.add(&amp;quot;last&amp;quot;);
System.out.println(STR.&amp;quot;first -&amp;gt; \{list.getFirst()}&amp;quot;);
System.out.println(STR.&amp;quot;last -&amp;gt; \{list.getLast()}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;加了一些工具类&#34;&gt;加了一些工具类&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;StringBuilder中的repeat方法&lt;/li&gt;
&lt;li&gt;补充&lt;code&gt;java.lang.Character#isEmoji&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/21
 * @description 加了些新方法
 */
public class SomethingExample {

    void main() {

        System.out.println(STR.&amp;quot;repeat =&amp;gt; \{new StringBuffer().repeat(&amp;quot;*&amp;quot;, 10)}&amp;quot;);
        //repeat =&amp;gt; **********

        var happy = &amp;quot;你开心吗? 😄&amp;quot;;
        System.out.println(STR.&amp;quot;isEmoji =&amp;gt; \{happy.codePoints().anyMatch(Character::isEmoji)}&amp;quot;);
        //isEmoji =&amp;gt; true
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Java 20~21 新特性</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-19-xin-te-xing/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;Java 19 最核心的特性就是&lt;strong&gt;虚拟线程（Virtual Threads）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;p&gt;该特性在Java19中是预览特性，虚拟线程是用户态下的线程，和&lt;code&gt;go&lt;/code&gt;语言中的&lt;code&gt;goroutines&lt;/code&gt;，&lt;code&gt;Erlang&lt;/code&gt;中的&lt;code&gt;processes&lt;/code&gt;类似，虚拟线程并非比线程快，而是提高了应用的吞吐量，相比于传统的线程是由操作系统调度来看，虚拟线程是我们自己程序调度的线程。虚拟线程的出现并没有修改Java原有的并发模型，也不会替代原有的线程，&lt;strong&gt;虚拟线程主要作用是提高服务器端的吞吐量（主要解决IO密集型而非CPU密集型任务）&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;吞吐量的瓶颈&#34;&gt;吞吐量的瓶颈&lt;/h1&gt;
&lt;p&gt;服务器应用程序的伸缩性受&lt;code&gt;利特尔法则（Little&#39;s Law）&lt;/code&gt;的制约，与下面三点有关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延迟：请求处理的耗时&lt;/li&gt;
&lt;li&gt;并发量：同一时刻处理的请求数量&lt;/li&gt;
&lt;li&gt;吞吐量：单位时间内处理的数据数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个服务处理延迟是&lt;code&gt;50ms&lt;/code&gt;，处理10个并发请求，则吞吐量是200请求/秒（10/0.05），如果吞吐量要达到2000请求/秒，则处理的并发请求数量是100. 如果按照1个请求一个线程来看，要想提高吞吐量，线程数量也要增加。&lt;/p&gt;
&lt;p&gt;Java中的线程在操作系统线程（OS Thread）进行了一层封装，而操作系统重线程是重量级资源，在硬件配置确定的前提下，不能无限制创建线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imyzt.top/post-images/1702907700240.png&#34; alt=&#34;os thread&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1702907767424.png&#34; alt=&#34;virtual thread&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;与虚拟地址可以映射到物理内存类似，Java将大量的虚拟线程映射到少量的操作系统线程上，虚拟线程的生命周期短暂，不会有很深的栈调用，一个虚拟线程的生命周期只运行一个任务，因此可以大量创建虚拟线程，&lt;strong&gt;且无需池化&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;虚拟线程的应用场景&#34;&gt;虚拟线程的应用场景&lt;/h1&gt;
&lt;p&gt;在服务器端的应用程序中，虚拟线程能够明显提高应用的吞吐量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;至少几千的并发任务量&lt;/li&gt;
&lt;li&gt;任务是IO密集型&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;平台线程和虚拟线程&#34;&gt;平台线程和虚拟线程&lt;/h1&gt;
&lt;p&gt;平台线程（platform thread）：指Java中的线程，比如通过&lt;code&gt;new Thread()&lt;/code&gt;创建的线程。&lt;br&gt;
虚拟线程并不会直接分配给CPU执行，而是通过&lt;code&gt;调度器&lt;/code&gt;分配给平台线程，平台线程再被调度器管理。Java中的虚拟线程的调度器采用了工作窃取的模式进行FIFO的操作，调度器的并行书默认是jvm获取的处理器数量（&lt;code&gt;Runtime.getRuntime().availableProcessors()&lt;/code&gt;），调度器并非分时（&lt;code&gt;time sharing&lt;/code&gt;）的。在使用虚拟线程编写程序时，不能控制虚拟线程合适分配给平台线程，也不能控制平台线程合适分配给CPU。&lt;/p&gt;
&lt;p&gt;以前任务和平台线程的关系：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1702908144716.png&#34; alt=&#34;old mode&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在使用虚拟线程之后，任务-虚拟线程-调度器-平台线程的关系，1个平台线程可以被调度器分配不同的虚拟线程：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1702908151069.png&#34; alt=&#34;new mode&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;携带器&#34;&gt;携带器&lt;/h1&gt;
&lt;p&gt;调度器将虚拟线程挂载到平台线程之后，该平台线程叫做虚拟线程的携带器，调度器并不维护虚拟线程和携带器的关联关系，&lt;span style=&#34;color: red&#34;&gt;&lt;strong&gt;因此在一个虚拟线程的生命周期可以被分配到不同的携带器&lt;/strong&gt;&lt;/span&gt;，即虚拟线程运行了一小段代码后，可能会脱离携带器，此时其他的虚拟线程会被分配到这个携带器上。&lt;/p&gt;
&lt;p&gt;携带器和虚拟线程是相互独立的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟线程不能使用携带器的标识，&lt;code&gt;Thread.current()&lt;/code&gt;方法获取的是虚拟线程本身。&lt;/li&gt;
&lt;li&gt;两者有各自的栈空间。&lt;/li&gt;
&lt;li&gt;两者不能访问对方的&lt;code&gt;ThreadLocal&lt;/code&gt;变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在程序的执行过程中，虚拟线程遇到阻塞的操作是大部分情况下会被解除挂载，阻塞结束后，虚拟线程会被调度器重新挂载到携带器上，因此虚拟线程会频繁的挂载和解除挂载，这并不会导致操作系统线程的阻塞。&lt;br&gt;
有些阻塞操作并不会导致虚拟线程接触挂载，这样会同时阻塞携带器和操作系统线程，例如：操作系统基本的文件操作，Java的&lt;code&gt;Object.wait()&lt;/code&gt;方法，下面两种情况下不会导致虚拟线程的解除挂载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行&lt;code&gt;synchronized&lt;/code&gt;同步代码（会导致携带器阻塞，所以建议使用&lt;code&gt;ReentrantLock&lt;/code&gt;替换掉&lt;code&gt;Synchronized&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;执行本地方法或外部函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;虚拟线程和平台线程api的区别&#34;&gt;虚拟线程和平台线程api的区别&lt;/h1&gt;
&lt;p&gt;从内存空间上来说，虚拟线程的栈空间可以看做是一个大块的站对象，他被存储在Java堆中，相比于单独存储对象，堆中存储虚拟线程会造成一些空间的浪费，这点在后续的Java版本中应该会得到改善，当然也有一些好处，就是可以重复利用这部分栈空间，不用多次申请开辟新的内存地址，虚拟线程的栈空间最大可以达到平台线程的栈空间容量。&lt;br&gt;
&lt;strong&gt;虚拟线程并不是&lt;code&gt;GC root&lt;/code&gt;，其中的引用不会出现&lt;code&gt;Stop World&lt;/code&gt;，当虚拟线程阻塞之后比如&lt;code&gt;BlockingQueue.take()&lt;/code&gt;，平台线程既不能获取到虚拟线程，也不能获取到&lt;code&gt;queue&lt;/code&gt;队列，这样该平台线程可能被回收掉，虚拟线程在运行或阻塞时不会被GC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过Thread构造方法创建的线程都是平台线程&lt;/li&gt;
&lt;li&gt;虚拟线程是守护线程，不能通过&lt;code&gt;setDaemon&lt;/code&gt;方法改为非守护线程&lt;/li&gt;
&lt;li&gt;虚拟线程的优先级是默认的5，不能被修改，将来版本可能允许修改&lt;/li&gt;
&lt;li&gt;虚拟线程不支持&lt;code&gt;stop()&lt;/code&gt;, &lt;code&gt;suspend()&lt;/code&gt;,&lt;code&gt;resume()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;创建虚拟线程的方式&#34;&gt;创建虚拟线程的方式&lt;/h1&gt;
&lt;p&gt;Java中创建的虚拟线程本质都是通过&lt;code&gt;Thread.Builder.OfVirtual&lt;/code&gt;对象进行创建的，有如下三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread.startVirtualThread()&lt;/code&gt;直接创建一个虚拟线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread.ofVirtual().name(&amp;quot;virtual-thread-&amp;quot;).unstarted(r)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;示例代码&#34;&gt;示例代码&lt;/h1&gt;
&lt;h2 id=&#34;虚拟线程池&#34;&gt;虚拟线程池&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.time.Duration;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.IntStream;

/**
 * @author imyzt
 * @date 2023/12/18
 * @description VirtualThread 1
 */
public class VirtualThread {

    public static void main(String[] args) throws InterruptedException {

        // 通过线程池创建虚拟线程池
        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {
            IntStream.range(0, 10000000).forEach(i -&amp;gt; {
                executor.submit(() -&amp;gt; {
                    try {
                        Thread.sleep(Duration.ofSeconds(1));
                        System.out.println(&amp;quot;执行任务: &amp;quot; + i);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;创建虚拟线程&#34;&gt;创建虚拟线程&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.concurrent.TimeUnit;

/**
 * @author imyzt
 * @date 2023/12/18
 * @description VirtualThread 2
 */
public class CreateVirtualThread {
    public static void main(String[] args) throws InterruptedException {

        Runnable r = () -&amp;gt; System.out.println(Thread.currentThread().getName() + &amp;quot; --- 执行了&amp;quot;);

        // 创建虚拟线程, 方式1
        Thread.startVirtualThread(r);

        Thread virtualThread = Thread.ofVirtual().name(&amp;quot;virtual-thread-&amp;quot;).unstarted(r);
        virtualThread.start();
        System.out.println(&amp;quot;是虚拟线程吗? &amp;quot; + virtualThread.isVirtual());

        Thread platformThread = Thread.ofPlatform().priority(0).daemon(true).name(&amp;quot;platform-thread-&amp;quot;).unstarted(r);
        platformThread.start();
        System.out.println(&amp;quot;是虚拟线程吗? &amp;quot; + platformThread.isVirtual());

        // --- 执行了
        //virtual-thread- --- 执行了
        //是虚拟线程吗? true
        //platform-thread- --- 执行了
        //是虚拟线程吗? false

        // 主线程休眠
        TimeUnit.SECONDS.sleep(1);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;其它&#34;&gt;其它&lt;/h1&gt;
&lt;p&gt;除了提出虚拟线程外，还提出来新的并发编程模型&lt;strong&gt;结构化并发&lt;/strong&gt;，&lt;/p&gt;
">Java 19 新特性</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-17~18-xin-te-xing/"" data-c="
          &lt;h1 id=&#34;特性列表&#34;&gt;特性列表&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Java 17（&lt;strong&gt;LTS&lt;/strong&gt;）&lt;/td&gt;
&lt;td&gt;1. &lt;code&gt;switch&lt;/code&gt; 类型推断 &lt;br/&gt; 2. 伪随机数变化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java 18&lt;/td&gt;
&lt;td&gt;1. 使用&lt;code&gt;UTF-8&lt;/code&gt;编码&lt;br/&gt; 2. &lt;code&gt;jwebserver&lt;/code&gt; &lt;br/&gt; 3. Object、Thread部分方法标记废弃&lt;br/&gt; 4. 增加&lt;code&gt;@snippet&lt;/code&gt;注解&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;java-17&#34;&gt;Java 17&lt;/h1&gt;
&lt;h2 id=&#34;switch-类型推断伪随机数变化&#34;&gt;switch 类型推断，伪随机数变化&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
import java.util.random.RandomGenerator;
import java.util.random.RandomGeneratorFactory;

/**
 * @author imyzt
 * @date 2023/12/17
 * @description switch 类型推断
 */
public class SwitchFuture {

    public static void main(String[] args) {

        Animal animal = new Cat();
        switch (animal) {
            case Cat c -&amp;gt; c.say();
            case Dog d -&amp;gt; d.say();
            case null -&amp;gt; System.out.println(&amp;quot;null&amp;quot;);
            default -&amp;gt; System.out.println(&amp;quot;default&amp;quot;);
        }

        /*
        ➜  java17 git:(master) ✗ java -version
        openjdk version &amp;quot;21.0.1&amp;quot; 2023-10-17 LTS
        OpenJDK Runtime Environment Corretto-21.0.1.12.1 (build 21.0.1+12-LTS)
        OpenJDK 64-Bit Server VM Corretto-21.0.1.12.1 (build 21.0.1+12-LTS, mixed mode, sharing)
        ➜  java17 git:(master) ✗ java SwitchFuture.java
        汪汪汪
         */

        RandomGeneratorFactory&amp;lt;RandomGenerator&amp;gt; factory = RandomGeneratorFactory.getDefault();
        RandomGenerator randomGenerator = factory.create();
        randomGenerator.ints(10).forEach(System.out::println);
        //261824154
        //540138312
        //-1600972486
        //-467718820
        //-660092685
        //-1149689401
        //-46916737
        //2110685130
        //-1910355456
        //-814203516
    }
}

class Animal {

}

class Cat extends Animal {
    void say() {
        System.out.println(&amp;quot;汪汪汪&amp;quot;);
    }
}
class Dog extends Animal {
    void say() {
        System.out.println(&amp;quot;喵喵喵&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;java-18&#34;&gt;Java 18&lt;/h1&gt;
&lt;h2 id=&#34;默认使用utf-8字符编码&#34;&gt;默认使用UTF-8字符编码&lt;/h2&gt;
&lt;p&gt;从jdk18开始，默认使用UTF-8字符编码，如果需要修改为其他字符，可以使用命令 &lt;code&gt;-Dfile.encoding=UTF-8&lt;/code&gt;来指定。&lt;/p&gt;
&lt;h2 id=&#34;简单web服务器&#34;&gt;简单web服务器&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;➜  java17 git:(master) ✗ jwebserver            
默认情况下绑定到环回。如果要表示所有接口，请使用 &amp;quot;-b 0.0.0.0&amp;quot; 或 &amp;quot;-b ::&amp;quot;。
为 127.0.0.1 端口 8000 上的 /xxxxxxxxx目录/java17 及子目录提供服务
URL http://127.0.0.1:8000/
127.0.0.1 - - [17/12月/2023:10:38:18 +0800] &amp;quot;GET / HTTP/1.1&amp;quot; 200 -
127.0.0.1 - - [17/12月/2023:10:38:18 +0800] &amp;quot;GET /favicon.ico HTTP/1.1&amp;quot; 404 -
127.0.0.1 - - [17/12月/2023:10:38:20 +0800] &amp;quot;GET /SwitchFuture.java HTTP/1.1&amp;quot; 200 -
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;将被废弃的方法&#34;&gt;将被废弃的方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;java.lang.Object#finalize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.lang.Thread#stop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新增snippet展示代码&#34;&gt;新增@snippet展示代码&lt;/h2&gt;
&lt;p&gt;之前需要用&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;标签框代码，不方便，现在通过&lt;code&gt;@snippet&lt;/code&gt;还是框代码&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1702781281538.png&#34; alt=&#34;snippet&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Java 17~18 新特性</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-10~16-xin-te-xing/"" data-c="
          &lt;h1 id=&#34;主要特性&#34;&gt;主要特性&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Java 10&lt;/td&gt;
&lt;td&gt;1. &lt;code&gt;var&lt;/code&gt;声明局部变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java 11 （&lt;strong&gt;LTS&lt;/strong&gt;）&lt;/td&gt;
&lt;td&gt;1. 字符串补充工具方法 &lt;br/&gt; 2. lambda 类型推断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java 12&lt;/td&gt;
&lt;td&gt;1. switch 箭头表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java 13&lt;/td&gt;
&lt;td&gt;1. switch 支持返回值，增加yield关键字&lt;br/&gt; 2. 多行字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java 14&lt;/td&gt;
&lt;td&gt;1. instanceof优化&lt;br/&gt; 2. NPE优化&lt;br/&gt;  3. record类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java 15&lt;/td&gt;
&lt;td&gt;1. scale密封类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java 16&lt;/td&gt;
&lt;td&gt;1. 包装类构造方法警告&lt;br/&gt; 2. DateTimeFormatter增加匹配方式&lt;br/&gt; 3. InvocationHandler新增方法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;java-10&#34;&gt;Java 10&lt;/h1&gt;
&lt;h2 id=&#34;var-声明局部变量&#34;&gt;&lt;code&gt;var&lt;/code&gt; 声明局部变量&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2023/12/16
 * @description Var
 */
public class VarDemo {
    public static void main(String[] args) {
        var str = &amp;quot;hello world&amp;quot;;
        var num = 10;

        System.out.println(str);
        System.out.println(num);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;java-11&#34;&gt;Java 11&lt;/h1&gt;
&lt;h2 id=&#34;字符串补充工具方法-lambda-类型推断&#34;&gt;字符串补充工具方法, lambda 类型推断&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/16
 * @description String 补充工具方法
 */
public class StrUtil {

    public static void main(String[] args) {
        //Unicode空白字符
        char c = &#39;\u2000&#39;;
        String str = c + &amp;quot;abc&amp;quot; + c;
        // 去除普通空白字符
        System.out.println(str.trim());
        // 去除Unicode空白字符
        System.out.println(str.strip());
        // 去除前面的空白字符
        System.out.println(str.stripLeading());
        // 去除后面的空白字符
        System.out.println(str.stripTrailing());
        // abc 
        //abc
        //abc 
        // abc

        // 判空
        System.out.println(&amp;quot; &amp;quot;.isBlank());
        // 支持直接定义常量使用format
        System.out.println(&amp;quot;%s_%s&amp;quot;.formatted(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;));
        // 重复字符串
        System.out.println(&amp;quot;abc&amp;quot;.repeat(3));
        //true
        //a_b
        //abcabcabc

        // lambda 类型推断
        // java11前
        MyFunc s1 = (String a, Integer b) -&amp;gt; a + b;
        MyFunc s2 = (a, b) -&amp;gt; a + b;
        // java11后, 支持类型推断(作用不大)
        MyFunc s3 = (var a, var b) -&amp;gt; a + b;
    }
}

@FunctionalInterface
interface MyFunc {
    String foo(String a, Integer b);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;java-12&#34;&gt;Java 12&lt;/h1&gt;
&lt;h2 id=&#34;switch-箭头表达式&#34;&gt;switch 箭头表达式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/16
 * @description switch
 */
public class SwitchFuture {

    public static void main(String[] args) {

        int month = LocalDate.now().getMonthValue();

        // java12 前 switch
        switch (month) {
            case 3:
            case 4:
            case 5:
                System.out.println(&amp;quot;spring&amp;quot;);
                break;
            case 6:
            case 7:
            case 8:
                System.out.println(&amp;quot;summer&amp;quot;);
                break;
            case 9:
            case 10:
            case 11:
                System.out.println(&amp;quot;fall&amp;quot;);
                break;
            case 12:
            case 1:
            case 2:
                System.out.println(&amp;quot;winter&amp;quot;);
                break;
            default:
                System.out.println(&amp;quot;err&amp;quot;);
        }

        // java12 之后的switch
        switch (month) {
            case 3,4,5 -&amp;gt; System.out.println(&amp;quot;spring&amp;quot;);
            case 6,7,8 -&amp;gt; System.out.println(&amp;quot;summer&amp;quot;);
            case 9,10,11 -&amp;gt; System.out.println(&amp;quot;fall&amp;quot;);
            case 12,1,2 -&amp;gt; System.out.println(&amp;quot;winter&amp;quot;);
            default -&amp;gt; System.out.println(&amp;quot;err&amp;quot;);

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;java-13&#34;&gt;Java 13&lt;/h1&gt;
&lt;h2 id=&#34;switch-箭头表达式支持返回值多行字符串增加yield关键字作为switch多行时的返回值&#34;&gt;switch 箭头表达式支持返回值，多行字符串，增加yield关键字作为switch多行时的返回值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.time.LocalDate;

/**
 * @author imyzt
 * @date 2023/12/16
 * @description switch 返回值
 */
public class SwitchFuture {

    public static void main(String[] args) {

        int month = LocalDate.now().getMonthValue();
        // java13 之后的switch
        String str = switch (month) {
            case 3, 4, 5 -&amp;gt; &amp;quot;spring&amp;quot;;
            case 6, 7, 8 -&amp;gt; &amp;quot;summer&amp;quot;;
            case 9, 10, 11 -&amp;gt; &amp;quot;fall&amp;quot;;
            case 12, 1, 2 -&amp;gt; &amp;quot;winter&amp;quot;;
            default -&amp;gt; {
                System.out.println(&amp;quot;err&amp;quot;);
                yield &amp;quot;err&amp;quot;;
            }
        };
        System.out.println(str);
        // winter

        String strline = &amp;quot;&amp;quot;&amp;quot;
                第一行
                第二行
                第三行&amp;quot;&amp;quot;&amp;quot;;
        System.out.println(strline);
        //第一行
        //第二行
        //第三行
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;java-14&#34;&gt;Java 14&lt;/h1&gt;
&lt;h2 id=&#34;instanceof-优化&#34;&gt;instanceof 优化&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/16
 * @description instanceof 优化
 */
public class InstanceofFuture {

    public static void main(String[] args) {

        // Java 14之前
        Object o = &amp;quot;str&amp;quot;;
        if (o instanceof String) {
            String str = (String) o;
            System.out.println(str);
        }

        // Java 14之后
        if (o instanceof String str) {
            System.out.println(str);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;npe优化在链式调用时-如果有空指针-可以明确是哪个变量空指针&#34;&gt;NPE优化，在链式调用时, 如果有空指针, 可以明确是哪个变量空指针&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/16
 * @description 友好的NPE提示
 */
public class NpeFuture {

    public static void main(String[] args) {
        C c = new C();
        // 在链式调用时, 如果有空指针, 可以明确是哪个变量空指针
        String name = c.b.a.name;
        System.out.println(name);
        // Cannot read field &amp;quot;a&amp;quot; because &amp;quot;c.b&amp;quot; is null
    }
}
class A {
    public String name;
}

class B {
    public A a;
}

class C {
    public B b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;record模式&#34;&gt;record模式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/16
 * @description record模式
 */
public class RecordFuture {

    public static void main(String[] args) {
        Student student = new Student(&amp;quot;yzt&amp;quot;, 25);
        System.out.println(student);
        // Student[name=yzt, age=25]

        student.study();
        // good good study!
    }
}

record Student(String name, Integer age) {
    public void study() {
        System.out.println(&amp;quot;good good study!&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;java-15&#34;&gt;Java 15&lt;/h1&gt;
&lt;h2 id=&#34;scale密封类&#34;&gt;scale密封类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;需要使用&lt;code&gt;sealed&lt;/code&gt;声明, 使用&lt;code&gt;permits&lt;/code&gt;指定&lt;/li&gt;
&lt;li&gt;继承密封类，必须指定自己为final(Dog)，或选择继续将自己指定为密封类(Cat)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/16
 * @description scale, permits
 */
public class ScaleFuture {
}

/**
 * 只希望Dog和Cat能继承, 需要使用sealed声明, 使用permits指定
 */
sealed class Animal permits Dog, Cat {
    
}

/**
 * 继承密封类,必须指定自己为final(Dog), 或继续将自己指定为密封类(Cat)
 */
final class Dog extends Animal {
    
}

/**
 * 将自己指定为密封类, 并且通过permits指定只有Cat2能够继承
 */
sealed class Cat extends Animal permits Cat2 {
    
}

final class Cat2 extends Cat {
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;java-16&#34;&gt;Java 16&lt;/h1&gt;
&lt;h2 id=&#34;包装类型的构造方法被标记过期&#34;&gt;包装类型的构造方法被标记过期&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @author imyzt
 * @date 2023/12/17
 * @description Integer
 */
public class IntegerFuture {

    public static void main(String[] args) {
        // &#39;Integer(int)&#39; is deprecated and marked for removal
        Integer i = new Integer(2);
        System.out.println(i);

        // 不建议这样编写,因为数字在常量池中, 会和其他毫不相干的地方使用同一个锁对象
        synchronized (i) {
            System.out.println(1);
        }

        // time format
        // All letters &#39;A&#39; to &#39;Z&#39; and &#39;a&#39; to &#39;z&#39; are reserved as pattern letters. The following pattern letters are defined:
        System.out.println(DateTimeFormatter.ofPattern(&amp;quot;B&amp;quot;).format(LocalDateTime.now()));

        //2
        //1
        //凌晨
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;datetimeformatter&#34;&gt;DateTimeFormatter&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/format/DateTimeFormatter.html&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Symbol&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;Presentation&lt;/th&gt;
&lt;th&gt;Examples&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;era&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;AD; Anno Domini; A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;year&lt;/td&gt;
&lt;td&gt;year&lt;/td&gt;
&lt;td&gt;2004; 04&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;year-of-era&lt;/td&gt;
&lt;td&gt;year&lt;/td&gt;
&lt;td&gt;2004; 04&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;day-of-year&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;189&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M/L&lt;/td&gt;
&lt;td&gt;month-of-year&lt;/td&gt;
&lt;td&gt;number/text&lt;/td&gt;
&lt;td&gt;7; 07; Jul; July; J&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;day-of-month&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;modified-julian-day&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;2451334&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Q/q&lt;/td&gt;
&lt;td&gt;quarter-of-year&lt;/td&gt;
&lt;td&gt;number/text&lt;/td&gt;
&lt;td&gt;3; 03; Q3; 3rd quarter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;week-based-year&lt;/td&gt;
&lt;td&gt;year&lt;/td&gt;
&lt;td&gt;1996; 96&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;week-of-week-based-year&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;week-of-month&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;day-of-week&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;Tue; Tuesday; T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;e/c&lt;/td&gt;
&lt;td&gt;localized day-of-week&lt;/td&gt;
&lt;td&gt;number/text&lt;/td&gt;
&lt;td&gt;2; 02; Tue; Tuesday; T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;day-of-week-in-month&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;am-pm-of-day&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;PM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;period-of-day&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;in the morning&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;clock-hour-of-am-pm (1-12)&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;hour-of-am-pm (0-11)&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;k&lt;/td&gt;
&lt;td&gt;clock-hour-of-day (1-24)&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;hour-of-day (0-23)&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;minute-of-hour&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;second-of-minute&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;fraction-of-second&lt;/td&gt;
&lt;td&gt;fraction&lt;/td&gt;
&lt;td&gt;978&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;milli-of-day&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;1234&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;nano-of-second&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;987654321&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;nano-of-day&lt;/td&gt;
&lt;td&gt;number&lt;/td&gt;
&lt;td&gt;1234000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;time-zone ID&lt;/td&gt;
&lt;td&gt;zone-id&lt;/td&gt;
&lt;td&gt;America/Los_Angeles; Z; -08:30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;generic time-zone name&lt;/td&gt;
&lt;td&gt;zone-name&lt;/td&gt;
&lt;td&gt;Pacific Time; PT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;z&lt;/td&gt;
&lt;td&gt;time-zone name&lt;/td&gt;
&lt;td&gt;zone-name&lt;/td&gt;
&lt;td&gt;Pacific Standard Time; PST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;localized zone-offset&lt;/td&gt;
&lt;td&gt;offset-O&lt;/td&gt;
&lt;td&gt;GMT+8; GMT+08:00; UTC-08:00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;zone-offset &#39;Z&#39; for zero&lt;/td&gt;
&lt;td&gt;offset-X&lt;/td&gt;
&lt;td&gt;Z; -08; -0830; -08:30; -083015; -08:30:15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;zone-offset&lt;/td&gt;
&lt;td&gt;offset-x&lt;/td&gt;
&lt;td&gt;+0000; -08; -0830; -08:30; -083015; -08:30:15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;zone-offset&lt;/td&gt;
&lt;td&gt;offset-Z&lt;/td&gt;
&lt;td&gt;+0000; -0800; -08:00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;pad next&lt;/td&gt;
&lt;td&gt;pad modifier&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&#39;&lt;/td&gt;
&lt;td&gt;escape for text&lt;/td&gt;
&lt;td&gt;delimiter&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&#39;&#39;&lt;/td&gt;
&lt;td&gt;single quote&lt;/td&gt;
&lt;td&gt;literal&lt;/td&gt;
&lt;td&gt;&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[&lt;/td&gt;
&lt;td&gt;optional section start&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;]&lt;/td&gt;
&lt;td&gt;optional section end&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;#&lt;/td&gt;
&lt;td&gt;reserved for future use&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{&lt;/td&gt;
&lt;td&gt;reserved for future use&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;}&lt;/td&gt;
&lt;td&gt;reserved for future use&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;invocationhandler新增方法&#34;&gt;InvocationHandler新增方法&lt;/h2&gt;
&lt;p&gt;该接口补充了新方法 &lt;code&gt;java.lang.reflect.InvocationHandler#invokeDefault&lt;/code&gt;，可以调用父接口中的&lt;code&gt;default&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CallerSensitive
public static Object invokeDefault(Object proxy, Method method, Object... args)
        throws Throwable {
    Objects.requireNonNull(proxy);
    Objects.requireNonNull(method);
    return Proxy.invokeDefault(proxy, method, args, Reflection.getCallerClass());
}
&lt;/code&gt;&lt;/pre&gt;
">Java 10~16 新特性</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-9-xin-te-xing/"" data-c="
          &lt;h1 id=&#34;主要特性&#34;&gt;主要特性&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;接口中支持定义 &lt;code&gt;private&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;try-with-resource&lt;/code&gt; 方式优化&lt;/li&gt;
&lt;li&gt;不可以使用 “_”下划线命名变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Deprecated&lt;/code&gt; 注解支持指定废弃版本(&lt;code&gt;since&lt;/code&gt;), 以及标记未来版本是否删除(&lt;code&gt;forRemoval&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;字符串的变化&lt;/li&gt;
&lt;li&gt;模块化&lt;/li&gt;
&lt;li&gt;jshell&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;接口定义private方法&#34;&gt;接口定义&lt;code&gt;private&lt;/code&gt;方法&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.concurrent.TimeUnit;

/**
 * @author imyzt
 * @date 2023/12/16
 * @description java 9 在接口中可以定义 private 方法, 只可在本接口中调用
 */
public interface InterfaceFuture {

    void foo();

    /**
     * java 8
     */
    default void foo1() throws InterruptedException {
        sleep();
    }

    /**
     * java 8
     */
    static void foo2() throws InterruptedException {
        sleep2();
    }

    /**
     * java 9
     */
    private void sleep() throws InterruptedException {
        TimeUnit.SECONDS.sleep(1);
    }

    /**
     * java 9
     */
    private static void sleep2() throws InterruptedException {
        TimeUnit.SECONDS.sleep(1);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;try-with-resource-方式优化&#34;&gt;&lt;code&gt;try-with-resource&lt;/code&gt; 方式优化&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package top.imyzt.jdk.features.jdk9;


import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

/**
 * @author imyzt
 * @date 2023/12/16
 * @description 1. try 代码块简化, 2. 不可以再使用 &amp;quot;_&amp;quot;(下划线)命名变量
 */
public class TryWithResource {

    public static void main(String[] args) throws FileNotFoundException {

        // java 8
        try (FileInputStream fis1 = new FileInputStream(&amp;quot;&amp;quot;);
             FileOutputStream fos1 = new FileOutputStream(&amp;quot;&amp;quot;)) {
            fis1.read();
        } catch (Exception e) {

        }

        // java 9
        // 可以将变量写到 try 代码块中, 让代码块更简洁
        FileInputStream fis2 = new FileInputStream(&amp;quot;&amp;quot;);
        FileOutputStream fos2 = new FileOutputStream(&amp;quot;&amp;quot;);
        try (fis2; fos2) {

        } catch (Exception e) {

        }


        // java 9 运行报错 As of Java 9, &#39;_&#39; is a keyword, and may not be used as an identifier
        // String _ = &amp;quot;123&amp;quot;;

    }

    /**
     * `@Deprecated` 注解支持指定废弃版本(since), 以及标记未来是否废弃(forRemoval)
     */
    @Deprecated(since = &amp;quot;9&amp;quot;, forRemoval = true)
    private void test() {

    }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;deprecated-注解升级&#34;&gt;&lt;code&gt;@Deprecated&lt;/code&gt; 注解升级&lt;/h1&gt;
&lt;p&gt;例如&lt;code&gt;java.lang.Object#finalize&lt;/code&gt;方法就在 Java9 中被标记废弃，并且在未来可能会被删除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Deprecated(since=&amp;quot;9&amp;quot;, forRemoval=true)
protected void finalize() throws Throwable { }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;string字符串的变化&#34;&gt;String字符串的变化&lt;/h1&gt;
&lt;p&gt;在 Java9 之前的版本中，&lt;code&gt;String&lt;/code&gt;内部使用&lt;code&gt;char&lt;/code&gt;数组存储，对于使用英语的人来说，一个字符用一个&lt;code&gt;byte&lt;/code&gt;就能存储，使用&lt;code&gt;char&lt;/code&gt;存储字符会&lt;strong&gt;浪费一半的内存空间&lt;/strong&gt;，因此在 Java9 中将String内部的&lt;code&gt;char&lt;/code&gt;数组改成了&lt;code&gt;byte&lt;/code&gt;数组，这样就节省了一半的内存占用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;char c = &#39;a&#39;; // 2个字节
byte b = 97; // 1个字节
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;String中增加了2个成员变量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;static final boolean COMPACT_STRINGS;&lt;/code&gt;：判断是否压缩，默认为true，如果=false，则不压缩，使用UTF-16编码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private final byte coder;&lt;/code&gt;：用来区分使用的字符编码
&lt;ul&gt;
&lt;li&gt;LATIN1，值为0，存储英文&lt;/li&gt;
&lt;li&gt;UTF-16，值为1，存储中文，或夹杂中文的英文（为了区分字符边界，如果英文使用&lt;code&gt;1byte&lt;/code&gt;，则不利于字符串的&lt;code&gt;sub&lt;/code&gt;等操作，也无法计算长度）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Native static final byte LATIN1 = 0;
@Native static final byte UTF16  = 1;

public int length() {
    // 如果开启压缩，`coder()=0`，不进行位移，返回value数组长度
    // 如果开启压缩，`coder()=1`，右移1=除以2，因为中文存储1个字符占用2个byte的空间
    return value.length &amp;gt;&amp;gt; coder();
}
byte coder() {
    // 如果开启压缩，则`coder=LATIN1=0`，否则`coder=UTF16=1`
    return COMPACT_STRINGS ? coder : UTF16;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;byte&lt;/code&gt;数组如何存储中文？通过源码 &lt;code&gt;java.lang.StringUTF16#toBytes(char[], int, int)&lt;/code&gt; 可以看到，1个中文会被存储到&lt;code&gt;byte&lt;/code&gt;数组中的两个元素上 ，即存储一个中文，&lt;code&gt;byte&lt;/code&gt;数组长度为2，存储2个中文，&lt;code&gt;byte&lt;/code&gt;数组长度为4.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1702720593239.png&#34; alt=&#34;string_&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;StringUTF16&lt;/code&gt; 部分源码截取，高八位和低八位分别存储，占用2个&lt;code&gt;byte&lt;/code&gt;数组的空间：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final int HI_BYTE_SHIFT;
static final int LO_BYTE_SHIFT;
static {
    // CPU架构大小端
    if (isBigEndian()) {
        HI_BYTE_SHIFT = 8;
        LO_BYTE_SHIFT = 0;
    } else {
        HI_BYTE_SHIFT = 0;
        LO_BYTE_SHIFT = 8;
    }
}
@IntrinsicCandidate
// intrinsic performs no bounds checks
static void putChar(byte[] val, int index, int c) {
    assert index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; length(val) : &amp;quot;Trusted caller missed bounds check&amp;quot;;
    index &amp;lt;&amp;lt;= 1;
    val[index++] = (byte)(c &amp;gt;&amp;gt; HI_BYTE_SHIFT);
    val[index]   = (byte)(c &amp;gt;&amp;gt; LO_BYTE_SHIFT);
}

@IntrinsicCandidate
// intrinsic performs no bounds checks
static char getChar(byte[] val, int index) {
    assert index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; length(val) : &amp;quot;Trusted caller missed bounds check&amp;quot;;
    index &amp;lt;&amp;lt;= 1;
    return (char)(((val[index++] &amp;amp; 0xff) &amp;lt;&amp;lt; HI_BYTE_SHIFT) |
                    ((val[index]   &amp;amp; 0xff) &amp;lt;&amp;lt; LO_BYTE_SHIFT));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;模块化&#34;&gt;模块化&lt;/h1&gt;
&lt;p&gt;Java8 和之前的版本中，主要源代码是放在 &lt;code&gt;rt.jar&lt;/code&gt; 中的，但是其中很多包是我们平时不会用到的，比如 &lt;code&gt;java.awt&lt;/code&gt; 如果全载入到内存中，会造成一定的浪费。&lt;br&gt;
所以在 Java9 开始，将 &lt;code&gt;rt.jar&lt;/code&gt; 分成了不同的模块，一个模块下可以包含多个包，模块之间存在依赖关系。其中 &lt;code&gt;java.base&lt;/code&gt; 为基础模块（包含&lt;code&gt;java.lang&lt;/code&gt;,&lt;code&gt;java.util&lt;/code&gt;..），不依赖其他模块。&lt;br&gt;
模块与包类似，只不过一个模块下可以包含多个包。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/&#34;&gt;Java8文档&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1702722874295.png&#34; alt=&#34;Java8文档&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/overview-summary.html&#34;&gt;Java9文档&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1702722819500.png&#34; alt=&#34;Java9文档&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.jar&lt;/code&gt;包中含有&lt;code&gt;.class&lt;/code&gt;文件，配置文件。&lt;br&gt;
&lt;code&gt;.jmod&lt;/code&gt;除了上述文件外，还包含&lt;code&gt;navite library&lt;/code&gt;，&lt;code&gt;legal licenses&lt;/code&gt;等。&lt;br&gt;
两者主要区别是&lt;code&gt;.jmod&lt;/code&gt;主要用在编译器和链接期，并非运行期，对于开发者来说，运行期任然需要使用jar包。&lt;/p&gt;
&lt;h2 id=&#34;模块化的优点&#34;&gt;模块化的优点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;精简JVM运行所需加载的class类，提升加载速度。&lt;/li&gt;
&lt;li&gt;对包更精细的控制，提高安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关键字&#34;&gt;关键字&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;exports： 声明导出包，正常可使用，反射可以使用。&lt;/li&gt;
&lt;li&gt;opens：声明导出包，只有反射可以使用，正常编写代码编译无法通过，报错 &lt;code&gt;Package &#39;package_name&#39; is declared in module &#39;develop&#39;, which does not export it to module &#39;test&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;requires：声明依赖包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;示例工程&#34;&gt;示例工程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建项目&lt;/li&gt;
&lt;li&gt;创建模块 &lt;code&gt;develop&lt;/code&gt; 、 &lt;code&gt;test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在模块 &lt;code&gt;develop&lt;/code&gt; 下创建 &lt;code&gt;Cat.java&lt;/code&gt;, &lt;code&gt;Apple.java&lt;/code&gt;，创建 &lt;code&gt;module-info.java&lt;/code&gt;，声明 &lt;code&gt;export develop&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package top.imyzt.learing.jdkfuture.dev1;


/**
 * @author imyzt
 * @date 2023/12/16
 * @description Cat
 */
public class Cat {

    public void eat() {
        System.out.println(&amp;quot;吃鱼&amp;quot;);
    }
}

package top.imyzt.learing.jdkfuture.dev2;


/**
 * @author imyzt
 * @date 2023/12/16
 * @description Apple
 */
public class Apple {
    public Apple() {
        System.out.println(&amp;quot;Apple Constructor&amp;quot;);
    }
}

module develop {
    // 导出包
    exports top.imyzt.learing.jdkfuture.dev1;
    // 导出包, 只能通过反射访问
    opens top.imyzt.learing.jdkfuture.dev2;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;在模块 &lt;code&gt;test&lt;/code&gt; 下创建 &lt;code&gt;Test.java&lt;/code&gt;，创建 &lt;code&gt;module-info.java&lt;/code&gt;，声明 &lt;code&gt;requie develop&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package main.top.imyzt.learing.jdkfuture.test;


import top.imyzt.learing.jdkfuture.dev1.Cat;
// Package &#39;top.imyzt.learing.jdkfuture.dev2&#39; is declared in module &#39;develop&#39;, which does not export it to module &#39;test&#39;
// import top.imyzt.learing.jdkfuture.dev2.Apple;

/**
 * @author imyzt
 * @date 2023/12/16
 * @description 描述信息
 */
public class Test {

    public static void main(String[] args) throws Exception {
        Cat cat = new Cat();
        cat.eat();

        Class&amp;lt;?&amp;gt; clazz = Class.forName(&amp;quot;top.imyzt.learing.jdkfuture.dev2.Apple&amp;quot;);
        clazz.getDeclaredConstructor().newInstance();
    }
}

module test {
    requires develop;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;项目结构图&#34;&gt;项目结构图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1702724406658.png&#34; alt=&#34;项目结构图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;源代码&#34;&gt;源代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/framework-in-java/jdk-new-features/jdk9_module&#34;&gt;示例项目&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;jshell&#34;&gt;jshell&lt;/h1&gt;
&lt;p&gt;作用不大，主要对于初学者可以学习语法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;➜  jshell
|  欢迎使用 JShell -- 版本 21.0.1
|  要大致了解该版本, 请键入: /help intro

jshell&amp;gt; System.out.println(&amp;quot;hello world&amp;quot;);
hello world

jshell&amp;gt; int a = 1;
a ==&amp;gt; 1

jshell&amp;gt; int b = 2;
b ==&amp;gt; 2

jshell&amp;gt; System.out.println(a+b);
3

jshell&amp;gt; /exit
|  再见
&lt;/code&gt;&lt;/pre&gt;
">Java 9 新特性</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/du-kuo-san-xie-kuo-san/"" data-c="
          &lt;p&gt;读扩散、写扩散，主要应用在feed流场景中，什么是feed流？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微博&lt;/li&gt;
&lt;li&gt;微信朋友圈&lt;br&gt;
等都是典型的信息流业务，存在好友关系，如关注和粉丝，自己的主页由别人发布的内容组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;feed流业务最大的特点是&lt;strong&gt;自己的主页由别人的feed组成&lt;/strong&gt;，获得主页本质上就是在组装别人的内容。&lt;br&gt;
从技术上主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拉取（读扩散）&lt;/li&gt;
&lt;li&gt;推送（写扩散）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;拉模式读扩散&#34;&gt;拉模式（读扩散）&lt;/h1&gt;
&lt;p&gt;假设存在A关注BC，那么存储A关注B、A关注C；C的粉丝有A、B的粉丝有A，这么一组关系。&lt;br&gt;
&lt;strong&gt;发布流程&lt;/strong&gt;：当B/C发布内容时，只需将自己的内容存储在自己的队列（feed记录）中。&lt;br&gt;
&lt;strong&gt;查询个人主页流程&lt;/strong&gt;：当A查看自己的主页时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拉取A的关注列表：存在B、C&lt;/li&gt;
&lt;li&gt;获取所关注列表中B、C的feed记录，判断是否有可见性设置&lt;/li&gt;
&lt;li&gt;对消息进行 &lt;code&gt;order by time desc&lt;/code&gt;，分页取数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;缺点&#34;&gt;缺点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;拉取信息流时，业务非常复杂&lt;/li&gt;
&lt;li&gt;多次访问时，每次都需要进行大量计算&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;存储结构简单，数据存储量较小，只存储一份不会冗余。&lt;/li&gt;
&lt;li&gt;关注、取关、发布feed的流程都很简单&lt;/li&gt;
&lt;li&gt;适合早期业务量不大的时候，可以快速实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;推模式写扩散&#34;&gt;推模式（写扩散）&lt;/h1&gt;
&lt;p&gt;这是&lt;strong&gt;蓝色&lt;/strong&gt;的文字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;继续上面的假设，关注关系依旧不变，但与读扩散不同的是，每个用户还需要&lt;span style=&#34;color:red&#34;&gt;存储自己&lt;strong&gt;收到&lt;/strong&gt;的feed流&lt;/span&gt;&lt;br&gt;
&lt;strong&gt;发布流程&lt;/strong&gt;：当B/C发布内容时，需要查询自己的粉丝列表，然后分别在粉丝A的feed中，写入B、C发布的feed信息。&lt;br&gt;
&lt;strong&gt;查询个人主页的流程&lt;/strong&gt;：当A查看自己的主页时：&lt;strong&gt;直接拉取自己的feed记录即可&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;缺点-2&#34;&gt;缺点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;实现关注取关时，关注时，需要将信息从写入到粉丝的feed记录中，移除时，同样需要将内容从feed记录中删除。&lt;/li&gt;
&lt;li&gt;极大的存储资源消耗，需要存储多份feed信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;优点-2&#34;&gt;优点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;拉取信息时非常简单，只需直接查询feed记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;拉模式，读扩散，feed存一份，存储小，用户集中访问数据，性能差;&lt;/li&gt;
&lt;li&gt;推模式，写扩散，feed存多份，用冗余存储换锁冲突，性能高;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;全文参考自：&lt;a href=&#34;https://www.51cto.com/article/697949.html&#34;&gt;58沈剑-读扩散，写扩散，终于讲清楚了！&lt;/a&gt;&lt;/p&gt;
">读扩散、写扩散</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/fen-bu-shi-wei-yi-biao-shi-she-ji/"" data-c="
          &lt;p&gt;当数据库面临分库分表时，无法依赖数据库自增主键来生成业务标识，或业务场景设计时为了防止自增id被外部撞库猜测数据，通常会考虑引入&lt;strong&gt;全局唯一标识生成器&lt;/strong&gt;来解决此类问题。&lt;/p&gt;
&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;目前市面上比较常见的基本为&lt;code&gt;Twitter&lt;/code&gt;开源的&lt;code&gt;Snowflake&lt;/code&gt;及其变种，&lt;code&gt;Snowflake&lt;/code&gt;的核心思想是将&lt;code&gt;64bit&lt;/code&gt;的二进制数字分为若干部分，每一部分都存储具有特定含义的数据，比如时间戳、机器ID、序列号等，最终&lt;strong&gt;生成全局唯一有序ID&lt;/strong&gt;，标准算法如下图：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1701578944155.jpeg&#34; alt=&#34;snowflake&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;41位的时间戳部分可以支撑&lt;code&gt;pow(2,41)/1000/60/60/24/365&lt;/code&gt; 年，约等于 69 年。&lt;/li&gt;
&lt;li&gt;如果系统部署在多机房，那么 10 位的机器 ID 可以继续划分为 &lt;code&gt;2～3&lt;/code&gt; 位的 &lt;strong&gt;IDC&lt;/strong&gt; 标示（可以支撑 4 个或者 8 个 IDC 机房）和 &lt;code&gt;7～8&lt;/code&gt; 位的 &lt;strong&gt;机器 ID&lt;/strong&gt;（支持 128-256 台机器）。&lt;/li&gt;
&lt;li&gt;12 位的序列号代表着每个节点每毫秒最多可以生成 4096 的 ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;部署方式&#34;&gt;部署方式&lt;/h1&gt;
&lt;p&gt;雪花ID具有两种使用方式，一种是独立部署一套&lt;strong&gt;发号器&lt;/strong&gt;，外部请求下发，另一种更为常见的做法是直接嵌入到应用内，使用&lt;code&gt;Snowflake&lt;/code&gt;工具类直接获取使用，当嵌入到应用内部时，可以考虑将&lt;strong&gt;机器ID&lt;/strong&gt;部分，分散标识到不同业务系统。&lt;/p&gt;
&lt;h1 id=&#34;缺点&#34;&gt;缺点&lt;/h1&gt;
&lt;h2 id=&#34;时间回拨问题&#34;&gt;时间回拨问题&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Snowflake&lt;/code&gt;算法设计很简单和巧妙，性能高效，具有&lt;strong&gt;全局唯一性、单调递增性和有业务含义的ID&lt;/strong&gt;，但是它也有一定缺点，其中&lt;strong&gt;最大的缺点就是他依赖于系统的时间戳&lt;/strong&gt;，一旦时间不准，就有可能生成重复的ID。如果是独立部署的发号器，如果发现系统时间不准，可以直接暂停发号，知道时间准确为止。&lt;/p&gt;
&lt;h2 id=&#34;qps低引起单调重复&#34;&gt;QPS低引起单调重复&lt;/h2&gt;
&lt;p&gt;如果发号器的QPS不高，例如每毫秒只能发一个ID，就会造成ID的末尾永远是1，&lt;strong&gt;如果在分库分表系统中使用ID作为分区间，就会造成库表分配的不均匀&lt;/strong&gt;。&lt;br&gt;
如何解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时间戳不记录毫秒而是记录秒，这样在一个时间区间内可以多发几个号，避免出现分库分表时数据分配不均。&lt;/li&gt;
&lt;li&gt;生成的序列号的起始号可以做一下随机，这一秒是21，下一秒可以是30，这样也会保证均衡。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://zq99299.github.io/note-architect/hc/02/04.html#%E5%9F%BA%E4%BA%8E-snowflake-%E7%AE%97%E6%B3%95%E6%90%AD%E5%BB%BA%E5%8F%91%E5%8F%B7%E5%99%A8&#34;&gt;发号器：如何保证分库分表后 ID 的全局唯一性？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzI4NDMyNTU2Mw==&amp;amp;mid=2247483679&amp;amp;idx=1&amp;amp;sn=584dbd80aa08fa1188627ad725680928&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1208L9z4yXKLW60rPph2ZmMn#rd&#34;&gt;万亿级调用系统：微信序列号生成器架构设计及演变&lt;br&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
">分布式唯一标识设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/threadpoolexecutor-fei-chang-yong-fang-fa/"" data-c="
          &lt;p&gt;平时在使用线程池时，更多关注到的是coreSize、maxSize、blockQueue、RejectedExecutionHandler这些参数，但在线程池监控领域，还需要关注到其他的一些方法。在此处做统一记录和备忘：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {

    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 5, 1, TimeUnit.MINUTES, new ArrayBlockingQueue&amp;lt;&amp;gt;(1024), new ThreadPoolExecutor.CallerRunsPolicy());

    // 启动所有核心线程(预热)
    threadPoolExecutor.prestartAllCoreThreads();
    // 启动一个核心线程
    threadPoolExecutor.prestartCoreThread();

    // 默认情况下构造器中的keepAliveTime指定的是非核心线程的空闲时间, 通过如下方法, 可以允许核心线程超时
    threadPoolExecutor.allowCoreThreadTimeOut(true);

    // ⭐️ 动态线程池必备方法
    // 启动后, 设置核心线程数量
    threadPoolExecutor.setCorePoolSize(3);
    // 启动后, 设置最大线程数量
    threadPoolExecutor.setMaximumPoolSize(10);
    // 已执行完的任务总数
    threadPoolExecutor.getTaskCount();
    // 获取工作队列剩余数量
    threadPoolExecutor.getQueue().remainingCapacity();
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;p&gt;通过上面的代码可知，在运行过程中我们也是可以操作&lt;code&gt;coreSize&lt;/code&gt;和&lt;code&gt;maxSize&lt;/code&gt;的。那么如何才能实现对Queue的大小进行控制呢？目前开源届常用的是采取&lt;code&gt;RabbitMQ&lt;/code&gt;中的&lt;a href=&#34;https://github.com/rabbitmq/rabbitmq-java-client/blob/main/src/main/java/com/rabbitmq/client/impl/VariableLinkedBlockingQueue.java&#34;&gt;&lt;code&gt;VariableLinkedBlockingQueue&lt;/code&gt;&lt;/a&gt;来实现。&lt;/p&gt;
">ThreadPoolExecutor “非常用” 方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/rocketmq-client-qi-dong-yi-chang-jie-jue/"" data-c="
          &lt;h2 id=&#34;现象&#34;&gt;现象&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rocketmq-common-4.9.3&lt;/code&gt; 版本作为客户端消费数据时，从&lt;code&gt;MessageExt.getMsgId()&lt;/code&gt;获取消息ID时，会存在一个潜在的依赖冲突问题，最终导致方法执行失败，如下图：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1701179903562.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;从现象来看，&lt;code&gt;Could not initialize class org.apache.rocketmq.common.message.MessageClientIDSetter&lt;/code&gt; 表示 &lt;code&gt;MessageClientIDSetter&lt;/code&gt;类为正确被加载，通过搜索类似的资料找到了以下文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/rocketmq/issues/6264&#34;&gt;Client dependency conflict, cause NoClassDefFoundError. Require for shaded client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.51cto.com/u_15127641/2875028&#34;&gt;记一次RocketMQ消息消费异常&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从51cto的文章来看，基本可以分析出是&lt;code&gt;MessageClientIDSetter&lt;/code&gt;的静态代码块在执行时异常导致类加载器加载类失败。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
        byte[] ip;
        try {
            // 执行异常，导致`MessageClientIDSetter`未成功被类加载器加载
            ip = UtilAll.getIP();
        } catch (Exception e) {
            ip = createFakeIP();
        }
        LEN = ip.length + 2 + 4 + 4 + 2;
        ByteBuffer tempBuffer = ByteBuffer.allocate(ip.length + 2 + 4);
        tempBuffer.put(ip);
        tempBuffer.putShort((short) UtilAll.getPid());
        tempBuffer.putInt(MessageClientIDSetter.class.getClassLoader().hashCode());
        FIX_STRING = UtilAll.bytes2string(tempBuffer.array()).toCharArray();
        setStartTime(System.currentTimeMillis());
        COUNTER = new AtomicInteger(0);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;从上面的博客中已经可以得到结论是依赖冲突造成的，但问题是部分服务会出现，大多数服务不会出现，&lt;strong&gt;通过往深层次分析得出结论&lt;/strong&gt;：&lt;br&gt;
&lt;code&gt;rocketmq-acl&lt;/code&gt; &lt;code&gt;rocketmq-client&lt;/code&gt; 均依赖于 &lt;code&gt;commons-validator-1.7&lt;/code&gt; 版本，而项目中如果有类似于 &lt;code&gt;aliyun-log-appender&lt;/code&gt; 老版本的依赖，会传递依赖于旧版本的 &lt;code&gt; commons-validator&lt;/code&gt; ，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1701179052568.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;Maven在遇到依赖冲突时，首先会采用&lt;strong&gt;就近原则&lt;/strong&gt;，上图中第一个传递依赖有&lt;strong&gt;5&lt;/strong&gt;个层级，而下一个传递依赖只有&lt;strong&gt;4&lt;/strong&gt;个层级，所以就近取到了&lt;strong&gt;错误的1.4.0版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其它的服务更多是单模块项目，直接依赖于RocketMQ的client代码，而出现问题的服务是一个多模块依赖关系的服务，最终依赖传递了3层，导致依赖链路变长，最终优先依赖了链路更近的由 &lt;code&gt;log-appender&lt;/code&gt; 引入进来的 &lt;code&gt;1.4.0&lt;/code&gt; 版本。&lt;/p&gt;
&lt;p&gt;相关文章： &lt;a href=&#34;https://returnac.cn/pages/JAVA/maven/Maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97.html#%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6&#34;&gt;Maven依赖冲突避坑指北&lt;/a&gt;&lt;/p&gt;
">RocketMQ Client 启动异常解决</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/hash-chong-tu-jie-jue-fang-fa/"" data-c="
          &lt;h1 id=&#34;什么是hash冲突&#34;&gt;什么是hash冲突？&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;hash冲突就是在操作哈希表（散列表）的时候，不同的key值经过hash函数（散列算法）之后得到相同的hash值，那么&lt;strong&gt;一个位置没法放置两份value&lt;/strong&gt;，这种情况就是hash冲突。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;hash冲突常用解决方法&#34;&gt;Hash冲突常用解决方法&lt;/h1&gt;
&lt;h2 id=&#34;开放地址法open-addressing&#34;&gt;开放地址法（open addressing）&lt;/h2&gt;
&lt;p&gt;简单来说就是通过计算出来冲突的hash值进行再次的运算，直到得到可用的地址，主要有以下3种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线性探测再散列：发生冲突时，顺序查看哈希表下一单元是否可用，直到找到可用的单元&lt;/li&gt;
&lt;li&gt;二次探测再散列：发生冲突时，以冲突的位置为中心向左右探测是否有可用单元&lt;/li&gt;
&lt;li&gt;伪随机探测再散列：通过一组伪随机数列计算得到对应的单位位置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;单独链表法&#34;&gt;单独链表法&lt;/h2&gt;
&lt;p&gt;就是在哈希表中，针对相同的hash值使用链表的方式来存放&lt;/p&gt;
&lt;h2 id=&#34;再hash&#34;&gt;再Hash&lt;/h2&gt;
&lt;p&gt;提供多个hash函数，冲突时使用其他的hash函数再次运算&lt;/p&gt;
&lt;h2 id=&#34;建立公共溢出区&#34;&gt;建立公共溢出区&lt;/h2&gt;
&lt;p&gt;建立一个溢出表，hash冲突的时候放入溢出表&lt;/p&gt;
&lt;h1 id=&#34;java中hashmap如何解决冲突&#34;&gt;Java中HashMap如何解决冲突&lt;/h1&gt;
&lt;p&gt;其实，Java中的HashMap采用的hash冲突解决方案就是单独链表法，也就是在hash表节点使用链表存储hash值相同的值&lt;/p&gt;
&lt;p&gt;不过需要知道的是JDK8之后，如果链表长度超过8将会将链表转化为红黑树以便提高在hash冲突严重情况下的查询效率，也能够避免一定的hash碰撞攻击。&lt;/p&gt;
">Hash冲突解决方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/chrome-guan-bi-di-zhi-lan-sou-suo-li-shi/"" data-c="
          &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Chrome flag&lt;br&gt;
&lt;code&gt;chrome://flags/&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Omnibox Zero Prefix Suggestion Prefetching on NTP
Enables prefetching of the zero prefix suggestions for eligible users on the New Tab page. – Mac, Windows, Linux, ChromeOS, Android, Fuchsia, Lacros
#omnibox-zero-suggest-prefetching
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1701010760712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;DISABLE&lt;/li&gt;
&lt;/ol&gt;
">Chrome关闭地址栏搜索历史</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-zhong-shi-yong-dao-de-she-ji-mo-shi/"" data-c="
          &lt;p&gt;设计模式的基本原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开闭原则&lt;/li&gt;
&lt;li&gt;单一职责原则&lt;/li&gt;
&lt;li&gt;里氏替换原则&lt;/li&gt;
&lt;li&gt;依赖倒置原则&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Spring中用到的模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HandlerAdapter，适配器模式&lt;/li&gt;
&lt;li&gt;BeanFactory，简单工厂模式&lt;/li&gt;
&lt;li&gt;FactoryBean，工厂方法模式&lt;/li&gt;
&lt;li&gt;Controller的单例模式，也可以是原型模式&lt;/li&gt;
&lt;li&gt;Service@Transactional，代理模式&lt;/li&gt;
&lt;li&gt;@EventListener，观察者模式&lt;/li&gt;
&lt;li&gt;JdbcTemplate，RestTemplate，模板方法模式&lt;/li&gt;
&lt;li&gt;TransactionAwareCacheDecorator，装饰器模式&lt;/li&gt;
&lt;li&gt;AopProxy，策略模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他在业务中常用的模式：&lt;/p&gt;
&lt;h3 id=&#34;业务中涉及的模式&#34;&gt;业务中涉及的模式：&lt;/h3&gt;
&lt;p&gt;策略模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同数据的不同处理结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;观察者模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件监听和分发（不同处理类型）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;门面模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同活动的不同参数，统一门面，采用Jackson的类型映射子类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;状态模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支付的不同状态，通过事件和状态流转&lt;/li&gt;
&lt;/ul&gt;
">Spring中使用到的设计模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/rocketmq-xiao-xi-cun-chu-guo-cheng/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;讲完了消息的生产过程，接下来记录一下消息发送到&lt;code&gt;Broker&lt;/code&gt;后如何存储和分发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;首先看下RocketMQ Broker的消息存储目录结构，RocketMQ的消息存储在本地文件系统中，默认在当前用户主目录下的&lt;code&gt;store&lt;/code&gt;目录中：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1700059028911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;abort：该文件在Broker启动后自动创建，正常关闭自动消息，如果没有启动Broker的情况下看到此文件表示上次Broker是非正常关闭的&lt;/li&gt;
&lt;li&gt;checkpoint：存储着&lt;code&gt;commitlog&lt;/code&gt;,&lt;code&gt;consumequeue&lt;/code&gt;,&lt;code&gt;index&lt;/code&gt;文件的最后刷盘时间&lt;/li&gt;
&lt;li&gt;commitlog：存放&lt;code&gt;commitlog&lt;/code&gt;文件，消息就是存储在其中&lt;/li&gt;
&lt;li&gt;consumerqueue：存放&lt;code&gt;consumequeue&lt;/code&gt;文件，队列就是存放在其中&lt;/li&gt;
&lt;li&gt;index：存放消息索引文件，支持根据&lt;code&gt;key&lt;/code&gt;查询的依据&lt;/li&gt;
&lt;li&gt;lock：运行期间使用到的全局资源锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;消息存储&#34;&gt;消息存储&lt;/h1&gt;
&lt;h2 id=&#34;如何保证高性能读写&#34;&gt;如何保证高性能读写&lt;/h2&gt;
&lt;p&gt;传统的IO读写方式，存在多次上下文切换和多次数据的拷贝，在并发极高的MQ场景下，会严重影响读写效率。所以为了减少内核态&amp;lt;=&amp;gt;用户态切换，减少数据拷贝次数，引入了&lt;strong&gt;零拷贝&lt;/strong&gt;技术。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1699977065073.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;零拷贝&#34;&gt;零拷贝&lt;/h2&gt;
&lt;p&gt;零拷贝是一种思想，指的是CPU不需要先将数据从某处内存复制到另一个特定区域，实现零拷贝的方式有以下几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mmap()&lt;/li&gt;
&lt;li&gt;sendfile()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mmap&#34;&gt;mmap()&lt;/h3&gt;
&lt;p&gt;mmap(memory map) 是一种内存映射方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。&lt;br&gt;
对应上图中&lt;code&gt;内核缓冲区-&amp;gt;用户缓冲区-&amp;gt;Socket缓冲区&lt;/code&gt;的过程直接变成了&lt;code&gt;内核缓冲区-(CPU拷贝)-&amp;gt;Socket缓冲区&lt;/code&gt;，减少了一次拷贝所需的时间。&lt;br&gt;
但整个过程中，上下文切换依旧是&lt;strong&gt;4次&lt;/strong&gt;，相比于传统IO没有提升，切换过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当用户发起mmap调用的时候会发生上下文切换1，进行内存映射；&lt;/li&gt;
&lt;li&gt;然后数据被拷贝到内核缓冲区，mmap返回，发生上下文切换2；&lt;/li&gt;
&lt;li&gt;随后用户调用write，发生上下文切换3；&lt;/li&gt;
&lt;li&gt;将内核缓冲区的数据拷贝到Socket缓冲区，write返回，发生上下文切换4。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1700059059450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;FileChannel fileChannel = 
new RandomAccessFile(&amp;quot;mmap_test.txt&amp;quot;, &amp;quot;rw&amp;quot;).getChannel(); 
MappedByteBuffer mappedByteBuffer = 
fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileChannel.size());
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sendfile&#34;&gt;sendfile()&lt;/h3&gt;
&lt;p&gt;sendfile()和mmap()一样可以减少一次CPU拷贝，但它可以减少2次上下文切换，切换过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户发起sendfile()调用时会发生切换1，之后数据通过DMA拷贝到内核缓冲区&lt;/li&gt;
&lt;li&gt;之后再将内核缓冲区的数据CPU拷贝到Socket缓冲区，最后拷贝到网卡，sendfile()返回，发生切换2。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1700059065166.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//调用transferTo方法向目标数据传输 
FileChannel channel = FileChannel.open(Paths.get(&amp;quot;./test.txt&amp;quot;),
 StandardOpenOption.WRITE, StandardOpenOption.CREATE); 

channel.transferTo(position, len, target);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;commitlogmappedfile&#34;&gt;commitlog（mappedFile）&lt;/h1&gt;
&lt;h2 id=&#34;目录与文件&#34;&gt;目录与文件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;真正存储消息，&lt;strong&gt;一个Broker只有一个&lt;code&gt;commitlog&lt;/code&gt;目录，所有Topic的消息都存放于此。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mappedFile大小1G，文件名由20位十进制数组成，&lt;strong&gt;表示当前文件的第一条消息的起始位置偏移量。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个文件名一定是20位0构成，第一条消息的偏移量commitlog offset为0.&lt;/li&gt;
&lt;li&gt;当第一个文件放满时，会自动生成第二个文件继续存放消息，假设第一个&lt;code&gt;1073741820&lt;/code&gt;字节（1G=1073741824字节），最后只剩4字节不够存放下一条数据。则下一个文件名为&lt;code&gt;00000000001073741824&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息单元&#34;&gt;消息单元&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1700059080546.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;consumequeue&#34;&gt;consumequeue&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;存储topic消息在commitlog的位置索引。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了提高效率，会为每个topic在&lt;code&gt;~/store/consumequeue&lt;/code&gt;中创建一个目录&lt;code&gt;{TopicId}/{QueueId}&lt;/code&gt;，&lt;code&gt;consumequeue&lt;/code&gt;文件是&lt;code&gt;commitlog&lt;/code&gt;的索引文件，可以根据&lt;code&gt;consumequeue&lt;/code&gt;定位到具体的消息在&lt;code&gt;commitlog&lt;/code&gt;中的位置。&lt;/p&gt;
&lt;p&gt;consumequeue文件名也是由20位数字组成，&lt;strong&gt;表示当前文件的第一个索引条目的起始位置偏移量&lt;/strong&gt;，与mappedFile文件不同的是，其后续的文件名也是固定的，因为consumequeue文件大小是固定不变的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;每个consumequeue文件可以包含30w&lt;/code&gt;个索引条目，其中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息在mappedFile文件中的偏移量&lt;code&gt;commitlog offset&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消息长度&lt;/li&gt;
&lt;li&gt;消息Tag的hashcode值&lt;br&gt;
这三个属性占用20个字节，所以每个文件的大小是固定的30w * 20字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://imyzt.top/post-images/1700059143933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1700059149125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;对文件的读写&#34;&gt;对文件的读写&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1700059156240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;消息写入&#34;&gt;消息写入&lt;/h2&gt;
&lt;p&gt;一条消息进入到Broker后经历了以下几个过程才最终被持久化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即QueueOffset&lt;/li&gt;
&lt;li&gt;将queueId、queueOffset等数据，与消息一起封装为消息单元&lt;/li&gt;
&lt;li&gt;将消息单元写入到commitlog&lt;/li&gt;
&lt;li&gt;形成消息索引条目&lt;/li&gt;
&lt;li&gt;将消息索引条目分发到相应的consumequeue&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息拉取&#34;&gt;消息拉取&lt;/h2&gt;
&lt;p&gt;当Consumer来拉取消息时会经历以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Consumer获取到其要消费消息所在Queue的&lt;code&gt;消费偏移量offset&lt;/code&gt;，计算出其要消费消息的&lt;code&gt;消费offset&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;消费offset即消费进度，consumer对某个queue的消费offset，即消费到了该queue的第几条消息&lt;br&gt;
消息offset = 消费offset + 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Consumer向Broker发送拉取请求，其中会包含其要拉取消息的Queue、消息offset及消息Tag&lt;/li&gt;
&lt;li&gt;Broker计算在该consumequeue中的queueOffset&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;queueOffset = 消息offset * 20字节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;从该queueOffset处开始向后查找第一个指定Tag的索引条目&lt;/li&gt;
&lt;li&gt;解析该索引条目的&lt;code&gt;前8个字节&lt;/code&gt;，即可定位到该消息在commitlog中的commitlog offset&lt;/li&gt;
&lt;li&gt;从对应commitlog offset中读取消息单元，并发送给Consumer&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;刷盘机制&#34;&gt;刷盘机制&lt;/h1&gt;
&lt;p&gt;RocketMQ消息写入到Commitlog文件中时并不是直接写入到文件，而是先写到PageCache中，也就是前面IO图中的内核缓冲区，所以RocketMQ也和MySQL等类似的log刷盘机制&lt;/p&gt;
&lt;h2 id=&#34;异步刷盘&#34;&gt;异步刷盘&lt;/h2&gt;
&lt;p&gt;写入到PageCache后直接返回生产者消息存储成功，另外的后台线程在将消息刷到磁盘。其提供了2套刷盘机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定时间，默认每隔0.5s会刷一次【默认方式】&lt;/li&gt;
&lt;li&gt;每存一次会通知刷盘，但不会等待结果，同时如果0.5s没有收到通知，也会主动刷盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同步刷盘&#34;&gt;同步刷盘&lt;/h2&gt;
&lt;p&gt;同步刷盘机制很好理解，即每次一定等写入成功磁盘才会返回生产者写入成功，此方式可靠性更高，但会一定程度上影响系统吞吐量。&lt;/p&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;p&gt;本文参考：&lt;br&gt;
&lt;a href=&#34;https://juejin.cn/post/7186880907582636069&#34;&gt;https://juejin.cn/post/7186880907582636069&lt;/a&gt;&lt;/p&gt;
">RocketMQ消息存储过程</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-shi-xian-jian-dan-dan-ji-shi-jian-lun-fang-an/"" data-c="
          &lt;p&gt;时间轮的使用场景自不必多说，最近研究RocketMQ 5.0时，想简单写一个活跃下思路，遂写了下面的方案（没有参照任何代码，没有优化），主要做下记录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package top.imyzt.learning.algorithm.timer;

import lombok.Getter;
import lombok.Setter;
import lombok.SneakyThrows;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * 简易单机时间轮
 * @author imyzt
 * @date 2023-11-13 22:03
 */
public class SingleTimingWheel {

    public static void main(String[] args) throws InterruptedException {

        TimingWheel timingWheel = new TimingWheel(60);
        TimingWheel timingWheel2 = new TimingWheel(12);

        while (true) {
            System.out.print(&amp;quot;请输入延时周期: &amp;quot;);
            Scanner scanner = new Scanner(System.in);
            String next = scanner.next();
            if (&amp;quot;exit&amp;quot;.equals(next)) {
                timingWheel.shutdown();
                timingWheel2.shutdown();
                break;
            }

            String[] splits = next.split(&amp;quot;,&amp;quot;);

            for (String split : splits) {
                int delayTime = Integer.parseInt(split);
                System.out.println(&amp;quot;新生产一个任务, 延迟&amp;quot; + delayTime + &amp;quot;秒后执行&amp;quot; + &amp;quot;, 当前时间: &amp;quot; +
                        LocalDateTime.now() + &amp;quot;, 预计执行时间: &amp;quot; + LocalDateTime.now().plusSeconds(delayTime)
                );
                Task task = new Task(() -&amp;gt; Thread.currentThread().getName(), delayTime);
                timingWheel.addTask(task);
                timingWheel2.addTask(task);
            }
        }

        TimeUnit.SECONDS.sleep(1);
        System.exit(0);
    }
}

class TimingWheel {

    private final ExecutorService EXECUTOR_TASK_POOL;
    private final ScheduledExecutorService SCHEDULED_TASK_POOL;
    /**
     * 时间轮周期
     */
    private final int timer;

    /**
     * 记录每个刻度的任务
     */
    private final List&amp;lt;LinkedList&amp;lt;Task&amp;gt;&amp;gt; secondWheel;

    /**
     * 刻度计数器
     */
    private final AtomicInteger secondAtomic;

    /**
     * 任务队列
     */
    private final Queue&amp;lt;Task&amp;gt; taskQueue;

    /**
     * 运行标记
     */
    private boolean flag;

    public TimingWheel(int timer) {
        this.timer = timer;
        this.secondWheel = IntStream.range(0, timer).mapToObj(d -&amp;gt; new LinkedList&amp;lt;Task&amp;gt;()).collect(Collectors.toList());
        this.secondAtomic = new AtomicInteger(0);
        this.taskQueue = new LinkedBlockingQueue&amp;lt;&amp;gt;();
        this.EXECUTOR_TASK_POOL = Executors.newSingleThreadExecutor();
        this.SCHEDULED_TASK_POOL = Executors.newSingleThreadScheduledExecutor();
        this.flag = true;
        this.init();
    }

    public void addTask(Task task) {

        int delayTime = task.getDelayTime();
        int targetRunSecond = delayTime + secondAtomic.get();
        int cycle = delayTime / timer;
        int index = targetRunSecond % timer;
        task.setCycle(cycle);

        System.out.printf(&amp;quot;任务id: %s, 当前刻度: %s, cycle: %s, 计划执行刻度: %s \n&amp;quot;, task.getTaskId(), secondAtomic.get(), cycle, index);

        LinkedList&amp;lt;Task&amp;gt; tasks = secondWheel.get(index);
        if (tasks == null) {
            tasks = new LinkedList&amp;lt;&amp;gt;();
        }
        tasks.add(task);
    }

    public void shutdown() {
        EXECUTOR_TASK_POOL.shutdown();
        SCHEDULED_TASK_POOL.shutdown();
        this.flag = false;
        System.out.println(&amp;quot;[&amp;quot; + timer + &amp;quot;]shutdown...&amp;quot;);
    }

    @SneakyThrows
    private void init () {
        SCHEDULED_TASK_POOL.scheduleAtFixedRate(() -&amp;gt; {
            int second = secondAtomic.getAndAdd(1);
            if (second + 1 == timer) {
                secondAtomic.set(0);
            }
            LinkedList&amp;lt;Task&amp;gt; tasks = secondWheel.get(second);
            if (tasks != null &amp;amp;&amp;amp; !tasks.isEmpty()) {
                Iterator&amp;lt;Task&amp;gt; iterator = tasks.iterator();
                while (iterator.hasNext()) {
                    Task task = iterator.next();

                    Integer taskCycle = task.getCycle();
                    if (taskCycle != 0) {
                        task.setCycle(taskCycle - 1);
                        System.out.println(task.getTaskId() + &amp;quot;还未到时间, 当前周期&amp;quot; + taskCycle);
                        continue;
                    }

                    taskQueue.add(task);
                    // 从队列中剔除
                    iterator.remove();
                }
            }
        }, 0, 1, TimeUnit.SECONDS);

        EXECUTOR_TASK_POOL.execute(() -&amp;gt; {
            while (flag) {
                Task task = taskQueue.poll();
                if (task != null) {
                    System.out.println(LocalDateTime.now() + &amp;quot;, [&amp;quot; + timer + &amp;quot;]时间轮调度任务====&amp;gt;&amp;quot; + task);
                }
            }
        });
    }

}

@Getter
class Task {

    private final Integer taskId;

    /**
     * 执行任务
     */
    private final Supplier&amp;lt;String&amp;gt; runner;

    /**
     * 当前第几轮
     */
    @Setter
    private  Integer cycle;

    private final Integer delayTime;

    /**
     * 创建时间
     */
    private final LocalDateTime createdAt;

    /**
     * 理应执行时间
     */
    private final LocalDateTime runnerTime;

    public Task(Supplier&amp;lt;String&amp;gt; runner,  Integer delayTime) {
        this.taskId = new Random().nextInt() * 10000;
        this.runner = runner;
        this.delayTime = delayTime;
        this.createdAt = LocalDateTime.now();
        this.runnerTime = this.createdAt.plusSeconds(delayTime);
    }

    @Override
    public String toString() {
        return &amp;quot;Task{&amp;quot; +
                &amp;quot;taskId=&amp;quot; + taskId +
                &amp;quot;, runner=&amp;quot; + runner.get() +
                &amp;quot;, cycle=&amp;quot; + cycle +
                &amp;quot;, delayTime=&amp;quot; + delayTime +
                &amp;quot;, createdAt=&amp;quot; + createdAt +
                &amp;quot;, runnerTime=&amp;quot; + runnerTime +
                &#39;}&#39;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
">Java 实现简单单机时间轮方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/rocketmq-xiao-xi-sheng-chan-ji-ben-liu-cheng/"" data-c="
          &lt;p&gt;RocketMQ 相较于 RabbitMQ、Kafka 能够集成两者的不少优点（原生的延迟消息、支持事务消息、能够支撑较大流量），加之Java技术架构，所以已作为目前队列选型调研时的第一选择，本文主要以图解形式讲明白RocketMQ一条消息的基本流程。&lt;/p&gt;
&lt;h2 id=&#34;核心概念&#34;&gt;核心概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;NameServer：注册中心，用于保存Topic的路由信息、管理Broker的存活状态；NameServer一般是多节点部署的，多个NameServer之间互不通信。&lt;/li&gt;
&lt;li&gt;Broker：用于存储消息，在启动时会向NameServer注册自己的地址信息，启动后每30s向NameServer心跳报告健康状态；Broker实例可以有多个，相同的BrokerName为一组Broker，每个Broker组只保存一部分信息。&lt;/li&gt;
&lt;li&gt;Topic：消息的主题，一个Topic的消息可以分布在不同的Broker组下。&lt;/li&gt;
&lt;li&gt;Queue：一个Topic可以有很多Queue，默认一个Topic在同一个Broker组下是4个，如果一个Topic在2个Broker组中，则有可能是8个Queue。&lt;strong&gt;一个Queue只能被一个Consumer消费，一个Consumer可以同时消费多个Queue。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Producer：消息的生产者、可以成组出现（Producer Group）。&lt;/li&gt;
&lt;li&gt;Consumer：消息的消费者，可以成组出现（Consumer Group）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nameserver&#34;&gt;NameServer&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;NameServer是Broker和Topic路由的注册中心，支持Broker的动态注册与发现。&lt;br&gt;
主要包含2个功能：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Broker管理：接受Broker集群的注册信息并且保存下来作为消息路由信息的基本数据，提供心跳监测机制，检查Broker是否还存活。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1699778210047.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路由信息管理：每个NameServer都保存着Broker集群的整个路由信息和用于客户端查询的队列信息，Producer和Consumer可以通过NameServer获得整个Broker集群的路由信息，从而进行消息的投递和消费。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注册流程：&lt;/strong&gt;&lt;br&gt;
NameServer每个节点之间是不通信的，每个Broker在启动时，会给所有NameServer注册自己的信息，&lt;code&gt;每30秒心跳&lt;/code&gt;上报自己的信息（BrokerId、Broker地址、名称、所属集群名称等信息），NameServer收到后会更新Broker的最新存活时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优缺点：&lt;/strong&gt;&lt;br&gt;
优点：NameServer集群搭建简单，随意启动即可（因为互不通信）&lt;br&gt;
缺点：简单增加节点无效，Broker无法感知新NameServer不会向他注册信息和心跳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由剔除：&lt;/strong&gt;&lt;br&gt;
NameServer定时任务&lt;code&gt;每10秒&lt;/code&gt;扫描一次Broker列表，当Broker最新心跳时间戳距离当前时间&lt;code&gt;超过120秒&lt;/code&gt;，则将Broker从列表中剔除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运维方案：&lt;/strong&gt;&lt;br&gt;
当需要升级RocketMQ集群时，可以依次将每个节点对外关闭读写权限。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Producer发送到Broker会收到无权读写而切换另一个Broker投递消息。&lt;/li&gt;
&lt;li&gt;超过120秒不心跳，NameServer会自动将此Broker下线。&lt;/li&gt;
&lt;li&gt;Producer每30秒会从NameServer拉取Broker信息，当NameServer记录为下线后此Broker也不会再有Producer进行消息投递。然后再关闭升级此Broker即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;路由发现：&lt;/strong&gt;&lt;br&gt;
当Topic路由信息变化时，NameServer不会推送而是等客户端每30秒拉取一次最新的路由信息。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1699778321090.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端（Producer）NameServer选择策略：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先采用&lt;code&gt;随机策略&lt;/code&gt;, 然后采用&lt;code&gt;轮询策略&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生成一个随机数，从配置的NameServer集群地址中根据数量取模然后连接，如果连接失败会切换为轮询逐个连接其他节点。&lt;/p&gt;
&lt;p&gt;扩展：zk client如何选择zk server?&lt;br&gt;
经过两次Shuffle，然后选择第一台ZK Server。&lt;br&gt;
将配置文件中的zk server地址进行第一次shuffle，然后随机选择一个，这个选择出的一般都是hostname，然后获取到该hostname对应的所有IP，再对这些ip进行第二次shuffle。&lt;/p&gt;
&lt;h2 id=&#34;broker&#34;&gt;Broker&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Broker充当着消息中转角色，负责存储消息、转发消息。&lt;br&gt;
Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息。同时为消费者的拉取请求做准备。&lt;br&gt;
Broker同时存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;一个Topic存储在不同的Broker中，按Queue轮询存放，一个Queue在Master/Slave中存储多份做主备集群。&lt;br&gt;
Broker节点集群是主从集群，Broker集群是主备集群。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Remoting Module: 整个Broker的实体，负责处理来自clients的请求，由以下模块构成。&lt;/li&gt;
&lt;li&gt;Client Manager：客户端管理器，负责接受、解析来自客户端（Producer、Consumer）请求，管理客户端，比如维护Consumer的Topic订阅关系。&lt;/li&gt;
&lt;li&gt;Store Service：存储服务，处理&lt;code&gt;消息存储到物理硬盘&lt;/code&gt;和&lt;code&gt;消息查询&lt;/code&gt;功能。&lt;/li&gt;
&lt;li&gt;HA Service： 高可用服务，提供&lt;code&gt;Master Broker&lt;/code&gt;和&lt;code&gt;Slave Broker&lt;/code&gt;之间的数据同步功能。&lt;/li&gt;
&lt;li&gt;Index Service: 索引服务，根据特定的&lt;code&gt;Message Key&lt;/code&gt;，对投递到Broker的消息进行索引服务，同时提供根据 &lt;code&gt;Message Key&lt;/code&gt; 对消息进行快速查询的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息的生产和发送&#34;&gt;消息的生产和发送&lt;/h2&gt;
&lt;p&gt;通过上面的流程，我们知道了NameServer和Broker的交互流程，Producer启动时，只指向了NameServer，并不知道Broker的信息。那么一条消息从Producer生产后，是如何投递到哪个Broker的哪个Queue上面的呢？&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1699778590005.png&#34; alt=&#34;queue select&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;针对这种情况，RocketMQ采用了2种Queue选择算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮询算法&lt;/li&gt;
&lt;li&gt;最小投递延迟算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Producer可以将消息写入到某个Broker中的Queue中，过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Producer发送消息前，会向获取NameServer获取Topic的路由信息&lt;/li&gt;
&lt;li&gt;NameServer返回该Topic的&lt;code&gt;路由表&lt;/code&gt;和&lt;code&gt;Broker列表&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Producer根据代码中指定的Queue选择策略，从Queue列表中选择一个队列&lt;/li&gt;
&lt;li&gt;Producer对消息做处理，比如超过4M会进行压缩&lt;/li&gt;
&lt;li&gt;Producer向选择出的Queue所在的broker发送RPC请求，将消息发送到选择出的Queue中&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;路由表：一个Map，Key为QueueData实例列表，QueueData并不是一个queue对应一个queueData，而是一个Broker中该Topic所有的QueueData对应一个QueueData。即只要涉及到该Topic的Broker，一个Broker对应一个QueueData。&lt;br&gt;
路由表的key为Topic名称，value则为所有涉及该Topic的brokerName列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由表(一个Topic分散在哪些Broker上面，方便消费者和生产者连接Queue)：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Map&amp;lt;TopicName, List&amp;lt;BrokerName&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Broker列表：一个Map，Key为BrokerName，Value为BrokerData，一个Broker对应一个BrokerData实例，一套BrokerName名称相同的Master-Slave小集群对应一个BrokerData&lt;br&gt;
BrokerData中包含一个Map，key为brokerId，value为该broker对应的地址，&lt;code&gt;brokerId=0表示master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Broker列表(一个集群中Broker的分布，方便消费者和生产者连接Broker)：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Map&amp;lt;BrokerName, Map&amp;lt;brokerId, brokerAddress&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于无序消息的Queue选择算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮询算法&lt;br&gt;
默认选择方法，保证每个Queue都均匀获得消息&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;问题：当Broker出问题时，此Broker上的Queue投递延迟严重时，会造成producer消息堆积。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;最小投递延迟算法&lt;br&gt;
统计每次消息投递的延迟，统计处投递延迟最小的Queue，如果延迟相同则选用轮询算法&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;问题：Queue上的消息分配不均，投递延迟小的Queue会存在大量消息，&lt;strong&gt;导致对应Queue的消费者要处理的消息很大。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">RocketMQ消息生产基本流程</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/fastjson-xu-lie-hua-fan-xu-lie-hua-tuo-feng-he-xia-hua-xian-hu-zhuan/"" data-c="
          &lt;p&gt;在部分场景下，只需要简单将外部对象转换为标准JavaBean，而对接的外部是下划线命名时，如果需要一个个写&lt;code&gt;JSONField&lt;/code&gt;必然是比较麻烦的，可以通过FastJSON提供的序列化/反序列化配置类来快速实现。&lt;/p&gt;
&lt;p&gt;JSON是下划线，Bean是驼峰时：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ParserConfig parserConfig = new ParserConfig();
parserConfig.propertyNamingStrategy = PropertyNamingStrategy.CamelCase;
BytedanceClueLog bytedanceClueLog = clueJson.toJavaObject(BytedanceClueLog.class, parserConfig, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bean是驼峰，需要将JSON转为下划线时：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SerializeConfig serializeConfig = new SerializeConfig();
serializeConfig.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;
return JSON.toJSONString(req, serializeConfig);
&lt;/code&gt;&lt;/pre&gt;
">FastJSON 序列化反序列化驼峰和下划线互转</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/tong-guo-spring-gong-ju-lei-fu-lei-huo-qu-zi-lei-fan-xing-duo-tai-fan-xing-chuan-can/"" data-c="
          &lt;p&gt;在平时需要写抽象策略处理器时，希望传给处理器执行器的对象是泛型，避免每个子类都写强制类型转换的代码，通常需要获取子类的泛型，然后才能够避免写&lt;code&gt;@SuppressWarnings&lt;/code&gt;，可以通过如下工具类在&lt;code&gt;Abstract&lt;/code&gt;类上面获取到子类泛型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ResolvableType[] generics = ResolvableType.forClass(this.getClass()).getSuperType().getGenerics();
// generics[0]是第一个泛型
T o = (T) generalResult.toJavaObject(generics[0].resolve());
&lt;/code&gt;&lt;/pre&gt;
">通过Spring工具类，父类获取子类泛型（多态泛型传参）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-zi-fu-ji-bu-tong-zhuan-huan-zi-fu-ji-he-pai-xu-gui-ze/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 转换编码不一致的情况
cast(ldr.id as char character set utf8)
CONVERT(CAST(bpr.id AS char) USING utf8)
--转换排序规则也不一致的情况
convert(cl.app_id using utf8mb4) collate utf8mb4_unicode_ci
&lt;/code&gt;&lt;/pre&gt;
">MySQL字符集不同转换字符集和排序规则</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/go-xin-te-xing-qian-xi-fan-xing/"" data-c="
          &lt;p&gt;Golang在1.18时才支持了泛型，为此新增了两个操作符，&lt;code&gt;|&lt;/code&gt;和&lt;code&gt;~&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;~ T： 表示底层类型是T，比如 ~string表示所有基于string创建的自定义类型。&lt;br&gt;
T1 | T2 |...： 代表&lt;code&gt;或&lt;/code&gt;，类型列表之一。&lt;/p&gt;
&lt;p&gt;Go的泛型有别于其它语言的方案，在Go语言中泛型叫做Type Parameter(类型参数).&lt;/p&gt;
&lt;p&gt;Golang的泛型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1.18才有&lt;/li&gt;
&lt;li&gt;只能用在方法上,无法使用在结构体上&lt;/li&gt;
&lt;li&gt;泛型下边界需要在类型上使用 &lt;code&gt;~&lt;/code&gt; 表达式&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;泛型的示例&#34;&gt;泛型的示例&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;type myStr string

type customType interface {
	float32 | float64 | int | int8 | int32 | int16 | int64 | uint | uint8 | uint32 | uint16 | uint64 | ~string
}

func min[T customType](a, b T) T {
	if a &amp;gt; b {
		return b
	}
	return a
}

func main() {

    // 泛型
    fmt.Println(min(1, 2))
    fmt.Println(min(1.1, 2.2))
    fmt.Println(min(&amp;quot;3&amp;quot;, &amp;quot;2&amp;quot;))
    
    // 自定义类型泛型
    num1 := myStr(&amp;quot;33&amp;quot;)
    num2 := myStr(&amp;quot;344&amp;quot;)
    fmt.Println(min(num1, num2))
    
}
&lt;/code&gt;&lt;/pre&gt;
">go 新特性浅析（泛型）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/lao-ban-ben-ikbc-c87-winoptionzai-mac-wu-fa-shi-yong-wen-ti-jie-jue-fang-an/"" data-c="
          &lt;h1 id=&#34;解决方案&#34;&gt;解决方案&lt;/h1&gt;
&lt;p&gt;按住Fn+Del恢复出厂设置，option生效。IDEA跳单词问题解决！&lt;/p&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;p&gt;配置option与command键盘互换。&lt;/p&gt;
&lt;p&gt;系统偏好设置-键盘-修饰键-配置command与option互换（注意「选择键盘」为USB键盘）。&lt;/p&gt;
">老版本ikbc c87 win(option)在Mac无法使用问题解决方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-explain-xiang-jie/"" data-c="
          &lt;p&gt;详细讲解每一列的作用，当做字典查看。&lt;/p&gt;
&lt;h1 id=&#34;前置知识&#34;&gt;前置知识&lt;/h1&gt;
&lt;h2 id=&#34;半连接&#34;&gt;半连接&lt;/h2&gt;
&lt;h2 id=&#34;子查询物化&#34;&gt;子查询物化&lt;/h2&gt;
&lt;h2 id=&#34;索引合并&#34;&gt;索引合并&lt;/h2&gt;
&lt;h1 id=&#34;table&#34;&gt;table&lt;/h1&gt;
&lt;p&gt;无论查询语句中包含多少张表，最终都会转换为对单表的访问，所以EXPLAIN语句输出的每条记录都对应着对单表的访问方法，&lt;strong&gt;也即table列代表着表名&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;普通单表&#34;&gt;普通单表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;普通连接查询&#34;&gt;普通连接查询&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL                                  |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;id&#34;&gt;id&lt;/h1&gt;
&lt;p&gt;查询语句中，为每个select分配一个唯一id，当语句中包含多个select时（union、子查询），id的大小表示不同select的查询先后顺序。&lt;br&gt;
当id相同table不同时（一般出现在连接语句），在前面的表示驱动表，在后面的是被驱动表。&lt;/p&gt;
&lt;h2 id=&#34;普通单id&#34;&gt;普通单id&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 = &#39;a&#39;;
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;复杂连接语句&#34;&gt;复杂连接语句&lt;/h2&gt;
&lt;p&gt;语句中，id相同，s1是驱动表，s2是被驱动表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL                                  |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;语句中，id不同，表示MySQL先查询s1，后查询s2。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select id from s2) or key2 = &#39;b&#39;;
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key2      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where |
|  2 | SUBQUERY    | s2    | NULL       | index | PRIMARY       | idx_key2 | 5       | NULL | 10143 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
2 rows in set, 2 warnings (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;语句优化子查询转连接&#34;&gt;语句优化（子查询转连接）&lt;/h2&gt;
&lt;p&gt;虽然语句属于子查询，理应分配2个id，但是执行计划看出来只有id=1，因为在MySQL优化器将这种明显可以转换为连接查询优化速度的语句改写为连接查询了。&lt;br&gt;
可以通过后面的&lt;code&gt;show warnings ;&lt;/code&gt;语句查看code=1003的优化过程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select id from s2 where key1 = &#39;b&#39;);
+----+-------------+-------+------------+------+------------------+----------+---------+-------+-------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys    | key      | key_len | ref   | rows  | filtered | Extra                                              |
+----+-------------+-------+------------+------+------------------+----------+---------+-------+-------+----------+----------------------------------------------------+
|  1 | SIMPLE      | s2    | NULL       | ref  | PRIMARY,idx_key1 | idx_key1 | 303     | const |     1 |   100.00 | Using index                                        |
|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1         | NULL     | NULL    | NULL  | 10143 |    10.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+------------------+----------+---------+-------+-------+----------+----------------------------------------------------+
2 rows in set, 3 warnings (0.00 sec)

mysql&amp;gt; show warnings ;
| Level   | Code | Message
| Note    | 1003 | select 此处省略一堆查询列节省篇幅 from `xiaohaizi`.`s2` join `xiaohaizi`.`s1` where ((`xiaohaizi`.`s2`.`key1` = &#39;b&#39;) and (`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`id`)) |
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;去重临时表&#34;&gt;去重临时表&lt;/h2&gt;
&lt;p&gt;当语句使用union对结果进行合并时，会使用临时表对结果进行去重。所以生成一个id=null的结果集。&lt;br&gt;
当使用union all时，因为不需要对结果进行去重，故不会产生NULL记录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 union select * from s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL            |
| NULL | UNION RESULT | &amp;lt;union1,2&amp;gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
3 rows in set, 1 warning (0.02 sec)

mysql&amp;gt; mysql&amp;gt; explain select * from s1 union all select * from s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
2 rows in set, 1 warning (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;select_type&#34;&gt;select_type&lt;/h1&gt;
&lt;p&gt;MySQL为每个select关键字代表的小查询都定义了一个名为select_type的属性，只要知道了小查询的select_type属性，也就知道了这个小查询在大查询中的角色。&lt;/p&gt;
&lt;h2 id=&#34;simple&#34;&gt;SIMPLE&lt;/h2&gt;
&lt;p&gt;查询语句中不包含union或者子查询，就是简单的查询就是&lt;code&gt;SIMPLE&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql&amp;gt; explain select * from s1 join s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL                                  |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+
2 rows in set, 1 warning (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;primary&#34;&gt;PRIMARY&lt;/h2&gt;
&lt;p&gt;对于union/union all/或者子查询等大查询来说，是有多个小查询组合而来的，最左边的那个查询就是&lt;code&gt;PRIMARY&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 union all select * from s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+
2 rows in set, 1 warning (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;union&#34;&gt;UNION&lt;/h2&gt;
&lt;p&gt;对于union/union all/或者子查询等大查询来说，是有多个小查询组合而来的，除最左边的那个查询是&lt;code&gt;PRIMARY&lt;/code&gt;外，其余所有小查询都是&lt;code&gt;UNION&lt;/code&gt;，执行计划同上。&lt;/p&gt;
&lt;h2 id=&#34;union-result&#34;&gt;UNION RESULT&lt;/h2&gt;
&lt;p&gt;MySQL选择使用临时表来完成UNION查询的去重工作，针对此临时表select_type就是&lt;code&gt;UNION RESULT&lt;/code&gt;，执行计划同「去重临时表」章节。&lt;/p&gt;
&lt;h2 id=&#34;subquery&#34;&gt;SUBQUERY&lt;/h2&gt;
&lt;p&gt;如果包含子查询的语句&lt;strong&gt;不能转换为对应的半连接形式&lt;/strong&gt;，&lt;strong&gt;并且该子查询是不相关子查询&lt;/strong&gt;，而且查询优化器决定采用&lt;strong&gt;子查询物化&lt;/strong&gt;的方案来执行该子查询时，select_type就是&lt;code&gt;SUBQUERY&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select key2 from s2) or key3 = &#39;b&#39;;
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where |
|  2 | SUBQUERY    | s2    | NULL       | index | idx_key2      | idx_key2 | 5       | NULL | 10143 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
2 rows in set, 1 warning (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dependent-subquery&#34;&gt;DEPENDENT SUBQUERY&lt;/h2&gt;
&lt;p&gt;如果包含子查询的查询语句不能转换为对应的半连接形式，并且该子查询被查询优化器转换为相关子查询的形式，则该子查询的第一个select关键字代表的那个查询的select_type就是&lt;code&gt;DEPENDENT SUBQUERY&lt;/code&gt;。&lt;br&gt;
select_type=&lt;code&gt;DEPENDENT SUBQUERY&lt;/code&gt;的子查询可能会被执行多次。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select key2 from s2 where s1.key2 = s2.key2) or key3 = &#39;b&#39;;
+----+--------------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+--------------------------+
| id | select_type        | table | partitions | type   | possible_keys | key      | key_len | ref               | rows  | filtered | Extra                    |
+----+--------------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+--------------------------+
|  1 | PRIMARY            | s1    | NULL       | ALL    | idx_key3      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where              |
|  2 | DEPENDENT SUBQUERY | s2    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | xiaohaizi.s1.key2 |     1 |   100.00 | Using where; Using index |
+----+--------------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+--------------------------+
2 rows in set, 2 warnings (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dependent-union&#34;&gt;DEPENDENT UNION&lt;/h2&gt;
&lt;p&gt;在包含union或union all的大查询中，如果各个小查询都依赖外层查询，则除了最左边的小查询&lt;code&gt;select_type=DEPENDENT SUBQUERY&lt;/code&gt;外，其余小查询都是&lt;code&gt;DEPENDENT UNION&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select key2 from s2 union select key3 from s2 union select key1 from s2) or key3 = &#39;b&#39;;
+----+--------------------+--------------+------------+------+---------------+----------+---------+------+-------+----------+--------------------------+
| id | select_type        | table        | partitions | type | possible_keys | key      | key_len | ref  | rows  | filtered | Extra                    |
+----+--------------------+--------------+------------+------+---------------+----------+---------+------+-------+----------+--------------------------+
|  1 | PRIMARY            | s1           | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where              |
|  2 | DEPENDENT SUBQUERY | s2           | NULL       | ref  | idx_key2      | idx_key2 | 5       | func |     1 |   100.00 | Using where; Using index |
|  3 | DEPENDENT UNION    | s2           | NULL       | ref  | idx_key3      | idx_key3 | 303     | func |     1 |   100.00 | Using index              |
|  4 | DEPENDENT UNION    | s2           | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |     1 |   100.00 | Using index              |
| NULL | UNION RESULT       | &amp;lt;union2,3,4&amp;gt; | NULL       | ALL  | NULL          | NULL     | NULL    | NULL |  NULL |     NULL | Using temporary          |
+----+--------------------+--------------+------------+------+---------------+----------+---------+------+-------+----------+--------------------------+
5 rows in set, 1 warning (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;derived&#34;&gt;DERIVED&lt;/h2&gt;
&lt;p&gt;在包含派生表的查询中，如果是以物化派生表的方式执行查询，则派生表对应的子查询的&lt;code&gt;select_type=DERIVED&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from (select key1, count(*) as total from s2  group by key1) t where total &amp;gt; 1;
+----+-------------+------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
| id | select_type | table      | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
|  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 10143 |    33.33 | Using where |
|  2 | DERIVED     | s2         | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 10143 |   100.00 | Using index |
+----+-------------+------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;materialized&#34;&gt;MATERIALIZED&lt;/h2&gt;
&lt;p&gt;当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询，该子查询对应的select_type=&lt;code&gt;MATERIALIZED&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第三条记录的select_type=MATERIALIZED，说明优化器将子查询先转换为物化表，执行计划的前两条记录的id都=1，说明这两条记录对应的表进行的是连接查询。&lt;br&gt;
&lt;strong&gt;第二条记录的table列的值是&lt;subquery2&gt;，说明该表其实就是执行计划中id为2对应的子查询执行之后产生的物化表，然后再将s1和该物化表进行连接查询。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select key1 from s2);
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+-------------------+-------+----------+-------------+
| id | select_type  | table       | partitions | type   | possible_keys       | key                 | key_len | ref               | rows  | filtered | Extra       |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1            | NULL                | NULL    | NULL              | 10143 |   100.00 | Using where |
|  1 | SIMPLE       | &amp;lt;subquery2&amp;gt; | NULL       | eq_ref | &amp;lt;auto_distinct_key&amp;gt; | &amp;lt;auto_distinct_key&amp;gt; | 303     | xiaohaizi.s1.key1 |     1 |   100.00 | NULL        |
|  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1            | idx_key1            | 303     | NULL              | 10143 |   100.00 | Using index |
+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+-------------------+-------+----------+-------------+
3 rows in set, 1 warning (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;uncacheable-subquery-uncacheable-union&#34;&gt;UNCACHEABLE SUBQUERY、UNCACHEABLE UNION&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;UNCACHEABLE SUBQUERY：对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）&lt;/li&gt;
&lt;li&gt;UNCACHEABLE UNION：UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;partitions&#34;&gt;partitions&lt;/h1&gt;
&lt;p&gt;版本5.7以前，该项是explain partitions显示的选项，5.7以后成为了默认选项。该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。&lt;/p&gt;
&lt;h1 id=&#34;type&#34;&gt;type&lt;/h1&gt;
&lt;p&gt;表示单表的访问方法，最为核心的字段之一。&lt;/p&gt;
&lt;h2 id=&#34;system&#34;&gt;system&lt;/h2&gt;
&lt;p&gt;当表只有一条记录且该表的存储引擎为MyISAM、MEMORY时，为&lt;code&gt;SYSTEM&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;const&#34;&gt;const&lt;/h2&gt;
&lt;p&gt;根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法为&lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;eq_ref&#34;&gt;eq_ref&lt;/h2&gt;
&lt;p&gt;执行连接查询时，如果&lt;strong&gt;被驱动表&lt;/strong&gt;是通过主键或者不允许存储NULL值的唯一二级索引列等值匹配的方式进行访问的（如果该主键或者不允许存储NULL值的唯一二级索引是联合索引，则所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 where s1.id = s2.id; --通过主键索引访问s2
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+-------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows  | filtered | Extra |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+-------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 10143 |   100.00 | NULL  |
|  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |     1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+-------+----------+-------+
2 rows in set, 1 warning (0.00 sec)

mysql&amp;gt; explain select * from s1 join s2 on s1.key2 = s2.key2; --通过唯一二级索引访问s2
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | ALL    | idx_key2      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where |
|  1 | SIMPLE      | s2    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | xiaohaizi.s1.key2 |     1 |   100.00 | NULL        |
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)

mysql&amp;gt; explain select * from s1 join s2 on s1.key2 = s2.key3; --通过唯一二级索引访问s1，注意这里是s1做被驱动表！！
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-----------------------+
| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref               | rows  | filtered | Extra                 |
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-----------------------+
|  1 | SIMPLE      | s2    | NULL       | ALL    | idx_key3      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where           |
|  1 | SIMPLE      | s1    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | xiaohaizi.s2.key3 |     1 |   100.00 | Using index condition |
+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-----------------------+
2 rows in set, 2 warnings (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ref&#34;&gt;ref&lt;/h2&gt;
&lt;p&gt;当通过普通二级索引列与常量进行等值匹配的方式来查询某个表时，对该表的访问方法就可能是ref。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 on s1.key3 = s2.key3;
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where |
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key3      | idx_key3 | 303     | xiaohaizi.s2.key3 |     1 |   100.00 | NULL        |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;fulltext&#34;&gt;fulltext&lt;/h2&gt;
&lt;p&gt;全文索引。&lt;/p&gt;
&lt;h2 id=&#34;ref_or_null&#34;&gt;ref_or_null&lt;/h2&gt;
&lt;p&gt;当对普通二级索引列进行等值匹配&lt;strong&gt;且该索引列的值也可以是NULL值&lt;/strong&gt;时，记为ref_or_null。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 = &#39;a&#39; or key1 is null;
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | s1    | NULL       | ref_or_null | idx_key1      | idx_key1 | 303     | const |    2 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;index_merge&#34;&gt;index_merge&lt;/h2&gt;
&lt;p&gt;一般情况下只会为单个索引生成扫描区间，但当在某些场景下可以使用Intersection、union、sort-union进行索引合并。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 = &#39;a&#39; or key3 = &#39;b&#39;;
+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |
+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |
+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
1 row in set, 1 warning (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unique_subquery&#34;&gt;unique_subquery&lt;/h2&gt;
&lt;p&gt;类似于两表连接中被驱动表的eq_ref访问方法。针对一些包含in子查询的查询语句。如果查询优化器决定将in子查询转换为exists子查询，而且子查询&lt;strong&gt;在转换后可以使用主键或唯一二级索引进行等值匹配&lt;/strong&gt;，记为&lt;code&gt;unique_subquery&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where common_field in (select id「这里主键/唯一二级索引是核心」 from s2 where s1.common_field = s2.common_field ) or key3 = &#39;b&#39;;
+----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+
| id | select_type        | table | partitions | type            | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |
+----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+
|  1 | PRIMARY            | s1    | NULL       | ALL             | idx_key3      | NULL    | NULL    | NULL | 10143 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | s2    | NULL       | unique_subquery | PRIMARY       | PRIMARY | 4       | func |     1 |    10.00 | Using where |
+----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+
2 rows in set, 2 warnings (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;index_subquery&#34;&gt;index_subquery&lt;/h2&gt;
&lt;p&gt;类似于unique_subquery，只不过在访问子查询中的表时使用的是普通的索引。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where common_field in (select key3「这里是普通索引」 from s2 where s1.common_field = s2.common_field ) or key3 = &#39;b&#39;;
+----+--------------------+-------+------------+----------------+---------------+----------+---------+------+-------+----------+-------------+
| id | select_type        | table | partitions | type           | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
+----+--------------------+-------+------------+----------------+---------------+----------+---------+------+-------+----------+-------------+
|  1 | PRIMARY            | s1    | NULL       | ALL            | idx_key3      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | s2    | NULL       | index_subquery | idx_key3      | idx_key3 | 303     | func |     1 |    10.00 | Using where |
+----+--------------------+-------+------------+----------------+---------------+----------+---------+------+-------+----------+-------------+
2 rows in set, 2 warnings (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;range&#34;&gt;range&lt;/h2&gt;
&lt;p&gt;如果使用索引获取某些单点扫描区间的记录，那么就可能使用到range访问方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key3 in (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;abc&#39;);
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | s1    | NULL       | range | idx_key3      | idx_key3 | 303     | NULL |    4 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;index&#34;&gt;index&lt;/h2&gt;
&lt;p&gt;当可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB特殊的点：当我们需要执行全表扫描，并且需要对主键进行排序时，type列的值也是index。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select key_part2 from s1 where key_part2 = &#39;ab&#39;;
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | s1    | NULL       | index | idx_key_part  | idx_key_part | 909     | NULL | 10143 |    10.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;all&#34;&gt;all&lt;/h2&gt;
&lt;p&gt;全表扫描。&lt;/p&gt;
&lt;h1 id=&#34;possible_keys-key&#34;&gt;possible_keys、key&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;possible_keys：可能使用的索引。&lt;/li&gt;
&lt;li&gt;key：实际用到的索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;possible_keys当type=index时显示为空，此时key展示的是实际使用的索引。&lt;/li&gt;
&lt;li&gt;possible_keys不是越多越好，越多查询优化器在计算查询成本时花费的时间就越长，尽可能删除用不到的索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;key_len&#34;&gt;key_len&lt;/h1&gt;
&lt;p&gt;表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。&lt;strong&gt;在不损失精确性的情况下，长度越短越好&lt;/strong&gt;。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，&lt;strong&gt;即key_len是根据表定义计算而得&lt;/strong&gt;，不是通过表内检索出来的。&lt;/p&gt;
&lt;h1 id=&#34;ref-2&#34;&gt;ref&lt;/h1&gt;
&lt;p&gt;当访问方法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery中的其中一个时，&lt;strong&gt;ref列展示的就是与索引列进行等值匹配的东西是什么&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常量，即右侧的值&lt;code&gt;&#39;1&#39;&lt;/code&gt;为常量。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where id = &#39;1&#39;;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;某个列，比如下面s2作为被驱动表时，s2的type=ref，ref=xiaohaizi.s1.key1&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 on s1.key1 = s2.key1;
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 12242 |   100.00 | Using where |
|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |     1 |   100.00 | NULL        |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;某个函数，比如下面s2作为被驱动表时，s2的type=ref，ref=func表示进行了函数操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 on s1.key1 = upper(s2.key1);
+----+-------------+-------+------------+------+---------------+----------+---------+------+-------+----------+-----------------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows  | filtered | Extra                 |
+----+-------------+-------+------------+------+---------------+----------+---------+------+-------+----------+-----------------------+
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 12558 |   100.00 | NULL                  |
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |     1 |   100.00 | Using index condition |
+----+-------------+-------+------------+------+---------------+----------+---------+------+-------+----------+-----------------------+
2 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;rows&#34;&gt;rows&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表该表的估算行数。&lt;/li&gt;
&lt;li&gt;如果使用索引来执行查询，执行计划的rows列就代表预计扫描的索引记录行数。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 &amp;gt; &#39;z&#39;;
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;filtered&#34;&gt;filtered&lt;/h1&gt;
&lt;p&gt;计算MySQL驱动表扇出的一种策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用全表扫描执行单表查询，那么计算驱动表扇出时需要估计出全部搜索条件的记录到底有多少条。&lt;/li&gt;
&lt;li&gt;如果使用索引来执行单表查询，&lt;strong&gt;那么计算驱动表扇出时需要估计出满足形成索引扫描区间的搜索条件外，还满足其他搜索条件的记录有多少条。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在单表查询时没太大意义，在连表查询时对估算执行次数有帮助。&lt;/p&gt;
&lt;p&gt;下表中，s1做驱动表，s2做被驱动表，s1的filtered=10，rows=12242，12242* 10%=1224.2，s2的filtered=100，rows=1，表示还要对被驱动表执行答曰1224次查询。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 on s1.key1 = s2.key1 where s1.common_field = &#39;a&#39;;
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 12242 |    10.00 | Using where |
|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |     1 |   100.00 | NULL        |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+
2 rows in set, 1 warning (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;extra&#34;&gt;Extra&lt;/h1&gt;
&lt;p&gt;展示额外信息时使用，比较多，此处按照书中描述，只记录常出现的内容。&lt;/p&gt;
&lt;h2 id=&#34;no-tables-used&#34;&gt;No tables used&lt;/h2&gt;
&lt;p&gt;当查询语句中没有FROM子句时，会提示。比如&lt;code&gt;SELECT 1&lt;/code&gt;之类。&lt;/p&gt;
&lt;h2 id=&#34;impossible-where&#34;&gt;Impossible WHERE&lt;/h2&gt;
&lt;p&gt;查询语句的WHERE子句永远为FALSE时，会提示。比如&lt;code&gt;SELECT * FROM s1 WHERE 1 &amp;lt;&amp;gt; 1&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;no-matching-minmax-row&#34;&gt;No matching min/max row&lt;/h2&gt;
&lt;p&gt;当查询列表处有MIN或MAX聚集函数，但是没有记录符合WHERE子句中的搜索条件时，会提示。比如&lt;code&gt;SELECT min(key1) FROM s1 WHERE key1 = &#39;一个不存在的值&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;using-index&#34;&gt;Using index&lt;/h2&gt;
&lt;p&gt;使用覆盖索引执行查询时，&lt;strong&gt;不用回表&lt;/strong&gt;，会提示。比如&lt;code&gt;SELECT key1 FROM s1 WHERE key1 = &#39;a&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;using-index-condition&#34;&gt;Using index condition&lt;/h2&gt;
&lt;p&gt;搜索条件中虽然出现了索引列，但却不能充当边界条件来形成扫描区间，&lt;strong&gt;也就是说不能用来减少需要扫描的记录数量&lt;/strong&gt;，会提示。&lt;br&gt;
比如：&lt;code&gt;SELECT * FROM s1 WHERE key1 &amp;gt; &#39;z&#39; AND key1 LIKE &#39;%a&#39;&lt;/code&gt;，其中的&lt;code&gt;key1 &amp;gt; &#39;z&#39;&lt;/code&gt;可以用来形成扫描区间，但是&lt;code&gt;key1 LIKE &#39;%a&#39;&lt;/code&gt;却不能。&lt;br&gt;
即索引覆盖（索引下推）达成条件。&lt;br&gt;
只对于二级索引有效，对于二级索引等值判断不生效（这时Extra=NULL），对于主键索引不生效（直接查数据）。&lt;/p&gt;
&lt;h2 id=&#34;using-where&#34;&gt;Using where&lt;/h2&gt;
&lt;p&gt;当某个搜索条件需要在server层进行判断时，在Extra列会提示，比如索引覆盖没有达成的情况。&lt;br&gt;
&lt;code&gt;SELECT * FROM s1 WHERE key1 = &#39;a&#39; AND common_field = &#39;a&#39;&lt;/code&gt;，由于comon_field无法在引擎层判断，只能通过key1形成扫描区间后，在server层判断。&lt;/p&gt;
&lt;h2 id=&#34;using-join-bufferblock-nested-loop&#34;&gt;Using join buffer（Block Nested Loop）&lt;/h2&gt;
&lt;p&gt;在连接过程中，当被驱动表不能有效的利用索引加快访问速度时，MySQL会分配一块JoinBuffer内存块来加快查询速度，基于块的嵌套循环算法执行连接查询。&lt;/p&gt;
&lt;h2 id=&#34;using-intersect-using-union和using-sort_union&#34;&gt;Using intersect(...)、Using union(...)和Using sort_union(...)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;intersect：准备使用Intersection索引合并的方式执行查询，括号中包含需要合并的索引名称。&lt;/li&gt;
&lt;li&gt;union：准备使用union索引合并方式执行查询。&lt;/li&gt;
&lt;li&gt;sort_union：准备使用Sort-Union索引合并的方式执行查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;zero_limit&#34;&gt;zero_limit&lt;/h2&gt;
&lt;p&gt;当Limit子句参数为0时，会提示。&lt;/p&gt;
&lt;h2 id=&#34;using-filesort&#34;&gt;Using filesort&lt;/h2&gt;
&lt;p&gt;对结果集中记录进行排序时，使用索引则不会出现，但很多情况无法使用索引进行排序，则会出现filesort。&lt;/p&gt;
&lt;h2 id=&#34;using-temporary&#34;&gt;Using temporary&lt;/h2&gt;
&lt;p&gt;MySQL利用临时表完成去重、排序时。&lt;br&gt;
比如DISTINCT、GROUP BY、UNION等子句查询过程中如无法使用索引则会提示。&lt;/p&gt;
&lt;h2 id=&#34;start-temporaryend-temporary&#34;&gt;Start temporary，End temporary&lt;/h2&gt;
&lt;p&gt;子查询时，查询优化器会优先尝试将IN子查询转换为半连接。半连接有很多种策略，当选择Duplicate Weedout时，也就是通过建立临时表来为外城查询中的记录进行去重操作时，驱动表查询执行计划的Extra列将显示Start temporary，被驱动表则会显示End temporary。&lt;/p&gt;
&lt;h2 id=&#34;loosescan&#34;&gt;LooseScan&lt;/h2&gt;
&lt;p&gt;在将IN子查询转换为半连接时，如果采用的是LooseScan执行策略，则驱动表执行计划的Extra列就显示LooseScan提示。&lt;/p&gt;
&lt;h2 id=&#34;firstmatchtable_name&#34;&gt;FirstMatch(table_name)&lt;/h2&gt;
&lt;p&gt;在将IN子查询转换为半连接时，如果采用的是FirstMatch执行策略，则被驱动表执行计划的Extra列就显示FirstMatch提示。&lt;/p&gt;
&lt;h1 id=&#34;建表和1w条数据&#34;&gt;建表和1w条数据&lt;/h1&gt;
&lt;h2 id=&#34;表&#34;&gt;表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE s1 (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;

CREATE TABLE s2 (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;插入数据&#34;&gt;插入数据&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
delimiter $
create procedure insertNData(n int)
begin
    declare total int default 0;
    declare num int default 1;
    while total &amp;lt;= n
        do
            set total = total + 1;
            set num = num + 1;
            INSERT INTO xiaohaizi.s1 (id, key1, key2, key3, key_part1, key_part2, key_part3, common_field)
            VALUES (null, substring(md5(rand()), 1, 10), floor(rand() * 100000000), substring(md5(rand()), 1, 10),
                    substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10),
                    substring(md5(rand()), 1, 10));
            INSERT INTO xiaohaizi.s2 (id, key1, key2, key3, key_part1, key_part2, key_part3, common_field)
            VALUES (null, substring(md5(rand()), 1, 10), floor(rand() * 100000000), substring(md5(rand()), 1, 10),
                    substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10),
                    substring(md5(rand()), 1, 10));
        end while;
    select count(*) from xiaohaizi.s1;
end $

call insertNData(10000) $


&lt;/code&gt;&lt;/pre&gt;
">MySQL Explain 详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-dan-biao-lian-jie-fang-wen-fang-fa/"" data-c="
          &lt;h1 id=&#34;const&#34;&gt;const&lt;/h1&gt;
&lt;p&gt;通过主键或者唯一二级索引列来定位一条记录的访问方法定义为const（常数级别，代价忽略不计）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM t WHERE id = xx;
SELECT * FROM t WHERE 唯一索引column = xx;

唯一索引A(列A，列B)
SELECT * FROM t WHERE 列A = xx AND 列B = xx;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例外：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WHERE 唯一索引column IS NULL，因为唯一索引不限制NULL值数量，所以会扫描出多条记录，否则最多只是ref&lt;/li&gt;
&lt;li&gt;多列唯一索引时，只有多列全匹配才会是const，否则最多只是ref&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ref&#34;&gt;ref&lt;/h1&gt;
&lt;p&gt;采用二级索引来执行查询的方法称为ref。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM t WHERE 普通二级索引column = xx;
SELECT * FROM t WHERE 普通二级索引column IS NULL;

唯一索引A(列A，列B)
SELECT * FROM t WHERE 列A = xx;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ref_or_null&#34;&gt;ref_or_null&lt;/h1&gt;
&lt;p&gt;ref_or_null访问方法只是比ref方法多扫描了一些值为NULL的二级索引记录。&lt;br&gt;
值为NULL的记录会被放在索引的最左边。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM t WHERE 普通二级索引column = xx OR 普通二级索引column IS NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;range&#34;&gt;range&lt;/h1&gt;
&lt;p&gt;使用索引查询时，对应的扫描区间为若干个单点扫描区间或者范围扫描区间时，访问方法称为range。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM t WHERE key1 IN (111,222) OR (key2 &amp;gt; 22 AND key2 &amp;lt;33)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只有单个扫描区间不能称为range。&lt;/li&gt;
&lt;li&gt;扫描区间为(-∞, +∞)也不能称为range。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;index&#34;&gt;index&lt;/h1&gt;
&lt;p&gt;由于二级索引比聚簇索引小得多（聚簇索引要存储记录，二级索引只需要存储索引列和主键），而且这个过程不用执行回表操作，所以&lt;strong&gt;直接扫描全部的二级索引的访问方法称为index方法。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;联合索引A(key1, key2, key3)
SELECT key2,key3 FROM t WHERE k1 = xx;

聚簇索引排序
SELECT * FROM t ORDER BY id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;all&#34;&gt;all&lt;/h1&gt;
&lt;p&gt;全表扫描，直接扫描全部的聚簇索引记录。称为all访问方法。&lt;/p&gt;
&lt;h1 id=&#34;eq_ref&#34;&gt;eq_ref&lt;/h1&gt;
&lt;p&gt;在单表中使用主键值或唯一二级索引列的值进行等值查询的方式称为const。&lt;br&gt;
在连接查询中使用主键值或唯一二级索引列的值进行等值查询的方式称为eq_ref。&lt;/p&gt;
">MySQL单表/连接访问方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/go-xin-te-xing-embed/"" data-c="
          &lt;p&gt;go 1.16版本开始，支持将静态资源文件打包至二进制文件啦~，在1.16版本之前，开源界提供了很多方案，终于在此版本官方提供了统一的解决方案。具体使用见官方文档：https://pkg.go.dev/embed&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import _ &amp;quot;embed&amp;quot;

//go:embed hello.txt
var s string
print(s)
&lt;/code&gt;&lt;/pre&gt;
">Go 新特性 embed</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/duo-ban-ben-bing-fa-kong-zhi-yuan-li-fen-xi-zhi-shu-ju-ke-jian-xing-suan-fa/"" data-c="
          &lt;p&gt;MySQL InnoDB通过多版本并发控制，对每一行记录都写入3个隐藏字段（TRX_ID、ROLL_POINT、ROW_ID），使&lt;code&gt;可重复读&lt;/code&gt;隔离级别下达到&lt;code&gt;事务开启且创建快照后其他任何其他事务的更新均对其不可见&lt;/code&gt;，至于其内部具体如何实现的，则通过下面的文章进行记录。&lt;/p&gt;
&lt;h1 id=&#34;四种事务隔离界别及解决的问题&#34;&gt;四种事务隔离界别及解决的问题&lt;/h1&gt;
&lt;p&gt;首先需要回顾下MySQL的四种事务隔离级别，以及其为了解决的问题。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别&lt;/th&gt;
&lt;th&gt;symbol&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交&lt;/td&gt;
&lt;td&gt;READ-UNCOMMITTED&lt;/td&gt;
&lt;td&gt;存在脏读、不可重复读、幻读的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;读已提交&lt;/td&gt;
&lt;td&gt;READ-COMMITTED&lt;/td&gt;
&lt;td&gt;解决脏读的问题，存在不可重复读、幻读的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;REPEATABLE-READ&lt;/td&gt;
&lt;td&gt;mysql 默认级别，解决脏读、不可重复读的问题，存在幻读的问题。使用 MMVC机制 实现可重复读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;序列化&lt;/td&gt;
&lt;td&gt;SERIALIZABLE&lt;/td&gt;
&lt;td&gt;解决脏读、不可重复读、幻读，可保证事务安全，但完全串行执行，性能最低&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MySQL的可重复读解决了脏读、不可重复读问题，但通过MVCC并未解决幻读问题，幻读是结合next-key-lock（间隙锁）来实现的。关于此处内容文章&lt;a href=&#34;https://segmentfault.com/a/1190000016566788&#34;&gt;mysql 幻读的详解、实例及解决办法&lt;/a&gt;讲得不错。&lt;/p&gt;
&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;
&lt;p&gt;TrxId = 当前记录（行数据）最后被修改的事务id&lt;br&gt;
UpId = 当前活跃最小事务id&lt;br&gt;
LowLimitId = 下一个即将分配的事务id（当前最大事务Id+1）&lt;br&gt;
活跃事务列表 = 当前所有开启了事务但未提交的事务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果当前记录最后被修改的事务id 小于 最小活跃事务id（当前所有活跃会话开启前事务提交的数据）  或者 当前记录最后被修改的事务id 和 当前事务id 相等（自己在当前事务下更新过该记录的数据）， 则可见&lt;/li&gt;
&lt;li&gt;当前记录最后被修改的事务id 大于等于 下一个即将被分配的事务id（low-limit-id是开启快照读时生成，当low-limit-id小于TRX_ID则说明此数据在当前快照创建后已修改，此数据不可见需要继续通过RollId往上找），则不可见，通过回滚指针继续向上找。&lt;/li&gt;
&lt;li&gt;当前记录最后被修改的事务id 在 活跃事务列表（活跃事务列表是开启快照读时生成，则说明是该事务创建时已经在活跃的事务） 中，则不可见，通过回滚指针继续向上找。&lt;/li&gt;
&lt;li&gt;其他所有情况，都可见&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2021/11/v8l8t51cssjm3rfassbhrg223b.jpg&#34; alt=&#34;可重复读隔离级别下算法&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;前提条件&#34;&gt;前提条件&lt;/h1&gt;
&lt;p&gt;基于MySQL 的 &lt;code&gt;可重复读&lt;/code&gt; 隔离级别下。&lt;/p&gt;
&lt;p&gt;快照读只有在当前事务第一次执行读取操作（SELECT）后才会生成。&lt;br&gt;
此时已经固定下来包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;活跃事务id列表&lt;/li&gt;
&lt;li&gt;最小活跃最小事务id&lt;/li&gt;
&lt;li&gt;下一个即将分配的事务id&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但没有固定 当前记录最后被修改的事务id，此字段根据每次查询时当前记录最后被更新的事务来更新（永远读最新的）。&lt;/p&gt;
&lt;h1 id=&#34;场景分析&#34;&gt;场景分析&lt;/h1&gt;
&lt;h2 id=&#34;场景一创建快照前的更新&#34;&gt;场景一：创建快照前的更新&lt;/h2&gt;
&lt;p&gt;同时开启4个事务，但事务2第一次快照读在事务4提交之后，故事务4的数据修改对于事务2可见。&lt;/p&gt;
&lt;p&gt;结合流程图分析：&lt;/p&gt;
&lt;p&gt;当前记录最后被修改事务id（TRX_ID）=4， upid=1，low-limit-id=5，当前事务id=2，&lt;br&gt;
活跃事务列表=（1、2、3），不包含4，因为4已提交&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TRX_ID &amp;lt; upId = false，TRX_ID = 当前事务id = false&lt;/li&gt;
&lt;li&gt;TRX_ID &amp;gt;= low-limit-id = false&lt;/li&gt;
&lt;li&gt;TRX_ID in 活跃事务列表 = false&lt;/li&gt;
&lt;li&gt;上述条件均不支持，数据可见。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2021/11/74mf4guj58jdlpkrke5flael6q.jpg&#34; alt=&#34;可重复读隔离级别-场景1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;场景二创建快照后开启事务的更新&#34;&gt;场景二：创建快照后开启事务的更新&lt;/h2&gt;
&lt;p&gt;开始只开启事务1和2、当事务2执行select之后（生成了快照读），再开启了事务3、4，事务4执行了update语句且进行了提交，事务4的更新对于事务2第二次select来说处于高水位，是不可见的。&lt;/p&gt;
&lt;p&gt;结合流程图分析：&lt;/p&gt;
&lt;p&gt;当前记录最后被修改事务id（TRX_ID）=4， upid=1，low-limit-id=3，当前事务id=2，&lt;br&gt;
活跃事务列表=（1、2），不包含3、4，因为2的快照读是在第一个select时创建的，那是3、4还未开启事务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TRX_ID &amp;lt; upId = false，TRX_ID = 当前事务id = false&lt;/li&gt;
&lt;li&gt;TRX_ID &amp;gt;= low-limit-id = true，符合，即不可见（其实就是高水位，是在当前快照之后创建的事务，当然不可见）&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2021/11/sne9d6nnj4gc4rq562ga6bdsrf.jpg&#34; alt=&#34;可重复读隔离级别-场景2&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;场景三创建快照同时开启事务的更新&#34;&gt;场景三：创建快照同时开启事务的更新&lt;/h2&gt;
&lt;p&gt;同时开启4个事务，事务2初次执行select时已创建快照读，在后续事务4执行了update操作进行了提交，事务4的更新对于事务2第二次select来说处于高水位，是不可见的。&lt;/p&gt;
&lt;p&gt;结合流程图分析：&lt;/p&gt;
&lt;p&gt;当前记录最后被修改事务id（TRX_ID）=4， upid=1，low-limit-id=5，当前事务id=2，&lt;br&gt;
活跃事务列表=（1、2、3、4）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TRX_ID &amp;lt; upId = false, TRX_ID = 当前事务id = false&lt;/li&gt;
&lt;li&gt;TRX_ID &amp;gt;= low-limit-id = false&lt;/li&gt;
&lt;li&gt;TRX_ID in 活跃事务列表 = true，即不可见，保证了事务2在两次select时的查询均是一致的，事务4的更新对于事务2来说永远不可见。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2021/11/sju3secjpmi85phpfv3khgs6bo.jpg&#34; alt=&#34;可重复读隔离级别-场景3&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;记录&#34;&gt;记录&lt;/h1&gt;
&lt;p&gt;本文基于慕课网课程&lt;a href=&#34;https://www.imooc.com/learn/1309&#34;&gt;探秘 MySQL 多版本并发控制原理&lt;/a&gt;&lt;/p&gt;
">多版本并发控制原理分析之数据可见性算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-insert-into-select/"" data-c="
          &lt;h1 id=&#34;初始化数据库&#34;&gt;初始化数据库&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `xiaohaizi_second_table` (
  `c1` int unsigned NOT NULL AUTO_INCREMENT,
  `c2` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,
  `c3` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,
  PRIMARY KEY (`c1`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&#39;学习小孩子-insert-into-select测试&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;查询结果插入数据&#34;&gt;查询结果插入数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO table_name(c1, c2, c3) SELECT c1, c2, c3 FROM table_name2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;查询结果插入数据-如果遇到-唯一约束-则跳过&#34;&gt;查询结果，插入数据， 如果遇到 唯一约束， 则跳过&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;INSERT IGNORE INTO table_name(c1, c2, c3) SELECT c1, c2, c3 FROM table_name2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;查询结果插入数据如果遇到-唯一约束-则更新&#34;&gt;查询结果，插入数据，如果遇到 唯一约束， 则更新&lt;/h1&gt;
&lt;h2 id=&#34;冲突更新单列&#34;&gt;冲突更新单列：&lt;/h2&gt;
&lt;p&gt;假设c1列具有唯一索引，插入数据(1, ‘xx’, ‘yy’)，如果c1列已存在c1=1的数据，则将此列的c2字段更新为’hhh’&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO table_name(c1, c2, c3) VALUES(1, ‘xx’, ‘yy’) ON DUPLICATE KEY UPDATE c2 = ‘hhh&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;冲突更新多列&#34;&gt;冲突更新多列：&lt;/h2&gt;
&lt;p&gt;假设c1列具有唯一索引，插入数据(1, ‘xx’, ‘yy’)，如果c1列已存在c1=1的数据，则将此列的c2字段更新为待插入行中对应列的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO table_name ( c1, c2, c3 )
VALUES
	( 1, &amp;quot;xx1&amp;quot;, &amp;quot;yy1&amp;quot; ),
	( 2, &amp;quot;xxx2&amp;quot;, &amp;quot;yyy2&amp;quot; ) 
	ON DUPLICATE KEY UPDATE c2 =
VALUES
	( c2 ),
	c3 =
VALUES
	( c3 );
&lt;/code&gt;&lt;/pre&gt;
">MySQL INSERT INTO SELECT</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/arthas-zai-xiang-mu-kai-fa-zhong-de-ying-yong-xian-shang-gu-zhang-ding-wei/"" data-c="
          &lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1722136355320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。&lt;br&gt;
Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。&lt;/p&gt;
&lt;h2 id=&#34;arthas能为我们解决哪些问题&#34;&gt;Arthas能为我们解决哪些问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？&lt;/li&gt;
&lt;li&gt;我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？&lt;/li&gt;
&lt;li&gt;遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？&lt;/li&gt;
&lt;li&gt;线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！&lt;/li&gt;
&lt;li&gt;是否有一个全局视角来查看系统的运行状况？&lt;/li&gt;
&lt;li&gt;有什么办法可以监控到JVM的实时运行状态？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;与skywalking的区别&#34;&gt;与SkyWalking的区别&lt;/h2&gt;
&lt;p&gt;Skywalking是一个可观测性分析平台（Observability Analysis Platform，OAP）和一个应用性能管理（Application Performance Management，APM）系统。&lt;/p&gt;
&lt;h1 id=&#34;quick-start&#34;&gt;Quick Start&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动本地Java进程 （实例工程，空SpringBoot项目）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载arthas-boot curl -O https://arthas.aliyun.com/arthas-boot.jar，此步骤仅完成基础包下载，大小为139K上下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行命令 java -jar arthas-boot.jar，选择需要attch的Java进程，进入arthas的命令界面&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136365937.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本操作（官网入门示例）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dashboard&#34;&gt;dashboard&lt;/h3&gt;
&lt;p&gt;执行dashboard，将展示当前进程的信息。如图：&lt;br&gt;
通过此命令可以查看JVM的堆内存情况，以及活跃线程、JVM基本信息等内容。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136372698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;jad反编译代码&#34;&gt;jad反编译代码&lt;/h3&gt;
&lt;p&gt;通过jad指令，反编译class&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136380342.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;watch方法执行数据观测查看函数入参和返回值&#34;&gt;watch方法执行数据观测（查看函数入参和返回值）&lt;/h3&gt;
&lt;p&gt;通过模拟对入参 *2 的程序，反应watch的强大。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1722136387106.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过watch命令，监听方法的一切行为。watch的参数比较多，以下摘抄自官网：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;class-pattern&lt;/th&gt;
&lt;th&gt;类名表达式匹配&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;method-pattern&lt;/td&gt;
&lt;td&gt;方法名表达式匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;express&lt;/td&gt;
&lt;td&gt;观察表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;condition-express&lt;/td&gt;
&lt;td&gt;条件表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[b]&lt;/td&gt;
&lt;td&gt;在方法调用之前观察&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[e]&lt;/td&gt;
&lt;td&gt;在方法异常之后观察&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[s]&lt;/td&gt;
&lt;td&gt;在方法返回之后观察&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[f]&lt;/td&gt;
&lt;td&gt;在方法结束之后(正常返回和异常返回)观察&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[E]&lt;/td&gt;
&lt;td&gt;开启正则表达式匹配，默认为通配符匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[x:]&lt;/td&gt;
&lt;td&gt;指定输出结果的属性遍历深度，默认为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1722136394130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;monitor方法执行监控什么时候执行了&#34;&gt;monitor方法执行监控（什么时候执行了）&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数名称&lt;/th&gt;
&lt;th&gt;参数说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;class-pattern&lt;/td&gt;
&lt;td&gt;类名表达式匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;method-pattern&lt;/td&gt;
&lt;td&gt;方法名表达式匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;condition-express&lt;/td&gt;
&lt;td&gt;条件表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[E]&lt;/td&gt;
&lt;td&gt;开启正则表达式匹配，默认为通配符匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[c:]&lt;/td&gt;
&lt;td&gt;统计周期，默认值为120秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[b]&lt;/td&gt;
&lt;td&gt;在方法调用之前计算condition-express&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;monitor -c 5 top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController index&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;每5秒监听一次，统计耗时、失败率、总次数、成功次数、失败次数等信息&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136401218.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过表达式过滤不需要的请求方法调用。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136409477.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;trace方法内部调用路径输出方法路径上的节点耗时我调用了谁&#34;&gt;trace方法内部调用路径，输出方法路径上的节点耗时（我调用了谁）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;trace top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController index&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为代价比较高（这属于skywarking的工作范围），trace默认只支持一层的耗时分析。但官网提供了多层trace的方法，具体见：https://arthas.aliyun.com/doc/trace.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imyzt.top/post-images/1722136417885.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136422365.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;stack方法输出当前方法被调用的调用路径谁调用了我&#34;&gt;stack方法输出当前方法被调用的调用路径（谁调用了我）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;stack top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController getResult -n 3&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1722136451605.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;tt 记录方法请求的信息，方便重做请求和查看结果&lt;br&gt;
方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测&lt;br&gt;
watch指令复杂，通过tt记录请求的信息后面可以针对性分析&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1722136456891.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-进阶操作&#34;&gt;2. 进阶操作&lt;/h2&gt;
&lt;h3 id=&#34;热加载代码&#34;&gt;热加载代码&lt;/h3&gt;
&lt;p&gt;首先声明：在生产环境热更新代码是不很不好的行为。&lt;br&gt;
但是肯定有它使用的场景。&lt;/p&gt;
&lt;p&gt;涉及到几个命令：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;jad（反编译指定已加载类的源码）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sc（查看JVM已加载的类信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mc（内存编译器，内存编译.java文件为.class文件）、&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;redefine（加载外部的.class文件，redefine到JVM里）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jad反编译代码，vim调整代码逻辑&lt;br&gt;
&lt;code&gt;jad --source-only top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController &amp;gt; /tmp/IndexController.java&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136462341.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 sc 命令，找到类加载器&lt;br&gt;
&lt;code&gt;sc -d *IndexController&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136467677.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 mc 内存编译java -&amp;gt; class&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;mc -c 31221be2 /tmp/IndexController.java -d /tmp&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;通过 redefine 热加载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;redefine /tmp/top/imyzt/learning/arthas/arthaswebdemo/web/controller/IndexController.class&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;全流程&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136472731.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;profiler图&#34;&gt;profiler🔥图&lt;/h2&gt;
&lt;p&gt;通过 profiler start/stop 获得一份程序的火焰图&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136500580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136504657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;火焰图查看工具&#34;&gt;火焰图查看工具&lt;/h3&gt;
&lt;p&gt;JDK JMC：https://github.com/openjdk/jmc&lt;br&gt;
JProfiler(付费)： https://www.ej-technologies.com/download/jprofiler/files&lt;/p&gt;
&lt;h3 id=&#34;如何读懂火焰图&#34;&gt;如何读懂火焰图？&lt;/h3&gt;
&lt;p&gt;如何读懂火焰图? - 阮一峰的网络日志&lt;br&gt;
使用arthas+jprofiler做复杂链路分析 · Issue #1416 · alibaba/arthas&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;进阶使用&amp;amp;命令列表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://arthas.aliyun.com/doc/advanced-use.html&#34;&gt;https://arthas.aliyun.com/doc/advanced-use.html&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://arthas.aliyun.com/doc/commands.html&#34;&gt;https://arthas.aliyun.com/doc/commands.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;常用使用场景分析和讨论&#34;&gt;常用使用场景分析和讨论&lt;/h1&gt;
&lt;p&gt;同传统方式进行对比，最大的目的是为了解决目前低效的生产环境问题排查方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过watch观察方法入参，是否可以客户反馈使用出了问题，但是又不知道小程序发过来的请求具体是啥？&lt;/li&gt;
&lt;li&gt;通过stack观察，某个方法什么时候被调用了，被谁调用了？&lt;/li&gt;
&lt;li&gt;通过tt记录请求信息，便于重做请求，模拟用户操作？&lt;/li&gt;
&lt;li&gt;通过后台异步任务，观察定时周期出现问题的代码，阿里描述：当线上出现偶发的问题，比如需要watch某个条件，而这个条件一天可能才会出现一次时，异步后台任务就派上用场了，详情请参考这里&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上描述的操作虽然能解决很多问题，但是是否面临着一个更大的问题？&lt;/p&gt;
&lt;h1 id=&#34;适合生产环境的实践&#34;&gt;适合生产环境的实践&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Web_Console&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在attrch成功之后，直接访问本地3658端口，可以通过web界面操作。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136520274.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认情况下，arthas只listen 127.0.0.1，所以如果想从远程连接，则可以使用 --target-ip参数指定listen的IP。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Tunnel Server&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下载arthas-tunnel-server，本地java -jar启动，Web界面监听8080端口，WebSocket通信监听7777端口。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136525447.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;java -jar arthas-boot.jar --tunnel-server &#39;ws://127.0.0.1:7777/ws&#39;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136531162.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以通过http://127.0.0.1:8080/actuator/arthas访问本地，获得已连接到tunnel-server的arthas-client。密码在启动控制台。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136536317.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136540359.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过上面的操作，虽然免去了去生产环境机器直接操作arthas这种不现实的问题，但是在Web界面操作还有一个问题，就是谁给我们绑定执行 java -jar arthas-boot.jar --tunnel-server &#39;ws://127.0.0.1:7777/ws&#39; 这个命令呢.......&lt;/p&gt;
&lt;h1 id=&#34;与springboot集成更适合生产环境的实践&#34;&gt;与SpringBoot集成，更适合生产环境的实践&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;增加Maven依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.taobao.arthas&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;arthas-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;调整配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;server.port=8892

spring.application.name=arthas-demo

# 建议不指定, 会根据 spring.application.name 生成
#arthas.agent-id=arthas-demo
arthas.tunnel-server=ws://localhost:7777/ws
# -1会随机分配端口
arthas.http-port=-1
arthas.telnet-port=-1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;查看agentId&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136547923.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tunnel-server连接后操作&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1722136552794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;对性能的影响&#34;&gt;对性能的影响&lt;/h2&gt;
&lt;p&gt;通过spring-boot-starter的方式，在应用启动时，就对进程自动完成了attach，对于性能方面的影响是不大的，下面有两个官方的回复，从原理是解释了这个问题。&lt;/p&gt;
&lt;h2 id=&#34;开发团队回复&#34;&gt;开发团队回复：&lt;/h2&gt;
&lt;p&gt;目前arthas-spring-boot-starter方式是长期启动状态，对程序的性能有什么影响吗？ · Issue #1843 · alibaba/arthas&lt;br&gt;
是否进行过性能评估，attach之后对原进程性能有多大的影响呢 · Issue #44 · alibaba/arthas&lt;/p&gt;
&lt;h1 id=&#34;如何记住各种命令&#34;&gt;如何记住各种命令&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://arthas.aliyun.com/doc/idea-plugin.html&#34;&gt;https://arthas.aliyun.com/doc/idea-plugin.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;遇到的一些坑&#34;&gt;遇到的一些坑&lt;/h1&gt;
&lt;h2 id=&#34;pid1无法attach&#34;&gt;Pid=1无法Attach&lt;/h2&gt;
&lt;p&gt;linux保护机制，jstack无法attach住pid&amp;lt;=5的进程，arthas也无法使用，通用解决方案是使用tini挂载java进程。&lt;br&gt;
&lt;a href=&#34;https://github.com/alibaba/arthas/issues/362&#34;&gt;https://github.com/alibaba/arthas/issues/362&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;arthas端口问题&#34;&gt;Arthas端口问题&lt;/h2&gt;
&lt;p&gt;应用被Arthas-Boot attch之后，包括应用本身的端口，同时还会监听另外两个端口：&lt;br&gt;
默认情况下，Arthas的Telnet端口是3658，HTTP端口是8563，这个常常让用户迷惑。在新版本里，在3658端口同时支持Telnet/HTTP协议。&lt;br&gt;
在浏览器里访问 http://localhost:3658/ 也可以访问到Web Console了。&lt;br&gt;
在后续的版本里，考虑默认只侦听 3658端口，减少用户的配置项。&lt;/p&gt;
&lt;p&gt;当启动tunnel-server后，8080与7777端口也被监听。&lt;/p&gt;
&lt;h2 id=&#34;与skywalking的兼容性问题&#34;&gt;与Skywalking的兼容性问题&lt;/h2&gt;
&lt;p&gt;java.lang.ClassFormatError: null、skywalking arthas 兼容使用&lt;br&gt;
当出现这个错误日志java.lang.ClassFormatError: null,通常情况下都是被其他字节码工具修改过与arthas修改字节码不兼容。&lt;br&gt;
比如: 使用 skywalking V8.1.0 以下版本 无法trace、watch 被skywalking agent 增强过的类, V8.1.0 以上版本可以兼容使用,更多参考skywalking配置 skywalking compatible with other javaagent bytecode processing。&lt;/p&gt;
&lt;h2 id=&#34;jvm版本问题&#34;&gt;JVM版本问题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/alibaba/arthas/issues/1519&#34;&gt;启动Arthas的Java版本和启动应用的Java版本要保持一致&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;推荐文章&#34;&gt;推荐文章&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Arthas源码学习-1_慢一拍的coder-CSDN博客&lt;/li&gt;
&lt;li&gt;Arthas Tutorials&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/NZ5k9htzaak-yMR0UdCoZQ&#34;&gt;工商银行打造在线诊断平台的探索与实践&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;arthas使用到的技术&#34;&gt;Arthas使用到的技术&lt;/h1&gt;
&lt;h2 id=&#34;arthas运行原理&#34;&gt;Arthas运行原理&lt;/h2&gt;
&lt;p&gt;tt命令探究&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行 tt -t top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController index&lt;/li&gt;
&lt;li&gt;下载正在运行的字节码文件 dump top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController&lt;/li&gt;
&lt;li&gt;查看字节码 javap -c -s -v -l xxx.class&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1722136338422.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;相关文章：&lt;a href=&#34;https://juejin.cn/post/6904280021632974856&#34;&gt;Arthas原理系列(四):字节码插装让一切变得有可能&lt;/a&gt;&lt;/p&gt;
">Arthas在项目开发中的应用 - 线上故障定位</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/golang-zhi-xing-shell-bing-shi-shi-da-yin-shell-ri-zhi/"" data-c="
          &lt;p&gt;在网络上找到的，在此代码备忘下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package util

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os/exec&amp;quot;
	&amp;quot;strings&amp;quot;
)

func asyncLog(reader io.ReadCloser) error {
	bucket := make([]byte, 1024)
	buffer := make([]byte, 100)
	for {
		num, err := reader.Read(buffer)
		if err != nil {
			if err == io.EOF || strings.Contains(err.Error(), &amp;quot;closed&amp;quot;) {
				err = nil
			}
			return err
		}
		if num &amp;gt; 0 {
			line := &amp;quot;&amp;quot;
			bucket = append(bucket, buffer[:num]...)
			tmp := string(bucket)
			if strings.Contains(tmp, &amp;quot;\n&amp;quot;) {
				ts := strings.Split(tmp, &amp;quot;\n&amp;quot;)
				if len(ts) &amp;gt; 1 {
					line = strings.Join(ts[:len(ts)-1], &amp;quot;\n&amp;quot;)
					bucket = []byte(ts[len(ts)-1]) //不够整行的以后再处理
				} else {
					line = ts[0]
					bucket = bucket[:0]
				}
				fmt.Printf(&amp;quot;%s\n&amp;quot;, line)
			}

		}
	}
	return nil
}

func Execute(shellPath string) error {

	cmd := exec.Command(&amp;quot;/bin/bash&amp;quot;, &amp;quot;-c&amp;quot;, shellPath)

	stdout, _ := cmd.StdoutPipe()
	stderr, _ := cmd.StderrPipe()

	if err := cmd.Start(); err != nil {
		log.Printf(&amp;quot;Error starting command: %s......&amp;quot;, err.Error())
		return err
	}

	go asyncLog(stdout)
	go asyncLog(stderr)

	if err := cmd.Wait(); err != nil {
		log.Printf(&amp;quot;Error waiting for command execution: %s......&amp;quot;, err.Error())
		return err
	}

	return nil
}

&lt;/code&gt;&lt;/pre&gt;
">Golang执行shell并实时打印shell日志</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-rong-qi-de-de-refresh/"" data-c="
          &lt;p&gt;Spring容器的的refresh()【创建刷新】&lt;/p&gt;
&lt;h1 id=&#34;refresh源码&#34;&gt;refresh()源码&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        StartupStep contextRefresh = this.applicationStartup.start(&amp;quot;spring.context.refresh&amp;quot;);

        // 刷新前的预处理
        prepareRefresh();

        // 获取BeanFactory
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // BeanFactory的预处理工作，对BeanFactory进行一些赋值设置
        prepareBeanFactory(beanFactory);

        try {
            // BeanFactory准备工作完成后进行的后置处理工作
            postProcessBeanFactory(beanFactory);
            
            StartupStep beanPostProcess = this.applicationStartup.start(&amp;quot;spring.context.beans.post-process&amp;quot;);
            // 注册BeanFactory的后置处理器，执行BeanFactoryPostProcessor方法
            invokeBeanFactoryPostProcessors(beanFactory);

            // 注册Bean的后置处理器，用于拦截Bean的整个创建过程
            registerBeanPostProcessors(beanFactory);
            beanPostProcess.end();

            // 初始化MessageSource组件（做国际化功能，消息绑定，消息解析）
            initMessageSource();

            // 初始化事件派发器
            initApplicationEventMulticaster();

            // 留给子容器（子类）重写，在刷新上下文时自定义逻辑
            onRefresh();

            // 将项目中所有的ApplicationListener注册到容器中
            registerListeners();

            // 初始化所有剩下的单实例bean
            finishBeanFactoryInitialization(beanFactory);

            // 完成BeanFactory的初始化创建工作，IOC容器就创建完成
            finishRefresh();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;beanfactory的创建及预准备工作&#34;&gt;BeanFactory的创建及预准备工作&lt;/h1&gt;
&lt;h2 id=&#34;1-preparerefresh-刷新前的预处理&#34;&gt;1. prepareRefresh(); 刷新前的预处理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;initPropertySources(); 初始化一些属性设置（空），子类可实现后自定义个性化的属性设置方法&lt;/li&gt;
&lt;li&gt;getEnvironment().validateRequiredProperties(); 校验属性的合法等&lt;/li&gt;
&lt;li&gt;this.earlyApplicationEvents = new LinkedHashSet&amp;lt;&amp;gt;(); 保存容器中的一些早期的事件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-obtainfreshbeanfactory-获取beanfactory&#34;&gt;2. obtainFreshBeanFactory(); 获取BeanFactory&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;refreshBeanFactory(); 刷新【创建】BeanFactory对象
&lt;ol&gt;
&lt;li&gt;创建一个bean工厂&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;    public GenericApplicationContext() {
        this.beanFactory = new DefaultListableBeanFactory();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2. 设置id
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;getBeanFactory(); 返回刚才GenericApplicationContext创建的BeanFactory对象&lt;/li&gt;
&lt;li&gt;将创建的BeanFactory【DefaultListableBeanFactory】返回&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-preparebeanfactorybeanfactory-beanfactory的预处理工作对beanfactory进行一些赋值设置&#34;&gt;3. prepareBeanFactory(beanFactory); BeanFactory的预处理工作，对BeanFactory进行一些赋值设置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;设置BeanFactory的类加载器、支持表达式解析器...&lt;/li&gt;
&lt;li&gt;添加部分BeanPostProcessor【ApplicationContextAwareProcessor】&lt;/li&gt;
&lt;li&gt;设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、ApplicationStartupAware&lt;/li&gt;
&lt;li&gt;注册可以解析的自动装配，使我们能够在任何组件中自动注入(@Autowired)。BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext&lt;/li&gt;
&lt;li&gt;添加部分BeanPostProcessor【ApplicationListenerDetector】&lt;/li&gt;
&lt;li&gt;添加编译时的AspectJ&lt;/li&gt;
&lt;li&gt;给BeanFactory注册一些能用的组件
&lt;ol&gt;
&lt;li&gt;environment ConfigurableEnvironment&lt;/li&gt;
&lt;li&gt;systemProperties Map&amp;lt;String, Object&amp;gt;&lt;/li&gt;
&lt;li&gt;systemEnvironment Map&amp;lt;String, Object&amp;gt;&lt;/li&gt;
&lt;li&gt;applicationStartup ApplicationStartup&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-postprocessbeanfactorybeanfactory-beanfactory准备工作完成后进行的后置处理工作&#34;&gt;4. postProcessBeanFactory(beanFactory); BeanFactory准备工作完成后进行的后置处理工作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;子类可以重写此方法在BeanFactory创建并预准备完成以后做进一步的设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;beanfactory后面的流程&#34;&gt;BeanFactory后面的流程&lt;/h1&gt;
&lt;h2 id=&#34;5-invokebeanfactorypostprocessorsbeanfactory-注册beanfactory的后置处理器执行beanfactorypostprocessor方法&#34;&gt;5. invokeBeanFactoryPostProcessors(beanFactory); 注册BeanFactory的后置处理器，执行BeanFactoryPostProcessor方法&lt;/h2&gt;
&lt;p&gt;源代码位于：PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors()&lt;/p&gt;
&lt;p&gt;BeanFactoryPostProcessor:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BeanFactory的后置处理器&lt;/li&gt;
&lt;li&gt;在BeanFactory标准初始化之后执行&lt;/li&gt;
&lt;li&gt;拥有两个接口
&lt;ol&gt;
&lt;li&gt;BeanFactoryPostProcessor&lt;/li&gt;
&lt;li&gt;BeanDefinitionRegistryPostProcessor&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;执行beanfactorypostprocessor方法&#34;&gt;执行BeanFactoryPostProcessor方法&lt;/h3&gt;
&lt;p&gt;子接口[BeanDefinitionRegistryPostProcessor]具有最高优先级，其次再执行BeanFactoryPostProcessor的方法&lt;/p&gt;
&lt;h4 id=&#34;先执行beandefinitionregistrypostprocessor的方法&#34;&gt;先执行BeanDefinitionRegistryPostProcessor的方法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;获取所有的BeanDefinitionRegistryPostProcessor&lt;/li&gt;
&lt;li&gt;先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor
&lt;ol&gt;
&lt;li&gt;postProcessor.postProcessBeanDefinitionRegistry(registry);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor
&lt;ol&gt;
&lt;li&gt;postProcessor.postProcessBeanDefinitionRegistry(registry);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后执行没有实现任何优先级或顺序接口的BeanDefinitionRegistryPostProcessor
&lt;ol&gt;
&lt;li&gt;postProcessor.postProcessBeanDefinitionRegistry(registry);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;再执行beanfactorypostprocessor的方法&#34;&gt;再执行BeanFactoryPostProcessor的方法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;获取所有的BeanFactoryPostProcessor&lt;/li&gt;
&lt;li&gt;先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor
&lt;ol&gt;
&lt;li&gt;postProcessor.postProcessBeanFactory(beanFactory);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;再执行实现了Ordered顺序接口的BeanFactoryPostProcessor
&lt;ol&gt;
&lt;li&gt;postProcessor.postProcessBeanFactory(beanFactory);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后执行没有实现任何优先级或顺序接口的BeanFactoryPostProcessor
&lt;ol&gt;
&lt;li&gt;postProcessor.postProcessBeanFactory(beanFactory);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-registerbeanpostprocessorsbeanfactory-注册bean的后置处理器用于拦截bean的整个创建过程&#34;&gt;6. registerBeanPostProcessors(beanFactory); 注册Bean的后置处理器，用于拦截Bean的整个创建过程&lt;/h2&gt;
&lt;p&gt;源代码位于：PostProcessorRegistrationDelegate#registerBeanPostProcessors()&lt;/p&gt;
&lt;p&gt;不同接口类型的BeanPostProcessor，在Bean创建前后的执行时机是不一样的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BeanPostProcessor&lt;/li&gt;
&lt;li&gt;DestructionAwareBeanPostProcessor&lt;/li&gt;
&lt;li&gt;InstantiationAwareBeanPostProcessor&lt;/li&gt;
&lt;li&gt;SmartInstantiationAwareBeanPostProcessor&lt;/li&gt;
&lt;li&gt;MergedBeanDefinitionPostProcessor【internalPostProcessors】&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;执行过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取所有的BeanPostProcessor；后置处理器都默认可以通过PriorityOrdered、Ordered接口来实现优先级排序&lt;/li&gt;
&lt;li&gt;先注册PriorityOrdered优先级排序接口的BeanPostProcessor&lt;br&gt;
把每一个BeanPostProcessor都添加到BeanFactory中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;private static void registerBeanPostProcessors(
        ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanPostProcessor&amp;gt; postProcessors) {

    if (beanFactory instanceof AbstractBeanFactory) {
        // Bulk addition is more efficient against our CopyOnWriteArrayList there
        ((AbstractBeanFactory) beanFactory).addBeanPostProcessors(postProcessors);
    }
    else {
        for (BeanPostProcessor postProcessor : postProcessors) {
            beanFactory.addBeanPostProcessor(postProcessor);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;再注册Ordered接口的&lt;/li&gt;
&lt;li&gt;再注册没有实现任何优先级接口的&lt;/li&gt;
&lt;li&gt;最后注册MergedBeanDefinitionPostProcessor【internalPostProcessors】&lt;/li&gt;
&lt;li&gt;最终注册一个ApplicationListenerDetector；再Bean创建完后检查是否是ApplicationListener，如果是则将其注册到上下文中&lt;br&gt;
applicationContext.addApplicationListener((ApplicationListener&amp;lt;?&amp;gt;) bean);&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;7-initmessagesource初始化messagesource组件做国际化功能消息绑定消息解析&#34;&gt;7. initMessageSource();初始化MessageSource组件（做国际化功能，消息绑定，消息解析）&lt;/h2&gt;
&lt;p&gt;MessageSource按照区域，取出国际化配置文件中的某个key的值&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;getBeanFactory();获取BeanFactory&lt;/li&gt;
&lt;li&gt;判断容器中是否有id=messageSource的组件，类型=MessageSource
&lt;ol&gt;
&lt;li&gt;如果有，赋值给变量messageSource&lt;/li&gt;
&lt;li&gt;如果没有，自己创建一个DelegatingMessageSource&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;把创建好的MessageSource注册到容器中，后续可依赖注入&lt;br&gt;
&lt;code&gt;beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;8-initapplicationeventmulticaster初始化事件派发器&#34;&gt;8. initApplicationEventMulticaster();初始化事件派发器&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;获取BeanFactory&lt;/li&gt;
&lt;li&gt;从BeanFactory中获取ApplicationEventMulticaster的ApplicationEventMulticaster&lt;/li&gt;
&lt;li&gt;将创建的ApplicationEventMulticaster添加到BeanFactory中，后续可依赖注入&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;9-onrefresh-留给子容器子类&#34;&gt;9. onRefresh(); 留给子容器（子类）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;子类重写这个方法，在容器刷新的时候可以自定义逻辑；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;10-registerlisteners将项目中所有的applicationlistener注册到容器中&#34;&gt;10. registerListeners();将项目中所有的ApplicationListener注册到容器中&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从applicationListeners属性中拿到之前步骤中所有的ApplicationListener，注册到事件派发器中&lt;/li&gt;
&lt;li&gt;从容器中拿到所有的ApplicationListener，注册到事件派发器中&lt;br&gt;
&lt;code&gt;getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;派发（调用）之前步骤产生的事件&lt;br&gt;
&lt;code&gt;getApplicationEventMulticaster().multicastEvent(earlyEvent);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;11-finishbeanfactoryinitializationbeanfactory-初始化所有剩下的单实例bean&#34;&gt;11. finishBeanFactoryInitialization(beanFactory); 初始化所有剩下的单实例bean&lt;/h2&gt;
&lt;h3 id=&#34;111-beanfactorypreinstantiatesingletons-初始化剩下的单实例bean&#34;&gt;11.1 beanFactory.preInstantiateSingletons(); - 初始化剩下的单实例bean&lt;/h3&gt;
&lt;h4 id=&#34;1111-获取容器中的所有bean依次进行初始化和创建对象&#34;&gt;11.1.1 获取容器中的所有bean，依次进行初始化和创建对象&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; beanNames = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames);
// Trigger initialization of all non-lazy singleton beans...
for (String beanName : beanNames) {
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1112-获取bean的定义信息rootbeandefinition&#34;&gt;11.1.2 获取bean的定义信息RootBeanDefinition&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;1113-bean不是抽象的是单实例的不是懒加载的&#34;&gt;11.1.3 Bean不是抽象的，是单实例的，不是懒加载的&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !bd.isLazyInit()&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;11131-判断是否是factorybean是否是实现factorybean接口的bean&#34;&gt;11.1.3.1 判断是否是FactoryBean，是否是实现FactoryBean接口的bean&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;如果是，则利用FactoryBean接口的&lt;code&gt;FactoryBean#getObject&lt;/code&gt;获取对象&lt;/li&gt;
&lt;li&gt;如果不是，利用&lt;code&gt;getBean(beanName)&lt;/code&gt;创建对象&lt;br&gt;
0. getBean(beanName) -&amp;gt; 与ApplicationContext#getBean一致
&lt;ol&gt;
&lt;li&gt;doGetBean(name, null, null, false);&lt;/li&gt;
&lt;li&gt;先获取缓存中保存的单实例bean，如果能获取到，说明之前被创建过。（所有创建过的单实例Bean都会被缓存起来）&lt;/li&gt;
&lt;li&gt;getSingleton(beanName, true);&lt;br&gt;
&lt;code&gt;private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap&amp;lt;&amp;gt;(256);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;缓存中获取不到，开始创建对象流程&lt;/li&gt;
&lt;li&gt;标记当前bean已被创建 &lt;code&gt;markBeanAsCreated(beanName);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取Bean的定义信息&lt;br&gt;
&lt;code&gt;RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;【&lt;strong&gt;获取当前Bean依赖的其他bean，如果有按照getBean()把依赖的Bean先创建出来&lt;/strong&gt;】&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;String[] dependsOn = mbd.getDependsOn();
    if (dependsOn != null) {
        for (String dep : dependsOn) {
            ...
            registerDependentBean(dep, beanName);
            getBean(dep);
            ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;启动单实例Bean的创建流程 &lt;code&gt;mbd.isSingleton()&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory)&lt;/li&gt;
&lt;li&gt;createBean(beanName, mbd, args);&lt;/li&gt;
&lt;li&gt;resolveBeforeInstantiation(beanName, mbdToUse); 让BeanPostProcessor先提前拦截返回Bean代理对象&lt;br&gt;
【&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;】: 提前执行&lt;br&gt;
先触发：Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);&lt;br&gt;
如果有返回值，再触发：processor.postProcessAfterInitialization(result, beanName);&lt;/li&gt;
&lt;li&gt;Object beanInstance = doCreateBean(beanName, mbdToUse, args);
&lt;ol&gt;
&lt;li&gt;【创建Bean实例】：createBeanInstance(beanName, mbd, args);&lt;br&gt;
利用工厂方法或者对象的构造器创建出Bean实例&lt;/li&gt;
&lt;li&gt;applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);&lt;br&gt;
调用【MergedBeanDefinitionPostProcessor】的&lt;code&gt;processor.postProcessMergedBeanDefinition(mbd, beanType, beanName);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;【bean属性赋值】populateBean(beanName, mbd, instanceWrapper);&lt;br&gt;
赋值之前：
&lt;ol&gt;
&lt;li&gt;拿到InstantiationAwareBeanPostProcessor后置处理器&lt;br&gt;
执行&lt;code&gt;postProcessAfterInstantiation&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;拿到InstantiationAwareBeanPostProcessor后置处理器&lt;br&gt;
执行&lt;code&gt;postProcessPropertyValues&lt;/code&gt;方法&lt;br&gt;
=&lt;mark&gt;赋值之前&lt;/mark&gt;=&lt;/li&gt;
&lt;li&gt;应用bean属性的值，利用setter为属性赋值&lt;br&gt;
&lt;code&gt;applyPropertyValues(beanName, mbd, bw, pvs);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;【Bean初始化】initializeBean(beanName, exposedObject, mbd);
&lt;ol&gt;
&lt;li&gt;【执行Aware接口方法】invokeAwareMethods(beanName, wrappedBean, mbd);执行XXX_Aware接口为Aware属性赋值&lt;br&gt;
&lt;code&gt;BeanNameAware/BeanClassLoaderAware/BeanFactoryAware&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);&lt;br&gt;
&lt;code&gt;processor.postProcessBeforeInitialization(result, beanName);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);
&lt;ol&gt;
&lt;li&gt;是否是InitializingBean接口的实现，执行接口规定的初始化方法&lt;/li&gt;
&lt;li&gt;是否有自定义初始化方法 &lt;code&gt;String initMethodName = mbd.getInitMethodName();&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;【执行后置处理器初始化之后的方法】applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);&lt;br&gt;
&lt;code&gt;processor.postProcessAfterInitialization(result, beanName); &lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;5. 【注册bean的销毁方法】registerDisposableBeanIfNecessary(beanName, bean, mbd); 实现`DisposableBean`接口
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;将创建的bean添加到缓存&lt;code&gt;DefaultSingletonBeanRegistry#addSingleton&lt;/code&gt;中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;12-finishrefresh完成beanfactory的初始化创建工作ioc容器就创建完成&#34;&gt;12. finishRefresh();完成BeanFactory的初始化创建工作，IOC容器就创建完成&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;clearResourceCaches(); 清除上下文级别的资源缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;initLifecycleProcessor();初始化和生命周期有关的后置处理器：LifecycleProcessor&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认从容器中找是否存在名为lifecycleProcessor的组件[LifecycleProcessor]，如果没有就创建&lt;code&gt;new DefaultLifecycleProcessor();&lt;/code&gt;，然后加入到容器中&lt;/li&gt;
&lt;li&gt;自定义实现LifecycleProcessor接口，可以接收到两个回调
&lt;ol&gt;
&lt;li&gt;void onRefresh(); - 上下文刷新的通知&lt;/li&gt;
&lt;li&gt;void onClose(); - 上下文关闭的通知&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;getLifecycleProcessor().onRefresh(); 拿到刚才获取的生命周期处理器，回调&lt;code&gt;onRefresh()&lt;/code&gt;事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;publishEvent(new ContextRefreshedEvent(this)); - 发布容器刷新完成事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;在Spring启动时，先会保存所有注册进来的Bean定义信息
&lt;ol&gt;
&lt;li&gt;xml注册&lt;/li&gt;
&lt;li&gt;@Bean、@Component...&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Spring会在适当的时候创建对应的Bean
&lt;ol&gt;
&lt;li&gt;用到这个bean的时候，利用getBean创建&lt;/li&gt;
&lt;li&gt;启动时统一创建剩下的所有Bean，&lt;code&gt;finishBeanFactoryInitialization(beanFactory)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;后置处理器 BeanPostProcessor
&lt;ol&gt;
&lt;li&gt;每一个Bean创建完成后，都会使用各种后置处理器增强Bean的功能
&lt;ol&gt;
&lt;li&gt;AutowiredAnnotationBeanPostProcessor: 处理自动注入&lt;/li&gt;
&lt;li&gt;AsyncAnnotationBeanPostProcessor: 处理异步&lt;/li&gt;
&lt;li&gt;AnnotationAwareAspectJAutoProxyCreator: 处理AOP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;事件驱动模型
&lt;ol&gt;
&lt;li&gt;ApplicationListener：事件监听&lt;/li&gt;
&lt;li&gt;AnnotationAwareAspectJAutoProxyCreator：事件派发器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Spring容器的的refresh()</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/gin-can-shu-yan-zheng/"" data-c="
          &lt;h2 id=&#34;普通验证&#34;&gt;普通验证&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
更多验证规则
https://pkg.go.dev/gopkg.in/bluesuncorp/validator.v8#section-documentation
*/
type Student struct {
	Name string `form:&amp;quot;name&amp;quot; json:&amp;quot;name&amp;quot; binding:&amp;quot;required&amp;quot;`
	// binding 逗号分割表示并且, | 分割表示或者(满足一项)
	Age      int       `form:&amp;quot;age&amp;quot; json:&amp;quot;age&amp;quot; binding:&amp;quot;required,gt=10&amp;quot;`
	Birthday time.Time `form:&amp;quot;birthday&amp;quot; time_format:&amp;quot;2006-01-02 15:04:05&amp;quot; json:&amp;quot;birthday&amp;quot;`
}

func main() {

	r := gin.Default()
	r.POST(&amp;quot;test&amp;quot;, func(context *gin.Context) {

		var student Student
		// 根据不同的context-type,做不同的映射
		if err := context.ShouldBind(&amp;amp;student); err != nil {
			context.String(http.StatusBadRequest, &amp;quot;student bind error %v&amp;quot;, err.Error())
			return
		}

		context.JSON(http.StatusOK, student)
	})

	r.Run()

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自定义验证&#34;&gt;自定义验证&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
更多验证规则
https://pkg.go.dev/gopkg.in/bluesuncorp/validator.v8#section-documentation
*/
type Booking struct {
	// 时间必须符合bookabledate检查
	ChinkIn time.Time `form:&amp;quot;checkIn&amp;quot; json:&amp;quot;chink_in&amp;quot; binding:&amp;quot;required,bookabledate&amp;quot; time_format:&amp;quot;2006-01-02&amp;quot;`
	// 时间必须大于ChinkIn
	ChinkOut time.Time `form:&amp;quot;checkOut&amp;quot; json:&amp;quot;chink_out&amp;quot; binding:&amp;quot;required,gtfield=ChinkIn&amp;quot; time_format:&amp;quot;2006-01-02&amp;quot;`
}

func bookableDate(fl validator.FieldLevel) bool {

	if date, ok := fl.Field().Interface().(time.Time); ok {
		// 大于今天
		return date.Unix() &amp;gt; time.Now().Unix()
	}
	return false
}

func main() {

	r := gin.Default()

	// 注册验证规则
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		err := v.RegisterValidation(&amp;quot;bookabledate&amp;quot;, bookableDate)
		if err != nil {
			for _, e := range err.(validator.ValidationErrors) {
				fmt.Println(e)
			}
		}
	}

	r.POST(&amp;quot;test&amp;quot;, func(context *gin.Context) {

		var booking Booking
		// 根据不同的context-type,做不同的映射
		if err := context.ShouldBind(&amp;amp;booking); err != nil {
			context.String(http.StatusBadRequest, &amp;quot;booking bind error %v&amp;quot;, err.Error())
			return
		}

		context.JSON(http.StatusOK, booking)
	})

	r.Run()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;i18n验证&#34;&gt;i18n验证&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	en2 &amp;quot;github.com/go-playground/locales/en&amp;quot;
	zh2 &amp;quot;github.com/go-playground/locales/zh&amp;quot;
	ut &amp;quot;github.com/go-playground/universal-translator&amp;quot;
	&amp;quot;gopkg.in/go-playground/validator.v9&amp;quot;
	en_translations &amp;quot;gopkg.in/go-playground/validator.v9/translations/en&amp;quot;
	zh_translations &amp;quot;gopkg.in/go-playground/validator.v9/translations/zh&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;time&amp;quot;
)

/**
更多验证规则
https://pkg.go.dev/gopkg.in/bluesuncorp/validator.v8#section-documentation
*/
type Student struct {
	Name string `form:&amp;quot;name&amp;quot; json:&amp;quot;name&amp;quot; validate:&amp;quot;required&amp;quot;`
	Age      int       `form:&amp;quot;age&amp;quot; json:&amp;quot;age&amp;quot; validate:&amp;quot;required,gt=10&amp;quot;`
	Birthday time.Time `form:&amp;quot;birthday&amp;quot; time_format:&amp;quot;2006-01-02 15:04:05&amp;quot; json:&amp;quot;birthday&amp;quot;`
}

var (
	Uni *ut.UniversalTranslator
	Validate *validator.Validate
)

func main() {

	// 初始化验证器
	initValidator()

	r := gin.Default()

	r.GET(&amp;quot;test&amp;quot;, func(context *gin.Context) {

		// 根据不同语言,加载不同的验证器
		locale := context.DefaultQuery(&amp;quot;locale&amp;quot;, &amp;quot;zh&amp;quot;)
		translator, _ := Uni.GetTranslator(locale)
		switch locale {
		case &amp;quot;zh&amp;quot;:
			_ = zh_translations.RegisterDefaultTranslations(Validate, translator)
		case &amp;quot;en&amp;quot;:
			_ = en_translations.RegisterDefaultTranslations(Validate, translator)
		default:
			_ = zh_translations.RegisterDefaultTranslations(Validate, translator)
		}

		// 根据不同的context-type,做不同的映射
		var student Student
		if err := context.ShouldBind(&amp;amp;student); err != nil {
			context.String(http.StatusBadRequest, &amp;quot;student bind error %v&amp;quot;, err.Error())
			context.Abort()
			return
		}

		// 验证
		if valid(context, student, translator) {
			return
		}

		context.JSON(http.StatusOK, student)
	})

	r.Run()

	//➜  github.com curl -X GET &amp;quot;localhost:8080/test?name=xxx&amp;amp;bbb=ddd&amp;amp;locale=zh&amp;amp;age=2&amp;quot;
	//student validate error [Age必须大于10]%                                                                                                                                                                     ➜  github.com curl -X GET &amp;quot;localhost:8080/test?name=xxx&amp;amp;bbb=ddd&amp;amp;locale=en&amp;amp;age=2&amp;quot;
	//➜  github.com curl -X GET &amp;quot;localhost:8080/test?name=xxx&amp;amp;bbb=ddd&amp;amp;locale=en&amp;amp;age=2&amp;quot;
	//student validate error [Age must be greater than 10]%

}

func valid(context *gin.Context, student Student, translator ut.Translator) bool {
	if err := Validate.Struct(student); err != nil {
		errors := err.(validator.ValidationErrors)
		sliceErrors := []string{}
		for _, e := range errors {
			sliceErrors = append(sliceErrors, e.Translate(translator))
		}
		context.String(http.StatusBadRequest, &amp;quot;student validate error %v&amp;quot;, sliceErrors)
		context.Abort()
		return true
	}
	return false
}

func initValidator() {
	Validate = validator.New()
	zh := zh2.New()
	en := en2.New()
	Uni = ut.New(zh, en)
}

&lt;/code&gt;&lt;/pre&gt;
">Gin 参数验证</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/gin-ji-ben-zhi-shi/"" data-c="
          &lt;p&gt;相关代码位置：&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/golang/imooc-gin-study&#34;&gt;https://github.com/imyzt/learning-technology-code/tree/master/golang/imooc-gin-study&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;httpmethod-start&#34;&gt;httpMethod start&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/gin-gonic/gin&amp;quot;

func main() {

	// 简单gin使用
	r := gin.Default()
	r.GET(&amp;quot;/get&amp;quot;, func(context *gin.Context) {
		context.JSON(200, gin.H{
			&amp;quot;message&amp;quot;: &amp;quot;get&amp;quot;,
		})
	})
	r.POST(&amp;quot;/post&amp;quot;, func(context *gin.Context) {
		context.JSON(200, gin.H{
			&amp;quot;message&amp;quot;: &amp;quot;post&amp;quot;,
		})
	})
	r.DELETE(&amp;quot;/delete&amp;quot;, func(context *gin.Context) {
		context.JSON(200, gin.H{
			&amp;quot;message&amp;quot;: &amp;quot;delete&amp;quot;,
		})
	})
	r.PUT(&amp;quot;/put&amp;quot;, func(context *gin.Context) {
		context.JSON(200, gin.H{
			&amp;quot;message&amp;quot;: &amp;quot;put&amp;quot;,
		})
	})
	// 支持任意请求
	r.Any(&amp;quot;/any&amp;quot;, func(context *gin.Context) {
		context.String(200, &amp;quot;any&amp;quot;)
	})

	r.Run()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rest参数&#34;&gt;rest参数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.GET(&amp;quot;:name/:id&amp;quot;, func(context *gin.Context) {
    context.JSON(200, gin.H{
        &amp;quot;name&amp;quot;: context.Param(&amp;quot;name&amp;quot;),
        &amp;quot;id&amp;quot;: context.Param(&amp;quot;id&amp;quot;),
    })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;开放静态资源&#34;&gt;开放静态资源&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 静态文件夹
r.Static(&amp;quot;/asserts&amp;quot;, &amp;quot;./asserts&amp;quot;)
// 静态文件目录
r.StaticFS(&amp;quot;/static&amp;quot;, http.Dir(&amp;quot;/Users/imyzt/Downloads/&amp;quot;))
// 静态文件
r.StaticFile(&amp;quot;/test.html&amp;quot;, &amp;quot;./test.html&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;泛匹配&#34;&gt;泛匹配&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.GET(&amp;quot;/name/*action&amp;quot;, func(context *gin.Context) {
    context.String(200, &amp;quot;helloWorld&amp;quot;)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取get请求参数&#34;&gt;获取GET请求参数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.GET(&amp;quot;/test&amp;quot;, func(context *gin.Context) {
    firstName := context.Query(&amp;quot;firstName&amp;quot;)
    // 默认值
    lastName := context.DefaultQuery(&amp;quot;lastName&amp;quot;, &amp;quot;defaultLastName&amp;quot;)
    context.JSON(http.StatusOK, gin.H{
        &amp;quot;firstName&amp;quot;: firstName,
        &amp;quot;lastName&amp;quot;:  lastName,
    })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取post-form-data请求参数&#34;&gt;获取POST form-data请求参数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.POST(&amp;quot;/test&amp;quot;, func(context *gin.Context) {
    firstName := context.PostForm(&amp;quot;firstName&amp;quot;)
    // 默认值
    lastName := context.DefaultPostForm(&amp;quot;lastName&amp;quot;, &amp;quot;defaultLastName&amp;quot;)
    context.JSON(http.StatusOK, gin.H{
        &amp;quot;firstName&amp;quot;: firstName,
        &amp;quot;lastName&amp;quot;:  lastName,
    })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取post-body请求参数&#34;&gt;获取POST body请求参数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r.POST(&amp;quot;/test&amp;quot;, func(context *gin.Context) {

    bodyBytes, err := ioutil.ReadAll(context.Request.Body)
    if err != nil {
        context.String(http.StatusBadRequest, err.Error())
        context.Abort()
    }

    // 回传, 方便获取参数
    context.Request.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))

    // 默认值
    name := context.DefaultPostForm(&amp;quot;name&amp;quot;, &amp;quot;defaultName&amp;quot;)
    context.String(http.StatusOK, &amp;quot;%s - %s&amp;quot;, name, string(bodyBytes))
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CURL输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//curl -X POST &amp;quot;localhost:8080/test&amp;quot; -d &#39;name=xxx&amp;amp;bbb=ddd&#39;
//xxx - name=xxx&amp;amp;bbb=ddd%
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;getpost请求参数映射到struct&#34;&gt;GET/POST请求参数映射到struct&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Student struct {
	Name string `form:&amp;quot;name&amp;quot; json:&amp;quot;name&amp;quot;`
	Addr string `form:&amp;quot;addr&amp;quot; json:&amp;quot;addr&amp;quot;`
	Birthday time.Time `form:&amp;quot;birthday&amp;quot; time_format:&amp;quot;2006-01-02 15:04:05&amp;quot; json:&amp;quot;birthday&amp;quot;`
}
func main() {

	r := gin.Default()

	r.POST(&amp;quot;test&amp;quot;, test)
	r.GET(&amp;quot;test&amp;quot;, test)

	r.Run()
}

func test(context *gin.Context) {

	var student Student
	// 根据不同的context-type,做不同的映射
	if err := context.ShouldBind(&amp;amp;student); err != nil {
		context.String(http.StatusBadRequest, &amp;quot;student bind error %v&amp;quot;, err.Error())
		return
	}

	context.JSON(http.StatusOK, student)
}

&lt;/code&gt;&lt;/pre&gt;
">Gin基本知识</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-find-methods-by-annotation/"" data-c="
          &lt;p&gt;在Spring环境中，查找Bean是非常方便的，但是如果是需要查询方法上的注解进行反射调用或其它，则极其不方便。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;MethodIntrospector.selectMethods&lt;/code&gt;工具方法，通过遍历所有@Component Bean的方式，挨个查找。&lt;/p&gt;
&lt;p&gt;示例代码如下，既能拿到Method对象，又可以拿到注解信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; beans = applicationContext.getBeansWithAnnotation(Component.class);
beans.forEach((beanName, handler) -&amp;gt; {

    Map&amp;lt;Method, AnalysisListener&amp;gt; methodAnalysisListenerMap = MethodIntrospector.selectMethods(handler.getClass(),
            (MethodIntrospector.MetadataLookup&amp;lt;AnalysisListener&amp;gt;) method -&amp;gt; AnnotatedElementUtils.findMergedAnnotation(method, AnalysisListener.class));

});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AnalysisListener.class&lt;/code&gt;为自定义注解&lt;/p&gt;
">Spring Find Methods By Annotation </a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/redis-lua-ratelimiter/"" data-c="
          &lt;p&gt;参考文章：&lt;a href=&#34;https://mp.weixin.qq.com/s/ewjGZCgc_TUhiZIINCLfbg&#34;&gt;基于Redis的限流系统的设计&lt;/a&gt;&lt;br&gt;
本文作为总结和回顾&lt;/p&gt;
&lt;h1 id=&#34;限流脚本&#34;&gt;限流脚本&lt;/h1&gt;
&lt;p&gt;首先需要引入的是redis的LUA脚本.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
--- 判断source_str 中是否contains pattern_str
--- @param source_str
--- @param patter_str
local function contains(source_str, sub_str)
    local start_pos, end_pos = string.find(source_str, sub_str);
    if start_pos == nil then
        return false;
    end
    local source_str_len = string.len(source_str);

    if source_str_len == end_pos then
        return true
    elseif string.sub(source_str, end_pos + 1, end_pos + 1) == &amp;quot;,&amp;quot; then
        return true
    end
    return false;
end


--- 获取令牌
--- 返回码
--- 0 没有令牌桶配置
--- -1 表示取令牌失败，也就是桶里没有令牌
--- 1 表示取令牌成功
--- @param key 令牌的唯一标识
--- @param permits  请求令牌数量
--- @param curr_mill_second 当前毫秒数
--- @param context 使用令牌的应用标识
local function acquire(key, permits, curr_mill_second, context)
    local rate_limit_info = redis.pcall(&amp;quot;HMGET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, &amp;quot;curr_permits&amp;quot;, &amp;quot;max_permits&amp;quot;, &amp;quot;rate&amp;quot;, &amp;quot;apps&amp;quot;)
    local last_mill_second = rate_limit_info[1]
    local curr_permits = tonumber(rate_limit_info[2])
    local max_permits = tonumber(rate_limit_info[3])
    local rate = rate_limit_info[4]
    local apps = rate_limit_info[5]

    --- 标识没有配置令牌桶
    if type(apps) == &#39;boolean&#39; or apps == nil or not contains(apps, context) then
        return 0
    end


    local local_curr_permits = max_permits;

    --- 第一次, 没有last_mill_second, 所以local_curr_permits = max_permits, 
    --- 首先设置 redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second) 将上次更新时间修改为现在
    --- 然后直接进入到最下面 redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits - permits) 用最大速率-自己用的这一次
    
    --- 第二次, 有last_mill_second, 走进去if的逻辑
    --- reverse_permits -&amp;gt; 时间差转换成秒, 然后乘以每秒的速率rage -&amp;gt; 得到每秒需要添加多少个令牌
    
    --- 第二次

    --- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空
    --- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌，并且更新上一次向桶里添加令牌的时间
    --- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间
    if (type(last_mill_second) ~= &#39;boolean&#39;  and last_mill_second ~= nil) then
        --- 当前消耗时间内 -&amp;gt; 需要添加多少个令牌
        --- 假设curr_mill_second - last_mill_second = 100ms,rate=10, 100ms/1000=0.1s * 10 = 1个
        --- 假设curr_mill_second - last_mill_second = 1000000ms,rate=10, 1000000ms/1000=1000s * 10 = 1w个 -》 说明很久没有访问了，下面math.min就会丢弃掉多的
        --- 即刚过去的这一段时间, 需要往桶里面添加1个令牌  
        local reverse_permits = math.floor(((curr_mill_second - last_mill_second) / 1000) * rate)
        --- 需要+的 + 当前还剩余的令牌 = 期望当前的令牌数量
        local expect_curr_permits = reverse_permits + curr_permits;
        --- 将期望的和最大速率比对, 取小的, 防止超载
        --- 多于最大速率后的漏（丢弃策略）
        local_curr_permits = math.min(expect_curr_permits, max_permits);

        --- 大于0表示不是第一次获取令牌，也没有向桶里添加令牌
        --- 如果当前消耗时间内需要添加令牌, 设置最新的添加时间为当前时间 
        if (reverse_permits &amp;gt; 0) then
            redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second)
        end
    else
        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second)
    end


    local result = -1
    if (local_curr_permits - permits &amp;gt;= 0) then
        result = 1
        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits - permits)
    else
        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits)
    end

    return result
end


--- 初始化令牌桶配置
--- @param key 令牌的唯一标识
--- @param max_permits 桶大小
--- @param rate  向桶里添加令牌的速率
--- @param apps  可以使用令牌桶的应用列表，应用之前用逗号分隔
local function init(key, max_permits, rate, apps)
    local rate_limit_info = redis.pcall(&amp;quot;HMGET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, &amp;quot;curr_permits&amp;quot;, &amp;quot;max_permits&amp;quot;, &amp;quot;rate&amp;quot;, &amp;quot;apps&amp;quot;)
    local org_max_permits = tonumber(rate_limit_info[3])
    local org_rate = rate_limit_info[4]
    local org_apps = rate_limit_info[5]

    if (org_max_permits == nil) or (apps ~= org_apps or rate ~= org_rate or max_permits ~= org_max_permits) then
        redis.pcall(&amp;quot;HMSET&amp;quot;, key, &amp;quot;max_permits&amp;quot;, max_permits, &amp;quot;rate&amp;quot;, rate, &amp;quot;curr_permits&amp;quot;, max_permits, &amp;quot;apps&amp;quot;, apps)
    end
    return 1;
end


--- 删除令牌桶
local function delete(key)
    redis.pcall(&amp;quot;DEL&amp;quot;, key)
    return 1;
end


local key = KEYS[1]
local method = ARGV[1]

if method == &#39;acquire&#39; then
    return acquire(key, ARGV[2], ARGV[3], ARGV[4])
elseif method == &#39;init&#39; then
    return init(key, ARGV[2], ARGV[3], ARGV[4])
elseif method == &#39;delete&#39; then
    return delete(key)
else
    --ignore
end


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;LUA的下标是从1开始的&lt;/li&gt;
&lt;li&gt;LUA的KEYS是调用方逗号分割前一部分，ARGV是后一部分。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整个脚本包含了4个方法，入口处使用ARGV[1]判断，决定调用哪一个方法&lt;/p&gt;
&lt;p&gt;其核心使用了一个 &lt;code&gt;HASH&lt;/code&gt; 来存放策略信息。其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;max_permits -&amp;gt; 每秒最大速率&lt;/li&gt;
&lt;li&gt;rate -&amp;gt; 每秒放入速率&lt;/li&gt;
&lt;li&gt;curr_permits -&amp;gt; 当前速率&lt;/li&gt;
&lt;li&gt;apps -&amp;gt; 应用列表&lt;/li&gt;
&lt;li&gt;last_mill_second -&amp;gt; 上次添加令牌时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;delete&#34;&gt;delete&lt;/h2&gt;
&lt;p&gt;delete方法最为简单，就是调用DEL删除key即可，相当于删除了访问控制的策略。&lt;/p&gt;
&lt;h2 id=&#34;init&#34;&gt;init&lt;/h2&gt;
&lt;p&gt;初始化方法即将数据库或其他三方的元数据，加载到redis中，以redis的数据格式 &lt;code&gt;Hash&lt;/code&gt; 存储。&lt;br&gt;
此方法是幂等的，在加入之前会进行判断，如果没有才会添加。&lt;/p&gt;
&lt;h2 id=&#34;acquire&#34;&gt;acquire&lt;/h2&gt;
&lt;p&gt;此方法最为核心，是从桶中获取令牌的动作，并且模拟RateLimiter实现了触发式添加，从而提升QPS。&lt;/p&gt;
&lt;p&gt;方法前面内容均为赋值操作和基本判空操作，没什么好说的。&lt;br&gt;
从&lt;code&gt;local local_curr_permits = max_permits;&lt;/code&gt;便开始了触发式添加动作。&lt;br&gt;
从&lt;code&gt;if (local_curr_permits - permits &amp;gt;= 0) then&lt;/code&gt;开始消耗动作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--- 获取令牌
--- 返回码
--- 0 没有令牌桶配置
--- -1 表示取令牌失败，也就是桶里没有令牌
--- 1 表示取令牌成功
--- @param key 令牌的唯一标识
--- @param permits  请求令牌数量
--- @param curr_mill_second 当前毫秒数
--- @param context 使用令牌的应用标识
local function acquire(key, permits, curr_mill_second, context)
    local rate_limit_info = redis.pcall(&amp;quot;HMGET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, &amp;quot;curr_permits&amp;quot;, &amp;quot;max_permits&amp;quot;, &amp;quot;rate&amp;quot;, &amp;quot;apps&amp;quot;)
    local last_mill_second = rate_limit_info[1]
    local curr_permits = tonumber(rate_limit_info[2])
    local max_permits = tonumber(rate_limit_info[3])
    local rate = rate_limit_info[4]
    local apps = rate_limit_info[5]

    if type(apps) == &#39;boolean&#39; or apps == nil or not contains(apps, context) then
        return 0
    end

    --- 将当前令牌调整为配置的最大速率
    local local_curr_permits = max_permits;

    --- 此处为触发式添加令牌动作
    --- 判断是否有上次添加令牌时间, 此处有三种情况:
    --- 1. 第一次进来, last_mill_second = nil, 直接走进else, 然后消耗令牌
    --- 2. 第二次进来, 分为两种情况
    --- 2.1 在第一次后的1秒内访问, 即下方情况1
    --- 2.2 在第一次后的1秒后访问, 即下方情况2
    if (type(last_mill_second) ~= &#39;boolean&#39;  and last_mill_second ~= nil) then
        --- 向下取整(距离上次添加过去多少秒 * rate) = 需要向令牌桶添加的令牌数量
        --- 假设rate=10, max_permits=10
        --- 情况1: 距离上次添加过去多少秒 &amp;lt; 1秒 假设=0.2秒 * 10 = 2个令牌
        --- 情况2: 距离上次添加过去多少秒 &amp;gt; 1秒 假设=10秒 * 10 = 100个令牌
        local reverse_permits = math.floor(((curr_mill_second - last_mill_second) / 1000) * rate)
        --- 本次需要添加的令牌 + 剩余的令牌 = 期望令牌数量
        --- 情况1: 可能出现两种情况
        --- 情况1.1 reverse_permits = 2, curr_permits &amp;gt;= 9 , 即桶中还只消耗1个或没有消耗, 但是本次需要添加2个, 多了, 下方min函数会将其漏掉
        --- 情况1.2 reverse_permits = 2, curr_permits &amp;lt; 9 , 即桶中消耗了超过2个, 本次添加2个, 符合
        --- 情况2: 绝对多了, 下方min函数会将其漏掉
        local expect_curr_permits = reverse_permits + curr_permits;
        --- 此处解决上面两种情况, 防止过载(即将多的令牌丢弃的动作)
        --- 情况1: 期望令牌 &amp;lt; max_permits(10), 设置期望令牌到当前令牌
        --- 情况2: 期望令牌 &amp;gt; max_permits(10), 设置最大令牌到当前令牌 -&amp;gt; 即很久没有访问后的一次访问动作
        local_curr_permits = math.min(expect_curr_permits, max_permits);

        --- 如果需要向令牌桶添加的令牌数量 &amp;gt; 0, 就更新上次添加令牌时间
        if (reverse_permits &amp;gt; 0) then
            redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second)
        end
    else
        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second)
    end


    local result = -1
    --- 当前令牌 够本次 申请的令牌数量
    if (local_curr_permits - permits &amp;gt;= 0) then
        result = 1
        --- 消耗令牌
        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits - permits)
    else
        --- 上面的if不满足, 即令牌没有了
        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits)
    end

    return result
end

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;java客户端编写&#34;&gt;Java客户端编写&lt;/h1&gt;
&lt;h2 id=&#34;载入脚本&#34;&gt;载入脚本&lt;/h2&gt;
&lt;p&gt;整个脚本较大，可以事先载入到redis服务器，采用SHA1串访问。&lt;br&gt;
多个实例创建多份rateLimiterLua也无妨，因为是同一个脚本文件内容，创建出来的sha1串也是一致的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Bean
public DefaultRedisScript&amp;lt;Long&amp;gt; rateLimiterLua() {
    DefaultRedisScript&amp;lt;Long&amp;gt; redisScript = new DefaultRedisScript&amp;lt;&amp;gt;();
    redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(&amp;quot;scripts/rate_limiter.lua&amp;quot;)));
    redisScript.setResultType(Long.class);
    return redisScript;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编写java访问客户端&#34;&gt;编写Java访问客户端&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;init() - 初始化访问策略&lt;/li&gt;
&lt;li&gt;acquire() - 获取令牌&lt;/li&gt;
&lt;li&gt;delete() - 删除访问策略&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;public class RateLimiterClient {

    @Autowired
    @Qualifier(&amp;quot;longRedisTemplate&amp;quot;)
    private RedisTemplate&amp;lt;String, Long&amp;gt; longRedisTemplate;
    @Autowired
    private RedisTemplate&amp;lt;String, String&amp;gt; redisTemplate;

    @Resource
    private RedisScript&amp;lt;Long&amp;gt; rateLimiterLua;

    /**
     * 获取访问令牌
     * @param context 应用名称
     * @param key 限制速率key
     * @param permits 获取令牌数量
     * @return token
     */
    public Token acquireToken(String context, String key, Integer permits) {

        Token token;
        try {
            // redis当前时间
            Long currMillSecond = longRedisTemplate.execute(RedisServerCommands::time);
            // 获取令牌
            Long acquire = longRedisTemplate.execute(rateLimiterLua, ImmutableList.of(getKey(key)), RATE_LIMITER_ACQUIRE_METHOD, permits.toString(), currMillSecond, context);

            if (acquire == null) {
                log.error(&amp;quot;no rate limit config for context = {}&amp;quot;, context);
                return Token.NO_CONFIG;
            }

            if (acquire == 1) {
                token = Token.PASS;
            } else if (acquire == -1) {
                token = Token.FUSING;
            } else {
                log.error(&amp;quot;no rate limit config for context = {}&amp;quot;, context);
                token = Token.NO_CONFIG;
            }
        } catch (Exception e) {
            log.error(&amp;quot;get rage limit token for redis error, key = &amp;quot; + key, e);
            token = Token.ACCESS_REDIS_FAIL;
        }
        return token;
    }

    public void deleteRateLimiter(String key) {
        redisTemplate.execute(rateLimiterLua, ImmutableList.of(getKey(key)), RATE_LIMITER_DELETE_METHOD);
    }

    public void initRateLimiter(String code, Integer maxPermits, Integer rate, String apps) {
        redisTemplate.execute(rateLimiterLua,
                ImmutableList.of(getKey(code)),
                RATE_LIMITER_INIT_METHOD,
                maxPermits.toString(),
                rate.toString(),
                apps);
    }
    
    private String getKey(String key) {
        return RateLimiterConstants.RATE_LIMITER_KEY_PREFIX + key;
    }

}
&lt;/code&gt;&lt;/pre&gt;
">Redis LUA RateLimiter</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/shou-xie-yi-ge-springboot-conditionon/"" data-c="
          &lt;h1 id=&#34;springboot自带的conditional&#34;&gt;SpringBoot自带的Conditional&lt;/h1&gt;
&lt;p&gt;打开任意*AutoConfiguration文件，一般都有下面的条件注解，在spring-boot-autoconfigure-1.5.3.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下条件注解如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@ConditionalOnBean：当前容器有指定Bean的条件下。&lt;/li&gt;
&lt;li&gt;@ConditionalOnClass：当前类路径下有指定的类的条件下。&lt;/li&gt;
&lt;li&gt;@ConditionalOnExpression：基于SpEL表达式作为判断条件。&lt;/li&gt;
&lt;li&gt;@ConditionalOnJava：基于JVM版本作为判断条件。&lt;/li&gt;
&lt;li&gt;@ConditionalOnJndi：在JNDI存在的条件下查找指定的位置。&lt;/li&gt;
&lt;li&gt;@ConditionalOnMissingBean：当容器里没有指定Bean的情况下。&lt;/li&gt;
&lt;li&gt;@ConditionalOnMissingClass：当类路径下没有指定的类的条件下。&lt;/li&gt;
&lt;li&gt;@ConditionalOnNotWebApplication：当前项目不是WEB项目的条件下。&lt;/li&gt;
&lt;li&gt;@ConditionalOnProperty：指定属性是否有指定的值。&lt;/li&gt;
&lt;li&gt;@ConditionalOnResource：类路径是否有指定的值。&lt;/li&gt;
&lt;li&gt;@ConditionalOnSingleCandidate：当指定Bean在容器中只有一个，或者虽然有多个但 是指定首选的Bean。&lt;/li&gt;
&lt;li&gt;@ConditionalOnWebApplication：当前项目是WEB项目的条件下。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些注解都组合了@Conditional元注解，只是使用了不同的条件（Conditional），Spring 条件注解（@Conditional）我们介绍过根据不同条件创建不同Bean。&lt;br&gt;
虽然平时使用的多，但是没怎么了解过是怎么实现的，其实就是实现&lt;code&gt;org.springframework.context.annotation.Condition&lt;/code&gt;的不同子类做不同的扩展即可。&lt;/p&gt;
&lt;h1 id=&#34;手写一个&#34;&gt;手写一个&lt;/h1&gt;
&lt;h2 id=&#34;注解&#34;&gt;注解&lt;/h2&gt;
&lt;p&gt;首先写一个ConditionOnOS注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2021/01/02
 * @description 是否是对应OS
 */
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnOSCondition.class)
public @interface ConditionOnOS {


    /**
     * 系统类型
     */
    OSType osType();


    public enum OSType {
        MAC,
        LINUX,
        WINDOWS,
        ;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;处理程序&#34;&gt;处理程序&lt;/h2&gt;
&lt;p&gt;然后写一个处理程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Order
public class OnOSCondition implements ConfigurationCondition {


    @Override
    public ConfigurationPhase getConfigurationPhase() {
        return ConfigurationPhase.REGISTER_BEAN;
    }


    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {


        Map&amp;lt;String, Object&amp;gt; attributes = metadata.getAnnotationAttributes(ConditionOnOS.class.getName());
        ConditionOnOS.OSType osType = (ConditionOnOS.OSType) attributes.get(&amp;quot;osType&amp;quot;);


        boolean contains = System.getProperty(&amp;quot;os.name&amp;quot;).toUpperCase().contains(osType.name());


        return contains;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试程序&#34;&gt;测试程序&lt;/h2&gt;
&lt;p&gt;最后写一个启动程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package top.imyzt.learning.condition;


import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;


/**
 * @author imyzt
 * @date 2021/01/02
 * @description 手写一个ConditionOn*
 */
@ComponentScan(&amp;quot;top.imyzt.learning.condition&amp;quot;)
@Configuration
public class ConditionOnTest {


    public static void main(String[] args) {


        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext();


        annotationConfigApplicationContext.register(ConditionOnTest.class);


        annotationConfigApplicationContext.refresh();


        HelloWorld helloWorld;
        try {
            helloWorld = (HelloWorld) annotationConfigApplicationContext.getBean(&amp;quot;helloWorld&amp;quot;);
        } catch (NoSuchBeanDefinitionException e) {
            System.out.println(&amp;quot;helloWorld bean is not exists!&amp;quot;);
            return;
        }


        helloWorld.say();


    }


    @Bean
    @ConditionOnOS(osType = ConditionOnOS.OSType.MAC)
    public HelloWorld helloWorld() {
        return new HelloWorld(ConditionOnOS.OSType.MAC.name());
    }


    public class HelloWorld{
        private String name;


        public HelloWorld(String name) {
            this.name = name;
        }


        public void say() {
            System.out.println(this.name + &amp;quot; --- say hello!&amp;quot;);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;测试&#34;&gt;测试&lt;/h1&gt;
&lt;h2 id=&#34;正向&#34;&gt;正向&lt;/h2&gt;
&lt;p&gt;我的电脑是Mac，所以我执行后的结果是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;…省略
15:42:08.868 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;conditionOnTest&#39;
15:42:08.873 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;helloWorld&#39;
MAC --- say hello!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;反向&#34;&gt;反向&lt;/h2&gt;
&lt;p&gt;当将注解的参数修改为 ConditionOnOS.OSType.LINUX 后，结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;15:42:59.405 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;conditionOnTest&#39;
helloWorld bean is not exists!
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;讲解&#34;&gt;讲解&lt;/h1&gt;
&lt;p&gt;其中自主要的是在注解ConditionOnOS上面的@Conditional(OnOSCondition.class)元注解，它指定了判断的处理程序是OnOSCondition.class。&lt;br&gt;
其次是OnOSCondition通过实现ConfigurationCondition来重写判断逻辑。&lt;/p&gt;
&lt;h2 id=&#34;getconfigurationphase&#34;&gt;getConfigurationPhase()&lt;/h2&gt;
&lt;p&gt;getConfigurationPhase()用于提供给Spring告知其构建阶段，有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PARSE_CONFIGURATION： 一个是Condition应评估@Configuration类，如果此时条件不匹配，@Configuration 则不会添加该类。&lt;/li&gt;
&lt;li&gt;REGISTER_BEAN： 该条件不会阻止@Configuration添加类，在评估条件时，所有@Configurations都将被解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ConfigurationPhase的作用并不是根据条件来判断是否加载这个配置类，&lt;strong&gt;实际ConfigurationPhase控制的是过滤的时&lt;/strong&gt;机，是在创建Configuration类的时候过滤还是在创建bean的时候过滤（也可用条件注解的生效阶段来描述）。&lt;br&gt;
此处@https://blog.csdn.net/xcy1193068639/article/details/81589489&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum ConfigurationPhase {


   /**
    * The {@link Condition} should be evaluated as a {@code @Configuration}
    * class is being parsed.
    * &amp;lt;p&amp;gt;If the condition does not match at this point, the {@code @Configuration}
    * class will not be added.
    */
   PARSE_CONFIGURATION,


   /**
    * The {@link Condition} should be evaluated when adding a regular
    * (non {@code @Configuration}) bean. The condition will not prevent
    * {@code @Configuration} classes from being added.
    * &amp;lt;p&amp;gt;At the time that the condition is evaluated, all {@code @Configuration}
    * classes will have been parsed.
    */
   REGISTER_BEAN
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;matches&#34;&gt;matches()&lt;/h2&gt;
&lt;p&gt;matches()方法用于重写匹配逻辑，此方法根据自己的业务逻辑重写即可。&lt;/p&gt;
&lt;h1 id=&#34;后文&#34;&gt;后文&lt;/h1&gt;
&lt;p&gt;本篇文章的源代码位置：&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/source-code/xiaomage-springboot-teach/spring-boot-condition&#34;&gt;https://github.com/imyzt/learning-technology-code/tree/master/source-code/xiaomage-springboot-teach/spring-boot-condition&lt;/a&gt;&lt;/p&gt;
">手写一个SpringBoot ConditionOn*</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-throwable-yi-chang-dui-zhan-shou-ji-de-xing-neng-wen-ti/"" data-c="
          &lt;p&gt;在项目中，大家通常都喜欢使用 &lt;code&gt;throw new BusinessException()&lt;/code&gt; 来阻断错误的参数或者业务逻辑异常等已知异常，反馈给用户。比如用户未绑定手机号、用户的参数异常等情况。在大部分情况下，使用异常终止流程都不是很好的方式，但是奈何在SpringBoot 环境下，&lt;code&gt;@RestControllerAdvice&lt;/code&gt; 实在是香，不需要定义很多返回状态码。所以被大多数人使用在项目中。&lt;/p&gt;
&lt;p&gt;但是使用此方式是具有一定的性能损耗的，因为在基类Throwable 的fillInStackTrace()方法会不断收集各层的调用链路，而SpringMVC又是在外层的Tomcat到DispatcherServlet到应用自定义的各种intercepter层层调用，调用堆栈通常较长。所以多多少少具有一定的性能消耗，下面进行了一个基本测试。&lt;/p&gt;
&lt;p&gt;第一个for循环是为了给JVM预热。&lt;br&gt;
第二个模拟普通的异常。&lt;br&gt;
第三个模拟重写了fillInStackTrace()方法的异常。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2021/01/02
 * @description 异常收集测试
 */
public class TestMain {


    public static void main(String[] args) {


        int idx = 1000022;


        long t1Start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; idx; i++) {
            Test test = new Test(&amp;quot;aa&amp;quot; + i);
        }
        long t1end = System.currentTimeMillis();
        System.out.println(t1end - t1Start);




        long t2Start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; idx; i++) {
            try {
                throw new ThrowableTest(&amp;quot;aa&amp;quot; + i);
            } catch (ThrowableTest throwableTest) {
            }
        }
        long t2end = System.currentTimeMillis();
        System.out.println(t2end - t2Start);






        long t3Start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; idx; i++) {
            try {
                throw new ThrowableTest2(&amp;quot;aa&amp;quot; + i);
            } catch (ThrowableTest2 throwableTest) {


            }
        }
        long t3end = System.currentTimeMillis();
        System.out.println(t3end - t3Start);
    }




    public static class Test {


        private String name;


        public Test(String name) {
            this.name = name;
        }
    }


    public static class ThrowableTest extends RuntimeException {


        private String msg;


        public ThrowableTest(String msg) {
            super(msg);
            this.msg = msg;
        }
    }


    public static class ThrowableTest2 extends RuntimeException {


        private String msg;


        public ThrowableTest2(String msg) {
            super(msg);
            this.msg = msg;
        }


        @Override
        public synchronized Throwable fillInStackTrace() {
            return this;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;耗时对比：&lt;/p&gt;
&lt;p&gt;88&lt;br&gt;
1631&lt;br&gt;
74&lt;/p&gt;
&lt;p&gt;通过结果可以看出，即使在非Web环境下都有如此巨大的性能差距，web环境下冗长的调用链路差距只会更大，大家可使用web环境下进行测试。&lt;/p&gt;
&lt;p&gt;但是不是说有性能损耗就不用， 也需要结合业务进行权衡，比如可以将类似于参数错误等无需通过调用堆栈判断的、但是出现频率有很高的的异常进行重写基类的&lt;code&gt;fillInStackTrace()&lt;/code&gt;方法，使其不收集堆栈，但是此举会使出现异常后无法排查，所以只能使用在无需通过堆栈判断问题的场景下用于提升性能。&lt;/p&gt;
">Java Throwable异常堆栈收集的性能问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-80-gong-yong-biao-biao-da-shi-cte/"" data-c="
          &lt;p&gt;从版本8.0开始，MySQL简单地引入了公用表表达式功能或CTE。&lt;br&gt;
用于单词定义多次引用使用。&lt;/p&gt;
&lt;p&gt;语法如下所示，其中需要注意的是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义后，必须下方接着使用，不然语法错误。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;同一个语句可以定义多个CTE&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;with 别名 as (SQL语句),
with 别名2 as (SQL语句)
SELECT/DELETE/UPDATE/INSERT子句
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with cte as (select *
             from t_window_func)
select dept, count(*)
from cte
where salary not in (select salary from cte where salary &amp;lt; 13000)
group by dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上语句的外层&lt;code&gt;from cte&lt;/code&gt;和内层&lt;code&gt;not in&lt;/code&gt;中多次引用了&lt;code&gt;cte&lt;/code&gt;这个”公用表“&lt;/p&gt;
">MySQL 8.0 公用表表达式（CTE）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-80-window-functionser/"" data-c="
          &lt;p&gt;接&lt;a href=&#34;http://blog.imyzt.top/article/118&#34;&gt;上一篇&lt;/a&gt;的内容，继续讲一下窗口函数和分析函数结合的使用。&lt;/p&gt;
&lt;p&gt;lag与lead函数是跟偏移量相关的两个分析函数，通过这两个函数可以在一次查询中取出同一字段的前N行的数据(lag)和后N行的数据(lead)作为独立的列,从而更方便地进行进行数据过滤。&lt;strong&gt;这种操作可以代替表的自联接，并且LAG和LEAD有更高的效率。&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://my.oschina.net/u/2338224/blog/3112042&#34;&gt;https://my.oschina.net/u/2338224/blog/3112042&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;lagexpression-offset-default_value&#34;&gt;lag(expression, offset, default_value)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;取出同一字段的前N行的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;p&gt;lag(expression, offset, default_value)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;expression: 表达式，需要处理的结果列。&lt;/li&gt;
&lt;li&gt;offset: 偏移量，必须&amp;gt;=0，=0时返回当前行自己。&amp;gt;0返回当前行的前几行&lt;/li&gt;
&lt;li&gt;default_value: 默认值，第一行没有值时显示。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;select
name, dept,
       salary,
       lag(salary, 1) over (partition by dept order by salary ) as &#39;上一个人的工资&#39;
from t_window_func
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;lag(salary, 1) over (partition by dept order by salary )&lt;/code&gt; 通过对部门分区，对薪资取上一条数据，最后根据薪资正序排序，展示了不同部门每个人自己和上一个人的薪资情况。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/ssu8u0eo5uiu0qk3i41fmrkv4g.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从结果集中，我们看到了的是，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先数据根据&lt;code&gt;partition by dept&lt;/code&gt;, 根据部门进行了分区，不同分区不同处理。&lt;/li&gt;
&lt;li&gt;defaultValue展示了默认值&lt;/li&gt;
&lt;li&gt;员工2的上一个人工资=员工1的10000，员工3的上一个人工资=员工2的10000，以此类推&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;leadexpression-offset-default_value&#34;&gt;lead(expression, offset, default_value)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;取出同一字段的后N行的数据&lt;/strong&gt;，语法与lag的相同。&lt;/p&gt;
&lt;h2 id=&#34;示例-2&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;select
name, dept,
       salary,
       lead(salary, 1, &#39;defaultValue&#39;) over (partition by dept order by salary ) as &#39;下一个人的工资&#39;
from t_window_func
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/09pl5ltr1uh7bq2eu8qrtj7bob.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">MySQL 8.0 window functions（二）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-80-window-functionsyi/"" data-c="
          &lt;h1 id=&#34;什么是window-functions&#34;&gt;什么是window functions&lt;/h1&gt;
&lt;p&gt;window functions（开窗函数），主要是用来解决聚合函数执行后丢失原有结果的问题。&lt;br&gt;
通过使用window functions可以同时携带原有结果并且具有聚合后的结果。&lt;/p&gt;
&lt;p&gt;目前，MySQL8.0已经支持开窗函数了。喜大普奔&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/window-functions.html&#34;&gt;MySQL8.0 - Window Functions&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;知识点复习&#34;&gt;知识点复习&lt;/h1&gt;
&lt;h2 id=&#34;group-by是分组函数&#34;&gt;group by是分组函数&lt;/h2&gt;
&lt;p&gt;group by则只保留参与分组的字段和聚合函数的结果&lt;/p&gt;
&lt;h2 id=&#34;sum等聚合函数&#34;&gt;sum()等聚合函数&lt;/h2&gt;
&lt;p&gt;avg()、sum()、min()、max()&lt;/p&gt;
&lt;p&gt;求平均、求和、求最大最小等&lt;/p&gt;
&lt;h2 id=&#34;partition-by是分析函数&#34;&gt;partition by是分析函数&lt;/h2&gt;
&lt;p&gt;partition by相比较于group by，能够在保留全部数据的基础上，只对其中某些字段做分组排序&lt;/p&gt;
&lt;h1 id=&#34;样例数据准备&#34;&gt;样例数据准备&lt;/h1&gt;
&lt;p&gt;通过创建一个测试数据表，里面包含员工编号、员工姓名、部门和薪资数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
CREATE TABLE `t_window_func` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) DEFAULT NULL,
  `dept` varchar(32) DEFAULT NULL,
  `salary` int DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (1, &#39;员工1&#39;, &#39;部门1&#39;, 10000);
INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (2, &#39;员工2&#39;, &#39;部门1&#39;, 11000);
INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (3, &#39;员工3&#39;, &#39;部门1&#39;, 12000);
INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (4, &#39;员工4&#39;, &#39;部门2&#39;, 13000);
INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (5, &#39;员工5&#39;, &#39;部门2&#39;, 14000);
INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (6, &#39;员工6&#39;, &#39;部门2&#39;, 15000);
INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (7, &#39;员工7&#39;, &#39;部门3&#39;, 16000);
INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (8, &#39;员工8&#39;, &#39;部门3&#39;, 17000);
INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (9, &#39;员工9&#39;, &#39;部门3&#39;, 18000);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/q6mkoi9kbogdkqo18m8148qoc8.png&#34; alt=&#34;表数据&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;开窗函数与排名函数结合&#34;&gt;开窗函数与排名函数结合&lt;/h1&gt;
&lt;p&gt;窗口函数只要有以下几个：&lt;br&gt;
row_number()，rank()，dense_rank()，NTILE()，PERCENT_RANK()&lt;/p&gt;
&lt;p&gt;下面将每种介绍一个场景进行测试&lt;/p&gt;
&lt;h2 id=&#34;row_number&#34;&gt;row_number()&lt;/h2&gt;
&lt;p&gt;显示结果集的行号，&lt;strong&gt;当遇到相同数据时，会直接顺序编号&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;分别统计每个部门薪资排名&#34;&gt;分别统计每个部门薪资排名&lt;/h3&gt;
&lt;p&gt;通过对每个部门分区，对结果集进行汇总，展示在&lt;code&gt;salaryRank&lt;/code&gt;这一列，在没有开窗函数之前，实现此功能可是不简单。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select
name, dept, salary, 
       row_number() over (partition by dept order by salary desc ) salaryRank
from t_window_func
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/7f8tgcu962hgrp53fjkec0aoa8.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;统计每个部门薪资排名最高的前两个人&#34;&gt;统计每个部门薪资排名最高的前两个人&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select *
from (select name,
             dept,
             salary,
             row_number() over (partition by dept order by salary desc ) salaryRank
      from t_window_func
     ) tmp
where salaryRank &amp;lt;= 2
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/0hoie1p7isj9uophfhtsrhjrtb.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;rank-dense_rank&#34;&gt;rank()、dense_rank()&lt;/h2&gt;
&lt;h3 id=&#34;区别&#34;&gt;区别&lt;/h3&gt;
&lt;p&gt;rank()用于对结果记录生成序号，dense_rank()和rank()功能相同，当遇到排序字段数据相同时，两者的处理方式不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rank(): 跳跃排序，当第1、2行结果相同时，第1、2行排序为1，&lt;strong&gt;第3行排序为3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;dense_rank(): 不跳跃排序，当第1、2行结果相同时，第1、2行排序为1，&lt;strong&gt;第3行排序为2&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据准备&#34;&gt;数据准备&lt;/h3&gt;
&lt;p&gt;首先往表中插入一条数据，使&lt;code&gt;部门3&lt;/code&gt;有两个薪资一样的员工。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (10, &#39;员工10&#39;, &#39;部门3&#39;, 17000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;统计每个部门的排名&#34;&gt;统计每个部门的排名&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select name,
       dept,
       rank() over (partition by dept order by salary desc )       salaryRank,
       dense_rank() over (partition by dept order by salary desc ) salaryDenseRank
from t_window_func;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/o0fr73l0esjoho8q6jpev0qosf.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;ntile&#34;&gt;ntile()&lt;/h2&gt;
&lt;p&gt;函数ntile(group_num)主要用于数据分组，将所有记录分成group_num个组，每组序号一样。&lt;br&gt;
当数据不足以整除时，会把不够除的余数分给第一组。&lt;/p&gt;
&lt;h3 id=&#34;普通ntile分组&#34;&gt;普通ntile()分组&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select
name, dept, ntile(3) over (order by salary desc)
from t_window_func;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/tu8da9840ej8qoqf6m8gm3i0go.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;结合partition-by分区分组&#34;&gt;结合partition by分区分组&lt;/h3&gt;
&lt;p&gt;针对部门，进行分区分2组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select
name, dept, ntile(2) over (partition by dept order by salary desc)
from t_window_func;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/46engtn98cjgdpdrh4ftoflain.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;cume_dist&#34;&gt;cume_dist()&lt;/h2&gt;
&lt;p&gt;计算某个值在一组有序的数据中累计的分布&lt;br&gt;
计算方法为：&lt;strong&gt;相对位置/总行数,返回值为(0,1]&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;注意：对于重复值，计算的时候，取重复值的最后一行的位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select name,
       dept,
       salary,
       round(cume_dist() over (order by salary ), 2) randSalary
from t_window_func;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/6tsgjemm7che8pfdhufa10h85r.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;percent_rank&#34;&gt;percent_rank()&lt;/h2&gt;
&lt;p&gt;和cume_dist() 的不同点在于计算分布结果的方法&lt;br&gt;
计算方法为：&lt;strong&gt;（相对位置-1）/（总行数-1）&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;注意：对于重复值，计算的时候，取重复值的第一行的位&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select name,
       dept,
       salary,
       round(percent_rank() over (order by salary ), 2) randSalary
from t_window_func;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/4781raij6qhssrncu929g346aq.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;同一个window被多次使用&#34;&gt;同一个window被多次使用&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;select name,
             dept,
             salary,
            row_number() over w salaryRowNumber,
            rank() over w salaryRank,
            dense_rank() over w salaryDenseRank
      from t_window_func
window w as (partition by dept order by salary desc )
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/3pqcnolh46hfoo7qo83g6gsvnd.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;窗口函数和sum等聚合函数结合&#34;&gt;窗口函数和sum()等聚合函数结合&lt;/h1&gt;
&lt;p&gt;下面通过sum()函数演示具体的效果，对于avg()等聚合函数效果均相同。&lt;/p&gt;
&lt;h2 id=&#34;sum&#34;&gt;sum()&lt;/h2&gt;
&lt;h3 id=&#34;分部门求和&#34;&gt;分部门求和&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select id,
       name,
       dept,
       sum(salary) over (partition by dept )
from t_window_func;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/3o6mfujs1uge5qnngt84n16pdb.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;和group by结果类似，只是展示形式不同。group by 结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select id,
       name,
       dept,
       sum(salary)
from t_window_func
group by dept;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/sucgkgtr1sj82qdc5e2om28vfj.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;分部门阶段性累计求和&#34;&gt;分部门阶段性累计求和&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;上述窗口函数当over中加入了order by之后，结果集大不相同。(order by DESC|ASC)也影响结果&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;over(order by # desc)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;select id,
       name,
       dept,
       sum(salary) over (partition by dept order by salary desc )
from t_window_func;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/qve5un7bfagjmpqjl1khue6clj.png&#34; alt=&#34;order by desc&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;over(order by # asc)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;select id,
       name,
       dept,
       sum(salary) over (partition by dept order by salary asc )
from t_window_func;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/pbr47c6f50gn8q1ougnrmfnsvm.png&#34; alt=&#34;order by desc&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;求总和&#34;&gt;求总和&lt;/h3&gt;
&lt;p&gt;over() 中不包含 partition by 和 order by 时，对所有结果集进行求和。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select id,
       name,
       dept,
       sum(salary) over ()
from t_window_func;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/11/2qplonccncg7lq1tfsk8fcjc81.png&#34; alt=&#34;结果集&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">MySQL 8.0 window functions（一）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/fen-bu-shi-shi-wu-san-fen-bu-shi-shi-wu-jie-jue-fang-an/"" data-c="
          &lt;h3 id=&#34;dtp和xa&#34;&gt;DTP和XA&lt;/h3&gt;
&lt;p&gt;分布式事务的解决方案之一就是两阶段提交协议（2PC：Two-Phase Commit）&lt;/p&gt;
&lt;p&gt;1994年X/Open组织（现在的Open Group）定义了分布式事务处理的&lt;strong&gt;DTP模型&lt;/strong&gt;，该模型包括这样几个角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序（AP）：业务微服务&lt;/li&gt;
&lt;li&gt;事务管理器（TM）：全局事务管理者&lt;/li&gt;
&lt;li&gt;资源管理者（RM）：一般是数据库&lt;/li&gt;
&lt;li&gt;通信资源管理器（CRM）：是TM和RM间的通信中间件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在该模型中，一个分布式事务（全局事务）可以被拆分成多个本地事务，运行在不同的AP和RM上，每个本地事务的ACID很好实现，但是全局事务必须保证其中包含的每个本地事务都能成功，若有一个失败，则所有其他事务都必须回滚。&lt;br&gt;
问题是本地事务处理过程中，并不知道其他事务的运行状态，因此就&lt;strong&gt;需要通过CRM来通知各个本地事务，同步事务执行状态&lt;/strong&gt;。&lt;br&gt;
因此各个本地事务的通信必须有一个统一的标准，否则不同数据库之间就无法通信，XA就是X/Open DTP中通信中间件和TM间联系的&lt;strong&gt;接口规范&lt;/strong&gt;，定义了用于通知事务开始、提交、终止、回滚等接口，各个数据库厂商都必须实现这些接口。&lt;/p&gt;
&lt;h3 id=&#34;2pc两阶段提交&#34;&gt;2PC（两阶段提交）&lt;/h3&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/35298019&#34;&gt;漫话分布式系统共识协议: 2PC/3PC篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两阶提交协议&lt;/strong&gt;就是根据这一思想衍生出来的，将全局事务拆分为两个阶段来执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶段一：准备阶段，各个本地事务完成本地事务的准备工作。&lt;/li&gt;
&lt;li&gt;阶段二：执行阶段，各个本地事务根据上一阶段执行结果，进行提交或回滚。&lt;br&gt;
这个过程中需要一个协调者（coordinator），还有事务的参与者（voter）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;正常情况&#34;&gt;正常情况&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/80/v2-e2f7149a81d9ad3aa46589e25503d688_1440w.jpg&#34; alt=&#34;2pc&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;投票阶段&lt;/strong&gt;：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入undo和redo log，然后反馈事务执行成功。（agree）&lt;br&gt;
&lt;strong&gt;提交阶段&lt;/strong&gt;：协调组发现每个参与者都可以执行事务（agree），于是向各个事务参与者发出commit指令，各个事务参与者提交事务。&lt;/p&gt;
&lt;h4 id=&#34;异常情况&#34;&gt;异常情况&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/80/v2-d40abfa365ed84e84e264ba13900f64b_1440w.jpg&#34; alt=&#34;2pc&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;投票阶段&lt;/strong&gt;：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入undo和redo log，然后反馈事务执行结果，但只要有一个参与者返回的是&lt;code&gt;Disagree&lt;/code&gt;，就说明执行失败。&lt;br&gt;
&lt;strong&gt;提交阶段&lt;/strong&gt;：协调组发现每个有一个或多个参与者返回Disagree，认为执行失败，于是向各个事务参与者发出&lt;code&gt;abort&lt;/code&gt;指令，各个事务参与者回滚事务。&lt;/p&gt;
&lt;h4 id=&#34;缺陷&#34;&gt;缺陷&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;存在CRM单点故障问题&lt;br&gt;
协调者挂了之后就不知道别人什么情况。&lt;br&gt;
&lt;img src=&#34;https://pic3.zhimg.com/80/v2-a9e4ef8b9082ffdf76bc426e61ba3ed2_1440w.jpg&#34; alt=&#34;2pc&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞问题&lt;br&gt;
在准备阶段，提交阶段，每个事务参与者都会锁定本地资源，并等待其他事务的执行结果，阻塞时间较长。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;面对二阶段提交的缺点，后来又演变出来了三阶段提交，但是依旧没有解决阻塞和资源锁定的问题，而且引入了新的微，因此实际场景使用较少。&lt;/li&gt;
&lt;li&gt;2PC拥有稳定成熟的框架支持，可以保证强一致，并且对代码侵入度不高，&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;使用场景&#34;&gt;使用场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;适用于对效率要求不高，一致性要求高的场景&lt;/li&gt;
&lt;li&gt;代码侵入度小，不影响原有代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3pc三阶段提交&#34;&gt;3PC（三阶段提交）&lt;/h3&gt;
&lt;h2 id=&#34;tcc&#34;&gt;TCC&lt;/h2&gt;
&lt;p&gt;TCC模式可以解决2PC中资源锁定和阻塞的问题，减少资源锁定时间。&lt;/p&gt;
&lt;h3 id=&#34;基本原理&#34;&gt;基本原理&lt;/h3&gt;
&lt;p&gt;本质是一种&lt;strong&gt;补偿&lt;/strong&gt;的机制，事务运行包括三个方法，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;try：资源的检测和预留&lt;/li&gt;
&lt;li&gt;confirm：执行业务操作提交；要求try成功confirm一定能成功&lt;/li&gt;
&lt;li&gt;cancel：预留资源释放&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行分两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备阶段（try）：资源的检测和预留&lt;/li&gt;
&lt;li&gt;执行阶段（confirm/cancel）：根据上一步的结果，判断下面的执行方法。如果上一步所有事务参与者都成功，这里执行confirm，否则执行cancel&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/u3n1k3gdrmio1rn77kkmq75mk7.png&#34; alt=&#34;tcc&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;看似与两阶段提交没有什么区别，其实差距很大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;try，confirm，cancel都是独立的事务&lt;/strong&gt;，不受其他参与者的影响，不会阻塞等待他人。&lt;/li&gt;
&lt;li&gt;try，confirm，cancel由程序员在业务层编写，锁粒度由代码控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;
&lt;p&gt;假如账户A原来有100元，需要从余额扣除30元。如图：&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/tmr3m1trf2gphpmjn63s4apc1j.png&#34; alt=&#34;tcc&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一阶段（Try）：余额检查，并冻结用户部分金额，此阶段执行完毕，事务已提交。
&lt;ul&gt;
&lt;li&gt;检查用户余额是否足够，如果足够，冻结部分余额&lt;/li&gt;
&lt;li&gt;在账户表中添加冻结金额字段，值为30，余额不变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二阶段
&lt;ul&gt;
&lt;li&gt;提交（Confirm）：真正的扣款，把冻结金额从余额中扣除，冻结金额清空。
&lt;ul&gt;
&lt;li&gt;修改冻结金额=0，修改余额为100-30=79&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;补偿（Cancel）：释放之前冻结的金额，不是回滚
&lt;ul&gt;
&lt;li&gt;余额不变，修改账户冻结金额=0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优势缺点&#34;&gt;优势&amp;amp;缺点&lt;/h3&gt;
&lt;h4 id=&#34;优势&#34;&gt;优势&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;避免资源长期锁定和阻塞等待操作。执行效率高。&lt;br&gt;
TCC执行的每个阶段都是独立的事务，不需要等待其他事务的结果。如果执行失败，不是执行的回滚而是执行的&lt;strong&gt;补偿&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缺点&#34;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码侵入&lt;/strong&gt;：需要人为编写try，confirm，cancel操作，对开发人员要求高&lt;/li&gt;
&lt;li&gt;开发成本高：一个业务需要拆分三个阶段，开发成本高&lt;/li&gt;
&lt;li&gt;安全性考虑：cancel动作如果执行失败，资源就无法释放。需要引入重试，但是引入重试又有可能造成重复执行问题，还需要考虑重试时的幂等问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用场景-2&#34;&gt;使用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对事务有一定的一致性要求（最终一致性）&lt;/li&gt;
&lt;li&gt;对性能要求较高&lt;/li&gt;
&lt;li&gt;开发人员具备较高的编码能力和幂等处理经验&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可靠消息服务&#34;&gt;可靠消息服务&lt;/h2&gt;
&lt;p&gt;源于eBay，设计思想是将远程分布式事务拆分成一系列的本地事务。&lt;/p&gt;
&lt;h3 id=&#34;基本原理-2&#34;&gt;基本原理&lt;/h3&gt;
&lt;p&gt;事务分为&lt;code&gt;发起者A&lt;/code&gt;和&lt;code&gt;参与者BCD&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务&lt;code&gt;发起者A&lt;/code&gt;执行本地事务&lt;/li&gt;
&lt;li&gt;事务&lt;code&gt;发起者A&lt;/code&gt;通过MQ将需要执行的事务信息发送给&lt;code&gt;事务参与者BCD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事务&lt;code&gt;参与者BCD&lt;/code&gt;接收到消息后执行本地事务&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/qh87gftgnuiovqhu1aj3thcj8d.png&#34; alt=&#34;mq&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现实场景（老师给的场景，好像不恰当）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你点了一杯奶茶，付完钱。（发起者A完成）&lt;/li&gt;
&lt;li&gt;服务员给了你一个号码牌。（参与者B）&lt;/li&gt;
&lt;li&gt;你凭这张小票，一定能够领到一杯奶茶。（不断问服务员，重试）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;本地消息表&#34;&gt;本地消息表&lt;/h3&gt;
&lt;p&gt;为了避免消息发送失败或丢失，消息需要持久化到数据库。实现有简化版本和解耦合版本两种。&lt;/p&gt;
&lt;h4 id=&#34;简化版本&#34;&gt;简化版本&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/p0a94m11pgjahpd5btcceofk5m.png&#34; alt=&#34;mq&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;事务发起者
&lt;ol&gt;
&lt;li&gt;开启本地事务&lt;/li&gt;
&lt;li&gt;执行业务操作&lt;/li&gt;
&lt;li&gt;发送消息到MQ&lt;/li&gt;
&lt;li&gt;保存消息记录到数据库，&lt;strong&gt;记录为已发送&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;提交本地事务&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;事务参与者
&lt;ol&gt;
&lt;li&gt;接收消息&lt;/li&gt;
&lt;li&gt;开启本地事务&lt;/li&gt;
&lt;li&gt;执行业务操作&lt;/li&gt;
&lt;li&gt;修改数据库&lt;strong&gt;记录状态为已消费&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;提交本地事务&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;额外的定时任务
&lt;ul&gt;
&lt;li&gt;定时扫描数据库中超时未消费的，重新发送&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优点缺点&#34;&gt;优点&amp;amp;缺点&lt;/h3&gt;
&lt;h4 id=&#34;优点&#34;&gt;优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;与TCC相比，不用写那么多代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缺点-2&#34;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;数据一致性完全依赖MQ，因此消息服务一定需要可靠。&lt;/li&gt;
&lt;li&gt;需要处理被动业务方的幂等问题。&lt;/li&gt;
&lt;li&gt;被动业务失败不会主动业务回滚，而是重试被动的业务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事务业务与消息业务耦合，发起者业务完成后需要写消息表&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;独立消息服务&#34;&gt;独立消息服务&lt;/h3&gt;
&lt;p&gt;通过引入独立的消息服务，完成对消息的持久化、发送、确认、失败重试等行为。&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/rg722262raj42ous0564ei5dae.png&#34; alt=&#34;mq&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;rocketmq事务消息&#34;&gt;RocketMQ事务消息&lt;/h4&gt;
&lt;p&gt;自带事务消息，可以保证消息的可靠性，原理就是自带了一个本地消息表。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/apache/rocketmq/blob/master/docs/cn/features.md#7-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF&#34;&gt;RocketMQ-事务消息&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;rabbitmq的消息确认&#34;&gt;RabbitMQ的消息确认&lt;/h4&gt;
&lt;p&gt;RabbitMQ确保消息不丢失使用的是ACK确认机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者确认机制：确保从生产者 -&amp;gt; MQ不丢失
&lt;ul&gt;
&lt;li&gt;生产者发送消息到mq，设置异步监听MQ的ACK&lt;/li&gt;
&lt;li&gt;MQ接收到消息，返回ACK到生产者
&lt;ol&gt;
&lt;li&gt;消息到exchange但是route失败，返回失败ACK&lt;/li&gt;
&lt;li&gt;消息route成功，持久化失败，返回失败ACK&lt;/li&gt;
&lt;li&gt;消息route成功，持久化成功，返回成功ACK&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;生产者提前编写好不同回调的处理方式
&lt;ol&gt;
&lt;li&gt;成功，记录日志&lt;/li&gt;
&lt;li&gt;失败，一段时间后重新发送&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消费者确认机制：确保从MQ -&amp;gt; 消费者正确消费
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消费者开启监听时开启手动ACK模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;mq将消息发送到消费者后，会等待消费者ACK
&lt;ol&gt;
&lt;li&gt;收到消费者ACK才会删除消息&lt;/li&gt;
&lt;li&gt;一直没有收到ACK则一直保存&lt;/li&gt;
&lt;li&gt;消费者断开或异常后，发送给其它消费者（此处需要做好幂等）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;消费者处理完消息，提交事务，手动ACK。如果异常，则不会ACK，业务处理失败。等待处理下一条消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;事务消息优点缺点&#34;&gt;事务消息优点&amp;amp;缺点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;业务简单，不需要写三个阶段的代码&lt;/li&gt;
&lt;li&gt;多个本地事务，缩短资源锁定时间，性能高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;代码侵入度高&lt;/li&gt;
&lt;li&gt;一致性依赖MQ的可靠性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息发起者可以回滚，参与者无法引起全局事务回滚&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;时效性差，完全取决于MQ的消息发送是否及时，消费是否及时。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对缺点3，无法回滚问题。有人提出可以让事务参与者失败后，利用MQ通知消息服务，由消息服务通知其他参与者回滚，可是这是在利用MQ重新实现了2PC，又是一个轮子。没必要&lt;/p&gt;
&lt;h2 id=&#34;seata&#34;&gt;Seata&lt;/h2&gt;
&lt;p&gt;官网：&lt;a href=&#34;http://seata.io/&#34;&gt;http://seata.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Seata是阿里开源的框架，支持XA，AT，TCC，SAGA四种模式。&lt;/p&gt;
&lt;h3 id=&#34;at模式&#34;&gt;AT模式&lt;/h3&gt;
&lt;p&gt;2019年1月份，Seata开源了AT模式。AT模式是一种无侵入的分布式事务解决方案。是对TCC或两阶段提交模型的优化，解决了TCC模式代码侵入，编码复杂等问题。&lt;/p&gt;
&lt;p&gt;在AT模式下，用户只需要关注自己业务的&amp;quot;sql&amp;quot;，用户的业务SQL作为“一阶段”，Seata框架会解析SQL自动生成事务的“二阶段”提交或回滚操作。&lt;/p&gt;
&lt;p&gt;Seata官方文档：&lt;a href=&#34;seata.io&#34;&gt;seata.io&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/qlv6afj24ohdopkuksaoi920l2.png&#34; alt=&#34;at-1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;乍一看和TCC协议很像，都是分两阶段提交。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一阶段：执行本地事务，并返回执行结果&lt;/li&gt;
&lt;li&gt;二阶段：根据一阶段的结果，决定执行提交或回滚&lt;br&gt;
但是AT模式底层完全不同，二阶段完全不需要我们编码，框架帮我们实现了。我们写的代码和本地事务代码完全一致，无需手动处理分布式事务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一阶段&#34;&gt;一阶段&lt;/h4&gt;
&lt;p&gt;一阶段，Seata会拦截&lt;code&gt;业务SQL&lt;/code&gt;，首先解析SQL语义，找到&lt;code&gt;业务SQL&lt;/code&gt;要更新的业务数据，在业务数据被更新前，将其保存为&lt;code&gt;before image&lt;/code&gt;，然后执行&lt;code&gt;业务SQL&lt;/code&gt;，更新业务数据，在业务数据执行之后，再将其保存为&lt;code&gt;after image&lt;/code&gt;，最后获取全局行锁，&lt;strong&gt;提交事务&lt;/strong&gt;。以上所有操作都是在一个本地事务中完成，保证了一阶段的原子性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;before image&lt;/code&gt;和&lt;code&gt;after image&lt;/code&gt;类似于数据库的undo log和redo log。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/15j04em37giudou1njfedr92rv.png&#34; alt=&#34;at-2&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;二阶段提交&#34;&gt;二阶段提交&lt;/h4&gt;
&lt;p&gt;二阶段如果是提交的话，因为&lt;code&gt;业务SQL&lt;/code&gt;在一阶段已经提交到数据库，所以Seata框架只需要将一阶段保存的快照数据和行锁删掉，完成数据清理即可。&lt;/p&gt;
&lt;h4 id=&#34;二阶段回滚&#34;&gt;二阶段回滚&lt;/h4&gt;
&lt;p&gt;回滚可直接使用&lt;code&gt;before image&lt;/code&gt;还原业务数据，但在还原前首先要检查脏写，对比&lt;code&gt;数据库当前业务数据&lt;/code&gt;与&lt;code&gt;after image&lt;/code&gt;，如果两份完全一致则没有脏写，可以还原；如果数据不一致，说明出现了脏写，需要人工处理。&lt;/p&gt;
&lt;h4 id=&#34;详细架构和流程&#34;&gt;详细架构和流程&lt;/h4&gt;
&lt;p&gt;基本概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TC（Transaction Coordinator）：事务协调者，维护全局和分支事务的状态，驱动全局事务提交或回滚（TM之间的协调者）&lt;/li&gt;
&lt;li&gt;TM（Transaction Manager）：事务管理器，定义全局事务的范围：开启全局事务，提交或回滚全局事务&lt;/li&gt;
&lt;li&gt;RM（Resource Manager）：资源管理器，管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/qh04k2e1h2ge6qmqknagdselpf.png&#34; alt=&#34;at-3&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;TM：业务模块中全局事务的开启者
&lt;ul&gt;
&lt;li&gt;向TC开启一个全局事务&lt;/li&gt;
&lt;li&gt;调用其它微服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RM：业务模块执行者中，包含RM部分，负责向TC汇报事务执行状态
&lt;ul&gt;
&lt;li&gt;执行本地事务&lt;/li&gt;
&lt;li&gt;向TC注册分支事务，并提交本地事务执行结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TM：结束对微服务的调用，通知TC，全局事务执行完毕，一阶段结束&lt;/li&gt;
&lt;li&gt;TC：汇总各个分支事务执行结果，决定分布式事务是提交还是回滚&lt;/li&gt;
&lt;li&gt;TC：通知所有RM提交/回滚资源，二阶段结束&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;详细流程&#34;&gt;详细流程&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;一阶段
&lt;ul&gt;
&lt;li&gt;TM开启全局事务，并向TC声明全局事务，包括全局事务XID信息&lt;/li&gt;
&lt;li&gt;TM所在服务调用其他微服务&lt;/li&gt;
&lt;li&gt;微服务，主要由RM执行
&lt;ul&gt;
&lt;li&gt;查询&lt;code&gt;before image&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行本地事务&lt;/li&gt;
&lt;li&gt;查询&lt;code&gt;after image&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成&lt;code&gt;undo log&lt;/code&gt;写入数据库&lt;/li&gt;
&lt;li&gt;向TC注册分支事务，并告知事务执行结果&lt;/li&gt;
&lt;li&gt;获取全局锁（防止其他全局事务并发修改当前数据）&lt;/li&gt;
&lt;li&gt;释放本地锁（不影响其他业务对数据的操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二阶段
&lt;ul&gt;
&lt;li&gt;TC 统计各个分支事务的执行情况，根据情况做对应的操作
&lt;ul&gt;
&lt;li&gt;都成功：通知分支事务，提交事务&lt;/li&gt;
&lt;li&gt;有分支失败：通知执行成功的事务，回滚数据（做补偿）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分支事务RM
&lt;ul&gt;
&lt;li&gt;提交事务：直接清空&lt;code&gt;before image&lt;/code&gt;和&lt;code&gt;after image&lt;/code&gt;信息，释放全局锁&lt;/li&gt;
&lt;li&gt;回滚事务
&lt;ul&gt;
&lt;li&gt;校验&lt;code&gt;after image&lt;/code&gt;，判断是否有脏写&lt;/li&gt;
&lt;li&gt;如果没有脏写，回滚到&lt;code&gt;before image&lt;/code&gt;，清空&lt;code&gt;before image&lt;/code&gt;和&lt;code&gt;after image&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果有脏写，需要人工干预&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;优点缺点-2&#34;&gt;优点&amp;amp;缺点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;优点
&lt;ol&gt;
&lt;li&gt;一阶段无锁，高性能&lt;/li&gt;
&lt;li&gt;补偿服务易于实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ol&gt;
&lt;li&gt;解析，查询和保存undo log的blob字段徒增性能损耗，根据二八定理，80%的业务是不会出现问题，而需要接受这部分写入log的损耗&lt;/li&gt;
&lt;li&gt;不保证隔离性，一阶段完成后仅维护着全局事务锁XID提交了本地事务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;适用场景&#34;&gt;适用场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;业务流程长，业务逻辑多的地方。&lt;/li&gt;
&lt;li&gt;历史遗留代码无法修改的情况&lt;/li&gt;
&lt;/ul&gt;
">分布式事务(三) 分布式事务解决方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/fen-bu-shi-shi-wu-er-jie-jue-fen-bu-shi-shi-wu-de-si-lu/"" data-c="
          &lt;h2 id=&#34;cap理论&#34;&gt;CAP理论&lt;/h2&gt;
&lt;p&gt;什么是CAP理论？&lt;a href=&#34;http://www.ruanyifeng.com/blog/2018/07/cap.html&#34;&gt;阮一峰-CAP 定理的含义&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg&#34; alt=&#34;CAP&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;1998年，加州大学的计算机科学家Eric Brewer 提出，分布式系统有三个指标。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Consistency（一致性） - C&lt;/li&gt;
&lt;li&gt;Availability（可用性）  - A&lt;/li&gt;
&lt;li&gt;Partition tolerance（分区容错性）  - P&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;partition-tolerance&#34;&gt;Partition tolerance&lt;/h3&gt;
&lt;p&gt;大部分分布式系统都分布在多个子网络，每个子网络叫做一个&lt;strong&gt;区（Partition）&lt;/strong&gt;，分区容错的意思是区间通信可能会失败。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/3ar3v3qm3cjmeqe6080nbcl54o.png&#34; alt=&#34;cap-p&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上图中，G1和G2是两台跨区的服务器，G1向G2发送一条消息，G2可能无法收到，系统设计的时候，需要考虑到这种情况。&lt;br&gt;
一般来说，&lt;strong&gt;分布式系统中分区容错性无法避免，因此可以认为CAP中的P总是成立，根据CAP定理，剩下的C和A无法同时满足&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;consistency&#34;&gt;Consistency&lt;/h3&gt;
&lt;p&gt;一致性的意思是，写操作之后的读操作，必须返回该值，举例来说，某条记录是V0，用户向G1发起一个写操作，将其改为V1。&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/0rbg59pergi1uos6ht6hqgderm.png&#34; alt=&#34;cap-c-1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
接下来，用户的读操作就会得到V1，这叫做&lt;strong&gt;数据的一致性&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/pn2ki67jo6g27p0krmdk11n7qf.png&#34; alt=&#34;cap-c-2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
问题是，用户有可能向G2发起读操作，由于G2的值没有变化，因此返回的是V0，G1和G2读操作的结果不一致，这就不满足一致性了。&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/4b49j404vajttoqq733cm6st3b.png&#34; alt=&#34;cap-c-3&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
为了让G2也能变成V1，就要在G1写操作的时候，让G1向G2发送一条消息，要求G2也改成V1.&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/0a81st7q7eho5rfdd6vr5gq0s7.png&#34; alt=&#34;cap-c-4&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样的话，用户向G2发起读操作，也能得到V1.&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/prldhirihah0kq59fng5jj3q25.png&#34; alt=&#34;cap-c-5&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;availability&#34;&gt;Availability&lt;/h3&gt;
&lt;p&gt;只要收到了用户的请求，服务器就必须给出回应。（不论对错）&lt;br&gt;
用户可以向G1或G2发起读操作，不管是那台服务器，只要收到请求就必须返回用户到底是V1还是V0，否则就不满足&lt;strong&gt;可用性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;consistency和availability的矛盾&#34;&gt;Consistency和Availability的矛盾&lt;/h3&gt;
&lt;p&gt;Q：一致性和可用性为什么不能同时满足？&lt;br&gt;
A：因为通信可能会失败（出现分区容错）&lt;/p&gt;
&lt;p&gt;如果&lt;u&gt;保证G2的一致性&lt;/u&gt;，那么G1必须在写操作时，锁定G2的读写操作。只有数据库同步后，才能重新开放读写操作。锁定期间，G2没有&lt;strong&gt;可用性&lt;/strong&gt;&lt;br&gt;
如果&lt;u&gt;保证G2的可用性&lt;/u&gt;，那么不能锁定G2，G2没有&lt;strong&gt;一致性&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;几点疑问&#34;&gt;几点疑问&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;怎样同时满足CAP？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除非是单体架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何时要满足CP？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对一致性要求高的场景&lt;/strong&gt;，Zookeeper就是这样，在服务节点数据同步时，服务对外不可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何时要满足AP？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对可用性要求高的场景&lt;/strong&gt;，Eureka就是这样，必须保证注册中心随时可用，不然拉取不到服务就可能出问题，所以可能会出现eureka节点间数据不一致的问题。&lt;/p&gt;
&lt;h2 id=&#34;base理论&#34;&gt;Base理论&lt;/h2&gt;
&lt;p&gt;base是三个单词的缩写&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Basically Available（基本可用）&lt;br&gt;
不能满足完全可用，等一小段同步时间，就满足基本可用，只要时间足够短。&lt;/li&gt;
&lt;li&gt;Soft state（软状态）&lt;br&gt;
保留一个中间状态&lt;/li&gt;
&lt;li&gt;Eventually consistent（最终一致性）&lt;br&gt;
不能实时的一致性，等待数据同步完成后，满足一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决分布式事务，就是根据Base理论来实现的。&lt;/p&gt;
">分布式事务(二) 解决分布式事务的思路</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/fen-bu-shi-shi-wu-yi-ben-di-shi-wu-hui-gu/"" data-c="
          &lt;h1 id=&#34;什么是分布式事务&#34;&gt;什么是分布式事务&lt;/h1&gt;
&lt;p&gt;要了解分布式事务，首先需要了解什么是本地事务。&lt;/p&gt;
&lt;h2 id=&#34;本地事务&#34;&gt;本地事务&lt;/h2&gt;
&lt;p&gt;本地事务，是指传统的单机数据库事务，必须满足ACID原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子性（atomicity）&lt;br&gt;
整个事务中所有操作，要么一块完成，要么都不完成。&lt;br&gt;
对于事务发生错误，所有操作必须完成回滚。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一致性（consistency）&lt;br&gt;
事务的执行必须保证系统的一致性，事务在开始之前和结束之后，数据库的&lt;strong&gt;完整性&lt;/strong&gt;不能被破坏。&lt;br&gt;
比如在一个事务中，A（余额100）给B（余额100）转账10元，那么不管发生什么，最终A和B的账户总额必须是200元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隔离性（isolation）&lt;br&gt;
隔离性就是事务与事务之间不会互相影响，一个事务的中间状态不能被其他事务感知。数据库的隔离级别包括四种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Read UmCommitted 读取未提交内容&lt;/li&gt;
&lt;li&gt;Read Committed 读取提交内容&lt;/li&gt;
&lt;li&gt;Repeatable Read 可重复读&lt;/li&gt;
&lt;li&gt;Seriallzable 可串行化&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持久性（durability）&lt;br&gt;
事物一旦执行完毕，那么事务对数据进行的变更就完全保存在数据库硬盘中，即使断电、宕机也不会改变。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统项目中，项目部署基本都是单点式，这种情况下，数据库本身的事务机制就能保证ACID的原则，这样的事务叫做本地事务。&lt;br&gt;
其中原子性和持久性需要依靠undo和redo日志来实现。&lt;/p&gt;
&lt;h2 id=&#34;undo和redo日志&#34;&gt;undo和redo日志&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据库中数据从来不是最重要的，日志才是。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在缓存中也有log buffer，也有磁盘log file。&lt;br&gt;
&lt;strong&gt;MySQL的日志文件，有两种与事务有关，undo log和redo log&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;undo日志&#34;&gt;undo日志&lt;/h3&gt;
&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;
&lt;p&gt;数据库事务具备原子性（Atomicity），如果事务执行失败，需要把数据回滚。&lt;br&gt;
事务同时还具备持久性（durability），事务对数据做的更改完全保存在数据库，不能因为故障而丢失。&lt;br&gt;
原子性可以使用undo log来实现。&lt;/p&gt;
&lt;h4 id=&#34;原理&#34;&gt;原理&lt;/h4&gt;
&lt;p&gt;undo log的原理很简单，为了满足事务的原子性，&lt;strong&gt;在操作任何数据之前都会将数据备份到undo log中然后再对数据进行更改&lt;/strong&gt;。如果执行出错或者手动回滚后，系统可以利用undo log中备份的数据恢复到事务开始之前的状态。&lt;br&gt;
&lt;strong&gt;数据库写入数据到磁盘之前，会把数据先缓存在内存中。事务提交才写入到磁盘。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;实例&#34;&gt;实例&lt;/h4&gt;
&lt;p&gt;用undo log实现原子性和持久性的简化过程：&lt;br&gt;
假设有A=1, B=2两条数据。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/u01mna67dej84qtokjc1o342ca.png&#34; alt=&#34;实例.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如何保证持久性？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务提交前，会把修改数据记录到磁盘中，只要事务提交了，数据肯定持久化了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何保证原子性？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次对数据库修改，都会把修改前记录保存在undo log中，需要回滚时可以直接读取undo log恢复数据。&lt;/p&gt;
&lt;h4 id=&#34;缺陷&#34;&gt;缺陷&lt;/h4&gt;
&lt;p&gt;每个事务提交前都需要将数据和undo log写入到磁盘，导致大量磁盘IO，性能差。&lt;/p&gt;
&lt;h3 id=&#34;redo日志&#34;&gt;redo日志&lt;/h3&gt;
&lt;p&gt;和undo log相反，redo log是对新数据的备份，在事务提交之前，只要将redo log持久化即可，不需要将数据持久化，减少IO操作。&lt;/p&gt;
&lt;h4 id=&#34;实例-2&#34;&gt;实例&lt;/h4&gt;
&lt;p&gt;用undo log + redo log 实现原子性和持久性的简化过程：&lt;br&gt;
假设有A=1, B=2两条数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务开始&lt;/li&gt;
&lt;li&gt;记录A=1到undo log buffer&lt;/li&gt;
&lt;li&gt;修改A=3&lt;/li&gt;
&lt;li&gt;记录A=3到redo log buffer&lt;/li&gt;
&lt;li&gt;记录B=2到undo log buffer&lt;/li&gt;
&lt;li&gt;修改B=4&lt;/li&gt;
&lt;li&gt;记录B=4到redo log buffer&lt;/li&gt;
&lt;li&gt;将undo log写入&lt;strong&gt;redo log&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将redo log写入磁盘&lt;/li&gt;
&lt;li&gt;事务提交&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如何保证持久性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个过程数据并未持久化，因为数据已经写入到redo log中，而redo log已经写入到磁盘中，因此只要进行到（9）后，事务是可以提交的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何保证原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在事务提交前故障，通过undo log恢复数据，如果undo log还未写入（8），那么数据尚未持久化，无需回滚。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存中数据何时持久化到硬盘&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为redo log已经持久化，因此是否写入硬盘已经不重要了。但是一般为了避免内存数据与数据库数据不一致，在事务提交后或者会固定频率刷新到数据库中。&lt;/p&gt;
&lt;h4 id=&#34;问题&#34;&gt;问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;之前是将数据库数据和undo log写入磁盘，现在是将undo log和redo log写入磁盘，IO次数并没有减少吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;数据库数据写入是随机的，性能差&lt;/li&gt;
&lt;li&gt;redo log在初始化时会开辟一段连续空间，写入是顺序IO，性能高&lt;/li&gt;
&lt;li&gt;实际上undo log并不是直接写入磁盘，而是写入到redo log buffer中，当redo log持久化时，undo log也顺便持久化了。&lt;br&gt;
因此事务在提交前只需要将redo log持久化即可。&lt;br&gt;
另外redo log并不是写入一次就持久化一次，redo log在内存中有redo log buffer缓冲池，在最终数据库事务提交时一次性持久化，减少IO次数。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;redo log buffer已满（第8步）但事务未提交时会写入buffer数据到硬盘，而此时如果数据库宕机事务未提交已保存的部分redo log怎么处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;恢复时，只重做已经提交了的事务。&lt;/li&gt;
&lt;li&gt;恢复时，重做所有事务包括未提交的和回滚的事务，然后通过undo log回滚哪些未提交的事务。&lt;br&gt;
innodb采用了方案2，因此undo log要在redo log前持久化。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;undo log记录旧数据，redo log记录最新数据。&lt;/p&gt;
&lt;h2 id=&#34;分布式事务&#34;&gt;分布式事务&lt;/h2&gt;
&lt;h3 id=&#34;跨数据源&#34;&gt;跨数据源&lt;/h3&gt;
&lt;p&gt;对数据库进行水平或垂直拆分，将原表数据拆分成数据库分片。于是就产生了跨数据库事务问题。&lt;br&gt;
因为ACID是数据库内部的，不能解决多个数据库实例之间的问题。&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/4dq7t4f6sejrdq9edf4b85g9hq.png&#34; alt=&#34;multiDS&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;跨服务&#34;&gt;跨服务&lt;/h3&gt;
&lt;p&gt;对单体项目进行微服务拆分后，将原有的Spring Transaction Manager拆分到每个微服务之间都有自己的Spring事务管理器。导致出现分布式事务问题。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/vh310l61i6j1qqvph3lhkmaunq.png&#34; alt=&#34;microService&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;分布式系统的数据一致性问题&#34;&gt;分布式系统的数据一致性问题&lt;/h3&gt;
&lt;p&gt;当出现部分事务成功，部分事务失败时，业务数据就会不一致。&lt;br&gt;
例如电商下单场景，包括以下几个行为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建订单&lt;/li&gt;
&lt;li&gt;扣减库存&lt;/li&gt;
&lt;li&gt;扣减余额&lt;br&gt;
完成上面三个动作需要三个微服务和三个不同的数据库，一旦其中任何一个失败，其它的服务之间都无法感知，就会造成数据的不一致问题。&lt;br&gt;
这正是分布式事务要解决的问题。&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/09/oku3t2m7huglnrvm2mmd5fltdp.png&#34; alt=&#34;microServiceSimple&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
">分布式事务(一) 本地事务回顾</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/rabbitmq-shi-xian-yan-chi-dui-lie/"" data-c="
          &lt;h1 id=&#34;参考文章&#34;&gt;参考文章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;https://www.cnblogs.com/mfrank/p/11260355.html&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/u014308482/article/details/53036770&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/u012988901/article/details/88958654&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;本文大纲&#34;&gt;本文大纲&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/380dc612ncjaoojm2ta7l64ih8.png&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/380dc612ncjaoojm2ta7l64ih8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;什么是延迟队列&#34;&gt;什么是延迟队列&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;延迟队列也是队列，队列就意味着元素是有序的。元素出队和入队是有方向的，从一端进，从另一端出。&lt;/strong&gt;&lt;br&gt;
延迟队列体现在延迟上面，普通的队列是希望元素能够被更快的消费，而延迟队列是希望元素在指定的时间被消费。所以&lt;strong&gt;延迟队列里面的元素是带有时间属性&lt;/strong&gt;的。&lt;/p&gt;
&lt;h1 id=&#34;延迟队列的使用场景&#34;&gt;延迟队列的使用场景&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;用户订单10分钟内未支付自动取消&lt;/li&gt;
&lt;li&gt;预定会议后，开会前10分钟提醒&lt;/li&gt;
&lt;li&gt;优惠券到期前提醒&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;基础知识补充&#34;&gt;基础知识补充&lt;/h1&gt;
&lt;h2 id=&#34;ttltime-to-live&#34;&gt;TTL（Time To Live）&lt;/h2&gt;
&lt;h3 id=&#34;什么是ttl&#34;&gt;什么是TTL&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TTL是RabbitMQ中一个消息或者队列的属性，表明一条消息或者该队列中所有消息的最大存活时间，单位是毫秒&lt;/strong&gt;。如果一条设置了TTL属性的消息或者一条消息进入设置了TTL属性的队列后，那么这条消息在设置的时间内没有被消费，则会成为“死信”，如果消息配置了TTL后被投递到设置了TTL属性的队列中，则按照较小的那个值设置。&lt;/p&gt;
&lt;h3 id=&#34;如何设置ttl&#34;&gt;如何设置TTL&lt;/h3&gt;
&lt;p&gt;如果不设置TTL，则消息永远不会过期。&lt;br&gt;
如果TTL=0，则表示除非此时可以直接投递到该消息的消费者，否则这条消息就会被丢弃。&lt;/p&gt;
&lt;h3 id=&#34;创建队列时设置队列的ttl&#34;&gt;创建队列时，设置队列的TTL&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;String, Object&amp;gt;();
args.put(&amp;quot;x-message-ttl&amp;quot;, 6000);
channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置每条消息的ttl&#34;&gt;设置每条消息的TTL&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder();
builder.expiration(&amp;quot;6000&amp;quot;);
AMQP.BasicProperties properties = builder.build();
channel.basicPublish(exchangeName, routingKey, mandatory, properties, &amp;quot;msg body&amp;quot;.getBytes());
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;两种ttl的特性&#34;&gt;两种TTL的特性&lt;/h3&gt;
&lt;p&gt;两种设置方式有很大的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果设置了队列的TTL，那么一旦消息过期，就会被队列丢弃。&lt;/li&gt;
&lt;li&gt;针对每条消息设置TTL，即使消息过期，也不会马上丢弃，因为消息是否过期是在即将投递到消费者之前确定的，如果当前队列有严重的消息积压，则已经过期的消息也许还能存活很长时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述第2点，RabbitMQ只会检查第一个消息是否过期，消息过期还存活的原因是因为队列是有序消费的，而如果需要判断每条消息是否过期则需要遍历整个队列，性能损耗太大，选择在有序消费到该消息时准备投递前进行消息的判断，空间换时间的方案。&lt;/p&gt;
&lt;h2 id=&#34;dlxdead-letter-exchanges&#34;&gt;DLX（Dead Letter Exchanges）&lt;/h2&gt;
&lt;h3 id=&#34;什么是dlx&#34;&gt;什么是DLX&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;DLX的作用就是用来接收死信消息，当一个消息在队列中变成了死信消息后，可以发送到另一个exchange（交换机），这个交换机就是DLX，绑定DLX的队列成为死信队列，当这个队列存在死信消息时，RabbitMQ就会立即将这个消息发布到设置的DLX上去，进而被路由到绑定该DLX的死信队列上。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;什么是死信&#34;&gt;什么是死信&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;消息被拒绝 （Basic.Reject/Basic.Nack），并且设置requeue=false&lt;/li&gt;
&lt;li&gt;消息过期（TTL）&lt;/li&gt;
&lt;li&gt;队列达到最大长度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何设置dlx&#34;&gt;如何设置DLX&lt;/h3&gt;
&lt;p&gt;RabbitMQ的Queue可以配置&lt;code&gt;x-dead-letter-exchange&lt;/code&gt; 和 &lt;code&gt;x-dead-letter-routing-key&lt;/code&gt;（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由转发到指定的队列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange&lt;/li&gt;
&lt;li&gt;x-dead-letter-routing-key：出现dead letter之后将dead letter重新按照指定的routing-key发送&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基础知识总结&#34;&gt;基础知识总结&lt;/h2&gt;
&lt;p&gt;结合TTL和DLX两个特性，将消息设置了TTL规则之后当消息在队列中变为dead letter时，利用DLX特性将它转发到另一个Exchange或者Routing Key，这个时候绑定这个死信队列的消费者开始消费消息即可实现延时消费的效果。&lt;/p&gt;
&lt;p&gt;生产者生产一条延时消息，根据需要延时时间的不同，&lt;strong&gt;利用不同的routingKey将消息路由到不同的延时队列①&lt;/strong&gt;，每个队列都设置了不同的TTL属性，并绑定在同一个死信交换机中，消息过期后，根据routingKey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列进行处理即可。&lt;/p&gt;
&lt;p&gt;①：不同消息绑定在不同的队列中很重要，此处使用的是TTL的第一种，为队列设置时长。可以确保队列中消息的过期时间是有序的。因为如果队列中有不同过期时间的消息，会出现消息错乱的情况。比如第一条是10分钟过期，第二条是20秒过期，则必须要等第一条消息有序被消费后（结合TTL过期特性，空间换时间），才能在10分钟20秒后消费到第二条消息。&lt;/p&gt;
&lt;h1 id=&#34;实现延迟消息队列&#34;&gt;实现延迟消息队列&lt;/h1&gt;
&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;h3 id=&#34;配置部分&#34;&gt;配置部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 代码: https://www.cnblogs.com/mfrank/p/11260355.html
 * @author imyzt
 * @date 2020/08/29
 * @description 配置文件
 */
@Configuration
public class RabbitMQConfig {

    /**
     * 延迟交换机
     */
    public static final String DELAY_EXCHANGE_NAME = &amp;quot;delay.queue.demo.business.exchange&amp;quot;;
    /**
     * 延迟队列名称
     */
    private static final String DELAY_QUEUEA_NAME = &amp;quot;delay.queue.demo.business.queuea&amp;quot;;
    private static final String DELAY_QUEUEB_NAME = &amp;quot;delay.queue.demo.business.queueb&amp;quot;;
    /**
     * 延迟队列Routing Key
     */
    public static final String DELAY_QUEUEA_ROUTING_KEY = &amp;quot;delay.queue.demo.business.queuea.routingkey&amp;quot;;
    public static final String DELAY_QUEUEB_ROUTING_KEY = &amp;quot;delay.queue.demo.business.queueb.routingkey&amp;quot;;
    /**
     * 死信交换机
     */
    private static final String DEAD_LETTER_EXCHANGE = &amp;quot;delay.queue.demo.deadletter.exchange&amp;quot;;
    /**
     * 死信队列Routing Key
     */
    private static final String DEAD_LETTER_QUEUEA_ROUTING_KEY = &amp;quot;delay.queue.demo.deadletter.delay_10s.routingkey&amp;quot;;
    private static final String DEAD_LETTER_QUEUEB_ROUTING_KEY = &amp;quot;delay.queue.demo.deadletter.delay_60s.routingkey&amp;quot;;
    /**
     * 死信队列名称
     */
    public static final String DEAD_LETTER_QUEUEA_NAME = &amp;quot;delay.queue.demo.deadletter.queuea&amp;quot;;
    public static final String DEAD_LETTER_QUEUEB_NAME = &amp;quot;delay.queue.demo.deadletter.queueb&amp;quot;;

    /**
     * 首先声明延迟队列, 生产者通过交换机和Routing Key将消息发送到延迟队列上
     * 然后消息变为死信时, 死信交换机将消息转发到死信队列上, 消费者对死信队列进行监听
     */

    /**
     * 声明延迟队列交换机
     */
    @Bean
    public DirectExchange delayExchange() {
        return new DirectExchange(DELAY_EXCHANGE_NAME);
    }
    /**
     * 声明死信队列交换机
     */
    @Bean
    public DirectExchange deadLetterExchange() {
        return new DirectExchange(DEAD_LETTER_EXCHANGE);
    }

    /**
     * 声明延迟队列A
     * 延迟10秒
     * 并绑定到对应的死信交换机
     */
    @Bean
    public Queue delayQueueA() {
        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(3);
        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机
        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;, DEAD_LETTER_EXCHANGE);
        // x-dead-letter-routing-key  这里声明当前队列的死信路由key
        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;, DEAD_LETTER_QUEUEA_ROUTING_KEY);
        // x-message-ttl  声明队列的TTL
        args.put(&amp;quot;x-message-ttl&amp;quot;, 10000);
        return QueueBuilder.durable(DELAY_QUEUEA_NAME).withArguments(args).build();
    }
    /**
     * 声明延迟队列B
     * 延迟60秒
     * 并绑定到对应的死信交换机
     */
    @Bean
    public Queue delayQueueB() {
        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(3);
        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机
        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;, DEAD_LETTER_EXCHANGE);
        // x-dead-letter-routing-key  这里声明当前队列的死信路由key
        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;, DEAD_LETTER_QUEUEB_ROUTING_KEY);
        // x-message-ttl  声明队列的TTL
        args.put(&amp;quot;x-message-ttl&amp;quot;, 60000);
        return QueueBuilder.durable(DELAY_QUEUEB_NAME).withArguments(args).build();
    }

    /**
     * 声明死信队列A, 用于接收延迟10s的消息
     */
    @Bean
    public Queue deadLetterQueueA() {
        return new Queue(DEAD_LETTER_QUEUEA_NAME);
    }
    /**
     * 声明死信队列B, 用于接收延迟60s的消息
     */
    @Bean
    public Queue deadLetterQueueB() {
        return new Queue(DEAD_LETTER_QUEUEB_NAME);
    }

    /**
     * 声明延迟队列A与延迟队列交换机绑定关系
     * Routing Key
     */
    @Bean
    public Binding delayBindingA(@Qualifier(&amp;quot;delayQueueA&amp;quot;) Queue queue,
                                                                   @Qualifier(&amp;quot;delayExchange&amp;quot;) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEA_ROUTING_KEY).noargs();
    }
    /**
     * 声明延迟队列B与延迟队列交换机绑定关系
     * Routing Key
     */
    @Bean
    public Binding delayBindingB(@Qualifier(&amp;quot;delayQueueB&amp;quot;) Queue queue,
                                                                   @Qualifier(&amp;quot;delayExchange&amp;quot;) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEB_ROUTING_KEY).noargs();
    }

    /**
     * 声明死信队列A与死信队列交换机绑定关系
     * Routing Key
     */
    @Bean
    public Binding deadBindingA(@Qualifier(&amp;quot;deadLetterQueueA&amp;quot;) Queue queue,
                                                                   @Qualifier(&amp;quot;deadLetterExchange&amp;quot;) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY).noargs();
    }
    /**
     * 声明死信队列B与死信队列交换机绑定关系
     * Routing Key
     */
    @Bean
    public Binding deadBindingB(@Qualifier(&amp;quot;deadLetterQueueB&amp;quot;) Queue queue,
                                                                  @Qualifier(&amp;quot;deadLetterExchange&amp;quot;) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY).noargs();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;生产者部分&#34;&gt;生产者部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 消息生产者
 */
@Slf4j
@RestController
@RequestMapping(&amp;quot;sender&amp;quot;)
public class MessageSenderController {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostMapping
    public void sender(String msg, String type) {

        log.info(&amp;quot;当前时间：{},收到请求，msg:{},delayType:{}&amp;quot;, LocalDateTime.now().toString(), msg, type);

        switch (type) {
            case &amp;quot;DELAY_10S&amp;quot;:
                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEA_ROUTING_KEY, msg);
                break;
            case &amp;quot;DELAY_60S&amp;quot;:
                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEB_ROUTING_KEY, msg);
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;消费者部分&#34;&gt;消费者部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 死信队列消费者
 */
@Component
@Slf4j
public class DeadLetterQueueConsumer {

    @RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)
    public void receiveA(Message message, Channel channel) throws IOException {
        String msg = new String(message.getBody());
        log.info(&amp;quot;当前时间：{},死信队列A收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }

    @RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)
    public void receiveB(Message message, Channel channel) throws IOException {
        String msg = new String(message.getBody());
        log.info(&amp;quot;当前时间：{},死信队列B收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;两个交换机&#34;&gt;两个交换机&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/pu6dgrcf7kjtuqqahres3bp48v.jpg&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/pu6dgrcf7kjtuqqahres3bp48v.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;四个队列&#34;&gt;四个队列&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/3vtkq5kvviivlrlfvtd7mdtja3.jpg&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/3vtkq5kvviivlrlfvtd7mdtja3.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;延迟效果&#34;&gt;延迟效果&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/0hr7c5k8ochhhrfq0t2lldo29b.jpg&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/0hr7c5k8ochhhrfq0t2lldo29b.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;缺陷&#34;&gt;缺陷&lt;/h2&gt;
&lt;p&gt;从上面的效果来看，第一条消息在10秒后变成了死信消息，然后被消费掉。第二条消息在60秒后变成了死信队列，然后被消费掉。目前来看基本功能的延迟队列就算完成了。&lt;br&gt;
但是有一个问题就是，队列的消息都是有序的失效，如果增加一个新的时间需求，那么有需要增加一个队列处理上面的逻辑，实在是不够优雅。&lt;/p&gt;
&lt;h1 id=&#34;延迟队列优化&#34;&gt;延迟队列优化&lt;/h1&gt;
&lt;p&gt;通过上面实现的内容，使用RabbitMQ自带的DLX和TTL，实现的结果是无法对灵活过期时间的支持。&lt;br&gt;
针对这个问题的最终解决方案是使用rabbit提供的一个延迟插件实现。&lt;a href=&#34;https://www.rabbitmq.com/community-plugins.html&#34;&gt;https://www.rabbitmq.com/community-plugins.html&lt;/a&gt;，下载rabbitmq_delayed_message_exchange插件。&lt;/p&gt;
&lt;h2 id=&#34;插件的安装&#34;&gt;插件的安装&lt;/h2&gt;
&lt;p&gt;进入到RabbitMQ安装目录的bin目录下，执行指令安装插件即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rabbitmq-plugins enable rabbitmq_delayed_message_exchange
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;重新实现延迟功能&#34;&gt;重新实现延迟功能&lt;/h2&gt;
&lt;h3 id=&#34;配置部分-2&#34;&gt;配置部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 延迟插件实现消息延迟
 */
@Configuration
public class DelayedRabbitMQConfig {

    /**
     * 延迟队列
     */
    public static final String DELAYED_QUEUE_NAME = &amp;quot;delay.queue.demo.delay.queue&amp;quot;;
    /**
     * 延迟交换机
     */
    public static final String DELAYED_EXCHANGE_NAME = &amp;quot;delay.queue.demo.delay.exchange&amp;quot;;
    /**
     * 延迟队列 Routing Key
     */
    public static final String DELAYED_ROUTING_KEY = &amp;quot;delay.queue.demo.delay.routingkey&amp;quot;;


    /**
     * 创建延迟队列
     */
    @Bean
    public Queue immediateQueue() {
        return new Queue(DELAYED_QUEUE_NAME);
    }

    /**
     * 创建一个自定义的交换机(插件实现)
     */
    @Bean
    public CustomExchange customExchange() {
        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(1);
        args.put(&amp;quot;x-delayed-type&amp;quot;, &amp;quot;direct&amp;quot;);
        return new CustomExchange(DELAYED_EXCHANGE_NAME, &amp;quot;x-delayed-message&amp;quot;, true, false, args);
    }

    /**
     * 绑定交换机和队列
     */
    @Bean
    public Binding bindingNotify(@Qualifier(&amp;quot;immediateQueue&amp;quot;) Queue queue,
                                 @Qualifier(&amp;quot;customExchange&amp;quot;) CustomExchange customExchange) {
        return BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;生产者部分-2&#34;&gt;生产者部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 消息生产者
 */
@Slf4j
@RestController
@RequestMapping(&amp;quot;sender&amp;quot;)
public class MessageSenderController {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 通过插件实现的延迟消息
     * @param msg 消息内容
     * @param delayTime 延迟时间, 毫秒
     */
    @PostMapping(&amp;quot;v2&amp;quot;)
    public void sender(String msg, Integer delayTime) {

        log.info(&amp;quot;当前时间：{},收到请求，msg:{},delayTime:{}&amp;quot;, LocalDateTime.now().toString(), msg, delayTime);

        rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, messagePostProcessor -&amp;gt;{
            messagePostProcessor.getMessageProperties().setDelay(delayTime);
            return messagePostProcessor;
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;消费者部分-2&#34;&gt;消费者部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 死信队列消费者
 */
@Component
@Slf4j
public class DeadLetterQueueConsumer {

    /**
     * 插件延迟队列
     * 消费者
     */
    @RabbitListener(queues = DELAYED_QUEUE_NAME)
    public void receiveD(Message message, Channel channel) throws IOException {
        String msg = new String(message.getBody());
        log.info(&amp;quot;当前时间：{},延时队列收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;交换机&#34;&gt;交换机&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/7p9h2n83oojuqpn5rt3dmkfc3r.png&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/7p9h2n83oojuqpn5rt3dmkfc3r.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;队列&#34;&gt;队列&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/05esbd0g36giqrfcltkp3jg0bg.png&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/05esbd0g36giqrfcltkp3jg0bg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;效果图&#34;&gt;效果图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/1m6okllergjoqp3i0imaadojao.png&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/1m6okllergjoqp3i0imaadojao.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;TTL对消息设置过期时间，过期时间是无序的。所以不能用于延迟队列不同过期时间的处理。只能针对队列设置时间，一个队列处理一个时间的需求。&lt;/li&gt;
&lt;li&gt;如果需要可靠性延迟队列，推荐使用插件。&lt;/li&gt;
&lt;li&gt;rabbitmq_delayed_message_exchange插件在RAM节点会有一些问题，这个博主描述了这部分&lt;a href=&#34;https://blog.csdn.net/wangming520liwei/article/details/103352440&#34;&gt;https://blog.csdn.net/wangming520liwei/article/details/103352440&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文大量参考了“参考文章”中的内容，只是对自己学习延迟队列的内容记载。感谢原作者们。&lt;/li&gt;
&lt;li&gt;本文出现的源代码均在&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/mq-series/RabbitMQ/delay-queue-simple&#34;&gt;github&lt;/a&gt;中&lt;/li&gt;
&lt;/ol&gt;
">RabbitMQ 实现延迟队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/rabbitmq-yan-chi-gong-neng/"" data-c="
          &lt;h1 id=&#34;参考文章&#34;&gt;参考文章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;https://www.cnblogs.com/mfrank/p/11260355.html&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/u014308482/article/details/53036770&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/u012988901/article/details/88958654&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;本文大纲&#34;&gt;本文大纲&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/380dc612ncjaoojm2ta7l64ih8.png&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/380dc612ncjaoojm2ta7l64ih8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;什么是延迟队列&#34;&gt;什么是延迟队列&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;延迟队列也是队列，队列就意味着元素是有序的。元素出队和入队是有方向的，从一端进，从另一端出。&lt;/strong&gt;&lt;br&gt;
延迟队列体现在延迟上面，普通的队列是希望元素能够被更快的消费，而延迟队列是希望元素在指定的时间被消费。所以&lt;strong&gt;延迟队列里面的元素是带有时间属性&lt;/strong&gt;的。&lt;/p&gt;
&lt;h1 id=&#34;延迟队列的使用场景&#34;&gt;延迟队列的使用场景&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;用户订单10分钟内未支付自动取消&lt;/li&gt;
&lt;li&gt;预定会议后，开会前10分钟提醒&lt;/li&gt;
&lt;li&gt;优惠券到期前提醒&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;基础知识补充&#34;&gt;基础知识补充&lt;/h1&gt;
&lt;h2 id=&#34;ttltime-to-live&#34;&gt;TTL（Time To Live）&lt;/h2&gt;
&lt;h3 id=&#34;什么是ttl&#34;&gt;什么是TTL&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TTL是RabbitMQ中一个消息或者队列的属性，表明一条消息或者该队列中所有消息的最大存活时间，单位是毫秒&lt;/strong&gt;。如果一条设置了TTL属性的消息或者一条消息进入设置了TTL属性的队列后，那么这条消息在设置的时间内没有被消费，则会成为“死信”，如果消息配置了TTL后被投递到设置了TTL属性的队列中，则按照较小的那个值设置。&lt;/p&gt;
&lt;h3 id=&#34;如何设置ttl&#34;&gt;如何设置TTL&lt;/h3&gt;
&lt;p&gt;如果不设置TTL，则消息永远不会过期。&lt;br&gt;
如果TTL=0，则表示除非此时可以直接投递到该消息的消费者，否则这条消息就会被丢弃。&lt;/p&gt;
&lt;h3 id=&#34;创建队列时设置队列的ttl&#34;&gt;创建队列时，设置队列的TTL&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;String, Object&amp;gt;();
args.put(&amp;quot;x-message-ttl&amp;quot;, 6000);
channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置每条消息的ttl&#34;&gt;设置每条消息的TTL&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder();
builder.expiration(&amp;quot;6000&amp;quot;);
AMQP.BasicProperties properties = builder.build();
channel.basicPublish(exchangeName, routingKey, mandatory, properties, &amp;quot;msg body&amp;quot;.getBytes());
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;两种ttl的特性&#34;&gt;两种TTL的特性&lt;/h3&gt;
&lt;p&gt;两种设置方式有很大的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果设置了队列的TTL，那么一旦消息过期，就会被队列丢弃。&lt;/li&gt;
&lt;li&gt;针对每条消息设置TTL，即使消息过期，也不会马上丢弃，因为消息是否过期是在即将投递到消费者之前确定的，如果当前队列有严重的消息积压，则已经过期的消息也许还能存活很长时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述第2点，RabbitMQ只会检查第一个消息是否过期，消息过期还存活的原因是因为队列是有序消费的，而如果需要判断每条消息是否过期则需要遍历整个队列，性能损耗太大，选择在有序消费到该消息时准备投递前进行消息的判断，空间换时间的方案。&lt;/p&gt;
&lt;h2 id=&#34;dlxdead-letter-exchanges&#34;&gt;DLX（Dead Letter Exchanges）&lt;/h2&gt;
&lt;h3 id=&#34;什么是dlx&#34;&gt;什么是DLX&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;DLX的作用就是用来接收死信消息，当一个消息在队列中变成了死信消息后，可以发送到另一个exchange（交换机），这个交换机就是DLX，绑定DLX的队列成为死信队列，当这个队列存在死信消息时，RabbitMQ就会立即将这个消息发布到设置的DLX上去，进而被路由到绑定该DLX的死信队列上。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;什么是死信&#34;&gt;什么是死信&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;消息被拒绝 （Basic.Reject/Basic.Nack），并且设置requeue=false&lt;/li&gt;
&lt;li&gt;消息过期（TTL）&lt;/li&gt;
&lt;li&gt;队列达到最大长度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何设置dlx&#34;&gt;如何设置DLX&lt;/h3&gt;
&lt;p&gt;RabbitMQ的Queue可以配置&lt;code&gt;x-dead-letter-exchange&lt;/code&gt; 和 &lt;code&gt;x-dead-letter-routing-key&lt;/code&gt;（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由转发到指定的队列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange&lt;/li&gt;
&lt;li&gt;x-dead-letter-routing-key：出现dead letter之后将dead letter重新按照指定的routing-key发送&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基础知识总结&#34;&gt;基础知识总结&lt;/h2&gt;
&lt;p&gt;结合TTL和DLX两个特性，将消息设置了TTL规则之后当消息在队列中变为dead letter时，利用DLX特性将它转发到另一个Exchange或者Routing Key，这个时候绑定这个死信队列的消费者开始消费消息即可实现延时消费的效果。&lt;/p&gt;
&lt;p&gt;生产者生产一条延时消息，根据需要延时时间的不同，&lt;strong&gt;利用不同的routingKey将消息路由到不同的延时队列①&lt;/strong&gt;，每个队列都设置了不同的TTL属性，并绑定在同一个死信交换机中，消息过期后，根据routingKey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列进行处理即可。&lt;/p&gt;
&lt;p&gt;①：不同消息绑定在不同的队列中很重要，此处使用的是TTL的第一种，为队列设置时长。可以确保队列中消息的过期时间是有序的。因为如果队列中有不同过期时间的消息，会出现消息错乱的情况。比如第一条是10分钟过期，第二条是20秒过期，则必须要等第一条消息有序被消费后（结合TTL过期特性，空间换时间），才能在10分钟20秒后消费到第二条消息。&lt;/p&gt;
&lt;h1 id=&#34;实现延迟消息队列&#34;&gt;实现延迟消息队列&lt;/h1&gt;
&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;h3 id=&#34;配置部分&#34;&gt;配置部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 代码: https://www.cnblogs.com/mfrank/p/11260355.html
 * @author imyzt
 * @date 2020/08/29
 * @description 配置文件
 */
@Configuration
public class RabbitMQConfig {

    /**
     * 延迟交换机
     */
    public static final String DELAY_EXCHANGE_NAME = &amp;quot;delay.queue.demo.business.exchange&amp;quot;;
    /**
     * 延迟队列名称
     */
    private static final String DELAY_QUEUEA_NAME = &amp;quot;delay.queue.demo.business.queuea&amp;quot;;
    private static final String DELAY_QUEUEB_NAME = &amp;quot;delay.queue.demo.business.queueb&amp;quot;;
    /**
     * 延迟队列Routing Key
     */
    public static final String DELAY_QUEUEA_ROUTING_KEY = &amp;quot;delay.queue.demo.business.queuea.routingkey&amp;quot;;
    public static final String DELAY_QUEUEB_ROUTING_KEY = &amp;quot;delay.queue.demo.business.queueb.routingkey&amp;quot;;
    /**
     * 死信交换机
     */
    private static final String DEAD_LETTER_EXCHANGE = &amp;quot;delay.queue.demo.deadletter.exchange&amp;quot;;
    /**
     * 死信队列Routing Key
     */
    private static final String DEAD_LETTER_QUEUEA_ROUTING_KEY = &amp;quot;delay.queue.demo.deadletter.delay_10s.routingkey&amp;quot;;
    private static final String DEAD_LETTER_QUEUEB_ROUTING_KEY = &amp;quot;delay.queue.demo.deadletter.delay_60s.routingkey&amp;quot;;
    /**
     * 死信队列名称
     */
    public static final String DEAD_LETTER_QUEUEA_NAME = &amp;quot;delay.queue.demo.deadletter.queuea&amp;quot;;
    public static final String DEAD_LETTER_QUEUEB_NAME = &amp;quot;delay.queue.demo.deadletter.queueb&amp;quot;;

    /**
     * 首先声明延迟队列, 生产者通过交换机和Routing Key将消息发送到延迟队列上
     * 然后消息变为死信时, 死信交换机将消息转发到死信队列上, 消费者对死信队列进行监听
     */

    /**
     * 声明延迟队列交换机
     */
    @Bean
    public DirectExchange delayExchange() {
        return new DirectExchange(DELAY_EXCHANGE_NAME);
    }
    /**
     * 声明死信队列交换机
     */
    @Bean
    public DirectExchange deadLetterExchange() {
        return new DirectExchange(DEAD_LETTER_EXCHANGE);
    }

    /**
     * 声明延迟队列A
     * 延迟10秒
     * 并绑定到对应的死信交换机
     */
    @Bean
    public Queue delayQueueA() {
        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(3);
        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机
        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;, DEAD_LETTER_EXCHANGE);
        // x-dead-letter-routing-key  这里声明当前队列的死信路由key
        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;, DEAD_LETTER_QUEUEA_ROUTING_KEY);
        // x-message-ttl  声明队列的TTL
        args.put(&amp;quot;x-message-ttl&amp;quot;, 10000);
        return QueueBuilder.durable(DELAY_QUEUEA_NAME).withArguments(args).build();
    }
    /**
     * 声明延迟队列B
     * 延迟60秒
     * 并绑定到对应的死信交换机
     */
    @Bean
    public Queue delayQueueB() {
        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(3);
        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机
        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;, DEAD_LETTER_EXCHANGE);
        // x-dead-letter-routing-key  这里声明当前队列的死信路由key
        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;, DEAD_LETTER_QUEUEB_ROUTING_KEY);
        // x-message-ttl  声明队列的TTL
        args.put(&amp;quot;x-message-ttl&amp;quot;, 60000);
        return QueueBuilder.durable(DELAY_QUEUEB_NAME).withArguments(args).build();
    }

    /**
     * 声明死信队列A, 用于接收延迟10s的消息
     */
    @Bean
    public Queue deadLetterQueueA() {
        return new Queue(DEAD_LETTER_QUEUEA_NAME);
    }
    /**
     * 声明死信队列B, 用于接收延迟60s的消息
     */
    @Bean
    public Queue deadLetterQueueB() {
        return new Queue(DEAD_LETTER_QUEUEB_NAME);
    }

    /**
     * 声明延迟队列A与延迟队列交换机绑定关系
     * Routing Key
     */
    @Bean
    public Binding delayBindingA(@Qualifier(&amp;quot;delayQueueA&amp;quot;) Queue queue,
                                                                   @Qualifier(&amp;quot;delayExchange&amp;quot;) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEA_ROUTING_KEY).noargs();
    }
    /**
     * 声明延迟队列B与延迟队列交换机绑定关系
     * Routing Key
     */
    @Bean
    public Binding delayBindingB(@Qualifier(&amp;quot;delayQueueB&amp;quot;) Queue queue,
                                                                   @Qualifier(&amp;quot;delayExchange&amp;quot;) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEB_ROUTING_KEY).noargs();
    }

    /**
     * 声明死信队列A与死信队列交换机绑定关系
     * Routing Key
     */
    @Bean
    public Binding deadBindingA(@Qualifier(&amp;quot;deadLetterQueueA&amp;quot;) Queue queue,
                                                                   @Qualifier(&amp;quot;deadLetterExchange&amp;quot;) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY).noargs();
    }
    /**
     * 声明死信队列B与死信队列交换机绑定关系
     * Routing Key
     */
    @Bean
    public Binding deadBindingB(@Qualifier(&amp;quot;deadLetterQueueB&amp;quot;) Queue queue,
                                                                  @Qualifier(&amp;quot;deadLetterExchange&amp;quot;) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY).noargs();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;生产者部分&#34;&gt;生产者部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 消息生产者
 */
@Slf4j
@RestController
@RequestMapping(&amp;quot;sender&amp;quot;)
public class MessageSenderController {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @PostMapping
    public void sender(String msg, String type) {

        log.info(&amp;quot;当前时间：{},收到请求，msg:{},delayType:{}&amp;quot;, LocalDateTime.now().toString(), msg, type);

        switch (type) {
            case &amp;quot;DELAY_10S&amp;quot;:
                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEA_ROUTING_KEY, msg);
                break;
            case &amp;quot;DELAY_60S&amp;quot;:
                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEB_ROUTING_KEY, msg);
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;消费者部分&#34;&gt;消费者部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 死信队列消费者
 */
@Component
@Slf4j
public class DeadLetterQueueConsumer {

    @RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)
    public void receiveA(Message message, Channel channel) throws IOException {
        String msg = new String(message.getBody());
        log.info(&amp;quot;当前时间：{},死信队列A收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }

    @RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)
    public void receiveB(Message message, Channel channel) throws IOException {
        String msg = new String(message.getBody());
        log.info(&amp;quot;当前时间：{},死信队列B收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;两个交换机&#34;&gt;两个交换机&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/pu6dgrcf7kjtuqqahres3bp48v.jpg&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/pu6dgrcf7kjtuqqahres3bp48v.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;四个队列&#34;&gt;四个队列&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/3vtkq5kvviivlrlfvtd7mdtja3.jpg&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/3vtkq5kvviivlrlfvtd7mdtja3.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;延迟效果&#34;&gt;延迟效果&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/0hr7c5k8ochhhrfq0t2lldo29b.jpg&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/0hr7c5k8ochhhrfq0t2lldo29b.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;缺陷&#34;&gt;缺陷&lt;/h2&gt;
&lt;p&gt;从上面的效果来看，第一条消息在10秒后变成了死信消息，然后被消费掉。第二条消息在60秒后变成了死信队列，然后被消费掉。目前来看基本功能的延迟队列就算完成了。&lt;br&gt;
但是有一个问题就是，队列的消息都是有序的失效，如果增加一个新的时间需求，那么有需要增加一个队列处理上面的逻辑，实在是不够优雅。&lt;/p&gt;
&lt;h1 id=&#34;延迟队列优化&#34;&gt;延迟队列优化&lt;/h1&gt;
&lt;p&gt;通过上面实现的内容，使用RabbitMQ自带的DLX和TTL，实现的结果是无法对灵活过期时间的支持。&lt;br&gt;
针对这个问题的最终解决方案是使用rabbit提供的一个延迟插件实现。&lt;a href=&#34;https://www.rabbitmq.com/community-plugins.html&#34;&gt;https://www.rabbitmq.com/community-plugins.html&lt;/a&gt;，下载rabbitmq_delayed_message_exchange插件。&lt;/p&gt;
&lt;h2 id=&#34;插件的安装&#34;&gt;插件的安装&lt;/h2&gt;
&lt;p&gt;进入到RabbitMQ安装目录的bin目录下，执行指令安装插件即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rabbitmq-plugins enable rabbitmq_delayed_message_exchange
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;重新实现延迟功能&#34;&gt;重新实现延迟功能&lt;/h2&gt;
&lt;h3 id=&#34;配置部分-2&#34;&gt;配置部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 延迟插件实现消息延迟
 */
@Configuration
public class DelayedRabbitMQConfig {

    /**
     * 延迟队列
     */
    public static final String DELAYED_QUEUE_NAME = &amp;quot;delay.queue.demo.delay.queue&amp;quot;;
    /**
     * 延迟交换机
     */
    public static final String DELAYED_EXCHANGE_NAME = &amp;quot;delay.queue.demo.delay.exchange&amp;quot;;
    /**
     * 延迟队列 Routing Key
     */
    public static final String DELAYED_ROUTING_KEY = &amp;quot;delay.queue.demo.delay.routingkey&amp;quot;;


    /**
     * 创建延迟队列
     */
    @Bean
    public Queue immediateQueue() {
        return new Queue(DELAYED_QUEUE_NAME);
    }

    /**
     * 创建一个自定义的交换机(插件实现)
     */
    @Bean
    public CustomExchange customExchange() {
        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(1);
        args.put(&amp;quot;x-delayed-type&amp;quot;, &amp;quot;direct&amp;quot;);
        return new CustomExchange(DELAYED_EXCHANGE_NAME, &amp;quot;x-delayed-message&amp;quot;, true, false, args);
    }

    /**
     * 绑定交换机和队列
     */
    @Bean
    public Binding bindingNotify(@Qualifier(&amp;quot;immediateQueue&amp;quot;) Queue queue,
                                 @Qualifier(&amp;quot;customExchange&amp;quot;) CustomExchange customExchange) {
        return BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;生产者部分-2&#34;&gt;生产者部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 消息生产者
 */
@Slf4j
@RestController
@RequestMapping(&amp;quot;sender&amp;quot;)
public class MessageSenderController {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 通过插件实现的延迟消息
     * @param msg 消息内容
     * @param delayTime 延迟时间, 毫秒
     */
    @PostMapping(&amp;quot;v2&amp;quot;)
    public void sender(String msg, Integer delayTime) {

        log.info(&amp;quot;当前时间：{},收到请求，msg:{},delayTime:{}&amp;quot;, LocalDateTime.now().toString(), msg, delayTime);

        rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, messagePostProcessor -&amp;gt;{
            messagePostProcessor.getMessageProperties().setDelay(delayTime);
            return messagePostProcessor;
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;消费者部分-2&#34;&gt;消费者部分&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2020/08/29
 * @description 死信队列消费者
 */
@Component
@Slf4j
public class DeadLetterQueueConsumer {

    /**
     * 插件延迟队列
     * 消费者
     */
    @RabbitListener(queues = DELAYED_QUEUE_NAME)
    public void receiveD(Message message, Channel channel) throws IOException {
        String msg = new String(message.getBody());
        log.info(&amp;quot;当前时间：{},延时队列收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;交换机&#34;&gt;交换机&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/7p9h2n83oojuqpn5rt3dmkfc3r.png&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/7p9h2n83oojuqpn5rt3dmkfc3r.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;队列&#34;&gt;队列&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/05esbd0g36giqrfcltkp3jg0bg.png&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/05esbd0g36giqrfcltkp3jg0bg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;效果图&#34;&gt;效果图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/08/1m6okllergjoqp3i0imaadojao.png&#34; alt=&#34;http://blog.imyzt.top/upload/2020/08/1m6okllergjoqp3i0imaadojao.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;TTL对消息设置过期时间，过期时间是无序的。所以不能用于延迟队列不同过期时间的处理。只能针对队列设置时间，一个队列处理一个时间的需求。&lt;/li&gt;
&lt;li&gt;如果需要可靠性延迟队列，推荐使用插件。&lt;/li&gt;
&lt;li&gt;rabbitmq_delayed_message_exchange插件在RAM节点会有一些问题，这个博主描述了这部分&lt;a href=&#34;https://blog.csdn.net/wangming520liwei/article/details/103352440&#34;&gt;https://blog.csdn.net/wangming520liwei/article/details/103352440&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文大量参考了“参考文章”中的内容，只是对自己学习延迟队列的内容记载。感谢原作者们。&lt;/li&gt;
&lt;li&gt;本文出现的源代码均在&lt;a href=&#34;https://github.com/imyzt/learning-technology-code/tree/master/mq-series/RabbitMQ/delay-queue-simple&#34;&gt;github&lt;/a&gt;中&lt;/li&gt;
&lt;/ol&gt;
">RabbitMQ实现延迟队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/go-qie-pian-shu-zu/"" data-c="
          &lt;h1 id=&#34;数组&#34;&gt;数组&lt;/h1&gt;
&lt;p&gt;数组只能存储同一种数据类型的数据&lt;br&gt;
数组长度一经初始化，不能够修改&lt;/p&gt;
&lt;h2 id=&#34;数组的声明&#34;&gt;数组的声明&lt;/h2&gt;
&lt;p&gt;var 数组名称 [长度]数据类型&lt;/p&gt;
&lt;p&gt;获取数组的长度使用内置函数len(arr)&lt;br&gt;
获取数组的容量使用内置函数cap(arr)&lt;/p&gt;
&lt;p&gt;func main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// var 数组名词 [长度]数据类型
var arr [5]int
arr[0] = 1
arr[1] = 2

// 没有赋值的内容, 默认为数组数据类型的零值
fmt.Println(arr[2])	// 0

fmt.Println(&amp;quot;数组的长度为:&amp;quot;, len(arr))	// 5
fmt.Println(&amp;quot;数组的容量为:&amp;quot;, cap(arr))	// 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2 id=&#34;数组的创建&#34;&gt;数组的创建&lt;/h2&gt;
&lt;p&gt;数组创建有四种方式&lt;/p&gt;
&lt;p&gt;func main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 0. 创建时制定长度, 不赋值
var arr0 [5]int
arr0[0] = 1
fmt.Println(arr0[0])	// 1

// 1. 创建时, 直接将值赋值到数组里面
arr := [3]int{1,2,3}
fmt.Println(arr[2])		// 3

// 2. 指定对应位置的值
arr1 := [3]int{0:3, 1:2, 2:1}
fmt.Println(arr1[0])	// 3

// 3. 创建时, 不指定数组长度, 由初始化赋值长度自动推断
arr2 := [...]int{1, 2, 3, 4, 5}
fmt.Println(&amp;quot;arr2 len: &amp;quot;, len(arr2))	// 5
fmt.Println(&amp;quot;arr2 cap: &amp;quot;, cap(arr2))	// 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2 id=&#34;数组的遍历&#34;&gt;数组的遍历&lt;/h2&gt;
&lt;p&gt;func main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr := [...]int{1,2,3,4,5}

// range方式遍历
for a := range arr {
	fmt.Println(a)
}

fmt.Println(&amp;quot;---&amp;quot;)

// for循环方式
for idx, a := range arr {
	fmt.Println(&amp;quot;idx=&amp;quot;, idx, &amp;quot;arr=&amp;quot;, a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2 id=&#34;二维数组&#34;&gt;二维数组&lt;/h2&gt;
&lt;p&gt;func main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 定义, 后赋值
// arr1 := [2][3]int

// 定义时初始化
arr := [2][3]int{{1,2,3},{11,22,33}}

printArr(arr)

//[0][0]=1
//[0][1]=2
//[0][2]=3
//[1][0]=11
//[1][1]=22
//[1][2]=33

fmt.Println(&amp;quot;---&amp;quot;)

// 通过下标修改数组元素
arr[1][0] = 111

printArr(arr)

//[0][0]=1
//[0][1]=2
//[0][2]=3
//[1][0]=111
//[1][1]=22
//[1][2]=33
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;func printArr(arr [2][3]int) {&lt;br&gt;
for one, ints := range arr {&lt;br&gt;
for two, i2 := range ints {&lt;br&gt;
fmt.Println(fmt.Sprintf(&amp;quot;[%v][%v]=%v&amp;quot;, one, two, i2))&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
}&lt;/p&gt;
&lt;h1 id=&#34;切片slice&#34;&gt;切片Slice&lt;/h1&gt;
&lt;h2 id=&#34;切片的声明&#34;&gt;切片的声明&lt;/h2&gt;
&lt;p&gt;它与数组的唯一区别，就是[]中不指定长度&lt;/p&gt;
&lt;p&gt;var 切片名称 []数据类型&lt;br&gt;
切片名称 := make([]数据类型, 初始数据, 初始容量)&lt;/p&gt;
&lt;p&gt;// 声明一个切片slice&lt;br&gt;
var slice []int&lt;br&gt;
// 初始化一个长度为2, 容量为5的切片&lt;br&gt;
slice := make([]int, 2, 5)&lt;/p&gt;
&lt;h2 id=&#34;切片的创建与扩容&#34;&gt;切片的创建与扩容&lt;/h2&gt;
&lt;p&gt;通过make函数创建切片&lt;br&gt;
通过append添加元素&lt;br&gt;
切片的扩容是成倍的,扩容后内存地址改变&lt;/p&gt;
&lt;p&gt;func main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 初始化一个长度为2, 容量为5的切片
slice := make([]int, 2, 5)

fmt.Println(slice)
fmt.Println(&amp;quot;len=&amp;quot;, len(slice), &amp;quot;cap=&amp;quot;, cap(slice))

// 切片通过append添加元素
slice = append(slice, 2, 3, 4, 5, 6)
fmt.Println(slice)
// 当切片容量不够时, 成倍扩容
fmt.Println(&amp;quot;len=&amp;quot;, len(slice), &amp;quot;cap=&amp;quot;, cap(slice))
//[0 0]
//len= 2 cap= 5
//[0 0 2 3 4 5 6]
//len= 7 cap= 10


// 添加一组切片到另一切片中
slice1 := append(slice)
// 修改源切片会影响到新切片, 因为是浅拷贝
slice[1] = 1
fmt.Println(slice)
fmt.Println(slice1)
//[0 1 2 3 4 5 6]
//[0 1 2 3 4 5 6]

s1 := make([]int, 0, 3)
fmt.Printf(&amp;quot;地址%p,长度%d,容量%d\n&amp;quot;, s1, len(s1), cap(s1))
s1 = append(s1, 1, 2)
fmt.Printf(&amp;quot;地址%p,长度%d,容量%d\n&amp;quot;, s1, len(s1), cap(s1))
s1 = append(s1, 3, 4, 5)
fmt.Printf(&amp;quot;地址%p,长度%d,容量%d\n&amp;quot;, s1, len(s1), cap(s1))

//地址0xc000016160,长度0,容量3
//地址0xc000016160,长度2,容量3
//地址0xc00001c180,长度5,容量6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2 id=&#34;make与new-的区别&#34;&gt;make()与new() 的区别&lt;/h2&gt;
&lt;p&gt;make()是Go语言中的内置函数，主要用于创建并初始化slice切片类型，或者map字典类型，或者channel通道类型数据。他与new方法的区别是。new用于各种数据类型的内存分配，在Go语言中认为他返回的是一个指针。指向的是一个某种类型的零值。make 返回的是一个有着初始值的非零值。&lt;/p&gt;
&lt;p&gt;func main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;slice1 := new([]int)
fmt.Println(slice1) // &amp;amp;[]

slice2 := make([]int, 3)
fmt.Println(slice2)	// [0 0 0]

//结果出错 slice1是一个空指针 invalid operation: slice1[0] (type *[]int does not support indexing)
fmt.Println(slice1[0])
//结果为 0 因为已经初始化了
fmt.Println(slice2[0])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
">Go 切片数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/go-yu-yan-de-bian-liang-yu-chang-liang/"" data-c="
          &lt;p&gt;go的变量定义了必须使用，不然无法通过编译&lt;br&gt;
全局变量定义后可以不使用，如果全局与局部同名，采用就近原则&lt;br&gt;
如果是简洁模式定义，左边至少应该包括一个新变量&lt;/p&gt;
&lt;h1 id=&#34;变量的定义&#34;&gt;变量的定义&lt;/h1&gt;
&lt;p&gt;变量从繁到简，总共三种方式&lt;br&gt;
var globalVar = &amp;quot;全局变量无法使用简洁模式定义, 但可以定义了不使用&amp;quot;&lt;/p&gt;
&lt;p&gt;func main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 先定义再赋值
var i int;
i = 1
// 定义变量, 定义数据类型, 赋值
var i2 int = 2
// 定义变量, 赋值, 数据类型自动推断
var i3= 3
// 省略变量, 数据类型定义, 数据类型自动推断
i4 := 4
// 定义多个变量
i5, i6, i7 := 5, 6, &amp;quot;i7&amp;quot;
// 会报错, 因为没有定义新的变量
//i5, i6 := 5, 6
//i6, i7 := 6, &amp;quot;i7&amp;quot;
// 表达式中定义了新的i8, 所以不会报错, 并且还给i7赋值了新值(i77)
i7, i8 := &amp;quot;i77&amp;quot;, &amp;quot;i8&amp;quot;

fmt.Println(i, i2, i3, i4, i5, i6, i7, i8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h1 id=&#34;变量的零值&#34;&gt;变量的零值&lt;/h1&gt;
&lt;p&gt;int  -&amp;gt; 0&lt;br&gt;
string -&amp;gt; &amp;quot;&amp;quot;&lt;br&gt;
bool  -&amp;gt; false&lt;br&gt;
float  -&amp;gt; 0.0&lt;/p&gt;
&lt;h1 id=&#34;匿名变量&#34;&gt;匿名变量&lt;/h1&gt;
&lt;p&gt;不想使用的变量可以丢给匿名变量&lt;br&gt;
func main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 赋值给匿名变量, 字符串在go中可以用双引号(&amp;quot;&amp;quot;)也可以用(``)
i1, _ := 1, `赋值给匿名变量的值`

fmt.Println(i1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h1 id=&#34;go变量交换&#34;&gt;go变量交换&lt;/h1&gt;
&lt;p&gt;其他语言交换需要中间变量，golang不需要&lt;br&gt;
func main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a, b := &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;
// 变量直接交换
a, b = b, a

fmt.Println(fmt.Sprintf(&amp;quot;a=%s, b=%s&amp;quot;, a, b))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;console：&lt;br&gt;
a=b, b=a&lt;/p&gt;
">go语言的变量与常量</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/golang-fen-zhi-yu-xun-huan/"" data-c="
          &lt;h2 id=&#34;if分支语句&#34;&gt;if分支语句&lt;/h2&gt;
&lt;h3 id=&#34;普通if&#34;&gt;普通if&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;resp, err := http.Get(url)
if err != nil {
  log.Fatal(fmt.Sprintf(&amp;quot;请求异常, url: %s&amp;quot;, url))
} else if {
} else {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;赋值if&#34;&gt;赋值if&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var nameList []string
if err := json.Unmarshal([]byte(jsonData), &amp;amp;nameList); err != nil {
  log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;switch分支语句&#34;&gt;switch分支语句&lt;/h2&gt;
&lt;h3 id=&#34;普通switch&#34;&gt;普通switch&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;func main()  {

	// 普通switch
	switch 2 {
	case 1:
		fmt.Println(1)
	case 2:
		fmt.Println(2)
	case 3, 4, 5:
		fmt.Println(&amp;quot;3, 4, 5&amp;quot;)
	default:
		fmt.Println(&amp;quot;default&amp;quot;)
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;判断switch&#34;&gt;判断switch&lt;/h3&gt;
&lt;p&gt;很神奇，可以代替多个if条件判断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 省略变量, 相当于作用于bool类型
func main() {

	age := 18
	switch {
    // 条件为true是 执行内容
	case age &amp;gt; 10:
		fmt.Println(&amp;quot;age &amp;gt; 10&amp;quot;)
	case age &amp;gt; 8:
		fmt.Println(&amp;quot;age &amp;gt; 8&amp;quot;)
	default:
		fmt.Println(&amp;quot;default&amp;quot;)
	}
    }
}

console

age &amp;gt; 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;赋值switch&#34;&gt;赋值switch&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;func main()  {

	switch name := &amp;quot;shenzhen&amp;quot;; name {
	case &amp;quot;shenzhen&amp;quot;:
		fmt.Println(&amp;quot;shenzhen&amp;quot;)
	case &amp;quot;foshan&amp;quot;:
		fmt.Println(&amp;quot;foshan&amp;quot;)
	default:
		fmt.Println(&amp;quot;default&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;带跳出的switch&#34;&gt;带跳出的switch&lt;/h3&gt;
&lt;p&gt;golang的switch case自带一个break&lt;br&gt;
如果需要向下执行可以使用fallthrough&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main()  {

	// break 强制跳出, 不执行 &amp;quot;gd3&amp;quot;
	switch name := &amp;quot;gd&amp;quot;; name {
	case &amp;quot;gd&amp;quot;:
		fmt.Println(&amp;quot;gd1&amp;quot;)
		fmt.Println(&amp;quot;gd2&amp;quot;)
		break
		fmt.Println(&amp;quot;gd3&amp;quot;)
	}

	fmt.Println(&amp;quot;-0----&amp;quot;)

	switch name := &amp;quot;sz&amp;quot;; name {
	case &amp;quot;sz&amp;quot;:
		fmt.Println(&amp;quot;深圳1&amp;quot;)
		fmt.Println(&amp;quot;深圳2&amp;quot;)
		fmt.Println(&amp;quot;深圳3&amp;quot;)
		// 执行完 case = &amp;quot;sz&amp;quot;后, 不跳出, 继续执行 case = &amp;quot;gz&amp;quot;
		fallthrough
	case &amp;quot;gz&amp;quot;:
		fmt.Println(&amp;quot;广州&amp;quot;)
	}
}

console: 

gd1
gd2
-0----
深圳1
深圳2
深圳3
广州
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;for循环语句&#34;&gt;for循环语句&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;for (init; condition; post) {}

Init: 初始化，只执行一次
condition: bool类型，
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;普通for&#34;&gt;普通for&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;func main()  {

	for i := 0; i &amp;lt; 5; i ++ {
		fmt.Println(i)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;外部初始化for&#34;&gt;外部初始化for&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;func main() {
	i := 0
	for i &amp;lt;= 5 {
		fmt.Println(i)
		i ++
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;死循环&#34;&gt;死循环&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;func main() {
	for {
		fmt.Println()
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;for循环中的跳转&#34;&gt;for循环中的跳转&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;func main() {

	for i := 1; i &amp;lt;= 5; i++ {
		// 跳出整个循环
		if i == 4 {
			break
		}

		// 跳出当前循环进行下一次循环
		if i &amp;lt; 3 {
			continue
		}
		fmt.Println(fmt.Sprintf(&amp;quot;i = %v&amp;quot;, i))
	}

	// 多层循环可通过定义标签跳转, 在for循环中break和goto都可以完成
	lable:
	for i := 1; i &amp;lt;= 5; i++ {
		for j := i; j &amp;lt;= 5; j++ {
			if i == j {
				break lable
			}
			if j &amp;gt; 3 {
				goto lable
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;for循环实现冒泡&#34;&gt;for循环实现冒泡&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;升序冒泡
func main() {

	arr := []int{1, 2, 5, 2, 22, 1}
	
	// len(arr) - 1, 对比时, 最后一位必须要对比
	for i := 0; i &amp;lt; len(arr) - 1; i++ {
		// j := i + 1, 对比时, 内层for循环无需从第一个开始比对, 即第一个(外层for)和第二个(内层for)比对
		// len(arr) 对比时, 最后一位参与上一层for循环的对比
		for j := i + 1; j &amp;lt; len(arr); j++ {
			if arr[i] &amp;gt; arr[j] {
				// 如果当前的数字, 大于后面的数字, 就把当前数字往后移
				arr[i], arr[j] = arr[j], arr[i]
			}
		}
	}

	for _, num := range arr {
		fmt.Println(num)
	}
}


console:

1
1
2
2
5
22
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;return跳出语句&#34;&gt;return跳出语句&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func main() {

	returnTest(1)
}

func returnTest(i uint) {

	if i &amp;gt; 0 {
		return
	}
	fmt.Println(&amp;quot;i &amp;lt;= 0&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
">golang分支与循环</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-huan-jing-xia-shi-jian-zi-fu-chuan-zhuan-huan/"" data-c="
          &lt;p&gt;Spring时间处理&lt;/p&gt;
&lt;h1 id=&#34;入参处理&#34;&gt;入参处理&lt;/h1&gt;
&lt;p&gt;入参在POST请求时，Spring会默认序列化字符串时间到LocalDateTime系列。&lt;br&gt;
入参在GET请求时，Spring默认不处理，需要在参数上写&lt;code&gt;@DateTimeFormat&lt;/code&gt;注解。&lt;br&gt;
可以通过统一处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/***
     * Date日期类型转换器
     */
    @Bean
    public Formatter&amp;lt;Date&amp;gt; dateFormatter() {
        return new Formatter&amp;lt;Date&amp;gt;() {

            @Override
            public Date parse(String text, Locale locale) {
                SimpleDateFormat sdf = new SimpleDateFormat(Dateutils.DATE_FORMAT_FULL);
                Date date = null;
                try {
                    date = sdf.parse(text);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return date;
            }

            @Override
            public String print(Date object, Locale locale) {
                SimpleDateFormat sdf = new SimpleDateFormat(Dateutils.DATE_FORMAT_FULL);
                return sdf.format(object);
            }
        };
    }
    @Bean
    public Formatter&amp;lt;LocalDate&amp;gt; localDateFormatter() {
        return new Formatter&amp;lt;LocalDate&amp;gt;() {
            @Override
            public LocalDate parse(String text, Locale locale) {
                return LocalDate.parse(text, DateTimeFormatter.ISO_LOCAL_DATE);
            }

            @Override
            public String print(LocalDate object, Locale locale) {
                return DateTimeFormatter.ISO_LOCAL_DATE.format(object);
            }
        };
    }

    @Bean
    public Formatter&amp;lt;LocalDateTime&amp;gt; localDateTimeFormatter() {
        return new Formatter&amp;lt;LocalDateTime&amp;gt;() {
            @Override
            public String print(LocalDateTime localDateTime, Locale locale) {
                return DateTimeFormatter.ofPattern(Dateutils.DATE_FORMAT_FULL).format(localDateTime);
            }

            @Override
            public LocalDateTime parse(String text, Locale locale) {
                return LocalDateTime.parse(text, DateTimeFormatter.ofPattern(Dateutils.DATE_FORMAT_FULL));
            }
        };
    }

    @Bean
    public Formatter&amp;lt;LocalTime&amp;gt; localTimeFormatter() {
        return new Formatter&amp;lt;LocalTime&amp;gt;() {
            @Override
            public String print(LocalTime localTime, Locale locale) {
                return DateTimeFormatter.ofPattern(Dateutils.DATE_FORMAT_HMS).format(localTime);
            }

            @Override
            public LocalTime parse(String text, Locale locale) {
                return LocalTime.parse(text, DateTimeFormatter.ofPattern(Dateutils.DATE_FORMAT_HMS));
            }
        };
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;出参处理&#34;&gt;出参处理&lt;/h1&gt;
&lt;p&gt;出参LocalDateTime时间需要写&lt;code&gt;@JsonFormat(pattern = Dateutils.DATE_FORMAT_FULL)&lt;/code&gt;处理，可以通过增加统一配置处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Bean
    public Jackson2ObjectMapperBuilderCustomizer customizer() {
        return builder -&amp;gt; {
            builder.locale(Locale.CHINA);
            builder.timeZone(TimeZone.getTimeZone(ZoneId.systemDefault()));
            builder.simpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);

            JavaTimeModule javaTimeModule = new JavaTimeModule();
            javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;)));
            javaTimeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(&amp;quot;yyyy-MM-dd&amp;quot;)));
            javaTimeModule.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(&amp;quot;HH:mm:ss&amp;quot;)));
            javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;)));
            javaTimeModule.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(&amp;quot;yyyy-MM-dd&amp;quot;)));
            javaTimeModule.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(&amp;quot;HH:mm:ss&amp;quot;)));

            builder.modules(javaTimeModule);
        };
    }
&lt;/code&gt;&lt;/pre&gt;
">Spring环境下时间字符串转换</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/zhu-jie-ji-cheng-zu-he-zhu-jie/"" data-c="
          &lt;h1 id=&#34;组合注解&#34;&gt;组合注解&lt;/h1&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;组合注解就是将多个注解组合到一个注解上。&lt;br&gt;
比如我们在编写控制器（Controller）时，一般需要写&lt;code&gt;@Controller&lt;/code&gt;和&lt;code&gt;@ResponseBody&lt;/code&gt;，通过组合注解，我们可以写一个&lt;code&gt;@RestController&lt;/code&gt;就可以实现两个注解的功能了。&lt;/p&gt;
&lt;p&gt;在使用SpringBoot时，经常能够看到这些注解的使用。&lt;br&gt;
比如我们在使用&lt;code&gt;@RestController&lt;/code&gt;, &lt;code&gt;@GetMapping&lt;/code&gt;, &lt;code&gt;@Service&lt;/code&gt;时，通过查看它们的源码，都能够发现元注解中有一些常见的注解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Controller // 组合@Controller元注解
@ResponseBody // 组合@ResponseBody元注解
public @interface RestController {}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(method = RequestMethod.GET) // 组合@RequestMapping元注解
public @interface GetMapping {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;值的获取&#34;&gt;值的获取&lt;/h2&gt;
&lt;p&gt;通过组合注解，我们可以很方便的自定义组合功能注解，但是我们没有办法在获取父注解时，像Java继承多态那样方便的获取到子注解的值。&lt;/p&gt;
&lt;p&gt;比如我们的&lt;code&gt;@Controller&lt;/code&gt;注解是有很多参数的，通过定义了&lt;code&gt;@RestController&lt;/code&gt;后，是没有办法传递值到&lt;code&gt;@Controller&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;所以Spring给我们提供了一个工具类，具体操作如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在子注解定义参数，通过&lt;code&gt;@AliasFor(annotation = Controller.class)&lt;/code&gt; 指定参数绑定的父注解参数（参数名相同无需指定）。主要用于约束（类似于重写）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@Controller
@ResponseBody
public @interface RestController {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any (or empty String otherwise)
	 * @since 4.0.1
	 */
	@AliasFor(annotation = Controller.class)
	String value() default &amp;quot;&amp;quot;;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;通过&lt;code&gt;AnnotatedElementUtils&lt;/code&gt;工具类，即可获取父注解（携带子注解值）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;父注解 变量名称 = AnnotatedElementUtils.findMergedAnnotation(子注解.class, 父注解.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实原理非常简单，就是将两个注解的值合并，具体可以查看spring官方文档 &lt;a href=&#34;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/AnnotatedElementUtils.html#findMergedAnnotation-java.lang.reflect.AnnotatedElement-java.lang.Class-&#34;&gt;findMergedAnnotation&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;注解继承&#34;&gt;注解继承&lt;/h1&gt;
&lt;p&gt;注解继承的意思就是标记该注解的类，子类也同等能够继承到父类的注解。&lt;/p&gt;
&lt;p&gt;可以通过 &lt;code&gt;@Inherited&lt;/code&gt; 元注解实现，底层是用jdk帮我们实现的。基本会使用就行&lt;/p&gt;
&lt;p&gt;可以看一下这篇博客： &lt;a href=&#34;https://www.jianshu.com/p/a848655d478e&#34;&gt;简书-JAVA注解的继承性&lt;/a&gt;&lt;/p&gt;
">注解继承、组合注解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/yapiupload-pei-zhi-ji-shi-yong/"" data-c="
          &lt;h1 id=&#34;什么是yapiupload&#34;&gt;什么是YapiUpload&lt;/h1&gt;
&lt;p&gt;yapiUpload是为IDEA提供的快速编写 &lt;a href=&#34;https://github.com/YMFE/yapi&#34;&gt;yapi&lt;/a&gt; 接口文档的工具，在编写好Spring Controller后，通过一系列配置，可以直接生成接口文档到YAPI上。&lt;/p&gt;
&lt;p&gt;yapiUpload是开源的&lt;br&gt;
代码仓库在：&lt;a href=&#34;https://github.com/diwand/YapiIdeaUploadPlugin&#34;&gt;https://github.com/diwand/YapiIdeaUploadPlugin&lt;/a&gt;&lt;br&gt;
文档在：&lt;a href=&#34;https://github.com/diwand/YapiIdeaUploadPlugin/wiki/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8&#34;&gt;https://github.com/diwand/YapiIdeaUploadPlugin/wiki&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;如何安装及配置&#34;&gt;如何安装及配置&lt;/h1&gt;
&lt;h2 id=&#34;idea安装插件&#34;&gt;IDEA安装插件&lt;/h2&gt;
&lt;p&gt;插件地址：&lt;br&gt;
&lt;a href=&#34;https://plugins.jetbrains.com/plugin/12276-yapiupload&#34;&gt;https://plugins.jetbrains.com/plugin/12276-yapiupload&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/05/q2nkc4848kg8gqgirhvv5pp2bc.png&#34; alt=&#34;安装图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;配置yapiupload&#34;&gt;配置yapiUpload&lt;/h2&gt;
&lt;p&gt;找到项目文件 &lt;code&gt;.idea/misc.xml&lt;/code&gt;，在&lt;code&gt;&amp;lt;project&amp;gt;&lt;/code&gt;节点粘贴以下内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;!--yapi配置--&amp;gt;
  &amp;lt;component name=&amp;quot;yapi&amp;quot;&amp;gt;
    &amp;lt;option name=&amp;quot;projectToken&amp;quot;&amp;gt;你的token&amp;lt;/option&amp;gt;
    &amp;lt;option name=&amp;quot;projectId&amp;quot;&amp;gt;14&amp;lt;/option&amp;gt;
    &amp;lt;option name=&amp;quot;yapiUrl&amp;quot;&amp;gt;你的yapi地址&amp;lt;/option&amp;gt;
    &amp;lt;option name=&amp;quot;projectType&amp;quot;&amp;gt;api&amp;lt;/option&amp;gt;
  &amp;lt;/component&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/05/qgo4ug4vd8jguqpci92n9lhj3v.png&#34; alt=&#34;请输入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;如何使用&#34;&gt;如何使用&lt;/h1&gt;
&lt;h2 id=&#34;编写一个标准的接口&#34;&gt;编写一个标准的接口&lt;/h2&gt;
&lt;p&gt;yapiUpload支持很多Javadoc注解，可以在官方文档查看。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/05/shtq7dpcbkgmrom8ttjaprbgr5.png&#34; alt=&#34;标准接口&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;上传到文档地址&#34;&gt;上传到文档地址&lt;/h2&gt;
&lt;h3 id=&#34;上传成功&#34;&gt;上传成功&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/05/rn8ue7flgejktrmv2tt8qk168e.png&#34; alt=&#34;上传成功&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;接口列表&#34;&gt;接口列表&lt;/h3&gt;
&lt;p&gt;登录yapi上查看即可&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/05/r8bpv8cg54iu1rjsk3vnik94t9.png&#34; alt=&#34;接口列表&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;接口详情&#34;&gt;接口详情&lt;/h3&gt;
&lt;p&gt;修改时，一般是直接覆盖，高版本yapi的api支持修改。不过好像这个工具还不支持。&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/05/tll83ishceintqja43s3utkfk9.png&#34; alt=&#34;接口详情&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;二次开发&#34;&gt;二次开发&lt;/h1&gt;
&lt;p&gt;yapiUpload本身是一个IDEA的插件，可以按照IDEA编码进行二次开发。&lt;br&gt;
yapi也提供了二次开发api，可以对该插件做升级。&lt;a href=&#34;https://hellosean1025.github.io/yapi/openapi.html&#34;&gt;https://hellosean1025.github.io/yapi/openapi.html&lt;/a&gt;&lt;/p&gt;
">YapiUpload配置及使用	</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/redis-lua-debug/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/06/umhrmcs17eho2qdnnfs44e7vjp.png&#34; alt=&#34;执行图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;调试命令&#34;&gt;调试命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;redis-cli --ldb --eval loop.lua keysargs1 keysargs2, argv1,argv2&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命令解析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;--ldb 即开启调试模式&lt;br&gt;
--eval 指定调试脚本&lt;br&gt;
keysargs1 keysargs2, argv1,argv2 逗号前是KEYS的参数， 之后是ARGV的参数。&lt;br&gt;
s 如果，通过 &lt;code&gt;s&lt;/code&gt; 执行下一步&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;loop.lua&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;local i=0
while true
do
	i=i+1
	redis.debug(i)
end
return &amp;quot;OK&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;redis-lua-调试工具&#34;&gt;redis lua 调试工具&lt;/h2&gt;
&lt;h4 id=&#34;ide-地址及安装&#34;&gt;IDE 地址及安装&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://redislabs.com/blog/zerobrane-studio-plugin-for-redis-lua-scripts/&#34;&gt;&lt;br&gt;
ZeroBrane Studio Plugin for Redis Lua Scripts&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;lua调试插件地址&#34;&gt;LUA调试插件地址&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/pkulchenko/ZeroBranePackage/blob/master/redis.lua&#34;&gt;https://github.com/pkulchenko/ZeroBranePackage/blob/master/redis.lua&lt;/a&gt;&lt;/p&gt;
">Redis LUA debug</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/redis-lua-ji-ben-shi-yong/"" data-c="
          &lt;h1 id=&#34;eval-lua&#34;&gt;EVAL LUA&lt;/h1&gt;
&lt;h2 id=&#34;rediscall&#34;&gt;redis.call&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过EVAL指令，使用 redis.call 执行LUA脚本，3指定的是，前三个参数是KEYS的，然后后面的是ARGV的。&lt;/li&gt;
&lt;li&gt;LUA索引从1开始。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; EVAL &amp;quot;return redis.call(’SET&#39;, KEYS[2], ARGV[3])&amp;quot; 3 1 2 3 4 5 6
127.0.0.1:6379&amp;gt; get 2
&amp;quot;6&amp;quot;

[1 2 3]是KEYS的
[4 5 6]是ARGV的
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;redispcall&#34;&gt;redis.pcall&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;redis.call 在遇到异常之后，不会继续往后执行。&lt;/li&gt;
&lt;li&gt;redis.pcall 可以捕获异常，如果没处理的话，将继续往后执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;此处第一条语句报错，第二条语句将不会执行。
127.0.0.1:6379&amp;gt; EVAL &amp;quot;redis.call(&#39;SETRRRR&#39;, KEYS[1], ARGV[1]); redis.call(&#39;SET&#39;, KEYS[2], ARGV[2])&amp;quot; 2 a b c d e f g
(error) ERR Error running script (call to f_8a873e7e4125dc92ef97aa5e8b07e22f7d185183): @user_script:1: @user_script: 1: Unknown Redis command called from Lua script
127.0.0.1:6379&amp;gt; get b
(nil)

通过redis.pcall命令，对错误进行捕获后，会继续执行第二条语句。
127.0.0.1:6379&amp;gt; EVAL &amp;quot;redis.pcall(&#39;SETRRRR&#39;, KEYS[1], ARGV[1]); redis.call(&#39;SET&#39;, KEYS[2], ARGV[2])&amp;quot; 2 a b c d e f g
(nil)
127.0.0.1:6379&amp;gt; get b
&amp;quot;d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;script&#34;&gt;SCRIPT&lt;/h1&gt;
&lt;h2 id=&#34;script作用&#34;&gt;SCRIPT作用&lt;/h2&gt;
&lt;p&gt;在开发过程中，如果LUA脚本比较长，是会有一定的网络开销的。可以事先将LUA脚本缓存到redis服务器上，还可以防止脚本暴露在程序中被篡改。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以通过 &lt;code&gt;SCRIPT LOAD &lt;/code&gt;指令将LUA脚本缓存到服务端，服务端返回一个RSA加密后的串。&lt;/li&gt;
&lt;li&gt;执行时，通过 &lt;code&gt;EVALSHA&lt;/code&gt; 执行 &lt;code&gt;RSA串&lt;/code&gt; 即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SCRIPT LOAD &amp;quot;redis.call(&#39;SET&#39;, KEYS[1], ARGV[1])&amp;quot;
&amp;quot;fcd2612e1ca113b83fdfbc2a88493d3b231a32ad&amp;quot;
127.0.0.1:6379&amp;gt; EVALSHA fcd2612e1ca113b83fdfbc2a88493d3b231a32ad 2 a b c d e f g
(nil)
127.0.0.1:6379&amp;gt; get a
&amp;quot;c&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;script基础指令&#34;&gt;SCRIPT基础指令&lt;/h2&gt;
&lt;h3 id=&#34;script-exists-检查是否存在脚本&#34;&gt;SCRIPT EXISTS 检查是否存在脚本&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SCRIPT EXISTS fcd2612e1ca113b83fdfbc2a88493d3b231a32ad
1) (integer) 1
127.0.0.1:6379&amp;gt; SCRIPT EXISTS fcd2612e1ca113b83fdfbc2a88493d3b231a32adaaa
1) (integer) 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;script-flush-清空所有脚本&#34;&gt;SCRIPT FLUSH 清空所有脚本&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SCRIPT FLUSH
OK
127.0.0.1:6379&amp;gt; SCRIPT EXISTS fcd2612e1ca113b83fdfbc2a88493d3b231a32ad
1) (integer) 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;script-kill-杀死当前正在运行的脚本&#34;&gt;SCRIPT KILL 杀死当前正在运行的脚本&lt;/h3&gt;
&lt;p&gt;loop.lua&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;local i=0
while true
do
	i=i+1
	redis.debug(i)
end
return &amp;quot;OK&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;redis-cli --eval loop.lua
进入锁死状态，开一个新窗口。所有指令都返回Redis服务器处于繁忙状态
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/06/rqj21n5tuajciqe98qdlp3tek3.png&#34; alt=&#34;锁死&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;通过KILL指令干掉当前正在执行的指令。
127.0.0.1:6379&amp;gt; SCRIPT KILL
OK
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/06/41h4b4jrrghg0pjagomun2fpbv.png&#34; alt=&#34;释放&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Redis LUA基本使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/xian-cheng-chi-dong-tai-guan-li/"" data-c="
          &lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;​	看了美团  &lt;a href=&#34;https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww&#34;&gt;Java线程池实现原理及其在美团业务中的实践&lt;/a&gt; 这篇文章之后，对线程池有了一些新的认识，后面看到了 &lt;a href=&#34;https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A&#34;&gt;如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答&lt;/a&gt; 四川好男人的一顿骚操作，瞬间又认识的更清晰了一些。就想着能不能做一套这样的线程池管理系统，然后就有了后文。&lt;/p&gt;
&lt;p&gt;​	Web应用系统中，ThreadPoolExecutor一般是由代码硬编码的，core/max/queueSize都是定数，而系统的流量不是一个定数。在峰值期间，线程池无法动态扩容，导致大量请求处理失败进行拒绝策略。本系统主要是做了一个可以动态调参的线程池，依赖ThreadPoolExecutor本身提供的set方法，对运行中的各项基本参数进行动态调控。并且包括监控报警、Web界面、自动扩容策略等。&lt;/p&gt;
&lt;h1 id=&#34;设计&#34;&gt;设计&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/06/rshg8a6buigc7rdvcdk9q193rj.png&#34; alt=&#34;架构图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;
&lt;h2 id=&#34;客户端&#34;&gt;客户端&lt;/h2&gt;
&lt;p&gt;配置文件需配置服务端地址&lt;/p&gt;
&lt;p&gt;线程池配置需配置线程池（三种接入方式）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;接入方式， 提供三种[##feature]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动时，携带应用名上报对应的线程池配置(多实例同时启动， 此接口需要幂等)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过Java定时器，定时上报线程池数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与服务端维持长连接，60秒一次，服务端线程池配置（web操作）变化时，返回对应发生改变的[线程池名称]。然后客户端请求服务端获取对应线程池新的配置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;服务端&#34;&gt;服务端&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上报接口&lt;/p&gt;
&lt;p&gt;1.1 配置上报接口(配置带版本号)&lt;/p&gt;
&lt;p&gt;1.1.1 初次上报(数据库无法查询, 即视为初次上报)， 存储初始化参数&lt;/p&gt;
&lt;p&gt;1.1.2 服务端Web发起调参, 自行记录， 无需客户端上报(可优化为客户端上报)&lt;/p&gt;
&lt;p&gt;1.2 工作状态上报接口&lt;/p&gt;
&lt;p&gt;​	1.2.1 定时上报应用每个线程池各项指标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发起调参后，接受客户端请求最新线程池参数请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储上报数据， 负责提供数据展示接口，读取数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;feature&#34;&gt;feature&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;接入方式新增, 除了Dynamic，让默认的Spring的task和jdk的executor都支持，只有dynamic支持修改队列大小。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;todo-list&#34;&gt;todo-list&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/imyzt/dynamic-thread-pool/projects/1&#34;&gt;https://github.com/imyzt/dynamic-thread-pool/projects/1&lt;/a&gt;&lt;/p&gt;
">线程池动态管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/fastjson-ji-cheng-lei-fan-xu-lie-hua-can-shu/"" data-c="
          &lt;h2 id=&#34;场景及问题&#34;&gt;场景及问题&lt;/h2&gt;
&lt;p&gt;做工具封装时，通常会定义一个顶级父类data struct，子类继承之后补充自己独有的属性。该模式在常规使用情况下都是可用的，但是在涉及到序列化后反序列化对象时，就不是那么管用了。&lt;/p&gt;
&lt;p&gt;我们假设有两个对象，&lt;code&gt;class BaseClass&lt;/code&gt; 和 &lt;code&gt;class ChildClass&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import lombok.Data;

/**
 * @author imyzt
 * @date 2020/04/25
 * @description 超类
 */
@Data
public class BaseClass {
    private Integer bashInfo;
}

import lombok.*;

/**
 * @author imyzt
 * @date 2020/04/25
 * @description 子类
 */
@EqualsAndHashCode(callSuper = true)
@Data
@ToString(callSuper = true)
@AllArgsConstructor
@NoArgsConstructor
public class ChildClass extends BaseClass {

    private String childInfo;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们假设生产端生产消息，通过FastJSON序列化为字符串，然后通过kafka或者其他途径传递到消费端，消费端通过超类&lt;code&gt;BaseClass&lt;/code&gt;转换消息，根据不同的子类通过不同的策略去处理。但是在这种情况下，通过&lt;strong&gt;超类解析字符串对象回JavaBean对象时&lt;/strong&gt;，一般只能将&lt;strong&gt;超类&lt;/strong&gt;中拥有的参数转换回来，不能获得子类的属性。示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import com.alibaba.fastjson.JSON;
import lombok.extern.slf4j.Slf4j;

/**
 * @author imyzt
 * @date 2020/04/25
 * @description test
 */

@Slf4j
public class Test {

    public static void main(String[] args) {

        ChildClass one = new ChildClass();
        one.setBashInfo(122);
        one.setChildInfo(&amp;quot;childInfo&amp;quot;);

        // 转换为字符串, 便于传输
        String str = parseStr(one);

        log.info(&amp;quot;str={}&amp;quot;, str);

        // 转换回java bean
        BaseClass childClass = JSON.parseObject(str, BaseClass.class);
        log.info(&amp;quot;childClass={}&amp;quot;, childClass);
    }

    private static String parseStr(BaseClass obj) {
        return JSON.toJSONString(obj);
    }
}

日志打印：
14:18:09.208 [main] INFO xxx.json.Test - str={&amp;quot;bashInfo&amp;quot;:122,&amp;quot;childInfo&amp;quot;:&amp;quot;childInfo&amp;quot;}
14:18:09.227 [main] INFO xxx.json.Test - childClass=BaseClass(bashInfo=122)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;
&lt;p&gt;遇到这种情况，我们可以通过JSON的&lt;strong&gt;自省&lt;/strong&gt;功能，实现在反序列化为JavaBean时，得到完整的子类属性，并且将JavaBean通过多态得到对应的子类对象。具体思路就是在序列化为JSON时，在json字符串中写入对应的类型，在反序列化时，通过JSON字符串中特殊标记的类型属性，按照该类型进行反序列化即可。&lt;/p&gt;
&lt;p&gt;FastJSON具体的实现是在调用 &lt;code&gt;JSON.toJSONString()&lt;/code&gt;时，第二个数组参数传入Feature功能&lt;code&gt;SerializerFeature.WriteClassName&lt;/code&gt;，完整调用如&lt;code&gt;JSON.toJSONString(obj, SerializerFeature.WriteClassName);&lt;/code&gt; 在写入为JSON字符串时，会带有一个特殊的标记&lt;code&gt;@type&lt;/code&gt;存储序列化时对应的类型，如下图。&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/04/upm13a7uk2hooofjkrdbe8kdhf.png&#34; alt=&#34;请输入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在反序列化时，只需要按照对应的类型进行解析即可。上述代码重新运行后日志如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;14:22:24.528 [main] INFO xxx.json.Test - str={&amp;quot;@type&amp;quot;:&amp;quot;xxx.json.ChildClass&amp;quot;,&amp;quot;bashInfo&amp;quot;:122,&amp;quot;childInfo&amp;quot;:&amp;quot;childInfo&amp;quot;}
14:25:03.631 [main] INFO xxx.json.Test - childClass=ChildClass(super=BaseClass(bashInfo=122), childInfo=childInfo)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注意点&#34;&gt;注意点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;子类必须实现全参构造，或者有用lombok的&lt;code&gt;@ToString(callSuper = true)&lt;/code&gt;也行，不然会出现映射父类属性的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OK, 整篇文章就讲了一个Feature，水了一整页。。可以多关注下JSON的其他Feature功能，说不定就是需要的。/狗头&lt;/p&gt;
">FastJSON继承类反序列化参数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/yapi-upload-cha-jian-shi-yong/"" data-c="
          &lt;h1 id=&#34;yapi-api&#34;&gt;yapi api&lt;/h1&gt;
&lt;p&gt;https://hellosean1025.github.io/yapi/openapi.html&lt;/p&gt;
">yapi upload插件使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/beancopier-de-gong-ju-lei/"" data-c="
          &lt;p&gt;平时对象参数拷贝时，顺手使用的都是&lt;code&gt;Spring&lt;/code&gt; 提供的 &lt;code&gt;BeanUtils&lt;/code&gt;。究其原因，更多都是因为它方便，好使。&lt;/p&gt;
&lt;p&gt;但是大家都知道cglib的 &lt;code&gt;BeanCopier&lt;/code&gt; 通过字节码技术，在大多数没有Converter的情况下，拷贝效率更高。只是因为每次使用都得&lt;code&gt;BeanCopier.create&lt;/code&gt;，创建一个BeanCopier对象，麻烦，代码还不好看。&lt;/p&gt;
&lt;p&gt;因此，就有了这个工具类。使用和Spring工具包一样的代码（重载方法甚至比Spring的更丰富），获得更好的效率。实现中通过对&lt;code&gt;BeanCopier&lt;/code&gt;对象的一个Map缓存，会使得其效率更高一丢丢。&lt;/p&gt;
&lt;p&gt;至于具体的速度对比，网上有很多的实例，我也不做对比测试了。代码如下，如有欠缺的地方，希望留言指正，不胜感激。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
import com.google.common.collect.Maps;
import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cglib.beans.BeanCopier;
import org.springframework.cglib.core.Converter;

import java.lang.reflect.InvocationTargetException;
import java.util.Map;
import java.util.Objects;

/**
 * @author imyzt
 * @date 2020/01/15
 * @description bean拷贝缓存工具类
 * 合理使用, 注意Map大小
 */
@UtilityClass
@Slf4j
public class BeanCopierUtils {

    private static final Map&amp;lt;String, BeanCopier&amp;gt; BEAN_COPIER_MAP = Maps.newConcurrentMap();

    /**
     * 使用BeanCopier拷贝对象属性
     * 1. target不能使用链式调用 {@link lombok.experimental.Accessors#chain}
     * 2. 只会拷贝source,target属性类型和名称完全一致的字段
     * @param source 源
     * @param target 目标
     * @param useCache 是否使用缓存
     * @param converter converter对象
     * @param &amp;lt;S&amp;gt; 源对象泛型
     * @param &amp;lt;T&amp;gt; 目标对象泛型
     * @return 返回target对象
     */
    public &amp;lt;S, T&amp;gt; T copy(S source, T target, boolean useCache, Converter converter) {

        requireNonNull(source, target);
        boolean useConverter = Objects.nonNull(converter);

        Class&amp;lt;?&amp;gt; targetClass = target.getClass();

        String key = getKey(source, targetClass);

        BeanCopier beanCopier = getBeanCopier(useCache, key, createBeanCopier(source, targetClass, useConverter));
        beanCopier.copy(source, target, converter);
        return target;
    }

    /**
     * 使用BeanCopier拷贝对象属性
     * 1. target不能使用链式调用 {@link lombok.experimental.Accessors#chain}
     * 2. 只会拷贝source,target属性类型和名称完全一致的字段
     * @param source 源
     * @param targetClass 目标类对象
     * @param useCache 是否使用缓存
     * @param converter converter对象
     * @param &amp;lt;S&amp;gt; 源对象泛型
     * @param &amp;lt;T&amp;gt; 目标对象泛型
     * @return 返回target对象
     */
    public &amp;lt;S, T&amp;gt; T copy(S source, Class&amp;lt;T&amp;gt; targetClass, boolean useCache, Converter converter) {

        requireNonNull(source, targetClass);
        boolean useConverter = Objects.nonNull(converter);

        String key = getKey(source, targetClass);

        BeanCopier beanCopier = getBeanCopier(useCache, key, createBeanCopier(source, targetClass, useConverter));

        T instance;
        try {
            instance = targetClass.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            throw new IllegalArgumentException();
        }
        beanCopier.copy(source, instance, converter);
        return instance;
    }

    private static BeanCopier getBeanCopier(boolean useCache, String key, BeanCopier beanCopier2) {
        BeanCopier beanCopier;
        if (useCache) {
            beanCopier = BEAN_COPIER_MAP.computeIfAbsent(key, k -&amp;gt; beanCopier2);
        } else {
            beanCopier = beanCopier2;
        }
        return beanCopier;
    }

    private static &amp;lt;S&amp;gt; void requireNonNull(S source, Object targetClass) {
        Objects.requireNonNull(source, &amp;quot;源对象不能为空&amp;quot;);
        Objects.requireNonNull(targetClass, &amp;quot;目标对象不能为空&amp;quot;);
    }

    public &amp;lt;S, T&amp;gt; T copy(S source, T target) {
        return copy(source, target, true, null);
    }

    public &amp;lt;S, T&amp;gt; T copy(S source, Class&amp;lt;T&amp;gt; targetClass) {
        return copy(source, targetClass, true, null);
    }

    public &amp;lt;S, T&amp;gt; T copy(S source, Class&amp;lt;T&amp;gt; targetClass, boolean useCache) {
        return copy(source, targetClass, useCache, null);
    }

    public &amp;lt;S, T&amp;gt; T copy(S source, Class&amp;lt;T&amp;gt; targetClass, Converter converter) {
        return copy(source, targetClass, true, converter);
    }

    public &amp;lt;S, T&amp;gt; T copy(S source, T target, boolean useCache) {
        return copy(source, target, useCache, null);
    }

    public &amp;lt;S, T&amp;gt; T copy(S source, T target, Converter converter) {
        return copy(source, target, true, converter);
    }

    private static &amp;lt;S, T&amp;gt; BeanCopier createBeanCopier(S source, Class&amp;lt;T&amp;gt; target, boolean useConverter) {
        return BeanCopier.create(source.getClass(), target, useConverter);
    }

    private static &amp;lt;S, T&amp;gt; String getKey(S source, Class&amp;lt;T&amp;gt; targetClass) {
        return source.getClass().getName() + &amp;quot;:&amp;quot; + targetClass.getName();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用时，有两点需要注意的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;target不能使用lombok等工具的链式调用，只有符合标准的set方法，cglib才会调用赋值。&lt;/li&gt;
&lt;li&gt;只会拷贝source，target类型和名称完全一致的属性。&lt;/li&gt;
&lt;/ol&gt;
">BeanCopier的工具类</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mybatis-yu-fa-jiu-cuo/"" data-c="
          &lt;p&gt;mybatis 在type表达式中，如果是内部类，不能通过 Class.InnerClass 指定，需要通过 Class$InnerClass 指定，不然会报ClassNotFound。&lt;/p&gt;
&lt;p&gt;错误堆栈&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Caused by: java.lang.ClassNotFoundException: Cannot find class: Class.InnerClass
	at org.apache.ibatis.io.ClassLoaderWrapper.classForName(ClassLoaderWrapper.java:200)
	at org.apache.ibatis.io.ClassLoaderWrapper.classForName(ClassLoaderWrapper.java:89)
	at org.apache.ibatis.io.Resources.classForName(Resources.java:261)
	at org.apache.ibatis.type.TypeAliasRegistry.resolveAlias(TypeAliasRegistry.java:116)
	... 104 common frames omitted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体的产生原因通过报错信息，发现是&lt;code&gt;org.apache.ibatis.type.TypeAliasRegistry#resolveAlias&lt;/code&gt;方法抛出的异常&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/04/5bdfpl20vcj4tp687qmbh2m8sm.png&#34; alt=&#34;resolveAlias&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过继续往里面走，发现是&lt;code&gt;org.apache.ibatis.io.ClassLoaderWrapper#classForName(java.lang.String, java.lang.ClassLoader[])&lt;/code&gt;方法内部使用&lt;code&gt;java.lang.Class#forName&lt;/code&gt;加载的类，&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/04/r6o46ekjhah0tpgif4a3mj9f0u.png&#34; alt=&#34;classForName&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而Java的内部类在编译之后，都会以&lt;code&gt;Class$InnerClass&lt;/code&gt;的形式进行保存字节码文件，所以说为什么使用 &lt;code&gt;.&lt;/code&gt; 会抛出ClassNotFound，因为mybatis最终底层还是使用的Java提供的类加载工具进行累的加载的。&lt;/p&gt;
&lt;p&gt;通过对内部类进行&lt;code&gt;javac&lt;/code&gt; 我们可以看到一个类编译之后的状态。&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/04/vdtmipks0ig1kq01bjagt6i1ra.png&#34; alt=&#34;javac&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Mybatis 语法纠错</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-zhi-shi-dian/"" data-c="
          &lt;h1 id=&#34;知识点&#34;&gt;知识点&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;innodb不支持全文检索&lt;/li&gt;
&lt;li&gt;between包含左右边界&lt;br&gt;
3.UPDATE IGNORE 用于在更新多行时，某一行报错不影响其他行&lt;/li&gt;
&lt;/ol&gt;
">MySQL知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-regexp-shi-yong/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;MySQL的regexp与LIKE语句非常类似，大部分功能都可以相互替补。之前一直没有使用过，最近在阅读《MySQL必知必会》第九章时，看到了这个内容，在此做下笔记记录一下。&lt;/p&gt;
&lt;p&gt;在此之前，首先建立对应的数据表，ddl与dml如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table if not exists test_db.products
(
	id int auto_increment
		primary key,
	prod_name varchar(20) not null
);

INSERT INTO test_db.products (id, prod_name) VALUES (1, &#39;JetPack 1000&#39;);
INSERT INTO test_db.products (id, prod_name) VALUES (2, &#39;JetPack 2000&#39;);
INSERT INTO test_db.products (id, prod_name) VALUES (3, &#39;1 ton anvil&#39;);
INSERT INTO test_db.products (id, prod_name) VALUES (4, &#39;2 ton anvil&#39;);
INSERT INTO test_db.products (id, prod_name) VALUES (5, &#39;TNT (1 stick)&#39;);
INSERT INTO test_db.products (id, prod_name) VALUES (6, &#39;.5 ton anvil&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2020/03/tcfrq33pfoi12o2lsjkr76m906.png&#34; alt=&#34;请输入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;常用指令&#34;&gt;常用指令&lt;/h1&gt;
&lt;p&gt;由于regexp与LIKE的高度相似性，所以学习时以常用的LIKE的指令作为对比学习，有助于记忆。&lt;/p&gt;
&lt;h2 id=&#34;基本字符匹配&#34;&gt;基本字符匹配&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;全文字匹配&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;select *
from products
where prod_name regexp &#39;1000&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2020/03/to3pl4isoehleqolviqulqs4tu.png&#34; alt=&#34;请输入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;模糊匹配&lt;br&gt;
类似于LIKE语句的 &#39;_&#39;（下划线）单字符匹配。模糊匹配单个字符。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;select *
from products
where prod_name regexp &#39;.000&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2020/03/0lv9oi93oegtoo3pm936ms8tfa.png&#34; alt=&#34;请输入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;or-匹配&#34;&gt;OR 匹配&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;select *
from products
where prod_name regexp &#39;1000|2000&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2020/03/7eovvhgj8kh5arqfvblopof7qu.png&#34; alt=&#34;请输入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;匹配几个字符之一&#34;&gt;匹配几个字符之一&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;正确用法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;select *
from products
where prod_name regexp &#39;[123] ton&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2020/03/tgh3m7dhtuhogoprg59jagi7ke.png&#34; alt=&#34;请输入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;错误示例&lt;br&gt;
正则表达式可以用 &lt;code&gt;[]&lt;/code&gt; 包含内容或者 &lt;code&gt;|&lt;/code&gt; 竖线 表示 &lt;code&gt;或&lt;/code&gt;，但如果使用下面的用法，不能获得正确的结果，因为在最后一个&#39;或&#39;时，MySQL会理解成 &lt;code&gt;3 ton&lt;/code&gt;。得到不同的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;select *
from products
where prod_name regexp &#39;1|2|3 ton&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2020/03/vh736s4prohc8q3e1rah515rci.png&#34; alt=&#34;请输入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;匹配范围&#34;&gt;匹配范围&lt;/h2&gt;
&lt;h2 id=&#34;匹配特殊字符&#34;&gt;匹配特殊字符&lt;/h2&gt;
&lt;h2 id=&#34;匹配字符类&#34;&gt;匹配字符类&lt;/h2&gt;
&lt;h2 id=&#34;匹配多个实例&#34;&gt;匹配多个实例&lt;/h2&gt;
">MySQL REGEXP 使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/git-yuan-li-xiang-jie-ji-shi-yong-zhi-nan-mergeaddlog/"" data-c="
          &lt;h2 id=&#34;merge&#34;&gt;merge&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;git merge就是合并，指定一个 commit 或者 branch，将其合并到当前 branch 或 commit 来。&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;目标commit&lt;/code&gt; 和 &lt;code&gt;当前commit&lt;/code&gt; 的&lt;strong&gt;分叉点起&lt;/strong&gt;，将 &lt;code&gt;目标commit&lt;/code&gt; 上的 &lt;code&gt;所有commit&lt;/code&gt; 一并合并到 &lt;code&gt;当前commit&lt;/code&gt;，并&lt;code&gt;自动生成一个新的commit&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1581992793896.gif&#34; alt=&#34;git merge 示意图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center&gt;图 - git merge 示意图&lt;/center&gt;
&lt;h3 id=&#34;特殊情况如何处理&#34;&gt;特殊情况，如何处理&lt;/h3&gt;
&lt;h5 id=&#34;放弃合并&#34;&gt;放弃合并&lt;/h5&gt;
&lt;p&gt;当前处于解决冲突的中间状态， 通过 &lt;code&gt;git merge --abort&lt;/code&gt; 取消合并，回到merge之前的状态。&lt;/p&gt;
&lt;h5 id=&#34;head领先于当前commit&#34;&gt;HEAD领先于当前commit&lt;/h5&gt;
&lt;p&gt;即&lt;strong&gt;合并之前的commit&lt;/strong&gt;，这是一个无意义操作，Git什么也不会做。空merge。&lt;/p&gt;
&lt;h5 id=&#34;head落后于当前commit快速前移&#34;&gt;HEAD落后于当前commit（快速前移）&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;在没有其它分支的情况下，Git会把HEAD指向的branch移动到目标commit。&lt;/li&gt;
&lt;li&gt;当前在HEAD指向master分支，执行 &lt;code&gt;git merge feature1&lt;/code&gt; 后的操作如下图所示：&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1581993447297.gif&#34; alt=&#34;合并领先于HEAD的commit&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;center&gt;图 - 合并领先于HEAD的commit&lt;/center&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;专有名词 - （快速前移）&lt;br&gt;
在 &lt;code&gt;git pull&lt;/code&gt; 经常出现，比如当前master分支本地没有更新，同事推送了新的commit到远程仓库，那么在执行 &lt;code&gt;git pull&lt;/code&gt; 时，&lt;strong&gt;目标commit（远程仓库最新commit）&lt;/strong&gt; 领先于 &lt;strong&gt;当前commit（本地commit）&lt;/strong&gt;，&lt;strong&gt;HEAD会携带本地master分支快速前移&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1581994083140.gif&#34; alt=&#34;git pull 实现原理&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;center&gt;图 - git pull 实现原理&lt;/center&gt;
&lt;h2 id=&#34;add&#34;&gt;add&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;添加的是文件改动，而不是文件&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;log&#34;&gt;log&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git log -p[--patch]&lt;/code&gt; 查看具体到每个commit的改动细节。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log --stat&lt;/code&gt; 查看每个commit改动的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git show [commitId] [filePath]&lt;/code&gt; 查看当前commit的改动细节（精确到文件）。&lt;/li&gt;
&lt;li&gt;对比
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git diff&lt;/code&gt; 查看当前工作区与暂存区的区别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git diff --staged[--cached]&lt;/code&gt; 查看当前暂存区与上一条commit的区别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git diff HEAD&lt;/code&gt; 查看当前工作区与上一条commit的区别。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;本章命令总结&#34;&gt;本章命令总结&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git merge commit/branch&lt;/code&gt; 合并某个提交或分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git merge --abort&lt;/code&gt; 放弃当前合并&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add .&lt;/code&gt; 添加某个文件改动到git暂存区&lt;/li&gt;
&lt;li&gt;git log 的详细操作 &lt;a href=&#34;#log&#34;&gt;git log&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;引用声明&#34;&gt;引用声明&lt;/h2&gt;
&lt;p&gt;本文内容来自&lt;a href=&#34;https://juejin.im/book/5a124b29f265da431d3c472e&#34;&gt;掘金小册-Git 原理详解及实用指南&lt;/a&gt;的学习笔记内容，图片等均来自原作者。此处只作为笔记记录。&lt;br&gt;
请支持原作者&lt;img src=&#34;https://imyzt.top/post-images/1581900705687.png&#34; alt=&#34;购买信息&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Git 原理详解及实用指南 - merge，add，log</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/git-yuan-li-xiang-jie-ji-shi-yong-zhi-nan-headbranch/"" data-c="
          &lt;h2 id=&#34;head&#34;&gt;HEAD&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;HEAD永远指向当前commit，每个仓库只有一个HEAD，每次提交之后都会向前移动到最新的commit。&lt;/li&gt;
&lt;li&gt;远程分支HEAD永远指向默认分支（master）。&lt;/li&gt;
&lt;li&gt;HEAD是Git中独特的引用，它是唯一的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;branch&#34;&gt;Branch&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;也是一类引用，HEAD除了直接指向commit之外，也可以&lt;strong&gt;通过指向branch间接指向commit&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1581900294211.gif&#34; alt=&#34;HEAD通过Branch间接指向Commit&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center&gt; 图 - HEAD通过Branch间接指向Commit &lt;/center&gt;  
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;当HEAD指向branch，发生commit时，HEAD会带着branch一起移动。如下图（HEAD携带feature1一起移动。）&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1581899709600.gif&#34; alt=&#34;HEAD移动示意图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center&gt; 图 - HEAD移动示意图 &lt;/center&gt;  
&lt;h2 id=&#34;push&#34;&gt;Push&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将当前 &lt;code&gt;branch&lt;/code&gt; 提交到远程仓库，并将当前 &lt;code&gt;branch&lt;/code&gt; 的所有 &lt;code&gt;commit&lt;/code&gt; 也提交到远程分支。&lt;/li&gt;
&lt;li&gt;push时，如果是远程仓库不存在的分支，需要指定名称，&lt;code&gt;git push origin branch_name&lt;/code&gt;, 或者通过修改 &lt;code&gt;git config&lt;/code&gt; 的 &lt;code&gt;push.default&lt;/code&gt; 来指定推送时默认分支。&lt;/li&gt;
&lt;li&gt;push之后上传分支，并不会上传 &lt;code&gt;HEAD&lt;/code&gt;, 远程仓库的 &lt;code&gt;HEAD&lt;/code&gt; 永远指向默认分支（master）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;master&#34;&gt;master&lt;/h2&gt;
&lt;p&gt;master是Git中默认的branch，它与其他branch的区别在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新建仓库中第一个commit会被master自动指向。&lt;/li&gt;
&lt;li&gt;在git clone时，会自动checkout到master（HEAD指向master分支，间接指向master分支的commit）。&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1581900572282.gif&#34; alt=&#34;克隆远程仓库流程&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;center&gt; 图 - 克隆远程仓库流程 &lt;/center&gt;  
&lt;h2 id=&#34;branch的基本操作&#34;&gt;branch的基本操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建： git branch 名称，或 git checkout -b 名称&lt;/li&gt;
&lt;li&gt;切换：git checkout 名称&lt;/li&gt;
&lt;li&gt;删除：git branch -d/-D 名称，-D强制删除&lt;/li&gt;
&lt;li&gt;推送：git push [origin branch_name]，将本地分支推送到远程仓库对应分支&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;本章命令总结&#34;&gt;本章命令总结&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;git log 查看提交日志&lt;/li&gt;
&lt;li&gt;git branch &lt;a href=&#34;#branch%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C&#34;&gt;branch的基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;git commit 提交代码到本地仓库&lt;/li&gt;
&lt;li&gt;git checkout branch_name 切换分支&lt;/li&gt;
&lt;li&gt;git clone origin_url 克隆远程仓库到本地仓库&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;git branch、HEAD都是围绕着commit走的；&lt;/li&gt;
&lt;li&gt;git push的本质是将 &lt;code&gt;当前branch&lt;/code&gt; 位置的（commit）上传到远程仓库，并将它的commit一并提交。&lt;/li&gt;
&lt;li&gt;HEAD，Branch都是引用，引用的本质就是一个字符串，可以是&lt;strong&gt;一个commit的SHA-1码&lt;/strong&gt;，也可以是&lt;strong&gt;一个branch的branch名&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;引用声明&#34;&gt;引用声明&lt;/h2&gt;
&lt;p&gt;本文内容来自&lt;a href=&#34;https://juejin.im/book/5a124b29f265da431d3c472e&#34;&gt;掘金小册-Git 原理详解及实用指南&lt;/a&gt;的学习笔记内容，图片等均来自原作者。此处只作为笔记记录。&lt;br&gt;
请支持原作者&lt;img src=&#34;https://imyzt.top/post-images/1581900705687.png&#34; alt=&#34;购买信息&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Git 原理详解及实用指南 - HEAD，branch，push</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-kai-fa-gong-ju-tui-jian/"" data-c="
          &lt;h1 id=&#34;工具包&#34;&gt;工具包&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/google-guava/&#34;&gt;Google Guava&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hutool.cn/docs/&#34;&gt;HuTool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ifeve.com/apache-common/&#34;&gt;Apache Commons(这玩意估计没人不知道了。)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;工具类&#34;&gt;工具类&lt;/h1&gt;
&lt;h2 id=&#34;antpathmatcher&#34;&gt;AntPathMatcher&lt;/h2&gt;
&lt;p&gt;作用：URL路径匹配&lt;/p&gt;
&lt;p&gt;？匹配一个字符&lt;br&gt;
*匹配0个或多个字符&lt;br&gt;
**匹配0个或多个目录&lt;/p&gt;
&lt;h2 id=&#34;stopwatch&#34;&gt;StopWatch&lt;/h2&gt;
&lt;p&gt;作用：方法耗时计算&lt;/p&gt;
&lt;p&gt;该类Spring和Guava都有提供，用法大同小异&lt;/p&gt;
&lt;h2 id=&#34;beancopier&#34;&gt;BeanCopier&lt;/h2&gt;
&lt;p&gt;作用：拷贝bean&lt;/p&gt;
&lt;p&gt;比Apache和Spring提供的BeanUtils效率好点&lt;/p&gt;
&lt;p&gt;注意点：&lt;br&gt;
该方法与lombok提供的&lt;code&gt;@Accessors(chain = true)&lt;/code&gt;注解冲突，在cglib最底层target调用set方法进行参数设置的时候，判断了set方法返回值是否为void，不为void不会进行赋值操作。&lt;br&gt;
解决方法有2：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;去掉&lt;code&gt;@Accessors(chain = true)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用org.springframework.beans.BeanUtils&lt;/li&gt;
&lt;/ol&gt;
">Java开发工具推荐</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mybatis-xml-test-yu-fa-bug/"" data-c="
          &lt;h1 id=&#34;事出有因&#34;&gt;事出有因&lt;/h1&gt;
&lt;p&gt;今天遇到一个mybatis语法的bug，在此记录一下。&lt;/p&gt;
&lt;p&gt;业务是前台有一个跟进状态的筛选按钮，与前台约定的参数是Integer类型的0-4, 标志不同的状态，根据不同的参数做不同的过滤。mybatis的语法如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;if test=&amp;quot;query.followStatus != null and query.followStatus != &#39;&#39;&amp;quot;&amp;gt;
    &amp;lt;choose&amp;gt;
        &amp;lt;!--未跟进--&amp;gt;
        &amp;lt;when test=&amp;quot;query.followStatus == 0&amp;quot;&amp;gt;
            AND scfu.id IS NULL
        &amp;lt;/when&amp;gt;
        &amp;lt;!--未选择意向--&amp;gt;
        &amp;lt;when test=&amp;quot;query.followStatus == 4&amp;quot;&amp;gt;
            AND scfu.intention IS NULL AND scfu.id IS NOT NULL
        &amp;lt;/when&amp;gt;
        &amp;lt;!--1,2,3的情况--&amp;gt;
        &amp;lt;otherwise&amp;gt;
            AND scfu.intention = #{query.followStatus}
        &amp;lt;/otherwise&amp;gt;
    &amp;lt;/choose&amp;gt;
&amp;lt;/if&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今天客户反馈了一个bug，该筛选项在前台选中&lt;strong&gt;未跟进&lt;/strong&gt;时，会出现筛选项无效的情况。也就是第一行 &lt;code&gt;if test&lt;/code&gt; 都没有进去，因为进去了的话，最起码什么都不符合的情况都会进入 &lt;code&gt;otherwise&lt;/code&gt; ，所以定位到问题出现在外层 &lt;code&gt;if&lt;/code&gt;。通过搜索发现有人遇到过相似的问题。&lt;/p&gt;
&lt;h1 id=&#34;解决方案&#34;&gt;解决方案&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/EasonJim/p/8075311.html&#34;&gt;MyBatis参数为Integer型并赋值为0时判断失误的问题解决&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据这位博主介绍，mybatis的test语法，在类型为&lt;code&gt;Integer&lt;/code&gt;时，如果值为&lt;code&gt;0&lt;/code&gt;, 会被识别为 &lt;code&gt;&#39;&#39;&lt;/code&gt;(空)， 导致第一个if的后一部分 &lt;code&gt;query.followStatus != &#39;&#39;&lt;/code&gt; 不符合。最终没有进入 &lt;code&gt;if&lt;/code&gt; 的逻辑。解决方法上面的博主已经给出了，我再此贴一下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过or进行二次判断&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;if test=&amp;quot;status !=null and (status!=&#39;&#39; or status == 0)&amp;quot;&amp;gt;
    业务逻辑
&amp;lt;/if&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;对Integer类型去除 != &#39;&#39; 的判断&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;p&gt;另一个常出现的问题，test语法中，布尔值比较需要用 &lt;code&gt;bool == true&lt;/code&gt; 的语法判断，说明：bool（一个布尔值变量）&lt;/p&gt;
">Mybatis XML test语法bug</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/springboot-guan-bi-di-zhi-yan-ge-pi-pei/"" data-c="
          &lt;h1 id=&#34;问题点&#34;&gt;问题点&lt;/h1&gt;
&lt;p&gt;Spring默认开启了地址的严格匹配，比如 localhost:8080/api/article/{aid} 能正确访问，但是 localhost:8080**/**/api/article/{aid} 就会造成访问404&lt;/p&gt;
&lt;h1 id=&#34;解决方案&#34;&gt;解决方案&lt;/h1&gt;
">SpringBoot 关闭地址严格匹配</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/idea-cha-jian-lie-biao/"" data-c="
          &lt;ul&gt;
&lt;li&gt;.ignore&lt;/li&gt;
&lt;li&gt;AceJump&lt;/li&gt;
&lt;li&gt;P3C&lt;/li&gt;
&lt;li&gt;BaseSupport&lt;/li&gt;
&lt;li&gt;CamelCase&lt;/li&gt;
&lt;li&gt;CodeGlance&lt;/li&gt;
&lt;li&gt;FindBugs-IDEA&lt;/li&gt;
&lt;li&gt;GsonFormat&lt;/li&gt;
&lt;li&gt;IdeaVim&lt;/li&gt;
&lt;li&gt;jrebel-mybatisplus-extension&lt;/li&gt;
&lt;li&gt;Jrebel&lt;/li&gt;
&lt;li&gt;Key Promoter X&lt;/li&gt;
&lt;li&gt;Lombok&lt;/li&gt;
&lt;li&gt;Maven Helper&lt;/li&gt;
&lt;li&gt;MybaticCodeHelperPro&lt;/li&gt;
&lt;li&gt;Nyan Progress Bar&lt;/li&gt;
&lt;li&gt;POJO TO JSON&lt;/li&gt;
&lt;li&gt;RestfulToolKit&lt;/li&gt;
&lt;li&gt;SonarLint&lt;/li&gt;
&lt;li&gt;Translation&lt;/li&gt;
&lt;li&gt;Rainbow Brackets&lt;/li&gt;
&lt;/ul&gt;
">idea 插件列表</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/shi-yong-mybatis-plus-dong-tai-biao-ming-sql-jie-xi-qi-shi-xian-mysql-fen-biao/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;随着业务发展，数据库单表量将会持续增长，当增长到一定大小，是需要对应的处理以解决数据查询越来越慢的问题的。&lt;br&gt;
一般的扩展方案分为两种，一种是&lt;strong&gt;垂直扩展&lt;/strong&gt;，即增大单机的配置。  另一种则是&lt;strong&gt;水平扩展&lt;/strong&gt;，是将任务分配到多台计算机上。&lt;/p&gt;
&lt;p&gt;我们的应用系统使用的是SpringBoot+Mybatis-Plus的搭配，由于分表业务比较简单，就没有使用插件，而是使用Mybatis-Plus提供的 &lt;code&gt;DynamicTableNameParser &lt;/code&gt; 处理器直接在程序中做动态路由。&lt;br&gt;
由于官方文档在此处描述的并不是特别详细，所以写这篇博客作为记录。&lt;/p&gt;
&lt;h1 id=&#34;开发&#34;&gt;开发&lt;/h1&gt;
&lt;p&gt;分表策略就不在此做说明了，网上已经有非常多不同的处理方式了，在这里主要阐述怎么样使用Mybatis-Plus提供的 &lt;code&gt;ITableNameHandler &lt;/code&gt;  接口将不同表的做出不同处理。&lt;/p&gt;
&lt;h2 id=&#34;实现-itablenamehandler-接口&#34;&gt;实现 ITableNameHandler 接口&lt;/h2&gt;
&lt;p&gt;首先我们需要实现 &lt;code&gt;ITableNameHandler&lt;/code&gt; 接口，该接口有两个方法(process, dynamicTableName)，process()方法是做表名SQL处理的，该方法有默认实现，它依赖于dynamicTableName()方法，所以我们需要重写的方法便是dynamicTableName()方法&lt;br&gt;
dynamicTableName()方法有三个入参，metaObject包括了元数据对象，sql是我们即将要执行的SQL，tableName则是我们执行的SQL表名称。我们需要修改的便是tableName。&lt;br&gt;
下方我的代码逻辑是从DaysContext上下文对象中拿到事先设置的表名动态规则生成的表后缀，拼接上tableName便是我们需要动态路由的表名称了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class MyDynamicTableNameParser implements ITableNameHandler {

    @Override
    public String dynamicTableName(MetaObject metaObject, String sql, String tableName) {

        DaysContext.Days days = DaysContext.get();

        // 加上分表逻辑后缀
        return tableName + &amp;quot;_&amp;quot; + days.getTableSuffix();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;将配置注入到mybatis-plus配置中&#34;&gt;将配置注入到Mybatis-Plus配置中&lt;/h2&gt;
&lt;p&gt;接下来需要将我们的动态表名处理器 &lt;code&gt;MyDynamicTableNameParser&lt;/code&gt; 配置到 &lt;code&gt;PaginationInterceptor&lt;/code&gt; 对象中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class MybatisPlusConfig {

    private final MyDynamicTableNameParser myDynamicTableNameParser;

    public MybatisPlusConfig(MyDynamicTableNameParser myDynamicTableNameParser) {
        this.myDynamicTableNameParser = myDynamicTableNameParser;
    }

    /**
     * 分页, 分表插件
     */
    @Bean
    public PaginationInterceptor paginationInterceptorMysql() {

        // 分页
        PaginationInterceptor page = new PaginationInterceptor();
        page.setDialectType(&amp;quot;mysql&amp;quot;);

        // 分表
        dynamicTableNameParser(page);

        return page;
    }

    /**
     * 分表
     */
    private void dynamicTableNameParser(PaginationInterceptor page) {

        // 为指定表设置动态表名处理器
        HashMap&amp;lt;String, ITableNameHandler&amp;gt; map = new HashMap&amp;lt;&amp;gt;(2);
        map.put(&amp;quot;sys_user&amp;quot;, myDynamicTableNameParser);
        map.put(&amp;quot;sys_logs&amp;quot;, myDynamicTableNameParser);

        // 将需要处理的表添加到动态表名 SQL 解析器
        DynamicTableNameParser dynamicTableNameParser = new DynamicTableNameParser();
        dynamicTableNameParser.setTableNameHandlerMap(map);

        // 加入处理器链中
        List&amp;lt;ISqlParser&amp;gt; iSqlParsers = new ArrayList&amp;lt;&amp;gt;();
        iSqlParsers.add(dynamicTableNameParser);
        page.setSqlParserList(iSqlParsers);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在dynamicTableNameParser()方法中，第一个代码块将需要动态路由的表通过K-V的形式配置我们刚编写的路由处理器对象。&lt;br&gt;
第二个代码块中将我们添加的表名处理器设置到 Mybatis-Plus的 表名处理器 DynamicTableNameParser 中&lt;br&gt;
第三个代码块将我们配置的表名处理器添加到Mybatis-Plus的处理器链中&lt;br&gt;
通过上面的配置，我们就能够根据配置的路由规则，将配置的需要路由的表动态拼接上我们生成的后缀名了。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;框架做了很好的封装，整个过程还是非常顺利的，也顺利通过了测试。写这篇博客做个记录。&lt;/p&gt;
">使用Mybatis-Plus 动态表名 SQL 解析器实现MySQL分表</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-fen-zu-cha-xun-zui-xin-shu-ju/"" data-c="
          &lt;p&gt;最近接到一个开发任务,有一个用户操作日志表, 里面包含用户id, 用户最近访问内容和时间. 需要查询到用户列表中每一个用户最近操作的内容&lt;/p&gt;
&lt;p&gt;我开始想到的是使用 &lt;code&gt;group by&lt;/code&gt; 分组, 然后 &lt;code&gt;order by&lt;/code&gt; 时间字段.  但是由于MySQL的执行顺序是先执行 &lt;code&gt;group&lt;/code&gt; 后执行 &lt;code&gt;order&lt;/code&gt;, 经过group之后的内容已经丢失了时间, 所以无法使用该方法实现. 然后在网上找到一种方式, 是通过 right join 自己, 然后取内容. 但是也比较复杂, 后来找到了一个方式比较简单, 在此记录备忘.&lt;/p&gt;
&lt;p&gt;其主要逻辑使用了&lt;code&gt;not exists&lt;/code&gt;, 然后通过子查询拿到最新数据, 通过 &lt;code&gt;WHERE t1.user_id = t2.user_id &lt;/code&gt; 建立关联, 其中user_id即为两表之间的关联字段.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT
	user_id,
	t1.login_time 
FROM
	tb_user_login t1 
WHERE
	NOT EXISTS ( SELECT 1 FROM tb_user_login t2 WHERE t1.user_id = t2.user_id AND t1.login_time &amp;lt; t2.login_time )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的表数据如下:&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/07/453uuuf45si59pvlsp81bb0a5p.png&#34; alt=&#34;数据库表内容&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;查询出来的结果如下:&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/07/272meb7mbgh6ir1sem51oi4ed2.png&#34; alt=&#34;查询结果&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;更新&#34;&gt;更新&lt;/h1&gt;
&lt;p&gt;上面的那种方式有严重的性能问题， 执行一次查询竟然要0.4S， 后来在知乎找到了这篇问题，下面 有挺多方式解决这个问题的。  &lt;a href=&#34;https://www.zhihu.com/question/20863388&#34;&gt;知乎链接&lt;/a&gt;&lt;/p&gt;
">MySQL 分组查询最新数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/springboot-null-zi-duan-xu-lie-hua-shi-xiu-gai-wei-kong-chuan/"" data-c="
          &lt;p&gt;SpringBoot jackson 提供了 &lt;code&gt;default-property-inclusion&lt;/code&gt; 为空时不序列化等功能，但是没有提供如果属性值为null时，修改为空串的功能，公司项目开发业务正好需要这个功能，琢磨了一下找到了修改 &lt;code&gt;MappingJackson2HttpMessageConverter&lt;/code&gt; 改变序列化规则的方法。&lt;/p&gt;
&lt;p&gt;相应的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/07/19
 * @description 自定义ObjectMapper, 修改序列化规则, 将String null 修改为 String &#39;&#39;
 */
@Configuration
public class JsonObjectMapper extends ObjectMapper {

    public JsonObjectMapper() {
        super();
        this.getSerializerProvider().setNullValueSerializer(new JsonSerializer&amp;lt;Object&amp;gt;() {
            @Override
            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
                jsonGenerator.writeString(StringUtils.EMPTY);
            }
        });
    }

    @Bean
    public MappingJackson2HttpMessageConverter objectMapper(){
        MappingJackson2HttpMessageConverter converter=new MappingJackson2HttpMessageConverter();
        converter.setObjectMapper(new JsonObjectMapper());
        return converter;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要逻辑就是继承ObjectMapper，构造器重写父类序列化规则，&lt;code&gt;setNullValueSerializer&lt;/code&gt;方法设置为null的值的序列化规则。&lt;code&gt;jsonGenerator.writeString(StringUtils.EMPTY);&lt;/code&gt; 然后重新创建一个 MappingJackson2HttpMessageConverter ，Jackson序列化时则会按照相关规则序列化。&lt;/p&gt;
">SpringBoot Null字段序列化时修改为空串</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-56-cuo-wu-ji-lu/"" data-c="
          &lt;p&gt;简单记录&lt;/p&gt;
&lt;p&gt;MySQL5.6 在服务器出现了报错，具体信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;表名&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误的具体原因是SELECT子句的字段必须出现在GROUP BY后面，因为数据库设置了&lt;code&gt;sql_mode=only_full_group_by&lt;/code&gt;，解决方法网上已经给出了方案，提供一个链接：&lt;a href=&#34;https://my.oschina.net/dajianguo/blog/1630970&#34;&gt;mysql遇见Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggre的问题&lt;/a&gt;&lt;/p&gt;
">MySQL 5.6 错误记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/shi-yong-pageable-shi-specified-class-is-an-interface-yi-chang/"" data-c="
          &lt;p&gt;SpringBoot为我们提供了分页对象 &lt;code&gt;org.springframework.data.domain.Pageable&lt;/code&gt;, 通过配合 &lt;code&gt;org.springframework.data.web.PageableDefault&lt;/code&gt; 注解, 可以自定义分页参数, 排序字段等.&lt;/p&gt;
&lt;p&gt;今天在使用的过程中, 遇到了一个问题, 前端传任何内容, 后端都会报 对象是接口 的错误. 对应的错误堆栈如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.data.domain.Pageable]: Specified class is an interface
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:99) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.annotation.ModelAttributeMethodProcessor.createAttribute(ModelAttributeMethodProcessor.java:141) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor.createAttribute(ServletModelAttributeMethodProcessor.java:81) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.annotation.ModelAttributeMethodProcessor.resolveArgument(ModelAttributeMethodProcessor.java:101) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:158) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:128) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) [tomcat-embed-core-8.5.16.jar:8.5.16]
	at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:841) [jetty-servlet-9.4.6.v20170531.jar:9.4.6.v20170531]
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650) [jetty-servlet-9.4.6.v20170531.jar:9.4.6.v20170531]
	at org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:55) [spring-boot-1.5.6.RELEASE.jar:1.5.6.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1637) [jetty-servlet-9.4.6.v20170531.jar:9.4.6.v20170531]
	at top.imyzt.learning.security.demo.web.filter.TimeFilter.doFilter(TimeFilter.java:29) [classes/:na]
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;问题解决&#34;&gt;问题解决&lt;/h1&gt;
&lt;p&gt;出现这个问题, 是因为没有配置对应的参数解析器的原因, 通过配置Pageable和Sort对象的参数转换器, 可以解决这个问题.&lt;/p&gt;
&lt;p&gt;编写一个类, 继承 &lt;code&gt;WebMvcConfigurationSupport&lt;/code&gt;, 重写 &lt;code&gt;addArgumentResolvers&lt;/code&gt; 方法, Spring为我们提供了默认的解析器, 我们只需要创建对应的对象即可. 代码如下.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class WebConfig extends WebMvcConfigurationSupport {

    @Override
    protected void addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt; argumentResolvers) {
        PageableHandlerMethodArgumentResolver pageableResolver = new PageableHandlerMethodArgumentResolver();
        SortHandlerMethodArgumentResolver sortResolver = new SortHandlerMethodArgumentResolver();
        argumentResolvers.add(pageableResolver);
        argumentResolvers.add(sortResolver);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;参数解析器&#34;&gt;参数解析器&lt;/h1&gt;
&lt;p&gt;关于怎样编写自定义的参数解析器, 可以看我的这篇文章 &lt;a href=&#34;http://blog.imyzt.top/article/61&#34;&gt;Spring 自定义参数解析&lt;/a&gt;&lt;/p&gt;
">使用Pageable时Specified class is an interface异常</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/springboot-ji-cheng-swagger/"" data-c="
          &lt;pre&gt;&lt;code&gt;@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket createRestApi() {
        ParameterBuilder ticketPar = new ParameterBuilder();
        List&amp;lt;Parameter&amp;gt; pars = new ArrayList&amp;lt;&amp;gt;();
        ticketPar.name(&amp;quot;token&amp;quot;).description(&amp;quot;授权码&amp;quot;)
                .modelRef(new ModelRef(&amp;quot;string&amp;quot;)).parameterType(&amp;quot;header&amp;quot;)
                .required(true).build();
        pars.add(ticketPar.build());
        return new Docket(DocumentationType.SWAGGER_2)
                .globalOperationParameters(pars)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage(&amp;quot;cn.anytec.demo.sdkclientdemo.controller&amp;quot;))
                .paths(PathSelectors.any())
                .build();
    }
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                //页面标题
                .title(&amp;quot;ANYTEC Face API&amp;quot;)
                //创建人
                .contact(new Contact(&amp;quot;ANYTEC&amp;quot;, &amp;quot;anytec.cn&amp;quot;, &amp;quot;&amp;quot;))
                //版本号
                .version(&amp;quot;1.0&amp;quot;)
                //描述
                .description(&amp;quot;ANYTEC Face API&amp;quot;)
                .build();
    }
}
&lt;/code&gt;&lt;/pre&gt;
">SpringBoot 集成Swagger</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/jsonview-zhu-jie/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;通过 &lt;code&gt;@JsonView&lt;/code&gt; 注解， 指定对应对象在对应控制器的不同返回内容.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JsonView以接口作为区分组， 不同的接口作为其参数可以针对不同类型进行分类区分.&lt;br&gt;
我们有一个 User 对象， 它有username和password属性， 然后对应两个控制器userList和getUserInfo， 我想在在userList接口时只返回用户的名称列表， 在getUserInfo时，将用户名和密码一起返回。那么可以通过定义两个接口：UserSimpleView和UserDetailView， UserDetailView继承自UserSimpleView，根据Java的继承关系也不难理解，就是当有simple的时候， 是独立的， 当有detail的时候， 会将simple注解了的参数一并展示，描述的可能不是特别好，可以通过代码得到更好的展示。&lt;/p&gt;
&lt;p&gt;首先，我们在User类中，定义两个接口。分别代表两种展示类别，然后再username字段加上simple接口参数，在password字段加上detail接口参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Data
@Accessors(chain = true)
public class User implements Serializable {

    public interface UserSimpleView {}
    public interface UserDetailView extends UserSimpleView {}

    @JsonView(UserSimpleView.class)
    private String username;
    @JsonView(UserDetailView.class)
    private String password;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后再对应的两个控制器，通过 &lt;code&gt;@JsonView&lt;/code&gt; 注解，和对应对象的属性绑定起来。&lt;br&gt;
可以看到，我们在getUserList方法上配置了simple接口，代表着它的参数返回中，只会包括usename字段属性值。&lt;br&gt;
在getInfo方法上，通过配置detail接口，代表着它的返回值中可以包括 &lt;code&gt;User&lt;/code&gt; 对象中的所有使用了 &lt;code&gt;Detail&lt;/code&gt; 接口以及其父接口的参数.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
@RequestMapping(&amp;quot;user&amp;quot;)
public class UserController {

    @GetMapping
    @JsonView(User.UserSimpleView.class)
    public List&amp;lt;User&amp;gt; getUserList(UserQueryCondition condition,
                              @PageableDefault(size = 20, page = 1, sort = &amp;quot;username,asc&amp;quot;) Pageable pageable) {

        System.out.println(ReflectionToStringBuilder.toString(condition, ToStringStyle.MULTI_LINE_STYLE));
        System.out.println(pageable);

        return Collections.singletonList(new User().setUsername(&amp;quot;yzt&amp;quot;).setPassword(&amp;quot;xxx&amp;quot;));
    }

    @GetMapping(&amp;quot;{id:\\d+}&amp;quot;)
    @JsonView(User.UserDetailView.class)
    public User getInfo(@PathVariable String id) {

        System.out.println(id);

        User user = new User();
        user.setUsername(&amp;quot;tom&amp;quot;).setPassword(&amp;quot;xxx&amp;quot;);
        return user;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来通过单元测试的返回值，具体的来看一下效果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootTest
@RunWith(SpringRunner.class)
public class UserControllerTest {

    @Autowired
    private WebApplicationContext wac;
    private MockMvc mockMvc;

    @Before
    public void setup() {
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    @Test
    public void whenQuerySuccess() throws Exception {
        String contentAsString = mockMvc.perform(get(&amp;quot;/user&amp;quot;)
                .param(&amp;quot;username&amp;quot;, &amp;quot;yzt&amp;quot;)
                .param(&amp;quot;age&amp;quot;, &amp;quot;20&amp;quot;)
                .param(&amp;quot;ageTo&amp;quot;, &amp;quot;30&amp;quot;)
                .param(&amp;quot;page&amp;quot;, &amp;quot;2&amp;quot;)
                .param(&amp;quot;size&amp;quot;, &amp;quot;10&amp;quot;)
                .param(&amp;quot;sort&amp;quot;, &amp;quot;age,desc&amp;quot;)
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isOk())
                .andExpect(jsonPath(&amp;quot;$.length()&amp;quot;).value(1))
                .andReturn()
                .getResponse()
                .getContentAsString();
        System.out.println(contentAsString);

    }


    @Test
    public void whenGetInfoSuccess() throws Exception {
        String content = mockMvc.perform(get(&amp;quot;/user/1&amp;quot;)
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isOk())
                .andExpect(jsonPath(&amp;quot;$.username&amp;quot;).value(&amp;quot;tom&amp;quot;))
                .andReturn()
                .getResponse()
                .getContentAsString();
        System.out.println(content);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的返回值如下:&lt;br&gt;
whenQuerySuccess接口返回值， 只看到了username参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;top.imyzt.learning.security.demo.dto.UserQueryCondition@67b560fe[
  username=yzt
  age=20
  ageTo=30
]
Page request [number: 2, size 10, sort: age: DESC]
[{&amp;quot;username&amp;quot;:&amp;quot;yzt&amp;quot;}]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;whenGetInfoSuccess接口返回值，可以看到了password参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;quot;username&amp;quot;:&amp;quot;tom&amp;quot;,&amp;quot;password&amp;quot;:&amp;quot;xxx&amp;quot;}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，博客结束了。有多学了一个骚操作。&lt;/p&gt;
">JsonView注解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/linux-ubuntu-chang-yong-ming-ling-ji/"" data-c="
          &lt;h1 id=&#34;后台运行程序并且打印日志到文件&#34;&gt;后台运行程序并且打印日志到文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;nohup run.sh &amp;gt;out.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
">Linux Ubuntu 常用命令集</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/she-ji-mo-shi-zhi-dai-li-mo-shi/"" data-c="
          &lt;p&gt;这是设计模式系列的第一篇文章, 也不知道能写几篇......&lt;/p&gt;
&lt;h1 id=&#34;代理模式的理解&#34;&gt;代理模式的理解&lt;/h1&gt;
&lt;p&gt;代理模式和装饰器模式很像，可以像装饰器模式一样理解它。&lt;/p&gt;
&lt;p&gt;代理（Proxy）模式， 提供了对&lt;strong&gt;目标对象&lt;/strong&gt;另外的访问方式，即通过代理访问目标对象。这样的好处是可以在&lt;strong&gt;目标实现&lt;/strong&gt;的基础上，增强额外的功能操作。（扩展对象的功能，不入侵目标对象的代码）。  符合设计模式开闭原则。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2019/05/6ummeouseaj3vpefmjc8c5m9ph.png&#34; alt=&#34;代理模式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;静态代理&#34;&gt;静态代理&lt;/h1&gt;
&lt;p&gt;关键： 代理对象要实现与目标对象一样的接口。&lt;/p&gt;
&lt;p&gt;举例：保存用户的操作，userDao（目标对象）只处理业务相关的保存操作，userDaoProxy（代理对象）负责给保存方法添加事务。&lt;/p&gt;
&lt;p&gt;优点： 不修改目标对象的前提下, 对目标对象进行扩展&lt;br&gt;
缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为代理对象需要和目标对象实现相同的接口, 所以会有很多代理类&lt;/li&gt;
&lt;li&gt;一旦接口增加方法, 目标对象和代理对象都要维护&lt;/li&gt;
&lt;li&gt;不可协商，比如UserDao有一个查询一个保存方法，只需要对保存方法进行事务处理。但是&lt;strong&gt;代理对象&lt;/strong&gt;必须也实现查询方法，因为Java的接口必须被子类实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;模拟用户操作DAO接口，目标对象和代理对象都需要实现该接口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface IUserDao {

    /**
     * 保存用户
     */
    void save();

    /**
     * 根据id查询用户
     * @param id 用户id
     */
    void queryUserById(int id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目标对象仅包含数据库业务操作，不干涉事务、日志等其它代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/5/28
 * @description 目标对象
 */
public class UserDao implements IUserDao {

    public void save() {
        System.out.println(&amp;quot;保存用户&amp;quot;);
    }

    public void queryUserById(int id) {
        System.out.printf(&amp;quot;id=%d, 用户详情&amp;quot;, id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而代理对象需要对目标对象进行扩展，相同的，实现UserDao接口。具有一个私有成员变量保存着目标对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/5/28
 * @description 目标对象的静态代理对象,要与目标对象实现一样的接口
 */
public class UserDaoProxy implements IUserDao {

    /**
     * 保存目标对象
     */
    private IUserDao target;

    UserDaoProxy(IUserDao target) {
        this.target = target;
    }

    /**
     * 扩展目标对象的方法, 加上事务
     */
    public void save() {
        PrintUtil.print(&amp;quot;开始事务&amp;quot;);

        target.save();

        PrintUtil.print(&amp;quot;提交事务&amp;quot;);
    }

    /**
     * 此方法可见, 静态代理不具备可扩展性. 只需要代理 {@link #save()} 方法时,
     * 因为接口必须继承, 必须将本方法实现
     */
    public void queryUserById(int id) {
        target.queryUserById(id);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后通过测试，展示静态代理是否成功运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/5/28
 * @description App
 */
public class App {

    public static void main(String[] args) {

        UserDao userDao = new UserDao();
        // class top.imyzt.learning.dp.proxy.a_static.UserDao
        System.out.println(userDao.getClass());

        UserDaoProxy userDaoProxy = new UserDaoProxy(userDao);
        // class top.imyzt.learning.dp.proxy.a_static.UserDaoProxy
        System.out.println(userDaoProxy.getClass());

        userDaoProxy.save();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;动态代理&#34;&gt;动态代理&lt;/h1&gt;
&lt;p&gt;为了解决上面静态代理的问题，随之出现了动态代理。对于动态代理我们熟知的Spring的AOP就是使用了动态代理的方式。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代理对象不需要实现接口&lt;/li&gt;
&lt;li&gt;代理对象的生成, 是利用JDKAPI, 动态的在内存中构建代理对象(需要我们指定创建代理对象实现的接口类型)&lt;/li&gt;
&lt;li&gt;动态代理, JDK代理(接口代理), 需要依赖于实现接口的目标对象.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;动态代理分为JDK动态代理和CGLIB代理, 都是通过动态生成字节码技术然后加载字节码到JVM中, 它们的主要区别是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JDK代理依赖目标对象实现接口, CGLIB不需要&lt;/li&gt;
&lt;li&gt;因为CGLIB是继承目标对象, 所以目标对象不能为final类, 而JDK代理不存在这个问题.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;jdk动态代理&#34;&gt;JDK动态代理&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;java.lang.reflect.Proxy#newProxyInstance(ClassLoader loader,    // 目标对象使用的类加载器
                                          Class&amp;lt;?&amp;gt;[] interfaces,                           // 目标对象实现的接口的类型
                                          InvocationHandler h)                             // 事件处理器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JDK动态代理：&lt;br&gt;
代理对象不需要实现接口, 但是目标对象一定要实现接口, 否则不能使用JDK动态代理.&lt;/p&gt;
&lt;p&gt;这里只是展示一下核心的代理工厂的代码, 更多代码在文末的github链接中有给出. JDK动态代理使用了JDK的反射功能实现.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/5/28
 * @description JDK动态代理工厂
 */
public class DynamicProxyFactory&amp;lt;T&amp;gt; {

    private static final Pattern p = Pattern.compile(&amp;quot;(query\\w+|find\\w+|get\\w)&amp;quot;);

    /**
     * 目标对象
     */
    private T target;

    public DynamicProxyFactory(T target) {
        this.target = target;
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public T getProxyInstance() {
        return  (T) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                (Object proxy, Method method, Object[] args) -&amp;gt; {

                    Object returnValue;

                    // 模拟Spring 的事务开启开关, 根据方法名判断是否需要开启事务
                    if (checkMethod(method)) {
                        // 执行目标对象的方法
                        return method.invoke(target, args);
                    }

                    PrintUtil.print(&amp;quot;开始事务&amp;quot;);

                    // 执行目标对象的方法
                    returnValue = method.invoke(target, args);

                    PrintUtil.print(&amp;quot;结束事务&amp;quot;);

                    return returnValue;
                });
    }


    /**
     * 检查方法是否需要开启事务. 根据方法名简单判断
     * @param method 方法
     */
    private boolean checkMethod(Method method) {
        String name = method.getName();
        Matcher matcher = p.matcher(name);
        return matcher.find();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cglib动态代理&#34;&gt;CGLIB动态代理&lt;/h2&gt;
&lt;p&gt;CGLIB可以弥补JDK动态代理不能代理没有实现接口的目标对象的情况, 可以对不实现接口的目标对象进行代理. 需要引入CGLIB的jar包. 这里使用Spring-core包封装的CGLIB即可.&lt;br&gt;
演示一个CGLIB对象工厂的代理对象, 通过泛型, 如业务没有改变的情况下, 可以重用的代理对象实现.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/5/28
 * @description CglibDynamicFactory
 */
public class CglibDynamicFactory&amp;lt;T&amp;gt; implements MethodInterceptor {

    private T target;

    public CglibDynamicFactory(T target) {
        this.target = target;
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public T getProxyInstance() {


        // 1. 工具类
        Enhancer enhancer = new Enhancer();

        // 2. 设置父类
        enhancer.setSuperclass(target.getClass());

        // 3. 设置回调函数
        enhancer.setCallback(this);

        return (T) enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {

        PrintUtil.print(&amp;quot;开始事务&amp;quot;);

        // 执行目标对象的方法
        Object returnValue = method.invoke(target, args);

        PrintUtil.print(&amp;quot;提交事务&amp;quot;);

        return returnValue;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">设计模式之代理模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/elasticsearch-an-zhuang-head-cha-jian/"" data-c="
          &lt;p&gt;es的安装较简单, 记录一下安装head插件就行了.&lt;/p&gt;
&lt;p&gt;首先下载es-head的代码. 地址在这里. &lt;a href=&#34;https://github.com/mobz/elasticsearch-head&#34;&gt;https://github.com/mobz/elasticsearch-head&lt;/a&gt;&lt;br&gt;
由于head是一个前端程序, 是有跨域问题的, 需要修改es的配置文件, 增加跨域支持. 修改一下 &lt;code&gt;config/elasticsearch.yml&lt;/code&gt; 文件, 在最底部增加两行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http.cors.enables: true
http.cors.allow-origin: &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后进入es-head的目录, 运行 &lt;code&gt;npm install&lt;/code&gt; 安装所需依赖, 最后 &lt;code&gt;npm run start&lt;/code&gt; 就可以访问浏览器 9100 端口了.&lt;/p&gt;
">ElasticSearch 安装head插件</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/autowired-inject-resource-san-ge-zhu-jie-de-zuo-yong-he-qu-bie/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;先说明一下, 这三个注解都可以用在注入对象时使用. 他们两个是javax包下自带的, 一个是由spring提供给我们的.&lt;/p&gt;
&lt;h1 id=&#34;autowired&#34;&gt;@Autowired&lt;/h1&gt;
&lt;p&gt;先说Autowired, 因为他是我们大多数人经常使用到的, 它是由spring为我们提供的依赖注入的注解,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它可以用在变量, 构造器和setter方法上.&lt;/li&gt;
&lt;li&gt;它是根据 &lt;strong&gt;类型&lt;/strong&gt; 进行装配bean的, 提供一个 &lt;code&gt;required&lt;/code&gt; 参数, 指定为false时, 当无法注入时, 不会报错.&lt;/li&gt;
&lt;li&gt;它可以配合 &lt;code&gt;@Qualifier&lt;/code&gt; 注解进行使用, 通过它的 &lt;code&gt;value&lt;/code&gt; 参数, 指定注入时需要的bean的 &lt;strong&gt;名称&lt;/strong&gt;, 就可以根据名称进行注入了.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;resource&#34;&gt;@Resource&lt;/h1&gt;
&lt;p&gt;这个注解大多数人不常使用, 它是javax包提供的, 基于 JSR250 的注解. 我平时更多的是使用它.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它可以用在字段或setter方法上.&lt;/li&gt;
&lt;li&gt;它是根据 &lt;strong&gt;名称&lt;/strong&gt; 进行装配bean的, 提供一个 &lt;code&gt;name&lt;/code&gt; 参数, 但是默认情况下不指定的话, 作用在参数上时会根据参数名注入, 作用在setter方法时, 会根据属性名进行装配, 都无法查找时, 会根据类型进行匹配.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;inject&#34;&gt;@Inject&lt;/h1&gt;
&lt;p&gt;这个注解应该大多数人都没见过, 在写文章之前, 我也没见过 😃&lt;br&gt;
这个注解是遵循 JSR330 规范的, 是由javax包提供的. 这里简单讲解一下(其实就是@Autowired的翻版).&lt;br&gt;
它可以作用在@Autowired能作用的地方, 并且默认也是根据类型装配, 通过 &lt;code&gt;@Named&lt;/code&gt; 修改为根据 &lt;strong&gt;名称&lt;/strong&gt; 装配.&lt;br&gt;
它与Autowired不同点在于它没有 &lt;code&gt;required&lt;/code&gt; 参数&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;@Autowired是Spring提供给我们的, @Inject(遵循JSR330规范)和@Resource(遵循JSR250规范)是javax包提供给我们的.&lt;/li&gt;
&lt;li&gt;@Autowired和@Inject是根据&lt;strong&gt;类型&lt;/strong&gt;装配, @Resource是根据&lt;strong&gt;名称&lt;/strong&gt;装配.&lt;/li&gt;
&lt;li&gt;@Autowired有required参数, @Inject没有.&lt;/li&gt;
&lt;li&gt;@Autowired配合@Qualifier可以使用&lt;strong&gt;名称&lt;/strong&gt;装配, @Inject配合@Named可以使用&lt;strong&gt;名称&lt;/strong&gt;装配, @Resource根据名称无法装配时, 会根据类型装配.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;平时使用记住一种就可以了. 一般推荐使用 @Autowired, 毕竟你是用它们的框架.&lt;/p&gt;
">@Autowired, @Inject, @Resource 三个注解的作用和区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/lombok-chang-yong-fang-fa-shi-li/"" data-c="
          &lt;p&gt;文章以一个方法一个代码块的方式演示.&lt;/p&gt;
&lt;h1 id=&#34;简单几个注解&#34;&gt;简单几个注解&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;set和get方法&lt;br&gt;
@Getter / @Setter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;toString方法&lt;br&gt;
@ToString&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;equals和hashCode方法&lt;br&gt;
@EqualsAndHashCode&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Data&lt;br&gt;
@Data 通常这个方法就够了, 包含上面几个注解.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全参, 无参&lt;br&gt;
@AllArgsConstructor, @NoArgsConstructor&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能为空&lt;br&gt;
@NonNull, 作用到属性上是, 如果不赋值会抛空指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志&lt;br&gt;
@Slf4j&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;链式调用&#34;&gt;链式调用&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;通过设置 &lt;code&gt;@Accessors&lt;/code&gt; 的 &lt;code&gt;chain=true&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;public class LombokTest {
    public static void main(String[] args) {

        Student student = new Student();
        
        student.setName(&amp;quot;yzt&amp;quot;).setAge(22);
    }
}

@Data
@Accessors(chain = true)
class Student {
    private String name;
    private Integer age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;静态方法构造器&#34;&gt;静态方法构造器&lt;/h1&gt;
&lt;p&gt;通过 &lt;code&gt;@NonNull&lt;/code&gt; 和 &lt;code&gt;@RequiredArgsConstructor(staticName = &amp;quot;ofName&amp;quot;)&lt;/code&gt; 实现.&lt;br&gt;
在 &lt;code&gt;name&lt;/code&gt; 属性上添加 &lt;code&gt;@NonNull&lt;/code&gt; 注解标识不能为空, 然后通过 &lt;code&gt;RequiredArgsConstructor&lt;/code&gt; 的 &lt;code&gt;staticName &lt;/code&gt; 属性设置静态构造器的名称.&lt;br&gt;
当然也是可以不使用 &lt;code&gt;@NonNull&lt;/code&gt; 属性的, 标识静态构造器是 &lt;strong&gt;空参&lt;/strong&gt; 的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;带参数的构造
public class LombokTest {
    public static void main(String[] args) {

        Student student = Student.ofName(&amp;quot;yzt&amp;quot;).setAge(22);
        System.out.println(student);
    }
}

@Data
@Accessors(chain = true)
@RequiredArgsConstructor(staticName = &amp;quot;ofName&amp;quot;)
class Student {
    @NonNull
    private String name;
    private Integer age;
}

空参构造
public class LombokTest {
    public static void main(String[] args) {

        Student student = Student.of().setName(&amp;quot;yzt&amp;quot;).setAge(22);
        System.out.println(student);
    }
}

@Data
@Accessors(chain = true)
@RequiredArgsConstructor(staticName = &amp;quot;of&amp;quot;)
class Student {
    private String name;
    private Integer age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;builder-模式&#34;&gt;builder 模式&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;public class LombokTest {
    public static void main(String[] args) {

        Student student = Student.builder().name(&amp;quot;yzt&amp;quot;).age(22).build();
        System.out.println(student);
    }
}

@Data
@Builder
class Student {
    private String name;
    private Integer age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;工具类&#34;&gt;工具类&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;@UtilityClass&lt;/code&gt; 注解作用在工具方法上, 会私有构造, 然后为方法添加 &lt;code&gt;static&lt;/code&gt; 关键字. 注意下方我演示的 &lt;code&gt;getIp()&lt;/code&gt; 方法没有添加 &lt;code&gt;static&lt;/code&gt; 关键字也能够调用.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class LombokTest {
    public static void main(String[] args) {

        String ip = HttpKit.getIp();
        System.out.println(ip);
    }
}

@UtilityClass
class HttpKit {

    public String getIp() {
        return &amp;quot;127.0.0.1&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;去除统一前缀&#34;&gt;去除统一前缀&lt;/h1&gt;
&lt;p&gt;这个在使用的时候命名一定要使用 &lt;strong&gt;驼峰命名法&lt;/strong&gt;, 不然会出现莫名其妙的问题.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class LombokTest {
    public static void main(String[] args) {

        Student student = new Student();
        student.setName(&amp;quot;yzt&amp;quot;);
        student.setAge(22);
        System.out.println(student);
    }
}

@Data
@Accessors(prefix = &amp;quot;f&amp;quot;)
class Student {
    private String fName;
    private Integer fAge;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;setget-方法不以-setget-开头&#34;&gt;set/get 方法不以 set/get 开头&lt;/h1&gt;
&lt;p&gt;就相当于去掉了 set/get 前缀的 set/get 方法. 不推荐使用. 不符合Java规范.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class LombokTest {
    public static void main(String[] args) {

        Student student = new Student();
        student.name(&amp;quot;yzt&amp;quot;);
        student.age(22);
        System.out.println(student.name());
    }
}

@Data
@Accessors(fluent = true)
class Student {
    private String name;
    private Integer age;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;代理方法&#34;&gt;代理方法&lt;/h1&gt;
&lt;p&gt;这个说起来有点懵逼, 直接看代码可能更清晰.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class LombokTest {
    public static void main(String[] args) {

        User user = new User();
        user.add(&amp;quot;yzt&amp;quot;);    // 这里其实调用的是 TemplateCollection 的方法
        user.add(&amp;quot;xxx&amp;quot;);
        user.add(&amp;quot;yyy&amp;quot;);
        System.out.println(user);
        user.remove(&amp;quot;yyy&amp;quot;);
        System.out.println(user);
    }
}

@ToString
class User {
    private interface TemplateCollection {
        boolean add(String obj);
        boolean remove(Object obj);
    }

    @Delegate(types = TemplateCollection.class)
    private final Collection&amp;lt;String&amp;gt; users = new ArrayList&amp;lt;&amp;gt;();
}

输出: 
User(users=[yzt, xxx, yyy])
User(users=[yzt, xxx])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;h2 id=&#34;编译注解到代码&#34;&gt;编译注解到代码&lt;/h2&gt;
&lt;p&gt;通过菜单栏的 &lt;code&gt;Refactor -&amp;gt; delombok&lt;/code&gt; 就可以得到源代码了&lt;/p&gt;
&lt;h2 id=&#34;关于lombok&#34;&gt;关于lombok&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;lombok.experimental.*&lt;/code&gt; 包下的是创新型注解. 与Java规范不符合, 有待考证&lt;br&gt;
在 &lt;code&gt;lombok.*&lt;/code&gt; 包下的放心使用.&lt;/p&gt;
">Lombok 常用方法实例</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mybatis-plus-cha-xun-shi-pai-chu-mou-yi-lie/"" data-c="
          &lt;pre&gt;&lt;code&gt;
public List&amp;lt;BrokerMessageLog&amp;gt; query4StatusAndTimeoutMessage() {
    return lambdaQuery().eq(BrokerMessageLog::getStatus, Constant.ORDER_SENDING)
            .le(BrokerMessageLog::getNextRetry, LocalDateTime.now())
            .select(BrokerMessageLog.class, tableFieldInfo -&amp;gt; !&amp;quot;name&amp;quot;.equals(tableFieldInfo.getColumn()))
            .list();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.select(BrokerMessageLog.class, tableFieldInfo -&amp;gt; !&amp;quot;name&amp;quot;.equals(tableFieldInfo.getColumn()))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;排除了字段名称为 &lt;code&gt;name&lt;/code&gt; 的字段.&lt;/p&gt;
">Mybatis-Plus查询时排除某一列</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/idea-she-zhi/"" data-c="
          &lt;h1 id=&#34;自动生成serialversionuid&#34;&gt;自动生成serialVersionUID&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Ctrl+Alt+S打开设置&lt;/li&gt;
&lt;li&gt;搜索栏搜索 &lt;code&gt;Inspections&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项栏搜索 &lt;code&gt;Serialization issues&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找到 &lt;code&gt;Serializable class without &#39;SerialVersionUID&#39;&lt;/code&gt;, 勾选&lt;/li&gt;
&lt;li&gt;应用&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://imyzt.top/upload/2019/05/qlojid2n4ih0dol3fgvmcrip97.jpg&#34; alt=&#34;操作图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对应的实现了 &lt;code&gt;Serializable&lt;/code&gt; 接口的类会报出黄色警告, Alt + Enter 组合键选中 &lt;code&gt;Add SerialVersionUID field&lt;/code&gt; 即可生成.&lt;br&gt;
&lt;img src=&#34;http://imyzt.top/upload/2019/05/rhnt03ocvsgslq7ccghg6kr1q5.jpg&#34; alt=&#34;操作图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;去除所有无用引用&#34;&gt;去除所有无用引用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Ctrl+Alt+S打开设置&lt;/li&gt;
&lt;li&gt;勾选图中的 &lt;code&gt;show notification after optimize imports action&lt;/code&gt;, 确认退出设置&lt;/li&gt;
&lt;li&gt;选中整个项目右键, 点击 &lt;code&gt;optimize imports&lt;/code&gt;, 点击确定即可.&lt;/li&gt;
&lt;li&gt;在类窗口, Ctrl+Alt+O, 可以单独去除该类的无用导入.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2020/01/v1m3vtp2tuh7hprrs113leh8lk.png&#34; alt=&#34;设置&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2020/01/o2cppdje38grfr90kfr1skeij1.png&#34; alt=&#34;设置&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;设置代码提示不缺分大小写&#34;&gt;设置代码提示不缺分大小写&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/08/q2nfu81mc8jrjogd77h83hb4hf.png&#34; alt=&#34;代码提示不缺分大小写&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;鼠标放上提示方法描述&#34;&gt;鼠标放上提示方法描述&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/08/p2gh6kaa10j9fr70f1l555p7g5.png&#34; alt=&#34;鼠标放上提示方法描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;idea-自动导包&#34;&gt;idea 自动导包&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/12/rdrq59g5oegjep1i54gtb7i4gm.png&#34; alt=&#34;自动导包&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">IDEA 设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/yaml-wen-jian-mo-ren-zhi/"" data-c="
          &lt;p&gt;SpringBoot引入yml文件作为配置文件, 可以通过@Value注解获取对应的值, 当然也是可以对值设定默认值的.&lt;br&gt;
比如在swagger的配置类中, 需要判定swagger是否开启, 我们在yml文件中设定属性如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;swagger:
  enable: ${SWAGGER_ENABLE:false}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面的设置, 默认情况下, 属性的值是false, 而当有指令对SWAGGER_ENABLE属性重设之后, 参数值也会跟随改变.&lt;/p&gt;
">YAML文件默认值</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/outofmemoryerror-fen-xi/"" data-c="
          &lt;h1 id=&#34;写一段代码&#34;&gt;写一段代码&lt;/h1&gt;
&lt;p&gt;堆内存溢出, 首先我们需要一段能够使堆内存溢出的代码.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;

/**
 * @author imyzt
 * @date 2019/5/7
 * @description Main
 */
public class Main {
    public static void main(String[] args) {
        ArrayList&amp;lt;Demo&amp;gt; demos = new ArrayList&amp;lt;&amp;gt;();
        while (true) {
            demos.add(new Demo());
        }
    }
}


/**
 * @author imyzt
 * @date 2019/5/7
 * @description Demo
 */
public class Demo {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过制定堆内存大小, 指定堆内存快照, 可以快速获取一份堆内存溢出信息.可以通过在IDE的 &lt;code&gt;VM options&lt;/code&gt; 设置.&lt;br&gt;
&lt;code&gt;-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/05/3rgpa4o22agripb5r64c6a3kdn.jpg&#34; alt=&#34;堆内存快照&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这份文件在我们项目的根目录下面. 后缀名是 &lt;code&gt;.hprof&lt;/code&gt;.  我们可以通过eclipse提供的mat工具对堆内存快照进行分析.  &lt;a href=&#34;https://www.eclipse.org/downloads/download.php?file=/mat/1.8.1/rcp/MemoryAnalyzer-1.8.1.20180910-win32.win32.x86_64.zip&#34;&gt;mat下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来就是将我们的快照数据导入到工具中.&lt;br&gt;
从图中我们可以看到 &lt;strong&gt;Problem Suspect 1&lt;/strong&gt;(可能出现问题的区域)比较大, 总共20M的内存, 15M都有可能出现问题&lt;br&gt;
从图中分析, 我们看到了95%的内存都被 main thread 占用, 然后点开树发现, 对象占用是最高的,几乎是主线程占用的内存的所有.&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/05/vns1bdk5u6ilvoqqubbrmh6ldp.jpg&#34; alt=&#34;内存分析&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">OutOfMemoryError 分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/docker-wu-fa-qi-dong/"" data-c="
          &lt;p&gt;就在今天, 我的服务器重启之后, docker ps突然没法用了, 提示信息如下.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ubuntu@xxx:~$ docker ps
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示信息很明显,就是问我docker是否启动, 按道理来说docker应该是服务自拉起的. 既然没有启动肯定是出了问题. 需要进行排查.&lt;br&gt;
第一步我是直接 systemctl 启动一次, 不过依旧报错.  信息如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ubuntu@xxx:~$ systemctl start docker.service
Job for docker.service failed because the control process exited with error code. See &amp;quot;systemctl status docker.service&amp;quot; and &amp;quot;journalctl -xe&amp;quot; for details.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示信息说启动失败了, 然后叫我 status 查看一下, 命令执行后信息如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ubuntu@xxx:~$ systemctl status docker.service
● docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)
   Active: failed (Result: start-limit-hit) since 二 2019-05-07 11:26:12 CST; 10s ago
     Docs: https://docs.docker.com
  Process: 26461 ExecStart=/usr/bin/dockerd -H fd:// (code=exited, status=2)
 Main PID: 26461 (code=exited, status=2)

5月 07 11:26:12 xxx systemd[1]: docker.service: Main process exited, code=exited, status=2/INVALIDARGUMENT
5月 07 11:26:12 xxx systemd[1]: Failed to start Docker Application Container Engine.
5月 07 11:26:12 xxx systemd[1]: docker.service: Unit entered failed state.
5月 07 11:26:12 xxx systemd[1]: docker.service: Failed with result &#39;exit-code&#39;.
5月 07 11:26:12 xxx systemd[1]: docker.service: Service hold-off time over, scheduling restart.
5月 07 11:26:12 xxx systemd[1]: Stopped Docker Application Container Engine.
5月 07 11:26:12 xxx systemd[1]: docker.service: Start request repeated too quickly.
5月 07 11:26:12 xxx systemd[1]: Failed to start Docker Application Container Engine.
5月 07 11:26:12 xxx systemd[1]: docker.service: Unit entered failed state.
5月 07 11:26:12 xxx systemd[1]: docker.service: Failed with result &#39;start-limit-hit&#39;.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从提示信息我反正是没看出来太多有用的信息来的, 然后就祭出了搜索大法, 发现和我一样问题的挺多的.  我就直接给我问题解决的链接先.&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/dalianmao890710/p/9241752.html&#34;&gt;博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据上面博主的解决方案, 我将 /etc/docker/daemon.json 的文件进行了修改, 文件内容展示在下面如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{                                                                                                                                                                                                                               
            &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;阿里云仓库加速链接&amp;quot;],
            &amp;quot;bip&amp;quot;: &amp;quot;10.0.0.1/16&amp;quot;,
             &amp;quot;graph&amp;quot;: &amp;quot;/mnt/docker-data&amp;quot;,
             &amp;quot;storage-driver&amp;quot;: &amp;quot;overlay&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来通过 &lt;code&gt;systemctl start docker.service &lt;/code&gt; 启动了一下docker, 问题果然消失了.  上面博主对问题描述的也已经非常清楚,我在此只是做一个引用.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ocker的engine 基于Device Mapper提供的一种存储驱动,而它又依赖与 devicemapper。于是乎我将它给删除并重启服务，解决了docker无法正常启动的问题。&lt;/p&gt;
&lt;/blockquote&gt;
">docker 无法启动</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/docker-swarm-bian-pai-gong-ju/"" data-c="
          &lt;h1 id=&#34;swarm介绍&#34;&gt;Swarm介绍&lt;/h1&gt;
&lt;p&gt;Swarm 是 Docker 公司在 2014 年 12 月初发布的一套较为简单的工具,用来管理 Docker 集群,它将一群 Docker 宿主机变成一个单一的,虚拟的主机。Swarm 使用标准的 Docker API接口作为其前端访问入口,换言之,各种形式的 Docker Client(docker client in go, docker_py,docker 等)均可以直接与 Swarm 通信。Swarm 几乎全部用 Go 语言来完成开发。&lt;br&gt;
Swarm deamon 只是一个调度器(Scheduler)加路由器(router),Swarm 自己不运行容器,它只是接受 docker 客户端发送过来的请求,调度适合的节点来运行容器,这意味着,即使Swarm 由于某些原因挂掉了,集群中的节点也会照常运行,当 Swarm 重新恢复运行之后,它会收集重建集群信息。下面是 Swarm 的结构图:&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/05/umrounlfd2hpeqc5dm7pqhib6p.png&#34; alt=&#34;swarm架构图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;环境准备&#34;&gt;环境准备&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;三台服务器或者虚拟机&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;server01, server02, server03&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;安装了docker&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;搭建集群&#34;&gt;搭建集群&lt;/h1&gt;
&lt;h2 id=&#34;初始化一个manager节点&#34;&gt;初始化一个manager节点&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;docker提供了init命令用于初始化一个集群, 从输出信息中可以得到对应的work节点的token&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker swarm init 
Swarm initialized: current node (wpx3o9mcpuq79ujpumykjkgt7) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-44a0imbc65z7o9fbfj89mxs4xfu7w3pmtfo7s50mt3ues809mr-0xhunq3plzdyhyhebswxuuds8 192.168.10.45:2377

To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;在其他服务器输入命令&#34;&gt;在其他服务器输入命令&lt;/h2&gt;
&lt;p&gt;在上一步的输出中, 已经包含了其他节点加入该集群的命令.只需要输入即可.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server02:~$ docker swarm join --token SWMTKN-1-44a0imbc65z7o9fbfj89mxs4xfu7w3pmtfo7s50mt3ues809mr-0xhunq3plzdyhyhebswxuuds8 192.168.10.45:2377
This node joined a swarm as a worker.

n-tech-admin@server03:~$ docker swarm join --token SWMTKN-1-44a0imbc65z7o9fbfj89mxs4xfu7w3pmtfo7s50mt3ues809mr-0xhunq3plzdyhyhebswxuuds8 192.168.10.45:2377
This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看docker-network&#34;&gt;查看docker network&lt;/h2&gt;
&lt;p&gt;创建集群之后, 我们可以看到network增加了&lt;code&gt;docker_gwbridge&lt;/code&gt;和&lt;code&gt;ingress&lt;/code&gt;两个网络.&lt;br&gt;
swarm的ingress连接的是ingress网络, 该网络需要通过docker_gwbridge网桥, 借助于docker daemon网桥跟主机进行连接.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker network ls
NETWORK ID          NAME                         DRIVER              SCOPE
cdb39c520f0b        bridge                       bridge              local
fd5e65ece1c7        docker_gwbridge              bridge              local
eb06b54c7e76        host                         host                local
tbsdc0m2p1le        ingress                      overlay             swarm
f4e8f15f758b        none                         null                local
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;高可用&#34;&gt;高可用&lt;/h2&gt;
&lt;p&gt;docker默认支持高可用, 通过选举将work节点挑选为manager节点. 只需要配置所有节点为manager节点即可.&lt;br&gt;
首先可以通过docker node ls查看所有的节点信息.可以看到默认情况下&lt;code&gt;MANAGER STATUS&lt;/code&gt;只有server01是一个Leader节点.  其他节点都是普通节点.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
wpx3o9mcpuq79ujpumykjkgt7 *   server01            Ready               Active              Leader              18.09.3
1bz3t5imxc9evv4poh9o3o65l     server02            Ready               Active                                  18.09.0
nuwhcuajlf71q4x23syi7tx06     server03            Ready               Active                                  18.02.0-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过在&lt;code&gt;manager节点&lt;/code&gt;执行 &lt;code&gt;docker node promote 服务器名称&lt;/code&gt;, 可以将其他节点提升为manager节点.&lt;br&gt;
可以看到执行之后, 另外两个work节点的&lt;code&gt;MANAGER STATUS&lt;/code&gt;也变成了&lt;code&gt;Reachable&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker node promote server02
Node server02 promoted to a manager in the swarm.
n-tech-admin@server01:~$ docker node promote server03
Node server03 promoted to a manager in the swarm.
n-tech-admin@server01:~$ docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
wpx3o9mcpuq79ujpumykjkgt7 *   server01            Ready               Active              Leader              18.09.3
1bz3t5imxc9evv4poh9o3o65l     server02            Ready               Active              Reachable           18.09.0
nuwhcuajlf71q4x23syi7tx06     server03            Ready               Active              Reachable           18.02.0-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;创建服务&#34;&gt;创建服务&lt;/h2&gt;
&lt;p&gt;我们在 &lt;code&gt;manager&lt;/code&gt;创建一个linux服务, 提供一个shell命令让他运行.&lt;br&gt;
通过执行 &lt;code&gt;service ls&lt;/code&gt;命令, 可以看到刚才运行服务已经成功了.&lt;/p&gt;
&lt;p&gt;还可以通过 &lt;code&gt;service inspect 服务名&lt;/code&gt; 查看服务的详细信息&lt;br&gt;
通过 &lt;code&gt;service logs 服务名&lt;/code&gt; 查看服务的详细日志&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service create --name test01 alpine ping baidu.com
ruzuc9hqpyv6dpe6qk8jmlc12
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================&amp;gt;] 
verify: Service converged


n-tech-admin@server01:~$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
ruzuc9hqpyv6        test01              replicated          1/1                 alpine:latest       

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来, 我们继续通过swarm创建一个nginx服务, 执行上面相同的命令, 创建完成后, 通过ls命令查看服务.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service create --name nginx nginx
n6svunal14gc78uffbzn5rl76
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================&amp;gt;] 
verify: Service converged

n-tech-admin@server01:~$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
n6svunal14gc        nginx               replicated          1/1                 nginx:latest        
ruzuc9hqpyv6        test01              replicated          1/1                 alpine:latest       

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;修改服务&#34;&gt;修改服务&lt;/h2&gt;
&lt;p&gt;我们发现, nginx没有对外端口, 我们可以通过 update 命令将nginx对外暴露一个端口&lt;br&gt;
然后我们通过浏览器访问 server01, server02, server03三个服务器, 发现都能够得到正确的响应, 这是因为docker通过虚拟IP的方式帮我们访问到最终提供服务的nginx容器.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service update --publish-add 9967:80 nginx 
nginx
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================&amp;gt;] 
verify: Service converged
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;服务扩展&#34;&gt;服务扩展&lt;/h2&gt;
&lt;p&gt;docker为我们提供了 scale 命令, 可以对服务进行扩容, 我们通过 service scale nginx=3, 将nginx容器扩容到三个, 然后通过ls命令可以看到 &lt;code&gt;REPLICAS&lt;/code&gt; 已经变成了3/3.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service scale nginx=3
nginx scaled to 3
overall progress: 3 out of 3 tasks 
1/3: running   [==================================================&amp;gt;] 
2/3: running   [==================================================&amp;gt;] 
3/3: running   [==================================================&amp;gt;] 
verify: Service converged 

n-tech-admin@server01:~$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
n6svunal14gc        nginx               replicated          3/3                 nginx:latest        *:9967-&amp;gt;80/tcp
ruzuc9hqpyv6        test01              replicated          1/1                 alpine:latest       

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;服务间应用连通性&#34;&gt;服务间应用连通性&lt;/h2&gt;
&lt;p&gt;通过上面, 我们创建了 test01 服务和 nginx 服务, 然后我们通过 &lt;code&gt;exec -it&lt;/code&gt; 登录到 alpine 的 test01 服务, 通过 &lt;code&gt; ping nginx&lt;/code&gt; 发现不能连通, 说明默认模式下创建的服务, &lt;strong&gt;不具备服务之间的连通性&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;那么, 既然问题提出了, 下面就来说一下怎么解决.&lt;/p&gt;
&lt;p&gt;首先, 我们创建一个 network, driver使用 overlay, 名字叫做 local-overlay. 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker network create -d overlay local-overlay
7lg34csui03vtcwie57pshodd

n-tech-admin@server01:~$ docker network ls
NETWORK ID          NAME                         DRIVER              SCOPE
cdb39c520f0b        bridge                       bridge              local
fd5e65ece1c7        docker_gwbridge              bridge              local
501f1e83da67        harbor_harbor                bridge              local
eb06b54c7e76        host                         host                local
tbsdc0m2p1le        ingress                      overlay             swarm
7lg34csui03v        local-overlay                overlay             swarm
f4e8f15f758b        none                         null                local
82d08c922135        syncd                        bridge              local
6b2cd023f92f        syncd-docker_syncd-network   bridge              local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们删除上面创建的两个服务.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
n6svunal14gc        nginx               replicated          3/3                 nginx:latest        *:9967-&amp;gt;80/tcp
ruzuc9hqpyv6        test01              replicated          1/1                 alpine:latest       
n-tech-admin@server01:~$ docker service rm nginx test01 
nginx
test01
n-tech-admin@server01:~$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来, 我们再次创建两个服务, 不过这次, 我们需要给服务指定网络使用 local-overlay&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service create --name nginx --network local-overlay -p 9967:80 nginx
9mtl0x99t67nxhllfh0ly2m43
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================&amp;gt;] 
verify: Service converged 

n-tech-admin@server01:~$ docker service create --name test02 --network local-overlay alpine ping baidu.com
7fnhnrzrxu9ih9hpu4ysnfijw
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================&amp;gt;] 
verify: Service converged 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们进入 test02 服务 的 alpine, 执行上面执行失败的 &lt;code&gt;ping&lt;/code&gt; 和 &lt;code&gt;wget&lt;/code&gt;, 我们发现, 所有的操作都已经能够正确执行了, 这是因为docker的vip为我们做了处理.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server02:~$ docker exec -it aa sh
/ # ping nginx
PING nginx (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: seq=0 ttl=64 time=0.105 ms
64 bytes from 10.0.0.2: seq=1 ttl=64 time=0.100 ms
64 bytes from 10.0.0.2: seq=2 ttl=64 time=0.070 ms
^C
--- nginx ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.070/0.091/0.105 ms
/ # wget nginx
Connecting to nginx (10.0.0.2:80)
index.html           100% |********************************************************************************************************************************************************************************|   612  0:00:00 ETA
/ # 

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;剔除集群中服务器&#34;&gt;剔除集群中服务器&lt;/h2&gt;
&lt;p&gt;如果想要移除集群中某一个服务器, 首先需要判断它是否是一台管理节点, 如果是管理节点, 首先需要将其降级为普通节点, 然后再执行删除命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;降级
docker node demote 节点的id

删除
docker node rm 节点的id
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;stack&#34;&gt;stack&lt;/h1&gt;
&lt;p&gt;docker 为集群部署的一系列操作提供了 &lt;code&gt;stack&lt;/code&gt; 子命令, 方便一次操作.&lt;br&gt;
首先我们需要准备一个 yml 文件, 里面包含了对服务的配置, 就和 &lt;code&gt;compose&lt;/code&gt; 文件一样, 不过比 compose文件多了一些对服务资源的限制.&lt;br&gt;
我在这里提供一个文件. &lt;code&gt;external: true&lt;/code&gt;表示该网络已存在的意思.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &amp;quot;3.4&amp;quot;
services:
  alpine:
    image: alpine
    command:
      - &amp;quot;ping&amp;quot;
      - &amp;quot;www.bing.com&amp;quot;
    networks:
      - local-overlay
    deploy:
      endpoint_mode: dnsrr
      replicas: 2
      restart_policy:
        condition: on-faliure
      resources:
        limits:
          cpus: &amp;quot;0.1&amp;quot;
          memory: &amp;quot;50M&amp;quot;
    depends_on:
      - nginx
  nginx:
    image: nginx
    networks:
      - local-overlay
    ports:
      - 9967:80

networks:
  local-overlay:
    external: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;stack deploy&lt;/code&gt;命令对服务进行部署. 通过 &lt;code&gt;stack service 服务名&lt;/code&gt; 查看服务详情, 通过 &lt;code&gt;stack ls&lt;/code&gt; 查看有多少个服务.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~/yzt_test_folder$ docker stack deploy -c service.yml test
Creating service test_alpine
Creating service test_nginx

n-tech-admin@server01:~/yzt_test_folder$ docker stack ls
NAME                SERVICES            ORCHESTRATOR
test                2                   Swarm

n-tech-admin@server01:~/yzt_test_folder$ docker stack services test 
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
3vqmi2loytn6        test_alpine         replicated          2/2                 alpine:latest       
wp7qiu0nbfol        test_nginx          replicated          1/1                 nginx:latest        *:9967-&amp;gt;80/tcp

n-tech-admin@server01:~/yzt_test_folder$ docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
3vqmi2loytn6        test_alpine         replicated          2/2                 alpine:latest       
wp7qiu0nbfol        test_nginx          replicated          1/1                 nginx:latest        *:9967-&amp;gt;80/tcp

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;网络模式&#34;&gt;网络模式&lt;/h1&gt;
&lt;p&gt;docker 集群模式下默认使用 &lt;code&gt;vip&lt;/code&gt; 模式, 可以显示的指定使用 &lt;code&gt;dnsrr&lt;/code&gt;模式. 如在 stack 下, 可以在 deploy 子节点指定 &lt;code&gt;endpoint_mode: dnsrr&lt;/code&gt; 来修改网络模式.&lt;/p&gt;
&lt;p&gt;vip: vip模式中每个服务都有一个固定的ip&lt;br&gt;
dnsrr: dnsrr模式是没有固定ip的, 通过dns服务解析&lt;/p&gt;
&lt;p&gt;查看服务的模式可以通过 &lt;code&gt;docker service inspect 服务名&lt;/code&gt;, 然后找到 &lt;code&gt;EndpointSpec&lt;/code&gt;节点即可查看.&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;通篇说了很多, 总结下来也就那么几个命令.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker swarm
docker network
docker service
docker node 
docker stack
&lt;/code&gt;&lt;/pre&gt;
">docker swarm编排工具</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/fu-hao-du-fa/"" data-c="
          &lt;p&gt;作为技术人员, 平时常有和同事, 朋友讲述的时候, 针对平时常用的符号, 做一个汇总. 以免贻笑大方.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中划线&lt;br&gt;
写法: -&lt;br&gt;
中文: 中划线&lt;br&gt;
英文: dash&lt;br&gt;
英文读法: &lt;a href=&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=zh-CN&amp;amp;text=dash&#34;&gt;dash-Google Translate&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下划线&lt;br&gt;
写法: _&lt;br&gt;
中文: 中划线&lt;br&gt;
英文: under score&lt;br&gt;
英文读法: &lt;a href=&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=zh-CN&amp;amp;text=under%20score&#34;&gt;under score-Google Translate&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反斜杠&lt;br&gt;
写法: \ &lt;br&gt;
中文: 反斜杠&lt;br&gt;
英文: Backslash&lt;br&gt;
英文读音: &lt;a href=&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=zh-CN&amp;amp;text=backslash&#34;&gt;Backslash-Google Translate&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;斜杠&lt;br&gt;
写法: /&lt;br&gt;
中文: 斜杠&lt;br&gt;
英文: slash&lt;br&gt;
英文读音: &lt;a href=&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=en&amp;amp;text=slash&#34;&gt;slash-Google Translate&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;英文逗号&lt;br&gt;
写法: .&lt;br&gt;
中文: 逗号&lt;br&gt;
英文: comma&lt;br&gt;
英文读音: &lt;a href=&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=en&amp;amp;tl=en&amp;amp;text=comma&#34;&gt;comma-Google Translate&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;英文句号&lt;br&gt;
写法: .&lt;br&gt;
中文: 句号&lt;br&gt;
英文: dot&lt;br&gt;
英文读音: &lt;a href=&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=en&amp;amp;text=dot&#34;&gt;dot-Google Translate&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如有不对之处, 烦请指正&lt;/p&gt;
">符号读法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/chrome-webview-diao-shi/"" data-c="
          &lt;p&gt;公司一个小demo将vue写的代码打包成apk, 运行在Android上面, apk实则是一个依赖&lt;code&gt;webview&lt;/code&gt;的网页, 所以能够通过和PC端的chrome进行远程调试. 有了PC端的调试, debug会更方便. 下面介绍如何进行操作.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开手机端webview调试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;WebView.setWebContentsDebuggingEnabled(true);　&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;访问chrome的&lt;code&gt;chrome://inspect/#devices&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;http://chrome://inspect/#devices&#34;&gt;chrome://inspect/#devices&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;选择要调试的应用. 点击&lt;code&gt;inspect&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/04/t88slb1p0ajl1ovqo8v86k3da7.jpg&#34; alt=&#34;调试&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来就可以开开心心的调试运行在Android webview实现的apk了.&lt;/p&gt;
">chrome webview调试</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-boot-cors/"" data-c="
          &lt;h1 id=&#34;问题的起因&#34;&gt;问题的起因&lt;/h1&gt;
&lt;p&gt;今天公司的一个小项目需要跑到Android上面，本身是通过token鉴权的，所以移植比较简单。但是在处理 跨域 问题的时候着实给踩了个大坑。&lt;br&gt;
网上说的重写 &lt;code&gt;addCorsMapping&lt;/code&gt;等方法在一般处理上没有大问题. 但是在统一异常拦截器上面有很大的问题.&lt;br&gt;
spring提供的跨域, 只是在响应是&lt;code&gt;Controller&lt;/code&gt;时生效, 而统一异常拦截器&lt;code&gt;ControllerAdvice&lt;/code&gt;是通过AOP处理的. 并且我们在很多时候需要通过自己的拦截器, 过滤器处理内容. 所以spring提供的跨域封装, 并不能很好的解决问题. 最后通过自己编写Filter解决了这个问题. 在此做一个小记录, 以后遇到需要跨域的问题时,直接使用此方法, 比使用spring封装的内容要好很多.&lt;/p&gt;
&lt;p&gt;顺便提一下, 关于跨域时 &lt;code&gt;PUT&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;两个复杂请求的参数处理, 由于这两个请求在发起之前都会发起一个  &lt;code&gt;预请求&lt;/code&gt;, 具体可以看一下 &lt;a href=&#34;https://segmentfault.com/q/1010000007442799&#34;&gt;这篇博客&lt;/a&gt;, 如果不做处理的话, PUT请求将得不到参数. 具体处理方法也在下面代码区给出.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;:&lt;br&gt;
是我太年轻, 统一异常拦截器还是没有办法正常的返回, 最后在统一异常拦截器的response上面加上了Origin的设置. 下面展示代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@CrossOrigin
response.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;代码&#34;&gt;代码&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;@WebFilter
public class CorsFilter extends OncePerRequestFilter {
    private static final String ORIGIN = &amp;quot;Origin&amp;quot;;
    private static final String HEADERS = &amp;quot;Access-Control-Request-Headers&amp;quot;;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        // 获取请求头中的 &#39;Origin&#39; 信息
        String origin = request.getHeader(ORIGIN);
        // 获取请求头中的 &#39;header&#39; 信息
        String headers = request.getHeader(HEADERS);

        /**
         * 1.支持任何域名跨域访问
         * 当 &#39;Access-Control-Allow-Origin&#39; 设置为 &#39;*&#39; 时，不能解决带 Cookie 的跨域
         */
        if (!StringUtils.isEmpty(origin)) {
            response.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;, origin);
        }

        /**
         * 2.支持自定义请求头的跨域
         */
        if (!StringUtils.isEmpty(headers)) {
            response.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;, headers);
        }

        // 3.设置支持带 Cookie 的跨域请求
        response.setHeader(&amp;quot;Access-Control-Allow-Credentials&amp;quot;, &amp;quot;true&amp;quot;);
        // 4.设置允许跨域请求的方法形式 &#39;GET&#39;、&#39;DELETE&#39; 等
        response.setHeader(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;*&amp;quot;);
        // 5.设置非简单请求的预检命令缓存时间，单位 &#39;s&#39;
        response.setHeader(&amp;quot;Access-Control-Max-Age&amp;quot;, &amp;quot;1728000&amp;quot;);

        if (&amp;quot;OPTIONS&amp;quot;.equals(request.getMethod())) {
            response.setStatus(HttpServletResponse.SC_OK);
        } else {
            filterChain.doFilter(request, response);
        }

    }
}



针对PUT请求参数的处理
@Component
public class PutFilter extends HttpPutFormContentFilter {

}
&lt;/code&gt;&lt;/pre&gt;
">Spring Boot Cors</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/tong-yong-de-redis-xu-lie-hua/"" data-c="
          &lt;p&gt;在使用springboot-data-redis的时候, 需要自定义序列化和反序列化. 由于经常使用, 所以写在这里留作备用. 序列化方法是从&lt;a href=&#34;https://blog.csdn.net/moshowgame/article/details/83246363&#34;&gt;CSDN博客&lt;/a&gt;上面找到的.&lt;/p&gt;
&lt;p&gt;都是一些很简单的东西, 所以在这里就只做了代码记录, 没有太多文字性的东西.&lt;/p&gt;
&lt;h1 id=&#34;引入依赖&#34;&gt;引入依赖&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.57&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;自定义序列化&#34;&gt;自定义序列化&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;/**
 * FastJson2JsonRedisSerializer
 *  Redis使用FastJson序列化
 *  by zhengkai.blog.csdn.net
 *  https://blog.csdn.net/moshowgame/article/details/83246363
 */
public class FastJson2JsonRedisSerializer&amp;lt;T&amp;gt; implements RedisSerializer&amp;lt;T&amp;gt; {

    private ObjectMapper objectMapper = new ObjectMapper();
    private static final Charset DEFAULT_CHARSET = Charset.forName(&amp;quot;UTF-8&amp;quot;);

    private Class&amp;lt;T&amp;gt; clazz;

    static {
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        //如果遇到反序列化autoType is not support错误，请添加并修改一下包名到bean文件路径
        // ParserConfig.getGlobalInstance().addAccept(&amp;quot;com.xxxxx.xxx&amp;quot;);
    }

    public FastJson2JsonRedisSerializer(Class&amp;lt;T&amp;gt; clazz) {
        super();
        this.clazz = clazz;
    }

    @Override
    public byte[] serialize(T t) throws SerializationException {
        if (t == null) {
            return new byte[0];
        }
        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);
    }

    @Override
    public T deserialize(byte[] bytes) throws SerializationException {
        if (bytes == null || bytes.length &amp;lt;= 0) {
            return null;
        }
        String str = new String(bytes, DEFAULT_CHARSET);

        return JSON.parseObject(str, clazz);
    }
    public void setObjectMapper(ObjectMapper objectMapper) {
        Assert.notNull(objectMapper, &amp;quot;&#39;objectMapper&#39; must not be null&amp;quot;);
        this.objectMapper = objectMapper;
    }

    protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz) {
        return TypeFactory.defaultInstance().constructType(clazz);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;设置到redis中&#34;&gt;设置到redis中&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);

        //使用FastJson2JsonRedisSerializer来序列化和反序列化redis的value值 by zhengkai
        FastJson2JsonRedisSerializer serializer = new FastJson2JsonRedisSerializer(Object.class);

        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(mapper);

        template.setValueSerializer(serializer);
        //使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">通用的redis序列化</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/win-wen-jian-zhan-yong/"" data-c="
          &lt;p&gt;Windows显示文件占用, 贼烦. 原因是在文件夹内运行了adb命令.&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ctrl+Shift+Esc 打开任务管理器.&lt;/li&gt;
&lt;li&gt;选择&lt;code&gt;性能&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;点击最下方的&lt;code&gt;打开资源监视器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择&lt;code&gt;CPU&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;关联的句柄&lt;/code&gt;中搜索相关文件夹. 找到后右键&lt;code&gt;结束进程&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;附图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/04/48j4m621rghe0ocdhndc8otgle.jpg&#34; alt=&#34;第2,3步&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/04/0d0t2ubmk4hc9pgu4vt6hnll99.jpg&#34; alt=&#34;第4,5步&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">win 文件占用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/da-jian-docker-si-you-cang-ku/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前就有在公司内网搭建过私有docker仓库，这次接着看这个课程。 将搭建docker仓库的过程记录下来。&lt;/p&gt;
&lt;h1 id=&#34;下载镜像&#34;&gt;下载镜像&lt;/h1&gt;
&lt;p&gt;首选， 我们从 [docker仓库官网][1] 将docker官方提供的私有仓库的镜像找到, 然后通过 &lt;code&gt;pull&lt;/code&gt; 命令下载下来。&lt;br&gt;
在仓库首页搜索 &lt;code&gt;regisrty&lt;/code&gt;，第一个就是官方提供的镜像。 找到 tag:2 ，将其复制到命令行界面。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker pull registry:2
2: Pulling from library/registry
c87736221ed0: Pull complete
1cc8e0bb44df: Pull complete
54d33bcb37f5: Pull complete
e8afc091c171: Pull complete
b4541f6d3db6: Pull complete
Digest: sha256:3b00e5438ebd8835bcfa7bf5246445a6b57b9a50473e89c02ecc8e575be3ebb5
Status: Downloaded newer image for registry:2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;启动镜像&#34;&gt;启动镜像&lt;/h1&gt;
&lt;p&gt;完成镜像的下载之后, 肯定是要运行起来, docker官方给我们提供了启动命令. 通过运行下面的命令, 我们就能够看到私有仓库是运行起来了.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -d -p 5000:5000 --restart always --name registry registry:2
dc8e14fcb2028bd1c354750a4647c139ac62d0662651bd3c974cbfd4667a9577


$ docker ps|grep registry
dc8e14fcb202        registry:2                   &amp;quot;/entrypoint.sh /etc…&amp;quot;   47 seconds ago      Up 47 seconds       0.0.0.0:5000-&amp;gt;5000/tcp   registry
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;推送镜像&#34;&gt;推送镜像&lt;/h1&gt;
&lt;p&gt;完成上面的操作，一个基本的本地私有的镜像仓库就算搭建完成了， 我们可以通过推送一个镜像到仓库中来测试是否成功。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先, 我们查看本地镜像, 找一个较小的alpine版本的jre试一下.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
user-edge-service     latest              8a4343ae292b        22 minutes ago      472MB
user-service          latest              5255cb130cfc        22 minutes ago      463MB
message-service       latest              e8a0aa292277        About an hour ago   932MB
course-edge-service   latest              93cdb20a805f        5 hours ago         470MB
course-service        latest              0347264048f7        6 hours ago         468MB
api-gateway-zuul      latest              66cde019cbaf        6 hours ago         476MB
python-base           latest              018c9430d5e1        22 hours ago        932MB
openjdk               8-jre-alpine3.9     ce8477c7d086        2 days ago          84.9MB
openjdk               8-jre               d55d64383c12        2 weeks ago         443MB
python                3.6                 2bb3204ab1d1        2 weeks ago         924MB
registry              2                   f32a97de94e1        5 weeks ago         25.8MB

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;docker tag&lt;/code&gt; 命令我们将本地的openjdk重新打包成 &lt;code&gt;localhost:5000/openjdk:8-jre-alpine3.9&lt;/code&gt; 镜像. 然后查看我们刚才打包的镜像.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ docker tag openjdk:8-jre-alpine3.9 localhost:5000/openjdk:8-jre-alpine3.9

$ docker images|grep localhost:5000
localhost:5000/openjdk   8-jre-alpine3.9     ce8477c7d086        2 days ago          84.9MB

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;最后, 通过 &lt;code&gt;docker push&lt;/code&gt;命令将我们刚才打包的镜像上传至本地仓库.  然后通过 &lt;code&gt;docker pull&lt;/code&gt;命令来验证是否上传成功.&lt;br&gt;
通过最后打印的 &lt;font color=&#39;red&#39;&gt;Status: Image is up to date &lt;/font&gt; 可以看出我们的镜像已经成功上传并且能够成功下载下来了.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ docker push localhost:5000/openjdk:8-jre-alpine3.9
The push refers to repository [localhost:5000/openjdk]
aae5c057d1b6: Pushed
dee6aef5c2b6: Pushed
a464c54f93a9: Pushed
8-jre-alpine3.9: digest: sha256:922d65ba63c3cccb58c0a03e8bdfa86161c60c2aeb33db85d952d99c54f9662b size: 947

$ docker pull localhost:5000/openjdk:8-jre-alpine3.9
8-jre-alpine3.9: Pulling from openjdk
Digest: sha256:922d65ba63c3cccb58c0a03e8bdfa86161c60c2aeb33db85d952d99c54f9662b
Status: Image is up to date for localhost:5000/openjdk:8-jre-alpine3.9
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;仓库页面&#34;&gt;仓库页面&lt;/h1&gt;
&lt;p&gt;有了上面的操作，我们这只算是完成了一个最基本的仓库功能。 它还没有页面。 在操作上还不是特别符合私有仓库的易用性。所以开源界有很多对 docker registry 做了界面开发， 其中非常不错的一个就是 VMware的 [harbor][2], 不过目前已经由 [goharbor][3] 组织负责维护了. 可以通过访问前面的链接, 下载 [Harbor offline installer][4] 版本. 下载速度还是非常不错的&lt;/p&gt;
&lt;p&gt;下载完成后对压缩包进行解压. 然后进入harbor的目录修改它的配置文件 &lt;code&gt;harbor.cfg&lt;/code&gt;, 将 &lt;code&gt;hostname&lt;/code&gt; 修改为你想要配置的地址.其它参数上面都加上了注释, 可以具体去看.&lt;br&gt;
下图我展示了我的配置.&lt;/p&gt;
&lt;p&gt;![harbor.cfg配置][5]&lt;/p&gt;
&lt;h2 id=&#34;安装harbor&#34;&gt;安装harbor&lt;/h2&gt;
&lt;p&gt;&lt;font color=&#39;#EE3D11&#39;&gt;[Warning] 用Linux安装&lt;/font&gt;，在安装过程中会踩无数的坑。我再次记录几个。&lt;/p&gt;
&lt;p&gt;首先我们将 docker-compose.yml 文件中的所有 &lt;code&gt;volumes&lt;/code&gt; 目录前面都加上 &lt;strong&gt;.&lt;/strong&gt;(当前目录), 防止文件乱窜，然后修改 &lt;code&gt;harbor.cfg&lt;/code&gt; 的 &lt;code&gt;secretkey_path=./data&lt;/code&gt;（设置当前目录）&lt;br&gt;
接下来运行目录下面的 &lt;code&gt;install.sh&lt;/code&gt; 文件. 你会收到各种错误。。。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误一&lt;br&gt;
你可能会收到下面的提示：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;OSError: [Errno 1] Operation not permitted: &#39;/data/secretkey&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决方法是将当前目录下面的 &lt;code&gt;data&lt;/code&gt; 目录 &lt;code&gt;chmod 777 data -R&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误二&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[Step 2]: preparing environment ...
loaded secret from file: ./data/secretkey
Traceback (most recent call last):
  File &amp;quot;./prepare&amp;quot;, line 220, in &amp;lt;module&amp;gt;
    secret_key = get_secret_key(secretkey_path)
  File &amp;quot;./prepare&amp;quot;, line 85, in get_secret_key
    secret_key = _get_secret(path, &amp;quot;secretkey&amp;quot;) 
  File &amp;quot;./prepare&amp;quot;, line 100, in _get_secret
    mark_file(key_file)
  File &amp;quot;./prepare&amp;quot;, line 82, in mark_file
    os.chown(path, uid, gid)
OSError: [Errno 1] Operation not permitted: &#39;./data/secretkey&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改了权限之后还报这个错误的话, 用 sudo 运行 install命令, 基本上问题就不打了. 看到下面的信息, 就说明艰难的过程完成了.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:heavy_check_mark: ----Harbor has been installed and started successfully.----

Now you should be able to visit the admin portal at http://harbor.mooc.com:10001. 
For more details, please visit https://github.com/goharbor/harbor .

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看harbor界面&#34;&gt;查看Harbor界面&lt;/h2&gt;
&lt;p&gt;完成上面的步骤, 我们就可以去访问Harbor的界面了. 默认用户名/密码: admin/Harbor12345&lt;/p&gt;
&lt;h3 id=&#34;创建用户&#34;&gt;创建用户&lt;/h3&gt;
&lt;p&gt;首先, 我们尝试着创建一个用户. 如图:&lt;/p&gt;
&lt;p&gt;![创建用户][6]&lt;/p&gt;
&lt;h3 id=&#34;推送镜像-2&#34;&gt;推送镜像&lt;/h3&gt;
&lt;p&gt;然后, 我们通过对前面使用的openjdk再次打包, 对内容进行发布.推送到刚创建的harbor仓库中..&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker tag openjdk:8-jre-alpine3.9 harbor.mooc.com:800/micro-service/openjdk:8-jre-alpine3.9

$ docker push harbor.mooc.com:800/micro-service/openjdk:8-jre-alpine3.9
``

----------


  [1]: http://hub.docker.com
  [2]: https://github.com/goharbor/harbo
  [3]: https://github.com/goharbor
  [4]: https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.5.tgz
  [5]: http://blog.imyzt.top/upload/2019/04/ul8re7m8bmgodr71216uvlelvc.jpg
  [6]: http://imyzt.top/upload/2019/04/usm33su6nuj6voqufj0l76pkl9.jpg&lt;/code&gt;&lt;/pre&gt;
">搭建docker私有仓库</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/win-docker-toolbox-wen-ti/"" data-c="
          &lt;p&gt;今天在学习docker课程的时候, 按照老师的配置, 怎么都不能访问到 api-gateway-zuul上面docker-compose的8080端口. 后来通过网络上搜索, 发现&lt;a href=&#34;https://blog.csdn.net/qq_33212500/article/details/79412930&#34;&gt;这篇文章&lt;/a&gt;的描述, 因为我使用的是 Windows 的 Docker Toolbox, 是在win上面运行了一个linux. 所以不是能够直接 &lt;code&gt;127.0.0.1&lt;/code&gt; 访问得到的. 然后通过访问 &lt;code&gt;192.168.99.100&lt;/code&gt; 得到了内容&lt;/p&gt;
&lt;p&gt;&lt;code&gt;192.168.99.100&lt;/code&gt;的IP是通过&lt;code&gt;docker-machine ip default&lt;/code&gt;命令获取的&lt;/p&gt;
">win docker toolbox 问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/springboot-qi-dong-shu-ju-ku-cuo-wu/"" data-c="
          &lt;p&gt;最近在看慕课网上的&lt;code&gt;Docker+Kubernetes(k8s)微服务容器化实战&lt;/code&gt;, 在微服务搭建过程中, 由于老师的一些代码已经过去了一年多了, 很多内容都不适用于现在的版本了, 一路踩坑过来, 今天在redis上面踩了一个坑才走出来, 又踩了另一个MySQL的坑. 在此记录一下解决过程.&lt;/p&gt;
&lt;h1 id=&#34;错误详情&#34;&gt;错误详情&lt;/h1&gt;
&lt;p&gt;在下方的错误日志, 最后一行&lt;code&gt;SQLErrorCodesFactory&lt;/code&gt;抛出了一个异常, 异常的大致意思就是不知道数据库类型. 然后程序就停在这里了. 导致其他的微服务无法调用, 然后超时了.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  .   ____          _            __ _ _
 /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  &#39;  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v1.5.3.RELEASE)

2019-04-10 17:22:13.197  INFO 20916 --- [           main] top.imyzt.user.ServiceApplication        : Starting ServiceApplication on DESKTOP-O8GDJEI with PID 20916 (D:\dev\imyzt\micro-service\user-thrift-service\target\classes started by n-tech in D:\dev\imyzt\micro-service)
2019-04-10 17:22:13.201  INFO 20916 --- [           main] top.imyzt.user.ServiceApplication        : No active profile set, falling back to default profiles: default
2019-04-10 17:22:13.247  INFO 20916 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@71e9ebae: startup date [Wed Apr 10 17:22:13 CST 2019]; root of context hierarchy
2019-04-10 17:22:32.354  INFO 20916 --- [       Thread-4] o.s.b.f.xml.XmlBeanDefinitionReader      : Loading XML bean definitions from class path resource [org/springframework/jdbc/support/sql-error-codes.xml]
2019-04-10 17:22:32.410  INFO 20916 --- [       Thread-4] o.s.jdbc.support.SQLErrorCodesFactory    : SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase, Hana]

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;解决方法&#34;&gt;解决方法&lt;/h1&gt;
&lt;p&gt;通过Google, 出现此问题多为数据库字段和SQL或dao中的不一样造成的.&lt;br&gt;
原解答: &lt;a href=&#34;http://www.zhimengzhe.com/shujuku/Oracle/30519.html&#34;&gt;http://www.zhimengzhe.com/shujuku/Oracle/30519.html&lt;/a&gt;,   如果出现了此类问题, 先在数据库认真排查一下数据库字段是否一致.&lt;br&gt;
我在排查的过程中是因为我将 &lt;code&gt;TeacherDTO&lt;/code&gt; 对应 数据库&lt;code&gt;pe_teacher&lt;/code&gt;的 &lt;code&gt;stars&lt;/code&gt; 错写成了 &lt;code&gt;starts&lt;/code&gt;, 造成了数据库一直报错, 导致整个服务链路抛异常.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/04/65pldi4m2aijhoo2q98nrv02ff.jpg&#34; alt=&#34;成功后查询课程列表的结果&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">SpringBoot 启动数据库错误</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/lesslesswo-mei-you-shuo-hua-greatergreater/"" data-c="
          &lt;p&gt;纳粹杀共产党时，&lt;br&gt;
我没有出声&lt;br&gt;
——因为我不是共产党员；&lt;br&gt;
接着他们迫害犹太人，&lt;br&gt;
我没有出声&lt;br&gt;
——因为我不是犹太人；&lt;br&gt;
然后他们杀工会成员，&lt;br&gt;
我没有出声&lt;br&gt;
——因为我不是工会成员；&lt;br&gt;
后来他们迫害天主教徒，&lt;br&gt;
我没有出声&lt;br&gt;
——因为我是新教徒；&lt;br&gt;
最后当他们开始对付我的时候，&lt;br&gt;
已经没有人能站出来为我发声了&lt;/p&gt;
">《我没有说话》</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/win-chang-yong-ming-ling-ji/"" data-c="
          &lt;ol&gt;
&lt;li&gt;通过端口号找到进程号&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;评论区老哥说win上面没有&lt;code&gt;grep&lt;/code&gt;命令, 由于我用的是&lt;a href=&#34;https://cmder.net/&#34;&gt;Cmder&lt;/a&gt;是包含&lt;code&gt;grep&lt;/code&gt;命令的, 在win上面可以使用&lt;code&gt;findstr&lt;/code&gt;用来做内容过滤.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;netstat -aon|grep 端口号 
tasklist.exe | findstr 端口号 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;通过进程号杀掉进程&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;taskkill -PID 进程号 -F 
&lt;/code&gt;&lt;/pre&gt;
">win 常用命令集</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/sop/"" data-c="
          &lt;p&gt;修改 &lt;code&gt;System.out.println()&lt;/code&gt; 的输出内容到文件. (改变System.out的标准输出流)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ChangeOut {
    public static void main(String args[]) {
        try {
            System.setOut(new PrintStream(new FileOutputStream(&amp;quot;log.txt&amp;quot;)));
            System.out.println(&amp;quot;Now the output is redirected!&amp;quot;);
        } catch(Exception e) {}
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文章来源: &lt;a href=&#34;https://mp.weixin.qq.com/s/dEuOL9EwhM-fipDxz9KNnw&#34;&gt;码农每日一题&lt;/a&gt;&lt;/p&gt;
">SOP</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-jdbc-url/"" data-c="
          &lt;h1 id=&#34;driver-package&#34;&gt;driver package&lt;/h1&gt;
&lt;h2 id=&#34;mysql8&#34;&gt;MySQL8&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;com.mysql.cj.jdbc.Driver
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mysql5&#34;&gt;MySQL5&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;com.mysql.jdbc.Driver
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;jdbc-url&#34;&gt;JDBC URL&lt;/h1&gt;
&lt;h2 id=&#34;mysql8-2&#34;&gt;MySQL8&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;jdbc:mysql://localhost:3306/test?useSSL=false&amp;amp;serverTimezone=UTC
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mysql5-2&#34;&gt;MySQL5&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;jdbc:mysql://localhost:3306/test?user=root&amp;amp;password=&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&amp;amp;autoReconnect=true&amp;amp;failOverReadOnly=false
&lt;/code&gt;&lt;/pre&gt;
">MySQL JDBC URL</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/wei-fu-wu-kai-fa-wei-fu-wu-rong-qi-hua-shi-zhan-xi-lie-ke-cheng/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;本课程是 &lt;code&gt;docker+kuberneter微服务容器化实战&lt;/code&gt; 系列课程的学习笔记. 用于记录学习过程中遇到的一些问题.&lt;/p&gt;
&lt;h1 id=&#34;课程项目架构图&#34;&gt;课程项目架构图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/03/su23t24230h6dob41lslrn0jro.png&#34; alt=&#34;课程项目架构图1.0&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;thrift&#34;&gt;thrift&lt;/h1&gt;
&lt;p&gt;微服务开发过程中必定牵扯的就是服务调用, 课程中使用了 &lt;code&gt;thrift&lt;/code&gt; 和 &lt;code&gt;dubbo&lt;/code&gt; 作服务调用.&lt;br&gt;
thrift的主要优势就是他是语言无关的, 可以在多语言系统中使用.下面通过课程的讲解, 简单记录一下thrift的使用.&lt;/p&gt;
&lt;h2 id=&#34;thrift的安装&#34;&gt;thrift的安装&lt;/h2&gt;
&lt;p&gt;在apache官网&lt;a href=&#34;http://thrift.apache.org/&#34;&gt;下载thrift&lt;/a&gt;, 将thrift配置到Path变量中.&lt;br&gt;
在命令行输入 &lt;code&gt;thrift --version&lt;/code&gt;, 如果看到版本信息, 则安装成功.&lt;/p&gt;
&lt;h2 id=&#34;thrift的简单使用&#34;&gt;thrift的简单使用.&lt;/h2&gt;
&lt;p&gt;thrift的使用也非常简单,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先我们定义好接口.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;echo &#39;开始生成&#39;

thrift --gen py -out ../ message.thrift

thrift --gen java -out ../../message-thrift-service-api/src/main/java message.thrift
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;然后通过运行这个脚本, 就可以得到对应的语言版本的工具类.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;问题解决&#34;&gt;问题解决&lt;/h1&gt;
&lt;p&gt;架构图中的&lt;code&gt;信息服务&lt;/code&gt;使用python开发, 由于之前没怎么接触过py, 开发过程中遇到了一些问题.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入包报错, 需要通过pip安装系统需要的thrift包.&lt;br&gt;
&lt;code&gt;python -m pip install thrift&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/03/2leg3ss9eajniq7tofsi9hln12.jpg&#34; alt=&#34;报错&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
">微服务开发(微服务容器化实战系列课程)</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/postconstruct-predestory/"" data-c="
          &lt;p&gt;原文地址:&lt;a href=&#34;https://www.cnblogs.com/landiljy/p/5764515.html&#34;&gt;https://www.cnblogs.com/landiljy/p/5764515.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;@PostConstruct说明&lt;/p&gt;
&lt;p&gt;被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的init()方法。被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。&lt;/p&gt;
&lt;p&gt;@PreDestroy说明&lt;/p&gt;
&lt;p&gt;被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前。&lt;/p&gt;
&lt;p&gt;执行顺序: Constructor &amp;gt;&amp;gt; @Autowired &amp;gt;&amp;gt; @PostConstruct&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/005SWfHCgy1g1amxq5d5lj306c0d0glj.jpg&#34; alt=&#34;执行顺序&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图源地址: &lt;a href=&#34;https://www.jianshu.com/p/98cf7d8b9ec3&#34;&gt;https://www.jianshu.com/p/98cf7d8b9ec3&lt;/a&gt;&lt;/p&gt;
">@PostConstruct, @PreDestory</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-autowired-yu-static-method/"" data-c="
          &lt;p&gt;原文地址: &lt;a href=&#34;https://www.cnblogs.com/chenfeng1122/p/6270217.html&#34;&gt;https://www.cnblogs.com/chenfeng1122/p/6270217.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;@Autowired注解和静态方法&lt;/p&gt;
&lt;p&gt;一、业务场景&lt;/p&gt;
&lt;p&gt;spring框架应用中有些静态方法需要依赖被容器管理的类，就像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class Test {
    
    @Autowired
    private static UserService userService;
    
    public static void test() {
        userService.test();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一定会报java.lang.NullPointerException: null异常。&lt;/p&gt;
&lt;p&gt;二、原理剖析&lt;/p&gt;
&lt;p&gt;&lt;font color=&#39;red&#39;&gt;静态变量、类变量不是对象的属性，而是一个类的属性，所以静态方法是属于类（class）的，普通方法才是属于实体对象（也就是New出来的对象）的，spring注入是在容器中实例化对象，所以不能使用静态方法。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;而使用静态变量、类变量扩大了静态方法的使用范围。静态方法在spring是不推荐使用的，依赖注入的主要目的,是让容器去产生一个对象的实例,然后在整个生命周期中使用他们，同时也让testing工作更加容易。&lt;/p&gt;
&lt;p&gt;一旦你使用静态方法,就不再需要去产生这个类的实例,这会让testing变得更加困难，同时你也不能为一个给定的类，依靠注入方式去产生多个具有不同的依赖环境的实例，这种static field是隐含共享的，并且是一种global全局状态，spring同样不推荐这样去做。&lt;/p&gt;
&lt;p&gt;三、解决方法&lt;/p&gt;
&lt;p&gt;1、将@Autowire加到构造方法上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class Test {
    
    private static UserService userService;
    
    @Autowired
    public Test(UserService userService) {
        Test.userService = userService;
    }
    
    public static void test() {
        userService.test();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、用@PostConstruct注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class Test {
    
    private static UserService userService;
    
    @Autowired
    private UserService userService2;
    
    @PostConstruct
    public void beforeInit() {
        userService = userService2;
    }
    
    public static void test() {
        userService.test();
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Spring @Autowired与static method</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-zi-ding-yi-can-shu-jie-xi/"" data-c="
          &lt;h1 id=&#34;缘起&#34;&gt;缘起&lt;/h1&gt;
&lt;p&gt;我们在使用Spring的时候，通常会直接在 Controller 的 handler（自定义的接口）中填写 &lt;code&gt;HttpServletRequest&lt;/code&gt;, &lt;code&gt;HttpServletResponse&lt;/code&gt;, &lt;code&gt;Model&lt;/code&gt;, &lt;code&gt;HttpSession&lt;/code&gt;，并且在方法中使用时对象是可以使用的。&lt;br&gt;
之前我一直好奇， 这是什么原理。通过这次在学习慕课网的&lt;a href=&#34;https://coding.imooc.com/class/chapter/168.html&#34;&gt;Java秒杀系统方案优化 高性能高并发实战&lt;/a&gt; 时，老师的讲解是我终于不是只会用，不知其如何实现了。&lt;/p&gt;
&lt;h1 id=&#34;原理&#34;&gt;原理&lt;/h1&gt;
&lt;p&gt;Spring给我们使用者预留了一个接口 &lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt;，通过实现这个接口， 覆盖它的 &lt;code&gt;supportsParameter&lt;/code&gt; 和 &lt;code&gt;resolveArgument&lt;/code&gt; 方法, 我们就可以将自己想要的对象在方法入参处自动注入了. Spring官方的名称叫做 &lt;strong&gt;自定义参数解析&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;在学习课程的过程中, 我们很多的方法都需要一个 &lt;code&gt;MiaoshaUser&lt;/code&gt; 对象, 下面我们结合实际需求, 通过代码展示的方式一步一步实现这个看起来很酷的功能.&lt;/p&gt;
&lt;h1 id=&#34;给我也整一个&#34;&gt;给我也整一个&lt;/h1&gt;
&lt;h2 id=&#34;第一步&#34;&gt;第一步&lt;/h2&gt;
&lt;p&gt;首先我们编写一个 &lt;code&gt;UserArgumentResolver&lt;/code&gt; 类, 使其实现 &lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt; 接口. 并且通过 &lt;code&gt;@Component&lt;/code&gt; 注解将它标记为Spring管理的Bean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/3/9 16:53
 * @description 实现此方法, 将自动对方法入参包含 {@link MiaoshaUser} 的对象的进行注入
 */
@Component
public class UserArgumentResolver implements HandlerMethodArgumentResolver {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第二步&#34;&gt;第二步&lt;/h2&gt;
&lt;p&gt;我们需要覆盖它的两个方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/3/9 16:53
 * @description 实现此方法, 将自动对方法入参包含 {@link MiaoshaUser} 的对象的进行注入
 */
@Component
public class UserArgumentResolver implements HandlerMethodArgumentResolver {

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        Class &amp;lt;?&amp;gt; parameterType = parameter.getParameterType();
        return parameterType == MiaoshaUser.class;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter,
                                  ModelAndViewContainer mavContainer,
                                  NativeWebRequest webRequest,
                                  WebDataBinderFactory binderFactory) {
        return UserContext.getUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;supportsparameter&#34;&gt;supportsParameter()&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;supportsParameter()&lt;/code&gt; 方法中判断请求参数是否被 &lt;code&gt;HandlerMethodArgumentResolver &lt;/code&gt; 支持, 它的判断依据非常多, 具体可以查看 &lt;code&gt;org.springframework.core.MethodParameter&lt;/code&gt; 的源代码找到合适自己业务的匹配方法. 我这里通过 &lt;code&gt;getParameterType()&lt;/code&gt; 方法获取了参数类型, 只要是参数类型是 &lt;code&gt;MiaoshaUser.class&lt;/code&gt; 的就表示我编写的 &lt;code&gt;UserArgumentResolver &lt;/code&gt; 解析类支持处理该方法入参. 下面开始下一个具体处理方法.&lt;/p&gt;
&lt;h2 id=&#34;resolveargument&#34;&gt;resolveArgument(...)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;resolveArgument(...)&lt;/code&gt; 方法及自定义参数解析的核心处理方法. Spring通过调用该方法将参数值注入到上面 &lt;code&gt;supportsParameter()&lt;/code&gt; 支持的方法入参上面去.&lt;br&gt;
我这里的处理方法比较简单, 因为我的用户信息在上一步的拦截器中已经保存在 &lt;code&gt;UserContext&lt;/code&gt; 用户上下文信息中. 所以只需要 &lt;code&gt;getUser()&lt;/code&gt; 即可获取用户信息.&lt;/p&gt;
&lt;p&gt;在这里备注一下, 我们可以通过 &lt;code&gt;webRequest&lt;/code&gt; 获取到当前请求的Request和Response信息. 代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;通过学习慕课上面的这个项目, 对于我这种没有接触过互联网项目的人来说, 是一个互联网开发扫盲. 里面的很多东西还是非常不错的. 在学习这个项目的过程中. 写了一些小笔记, 不在于实现, 而是一些思路. 项目地址: &lt;a href=&#34;https://github.com/imyzt/imooc_miaosha&#34;&gt;github&lt;/a&gt;&lt;/p&gt;
">Spring 自定义参数解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-boot-20-wu-fa-zhao-dao-springwebcontext/"" data-c="
          &lt;p&gt;1.0+版本是有的. 在2.0+版本去除了. 官方&lt;a href=&#34;https://github.com/thymeleaf/thymeleaf/issues/420&#34;&gt;issues&lt;/a&gt;给出了原因, 是为了优化依赖结构.区分边界.&lt;/p&gt;
&lt;p&gt;可通过 &lt;code&gt;org.thymeleaf.context.WebContext&lt;/code&gt; 方法得到同样的结果.&lt;/p&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://blog.csdn.net/wilsonsong1024/article/details/81535860&#34;&gt;https://blog.csdn.net/wilsonsong1024/article/details/81535860#2评论&lt;/a&gt;&lt;/p&gt;
">spring boot 2.0+ 无法找到SpringWebContext</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/redis-bing-fa-ce-shi-gong-ju-shi-yong/"" data-c="
          &lt;h1 id=&#34;简单测试&#34;&gt;简单测试&lt;/h1&gt;
&lt;p&gt;redis自带了并发测试工具 &lt;code&gt;redis-benchmark&lt;/code&gt;, 只需要携带几个简单的参数就可以完成redis的压力测试.&lt;/p&gt;
&lt;h2 id=&#34;并发测试&#34;&gt;并发测试&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;redis-benchmark.exe -h 127.0.0.1 -p 6379 -c 100 -n 100000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令意思是使用 100 的并发,发起 10w 次请求&lt;/p&gt;
&lt;h3 id=&#34;结果分析&#34;&gt;结果分析&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;====== GET ======                           
  100000 requests completed in 0.98 seconds 
  100 parallel clients                      
  3 bytes payload                           
  keep alive: 1                             
                                            
60.40% &amp;lt;= 1 milliseconds                    
99.66% &amp;lt;= 2 milliseconds                    
99.88% &amp;lt;= 3 milliseconds                    
99.99% &amp;lt;= 4 milliseconds                    
100.00% &amp;lt;= 4 milliseconds                   
102249.49 requests per second               
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如上面的就是执行了 &lt;code&gt;get&lt;/code&gt; 命令, 10w次请求在0.98s 执行完毕. 使用了100个客户端, 每次使用了 3个字节负载&lt;br&gt;
其中 60.40% 在1ms 执行完毕.....&lt;/p&gt;
&lt;h2 id=&#34;大数据测试&#34;&gt;大数据测试&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;redis-benchmark.exe -h 127.0.0.1 -p 6379 -q -d 200
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令的意思是 一次数据包200字节, 结果做简单输出&lt;/p&gt;
&lt;h3 id=&#34;结果分析-2&#34;&gt;结果分析&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;PING_INLINE: 104821.80 requests per second
PING_BULK: 113895.21 requests per second
SET: 102459.02 requests per second
GET: 110253.59 requests per second
INCR: 110011.00 requests per second
LPUSH: 91996.32 requests per second
RPUSH: 94786.73 requests per second
LPOP: 94428.70 requests per second
RPOP: 93984.96 requests per second
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;SET: 102459.02 requests per second&lt;/code&gt; 表示每秒执行了10w+次请求&lt;/p&gt;
&lt;h2 id=&#34;部分命令测试&#34;&gt;部分命令测试&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;redis-benchmark.exe -h 127.0.0.1 -p 6379 -t set,get -q -n 100000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令的意思是对 &lt;code&gt;set,get&lt;/code&gt; 两个命令做 10w 次请求测试, 结果做简单输出&lt;/p&gt;
&lt;h3 id=&#34;结果分析-3&#34;&gt;结果分析&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;SET: 97656.24 requests per second
GET: 108813.92 requests per second
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;GET: 108813.92 requests per second&lt;/code&gt; 表示每秒执行了10w+次 &lt;code&gt;get&lt;/code&gt; 操作&lt;/p&gt;
&lt;h2 id=&#34;只测试某种命令&#34;&gt;只测试某种命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;redis-benchmark.exe -h 127.0.0.1 -p 6379 -n 100000 -q script load &amp;quot;redis.call(&#39;set&#39;,&#39;name&#39;,&#39;yzt&#39;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令的意思是只测试 &lt;code&gt;set name yzt&lt;/code&gt; 这一个命令的速度&lt;/p&gt;
&lt;h3 id=&#34;结果分析-4&#34;&gt;结果分析&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;script load redis.call(&#39;set&#39;,&#39;name&#39;,&#39;yzt&#39;): 82644.63 requests per second
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果表示当前命令一秒钟可以完成 8w+ 次操作&lt;/p&gt;
&lt;h1 id=&#34;参数详解&#34;&gt;参数详解&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;-h, -p： 不解释&lt;/li&gt;
&lt;li&gt;-c： 并发数&lt;/li&gt;
&lt;li&gt;-n： 请求数&lt;/li&gt;
&lt;li&gt;-q： 简单结果输出&lt;/li&gt;
&lt;li&gt;-d 100： 100字节的负载&lt;/li&gt;
&lt;li&gt;-t set：只测试set&lt;/li&gt;
&lt;li&gt;script load：只测试某个脚本&lt;/li&gt;
&lt;/ul&gt;
">redis并发测试工具使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-cha-xun-biao-suo-you-lie/"" data-c="
          &lt;p&gt;在有些时候， 我们写 &lt;code&gt;insert into &lt;/code&gt;语句的时候, 需要列出所有的列名, 但是又不想全部手敲, 可以通过下面的SQL语句得到表所有列名,并以逗号分隔.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT
	GROUP_CONCAT(COLUMN_NAME SEPARATOR &amp;quot;,&amp;quot;)
FROM
	information_schema. COLUMNS
WHERE
	TABLE_SCHEMA = &#39;db_name&#39;
AND TABLE_NAME = &#39;table_name&#39;
&lt;/code&gt;&lt;/pre&gt;
">mysql 查询表所有列</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/linux-shan-chu-wen-jian-pai-chu-xx-wen-jian-rm-fan-xiang-shan-chu/"" data-c="
          &lt;p&gt;rm删除除去指定文件的剩余所有文件  (rm 反向删除）&lt;/p&gt;
&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;
&lt;p&gt;使用 &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt; 三个命令完成本次操作.  假如需要删除 &lt;code&gt;/tmp/&lt;/code&gt;下面的所有文件, 排除掉 &lt;code&gt;ab.txt&lt;/code&gt; 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n-tech-admin@findface1:~/tmp$ ls
a  ab  abc  abcd  abc.txt  ab.txt  a.txt
n-tech-admin@findface1:~/tmp$ rm -rf `ls |grep -v &amp;quot;^ab.txt$&amp;quot;`
n-tech-admin@findface1:~/tmp$ ls
ab.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;解析&#34;&gt;解析&lt;/h1&gt;
&lt;p&gt;其中 grep 的 &lt;code&gt;-v&lt;/code&gt; 支持正则表达式, &lt;code&gt;^&lt;/code&gt; 开头 &lt;code&gt;$&lt;/code&gt; 结尾 用于唯一匹配, &lt;code&gt;-rf&lt;/code&gt; 后面的引号是 ` (Esc下面的按键) , 而不是单引号.&lt;br&gt;
正则稍加改造就可以指定当前目录下所有包含 &lt;code&gt;ab&lt;/code&gt; 字眼的文件或文件夹. 以此类推&lt;/p&gt;
">Linux 删除文件排除xx文件 (rm反向删除)</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/zhuan-zai-spring-cloud-de-ban-ben/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/xingzc/p/9414208.html&#34;&gt;https://www.cnblogs.com/xingzc/p/9414208.html&lt;/a&gt;&lt;/p&gt;
">[转载] Spring Cloud的版本</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-boot-jpa-query/"" data-c="
          &lt;p&gt;今天在写一个很简单的查询语句的时候，因为结果只需要大表中的三四个字段，项目又使用的jpa作为数据框架，所以考虑使用 &lt;code&gt;@Query&lt;/code&gt; 注解自定义SQL，然后遇到了一个报错， 始终没有解决。最终在&lt;a href=&#34;https://ask.csdn.net/questions/655530&#34;&gt;CSDN&lt;/a&gt;搜索到一个回答解决了这个小问题.&lt;br&gt;
在自定义SQL的时候，需要加上 &lt;code&gt;nativeQuery = true&lt;/code&gt; 属性，否则JPA将按照默认的  &lt;code&gt;hql&lt;/code&gt; 执行我们写的原生SQL。&lt;/p&gt;
&lt;p&gt;错误堆栈：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2019-03-08 15:36:45.601  INFO 14220 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate Core {5.3.7.Final}
2019-03-08 15:36:45.603  INFO 14220 --- [           main] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
2019-03-08 15:36:45.788  INFO 14220 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.4.Final}
2019-03-08 15:36:45.983  INFO 14220 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2019-03-08 15:36:46.112  INFO 14220 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2019-03-08 15:36:46.126  INFO 14220 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5InnoDBDialect
2019-03-08 15:36:47.085  INFO 14220 --- [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit &#39;default&#39;
2019-03-08 15:36:47.660  INFO 14220 --- [           main] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory
2019-03-08 15:36:47.722  WARN 14220 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;dataController&#39; defined in file [D:\dev\Ntech\data\target\classes\cn\anytec\data\controller\DataController.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;snapServiceImpl&#39;: Unsatisfied dependency expressed through field &#39;personRepository&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;personRepository&#39;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!
2019-03-08 15:36:47.724  INFO 14220 --- [           main] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &#39;default&#39;
2019-03-08 15:36:47.727  INFO 14220 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2019-03-08 15:36:47.735  INFO 14220 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
2019-03-08 15:36:47.752  INFO 14220 --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]
2019-03-08 15:36:47.771  INFO 14220 --- [           main] ConditionEvaluationReportLoggingListener : 

Error starting ApplicationContext. To display the conditions report re-run your application with &#39;debug&#39; enabled.
2019-03-08 15:36:47.786 ERROR 14220 --- [           main] o.s.boot.SpringApplication               : Application run failed

org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;dataController&#39; defined in file [D:\dev\Ntech\data\target\classes\cn\anytec\data\controller\DataController.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;snapServiceImpl&#39;: Unsatisfied dependency expressed through field &#39;personRepository&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;personRepository&#39;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1325) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1171) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:849) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.__refresh(AbstractApplicationContext.java:549) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.jrLockAndRefresh(AbstractApplicationContext.java:40002) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:41008) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) ~[spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]
	at cn.anytec.data.DataApplication.main(DataApplication.java:16) [classes/:na]
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;snapServiceImpl&#39;: Unsatisfied dependency expressed through field &#39;personRepository&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;personRepository&#39;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:596) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:374) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1395) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:592) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1247) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1167) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	... 21 common frames omitted
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;personRepository&#39;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:593) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1247) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1167) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:593) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	... 35 common frames omitted
Caused by: java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!
	at org.springframework.data.jpa.repository.query.SimpleJpaQuery.validateQuery(SimpleJpaQuery.java:93) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.jpa.repository.query.SimpleJpaQuery.&amp;lt;init&amp;gt;(SimpleJpaQuery.java:63) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.jpa.repository.query.JpaQueryFactory.fromMethodWithQueryString(JpaQueryFactory.java:76) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.jpa.repository.query.JpaQueryFactory.fromQueryAnnotation(JpaQueryFactory.java:56) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$DeclaredQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:139) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:206) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:79) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.lookupQuery(RepositoryFactorySupport.java:566) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.lambda$mapMethodsToQuery$1(RepositoryFactorySupport.java:559) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) ~[na:1.8.0_171]
	at java.util.Iterator.forEachRemaining(Iterator.java:116) ~[na:1.8.0_171]
	at java.util.Collections$UnmodifiableCollection$1.forEachRemaining(Collections.java:1049) ~[na:1.8.0_171]
	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) ~[na:1.8.0_171]
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) ~[na:1.8.0_171]
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) ~[na:1.8.0_171]
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) ~[na:1.8.0_171]
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:1.8.0_171]
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) ~[na:1.8.0_171]
	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.mapMethodsToQuery(RepositoryFactorySupport.java:561) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.lambda$new$0(RepositoryFactorySupport.java:551) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at java.util.Optional.map(Optional.java:215) ~[na:1.8.0_171]
	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:551) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:324) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.lambda$afterPropertiesSet$5(RepositoryFactoryBeanSupport.java:297) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.util.Lazy.getNullable(Lazy.java:211) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.util.Lazy.get(Lazy.java:94) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.afterPropertiesSet(RepositoryFactoryBeanSupport.java:300) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean.afterPropertiesSet(JpaRepositoryFactoryBean.java:119) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1821) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1758) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	... 45 common frames omitted
Caused by: java.lang.IllegalArgumentException: org.hibernate.hql.internal.ast.QuerySyntaxException: tb_person is not mapped [select name,gender,group_id as groupId,id_number as idNumber,sdk_id as sdkId from tb_person where sdk_id = ?1]
	at org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:138) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:181) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:188) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.internal.AbstractSharedSessionContract.createQuery(AbstractSharedSessionContract.java:713) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.internal.AbstractSessionImpl.createQuery(AbstractSessionImpl.java:23) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_171]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_171]
	at sun.reflect.DelegatingMethodAccessorImpl.__invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_171]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:45009) ~[na:1.8.0_171]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:45012) ~[na:1.8.0_171]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_171]
	at org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:350) ~[spring-orm-5.1.5.RELEASE.jar:5.1.5.RELEASE]
	at com.sun.proxy.$Proxy101.createQuery(Unknown Source) ~[na:na]
	at org.springframework.data.jpa.repository.query.SimpleJpaQuery.validateQuery(SimpleJpaQuery.java:87) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]
	... 74 common frames omitted
Caused by: org.hibernate.hql.internal.ast.QuerySyntaxException: tb_person is not mapped [select name,gender,group_id as groupId,id_number as idNumber,sdk_id as sdkId from tb_person where sdk_id = ?1]
	at org.hibernate.hql.internal.ast.QuerySyntaxException.generateQueryException(QuerySyntaxException.java:79) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.QueryException.wrapWithQueryString(QueryException.java:103) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:219) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:143) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.engine.query.spi.HQLQueryPlan.&amp;lt;init&amp;gt;(HQLQueryPlan.java:119) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.engine.query.spi.HQLQueryPlan.&amp;lt;init&amp;gt;(HQLQueryPlan.java:80) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.engine.query.spi.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:153) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.internal.AbstractSharedSessionContract.getQueryPlan(AbstractSharedSessionContract.java:595) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.internal.AbstractSharedSessionContract.createQuery(AbstractSharedSessionContract.java:704) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	... 84 common frames omitted
Caused by: org.hibernate.hql.internal.ast.QuerySyntaxException: tb_person is not mapped
	at org.hibernate.hql.internal.ast.util.SessionFactoryHelper.requireClassPersister(SessionFactoryHelper.java:169) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.ast.tree.FromElementFactory.addFromElement(FromElementFactory.java:91) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.ast.tree.FromClause.addFromElement(FromClause.java:79) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.ast.HqlSqlWalker.createFromElement(HqlSqlWalker.java:331) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.fromElement(HqlSqlBaseWalker.java:3695) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.fromElementList(HqlSqlBaseWalker.java:3584) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.fromClause(HqlSqlBaseWalker.java:720) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.query(HqlSqlBaseWalker.java:576) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.selectStatement(HqlSqlBaseWalker.java:313) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.statement(HqlSqlBaseWalker.java:261) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.analyze(QueryTranslatorImpl.java:271) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:191) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]
	... 90 common frames omitted
&lt;/code&gt;&lt;/pre&gt;
">Spring boot JPA @Query</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-huo-qu-fu-wu-qi-nei-cun-shu-ju/"" data-c="
          &lt;h1 id=&#34;导包&#34;&gt;导包&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.fusesource&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;sigar&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.6.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;伪代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Sigar sigar = new Sigar();
Mem mem =  sigar.getMem();

//计数单位 K
Long totalMemory = mem.getTotal() / 1024L;
Long usedMemory = mem.getUsed() / 1024L;
Long freeMemory = mem.getFree() / 1024L;
&lt;/code&gt;&lt;/pre&gt;
">java获取服务器内存数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/python-da-kai-wen-jian/"" data-c="
          &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;mode&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;注意&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&#39;r&#39;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只读&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件必须存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&#39;w&#39;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只写&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件不存在则创建, 存在则清空内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&#39;a&#39;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;追加&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件不存在则创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&#39;r+&#39; / &#39;w+&#39;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;读写&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&#39;a+&#39;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;追加和读写&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件必须存在&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;rb, wb, ab, rb+, wb+, ab+: 二进制方式打开&lt;/p&gt;
">python打开文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java53-ge-guan-jian-zi-bao-han-2-ge-bao-liu-zi/"" data-c="
          &lt;h1 id=&#34;访问控制符&#34;&gt;访问控制符&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;public&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;protected&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;缺省&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;private&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同类可见&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同包子类可见&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同包非子类可见&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不同包子类可见&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不同包非子类可见&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;类方法和变量修饰符&#34;&gt;类,方法和变量修饰符&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;abstract&lt;br&gt;
表名类或者类中的方法时抽象的&lt;/li&gt;
&lt;li&gt;class&lt;br&gt;
声明类&lt;/li&gt;
&lt;li&gt;extends&lt;br&gt;
声明继承xx类&lt;/li&gt;
&lt;li&gt;final&lt;br&gt;
声明类标识不可继承、方法不可重写&lt;/li&gt;
&lt;li&gt;implements&lt;br&gt;
声明实现xx接口&lt;/li&gt;
&lt;li&gt;interface&lt;br&gt;
声明接口&lt;/li&gt;
&lt;li&gt;native&lt;br&gt;
声明本地方法&lt;/li&gt;
&lt;li&gt;new&lt;br&gt;
创建xx类的实例对象&lt;/li&gt;
&lt;li&gt;static&lt;br&gt;
表明域或方法是静态的，即该域或方法是属于类的&lt;/li&gt;
&lt;/ol&gt;
">JAVA53个关键字(包含2个保留字)</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/qian-shi-yi-qie-de-gen-yuan/"" data-c="
          &lt;p&gt;钱是一切的根源&lt;br&gt;
马克思在《资本论》里说：&lt;br&gt;
如果有20%的利润，资本就会蠢蠢欲动；&lt;br&gt;
如果有50%的利润，资本就敢于冒险；&lt;br&gt;
如果有100%的利润，资本就可以冒着绞首的危险；&lt;br&gt;
如果有300%的利润，资本就敢于践踏人间一切的法律。&lt;/p&gt;
&lt;p&gt;这段话也可以这样理解：&lt;br&gt;
20%的利润是人类谎言的界限；&lt;br&gt;
50%的利润是人类违法的界限；&lt;br&gt;
100%的利润是人类赴死的界限；&lt;br&gt;
300%的利润则是人类变成兽的界限；&lt;/p&gt;
">钱是一切的根源</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/docker-zhi-ding-rong-qi-ip/"" data-c="
          &lt;h1 id=&#34;docker的网络模式&#34;&gt;docker的网络模式&lt;/h1&gt;
&lt;p&gt;docker 总共有四种网络模式, 分别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;host 模式&lt;/li&gt;
&lt;li&gt;bridge 模式&lt;/li&gt;
&lt;li&gt;none 模式&lt;/li&gt;
&lt;li&gt;container 模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于docker的网络模式, 在这篇文章中有非常详尽的说明, 就不赘述了. &lt;a href=&#34;https://www.cnblogs.com/sammyliu/p/5894191.html&#34;&gt;理解Docker的网络模式&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;为什么需要指定容器ip&#34;&gt;为什么需要指定容器IP&lt;/h1&gt;
&lt;p&gt;实际部署中, 我们需要指定IP, 避免IP混乱&lt;/p&gt;
&lt;h1 id=&#34;如何实现指定容器ip&#34;&gt;如何实现指定容器IP&lt;/h1&gt;
&lt;p&gt;docker的bridge(docker0)网络, 在docker安装时就已经创建好了, 不支持指定容器IP, 所以我们需要再创建一个docker的bridge网络(bridge1), 为其指定子网, 使其支持指定容器IP, 接下来将通过命令演示的方式创建一个支持指定IP的docker bridge网络.&lt;/p&gt;
&lt;h2 id=&#34;创建一个驱动为bridge的网络-命名为newbridge&#34;&gt;创建一个驱动为bridge的网络, 命名为newbridge&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;docker network create --driver bridge --subnet 172.16.12.0/16 --gateway 172.16.1.1 newbridge
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/02/qj8478qriagtjqrqhi7on1m71u.jpg&#34; alt=&#34;创建网络&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;查看刚刚创建的网络&#34;&gt;查看刚刚创建的网络&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;docker network ls
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/02/vf0178qo9ojnio23gtuqu7kuvi.jpg&#34; alt=&#34;查看&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;创建容器测试&#34;&gt;创建容器测试&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;docker run -itd -h test --name test --network newbridge --ip 172.16.12.3 ubuntu
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;验证容器的ip&#34;&gt;验证容器的ip&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;此命令为查看所有容器ip命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;docker inspect --format=&#39;{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39; $(docker ps -aq)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/02/s9r8oeavpsgmqr1gvpi2ev2sh4.jpg&#34; alt=&#34;验证容器ip&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到容器的ip已经是刚才我们创建容器时指定的ip了. 大功告成.&lt;/p&gt;
&lt;h1 id=&#34;引用说明&#34;&gt;引用说明&lt;/h1&gt;
&lt;p&gt;文中操作学习自 &lt;a href=&#34;https://www.jianshu.com/p/b8625ccb5e9c&#34;&gt;Docker 创建容器时指定容器ip&lt;/a&gt;&lt;/p&gt;
">docker 指定容器IP</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/wu-sheng-de-zhong-guo/"" data-c="
          &lt;p&gt;中国人的性情是总喜欢调和折中的，譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶他们就来调和，愿意开窗了。&lt;/p&gt;
&lt;div style=&#34;text-align: right&#34;&gt;——鲁迅 《无声的中国》&lt;/div&gt;">无声的中国</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/yuan-zhu-jie/"" data-c="
          &lt;h1 id=&#34;什么是元注解&#34;&gt;什么是元注解&lt;/h1&gt;
&lt;p&gt;在java.lang.annotation包下, 提供了四个用来注解注解的元注解, 用于在自定义注解时使用.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Documented -- 注解是否包含在javaDoc中&lt;/li&gt;
&lt;li&gt;@Retention -- 什么时候用该注解&lt;/li&gt;
&lt;li&gt;@Target -- 注解用在什么地方&lt;/li&gt;
&lt;li&gt;@Inherited -- 是否允许子类继承该注解&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;documented&#34;&gt;@Documented&lt;/h1&gt;
&lt;p&gt;一个简单的Annotations注解标记, 标识是否将注解加入到Java文档中.&lt;/p&gt;
&lt;h1 id=&#34;retention&#34;&gt;@Retention&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;定义该注解的生命周期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;RetentionPolicy.SOURCE  在编译阶段丢弃, 注解在编译之后就不会再有任何意义, 不会写入字节码文件. @Override, @SupperssWarnings都属于该生命周期.&lt;/li&gt;
&lt;li&gt;RetentionPolicy.CLASS 在类加载的时候丢弃, 在字节码处理过程中有用, &lt;strong&gt;默认使用该生命周期&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;RetentionPolicy.RUNTIME 始终不会丢弃, 运行期也保留该注解, 可以使用反射读取该注解的信息, &lt;strong&gt;自定义注解时常使用该生命周期&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;target&#34;&gt;@Target&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;定义该注解用在什么地方, 默认可以用在所有地方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ElementType.TYPE -- 用于描述类&lt;/li&gt;
&lt;li&gt;ElementType.METHOD -- 用于描述方法&lt;/li&gt;
&lt;li&gt;ElementType.FIELD -- 用于描述成员变量, 对象, 属性(包括enum)&lt;/li&gt;
&lt;li&gt;ElementType.PACKAGE -- 用于描述包&lt;/li&gt;
&lt;li&gt;ElementType.CONSTRUCTOR -- 用于描述构造函数&lt;/li&gt;
&lt;li&gt;ElementType.LOCAL_VARIABLE -- 用于描述局部变量&lt;/li&gt;
&lt;li&gt;ElementType.PARAMETER -- 用于描述类, 接口(包括注解类型)或enum声明&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;inherited&#34;&gt;@Inherited&lt;/h1&gt;
&lt;p&gt;@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。&lt;/p&gt;
&lt;h1 id=&#34;栗子&#34;&gt;栗子&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;@Documented
@Retention(value = RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})
@Inherited
@interface AnnotationTest{
    String value() default &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
">元注解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/qian-hou-duan-fen-chi-shi-yong-nginx-zuo-fu-wu-zhuan-fa/"" data-c="
          &lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;前后端分离作为现在的大趋势，公司也开始了整合评估现有项目，打算对现有项目做前后端分离配置， 现阶段主要打算使用 &lt;code&gt;NGINX&lt;/code&gt; 做前端静态的HTTP请求服务器，还包括对 &lt;code&gt;WebSocket&lt;/code&gt; 内容的转发，当然还包括最主要的后台服务的负载均衡。&lt;/p&gt;
&lt;h1 id=&#34;nginx配置&#34;&gt;nginx配置&lt;/h1&gt;
&lt;p&gt;在nginx.conf中配置了 &lt;code&gt;include /etc/nginx/sites-enabled&lt;/code&gt; 所以在 &lt;code&gt;sites-enabled&lt;/code&gt; 下面编写配置信息.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map $http_upgrade $connection_upgrade {  
	default upgrade;  
	&#39;&#39; close;  
}  
upstream muti_instance_43{
#	server 192.168.10.62:9999 weight=10;
	server 192.168.10.62:9999;
#	server 192.168.10.213:9997 weight=2;
	keepalive 200;
}

server {
	listen 0.0.0.0:10070;
	sendfile off;


	proxy_set_header Host $http_host;
	proxy_set_header X-Real-IP $remote_addr;
	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	proxy_set_header X-Forwarded-Proto $scheme;
#	resolver 114.114.114.114 223.5.5.5 valid=3600s;
        resolver_timeout 3s;

	proxy_http_version 1.1;
	proxy_set_header Connection &amp;quot;&amp;quot;;

	#root /data/securityUI/static/;


	location  / { 
                #add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;
		#add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET&#39;;
		#add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization&#39;;
		#add_header &#39;Access-Control-Expose-Headers&#39; &#39;Content-Length,Content-Range&#39;;
		#add_header &#39;Access-Control-Max-Age&#39; 2592000;
		client_max_body_size    15g;
		#dav_access user:rw group:rw all:rw;
		#dav_methods PUT DELETE MKCOL COPY MOVE;

		#create_full_put_path on;

		#autoindex off;
		#autoindex_exact_size off;
		#autoindex_localtime on;
		#charset utf-8;
		if ($request_uri ~* /.) {
			proxy_pass http://muti_instance_43;
			break;
			#root /data/securityUI/static/;
                	#index index.html index.htm;
	
		}
		root /data/securityUI/static/;
                index login.html;
	}

	location ^~ /static/offlineMap/ {
		alias /data/securityUI/map/;
		#proxy_pass http://map_server;
	}

	location  /static/ {

		client_max_body_size 15g;
		alias /data/securityUI/static/;
		allow all;

	}
	location ^~ /index {
		alias /data/securityUI/static/;
		index index.html;

	}

	location ^~ /gee/ {
		proxy_pass http://muti_instance_43;
		proxy_set_header Upgrade $http_upgrade;
		proxy_set_header Connection &amp;quot;upgrade&amp;quot;;
		proxy_http_version 1.1;
		proxy_set_header        Host            $host;
		proxy_set_header        X-Real-IP       $remote_addr;
		proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;

	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;配置中最关键的点在 &lt;code&gt;location  / {}&lt;/code&gt; 节点, 其中的 &lt;code&gt;if&lt;/code&gt; 判断, 如果是访问的 &lt;code&gt;ip:port/xxx&lt;/code&gt; 带了任何内容, 就会转发到 &lt;code&gt;muti_instance_43&lt;/code&gt; 中, 如果没有带内容(即访问的首页), 就会将其转发到配置好了的静态首页面.&lt;/p&gt;
">前后端分离使用NGINX做服务转发</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/efk-ri-zhi-xi-tong-da-jian/"" data-c="
          &lt;h1 id=&#34;什么是efk&#34;&gt;什么是EFK&lt;/h1&gt;
&lt;p&gt;这里引用一下 &lt;a href=&#34;https://www.cnblogs.com/xishuai/p/elk-elasticsearch-kibana.html&#34;&gt;ELK 架构之 Elasticsearch 和 Kibana 安装配置&lt;/a&gt; 一文对ELK的介绍，详细内容在文中都有介绍，我主要将其从实体机安装转向在Docker-compose服务编排，EFK与ELK大同小异.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ELK 是三个开源软件的缩写，分别为：Elasticsearch、Logstash 以及 Kibana，它们都是开源软件。不过现在还新增了一个 Beats，它是一个轻量级的日志收集处理工具（Agent），Beats 占用资源少，适合于在各个服务器上搜集日志后传输给 Logstash，官方也推荐此工具，目前由于原本的 ELK Stack 成员中加入了 Beats 工具所以已改名为 Elastic Stack。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;elasticsearch搭建&#34;&gt;ElasticSearch搭建&lt;/h1&gt;
&lt;p&gt;ElasticSearch的安装需要替换配置文件的以下几个点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;network.host: 0.0.0.0 #所有地址都能够访问  
http.port: 9200 #端口  
http.cors.enabled: true 
 http.cors.allow-origin: &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;问题解决&#34;&gt;问题解决&lt;/h2&gt;
&lt;p&gt;在配置ElasticSearch时容易出现以下几点错误, 在此讲解以下如何解决:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;见图1-[ElasticSearch问题]&lt;br&gt;
原因：这是在因为系统不支持SecComp，而ES5.2.0默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。&lt;br&gt;
解决：在elasticsearch.yml中配置bootstrap.system_call_filter为false，注意要在Memory下面:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;bootstrap.memory_lock: false
bootstrap.system_call_filter: false
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;见图1-[ElasticSearch问题]第二个红框&lt;br&gt;
出现此问题只需要修改了 &lt;strong&gt;宿主机&lt;/strong&gt; 系统的max_map_count参数即可.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/sysctl.conf
vm.max_map_count=655360
sysctl -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://imyzt.top/upload/2019/02/61os9j93kshnvr88rcb91ufbfv.png&#34; alt=&#34;ElasticSearch问题&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图1-[ElasticSearch问题]&lt;/p&gt;
&lt;h1 id=&#34;logstash搭建&#34;&gt;Logstash搭建&lt;/h1&gt;
&lt;p&gt;Logstash的安装需要替换配置文件的以下几点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server.port: 5601 
server.host: &amp;quot;0.0.0.0&amp;quot; 
elasticsearch.url: &amp;quot;http://elasticsearch:9200&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;kibana搭建&#34;&gt;Kibana搭建&lt;/h1&gt;
&lt;p&gt;配置一个filebeat的服务接收端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input {
 beats {
   port =&amp;gt; 10515
  }
}
output {
    elasticsearch {
      hosts =&amp;gt; [&amp;quot;127.0.0.1:9200&amp;quot;]
      # 注释不能被解析,线上删除.此处做讲解
      # %{[fields][logtype]} 对应filebeat配置文件, 只需在此配置, 写入ElasticSearch的索引就可以主动创建和filebeat相关的索引
      index =&amp;gt; &amp;quot;%{[fields][logtype]}-%{+YYYY.MM.dd}&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;filebeat搭建&#34;&gt;filebeat搭建&lt;/h1&gt;
&lt;p&gt;filebeat作为 &lt;code&gt;日志探测器&lt;/code&gt; 需要配置一个日志探测配置文件, 可以是log4j的网络传输, 也可以是系统的某个目录.配置文件下图讲解的非常细致&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/02/sv179ptptkg8ppujgiuu8gqhcv.png&#34; alt=&#34;filebeat.conf&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;还需要做如下修改:&lt;br&gt;
注释掉默认开启的 ElasticSearch&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/02/7rglj7vc94i6tp56sd54tlgelp.png&#34; alt=&#34;注释掉es配置&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;开启默认未开启的 logstash, 指定logstash地址, 指定主机名而非localhost&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/02/2dqcnm00jmgqcqq5vaarpuicfe.png&#34; alt=&#34;开启logstash配置&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;容器编排&#34;&gt;容器编排&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;2&#39;

services: 
  elasticsearch:  
    image: docker.elastic.co/elasticsearch/elasticsearch:6.6.0
    volumes: 
      - ./es/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml
      - ./es/data:/usr/share/elasticsearch/data
      - ./es/logs:/path/to/logs
    ports: 
      - &#39;9200:9200&#39;
      - &#39;9300:9300&#39;
    environment:
      - &amp;quot;bootstrap.memory_lock=true&amp;quot;
      - &amp;quot;ES_JAVA_OPTS=-Xmx1g -Xms1g&amp;quot;
    ulimits:
      memlock:
        soft: -1
        hard: -1
    networks:
      - efk
  logstash:
    image: docker.elastic.co/logstash/logstash:6.6.0
    volumes:
      - ./logstash/logstash.yml:/usr/share/logstash/config/logstash.yml
      - ./logstash/logstash-sample.conf:/usr/share/logstash/config/logstash-sample.conf
      - ./logstash/pipeline:/usr/share/logstash/pipeline
      - ./logstash/pattern:/usr/share/logstash/pattern
    ports:
      - &amp;quot;5044:5044&amp;quot;
      - &amp;quot;10515:10515&amp;quot;
    environment:
      - &amp;quot;LS_JAVA_OPTS=-Xmx1g -Xms1g&amp;quot;
    command: logstash -f /usr/share/logstash/config/logstash-sample.conf
    networks:
      - efk
    depends_on:
      - elasticsearch
  kibana:
    image: docker.elastic.co/kibana/kibana:6.6.0
    volumes:
      - ./kibana/kibana.yml:/usr/share/kibana/config/kibana.yml
    ports:
      - &amp;quot;5601:5601&amp;quot;
    networks:
      - efk
    depends_on:
      - elasticsearch

networks:
  efk:
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;
">EFK日志系统搭建</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/pu-tong-rong-qi-bian-pai/"" data-c="
          &lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;容器主要包括了三个数据库MongoDB，MySQL，Redis，一个消息中间件RabbitMQ。security程序依赖三个数据库，security-rabbit依赖RabbitMQ，最后forward-nginx依赖于security程序。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/02/2qhouu9b3gi8erig24vba8tfnb.jpg&#34; alt=&#34;图解&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;
# 容器编排
version: &amp;quot;3&amp;quot;
services:
  security:
    image: anytec/security:0.0.1
    container_name: anytec-security
    expose:
      - &amp;quot;9999&amp;quot;
    networks:
      - docker-server
    depends_on:
      - mysql
      - mongodb
      - redis
      - rabbitmq
    restart: always
    deploy:
      replicas: 1
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure
  security-rabbitmq:
    image: anytec/security-rabbitmq:0.0.1
    container_name: anytec-security-rabbitmq
    expose:
      - &amp;quot;9998&amp;quot;
    networks:
      - docker-server
    depends_on:
      - rabbitmq
      - security
    restart: always
    deploy:
      replicas: 1
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure
  forward-nginx:
    image: nginx:latest
    container_name: anytec-forward-nginx
    ports:
      - &amp;quot;10070:10070&amp;quot;
    networks:
      - docker-server
    depends_on:
      - security
    restart: always
    deploy:
      replicas: 1
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure
    volumes:
      - /anytec/docker-server/forward-nginx/sites-enabled:/etc/nginx/sites-enabled/
      - /data/securityUI:/data/securityUI
      - /anytec/docker-server/forward-nginx/conf:/etc/nginx/
  rabbitmq:
    image: anytec/rabbitmq:3.6.15
    container_name: anytec-rabbitmq
    expose:
      - &amp;quot;5672&amp;quot;
    ports:
      - &amp;quot;15672:15672&amp;quot;
    networks:
      - docker-server
    environment:
     - RABBITMQ_DEFAULT_USER=admin
     - RABBITMQ_DEFAULT_PASS=ntech
     - RABBITMQ_USER admin
     - ENV RABBITMQ_PASSWORD ntech
     - RABBITMQ_CONFIG_FILE=/etc/rabbitmq/rabbitmq.config
     - RABBITMQ_ERLANG_COOKIE=CURIOAPPLICATION
    restart: always
    deploy:
      replicas: 1
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure
  mongodb:
    image: mongo:latest
    container_name: anytec-mongodb
    expose:
      - &amp;quot;27017&amp;quot;
    networks:
      - docker-server
    restart: always
    #environment:
      #MONGO_INITDB_ROOT_PASSWORD: ntech
      #MONGO_INITDB_ROOT_USERNAME: root
    volumes:
      - /anytec/docker-server/mongodb/data:/data/db
      - /anytec/docker-server/mongodb/conf/mongodb.conf:/etc/mongodb.conf 
    deploy:
      replicas: 1
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure
  redis:
    image: redis
    container_name: anytec-redis
    expose:
      - &amp;quot;6379&amp;quot;
    networks:
      - docker-server
    volumes:
      - /anytec/docker-server/redis/data:/data
      - /anytec/docker-server/redis/conf:/usr/local/etc/redis/
    command: [&#39;redis-server&#39;, &#39;/usr/local/etc/redis/redis.conf&#39;]
    restart: always
    deploy:
      replicas: 1
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure
  mysql:
    image: anytec/mysql:5.7
    container_name: anytec-mysql
    expose:
     - &amp;quot;3306&amp;quot;
    networks:
     - docker-server
    environment:
      MYSQL_ROOT_PASSWORD: ntech
      MYSQL_ROOT_HOST: &#39;%&#39;
      MYSQL_DATABASE: securitydb
    volumes:
      - /anytec/docker-server/mysql/data:/var/lib/mysql
    restart: always
    deploy:
      replicas: 1
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure
networks:
  docker-server:
    driver: bridge

&lt;/code&gt;&lt;/pre&gt;
">普通容器编排</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/synchronized/"" data-c="
          &lt;h1 id=&#34;synchronized的两种用法&#34;&gt;synchronized的两种用法&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;对象锁&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;包括方法锁(默认锁对象为&lt;strong&gt;this&lt;/strong&gt;当前实例对象)和同步代码块锁(自己指定锁对象)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;类锁&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;指synchronized修饰 &lt;strong&gt;static方法&lt;/strong&gt; 或指定锁对象为 &lt;strong&gt;Class对象&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;对象锁&#34;&gt;对象锁&lt;/h1&gt;
&lt;h2 id=&#34;同步代码块&#34;&gt;同步代码块&lt;/h2&gt;
&lt;h3 id=&#34;使用-this-锁定代码块&#34;&gt;使用 this 锁定代码块&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class SynchronizedObjectCodeBlock2 implements Runnable {

    static SynchronizedObjectCodeBlock2 codeBlock2 = new SynchronizedObjectCodeBlock2();

    @Override
    public void run() {

        synchronized (this) {
            System.out.println(&amp;quot;我是lock2, 我叫&amp;quot; + Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &amp;quot;, lock2 部分执行结束&amp;quot;);
        }

    }

    public static void main(String[] args) {

        Thread thread1 = new Thread(codeBlock2);
        Thread thread2 = new Thread(codeBlock2);

        thread1.start();
        thread2.start();

        while (thread1.isAlive() || thread2.isAlive()) {

        }

        System.out.println(&amp;quot;finished&amp;quot;);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我是lock2, 我叫Thread-0
Thread-0, lock2 部分执行结束
我是lock2, 我叫Thread-1
Thread-1, lock2 部分执行结束
finished
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用-自定义锁对象&#34;&gt;使用 自定义锁对象&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class SynchronizedObjectCodeBlock2 implements Runnable {

    static SynchronizedObjectCodeBlock2 codeBlock2 = new SynchronizedObjectCodeBlock2();

    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    @Override
    public void run() {

        synchronized (lock1) {
            System.out.println(&amp;quot;我是lock1, 我叫&amp;quot; + Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &amp;quot;, lock1 部分执行结束&amp;quot;);
        }

        synchronized (lock2) {
            System.out.println(&amp;quot;我是lock2, 我叫&amp;quot; + Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &amp;quot;, lock2 部分执行结束&amp;quot;);
        }

    }

    public static void main(String[] args) {

        Thread thread1 = new Thread(codeBlock2);
        Thread thread2 = new Thread(codeBlock2);

        thread1.start();
        thread2.start();

        while (thread1.isAlive() || thread2.isAlive()) {

        }

        System.out.println(&amp;quot;finished&amp;quot;);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果，可以看出来加粗部分， thread-0和thread-1同时执行和同时结束，因为两个线程使用的不是同一把锁。&lt;/p&gt;
&lt;p&gt;我是lock1, 我叫Thread-0&lt;br&gt;
Thread-0, lock1 部分执行结束&lt;br&gt;
&lt;strong&gt;我是lock2, 我叫Thread-0&lt;br&gt;
我是lock1, 我叫Thread-1&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;Thread-1, lock1 部分执行结束&lt;br&gt;
Thread-0, lock2 部分执行结束&lt;/strong&gt;&lt;br&gt;
我是lock2, 我叫Thread-1&lt;br&gt;
Thread-1, lock2 部分执行结束&lt;br&gt;
finished&lt;/p&gt;
&lt;h2 id=&#34;方法锁&#34;&gt;方法锁&lt;/h2&gt;
&lt;h3 id=&#34;代码展示&#34;&gt;代码展示&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class SynchronizedObjectMethod3 implements Runnable {

    public static void main(String[] args) {

        SynchronizedObjectMethod3 objectMethod3 = new SynchronizedObjectMethod3();

        Thread thread1 = new Thread(objectMethod3);
        Thread thread2 = new Thread(objectMethod3);

        thread1.start();
        thread2.start();
    }

    @Override
    public void run() {
        method();
    }

    public synchronized void method() {
        System.out.println(&amp;quot;对象锁的方法修饰符形式, threadName=&amp;quot; + Thread.currentThread().getName());
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &amp;quot;运行结束&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运行结果&#34;&gt;运行结果:&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;使用synchronized修饰一个成员方法, 该方法会根据实例依次执行.&lt;br&gt;
对象锁的方法修饰符形式, threadName=Thread-0&lt;br&gt;
Thread-0运行结束&lt;br&gt;
对象锁的方法修饰符形式, threadName=Thread-1&lt;br&gt;
Thread-1运行结束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;类锁&#34;&gt;类锁&lt;/h1&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;只有一个Class对象: Java类可能会有很多个实例对象, 但是只有一个Class对象&lt;/li&gt;
&lt;li&gt;本质: 所谓的类锁, 实质上是Class对象的锁而已&lt;/li&gt;
&lt;li&gt;用法和效果: 类锁只能在同一时刻被同一对象拥有&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;同步一个全局方法&#34;&gt;同步一个全局方法&lt;/h2&gt;
&lt;h3 id=&#34;代码展示-2&#34;&gt;代码展示&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class SynchronizedClassStatic4 implements Runnable {

    static SynchronizedClassStatic4 instance1 = new SynchronizedClassStatic4();
    static SynchronizedClassStatic4 instance2 = new SynchronizedClassStatic4();

    @Override
    public void run() {
        method();
    }

    public static synchronized void method() {
        System.out.println(&amp;quot;我是类锁的第一种形式: static形式, 我叫 &amp;quot; + Thread.currentThread().getName());
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &amp;quot;运行结束&amp;quot;);
    }

    public static void main(String[] args) {

        Thread thread1 = new Thread(instance1);
        Thread thread2 = new Thread(instance2);

        thread1.start();
        thread2.start();

        while (thread1.isAlive() || thread2.isAlive()) {

        }

        System.out.println(&amp;quot;finished&amp;quot;);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运行结果-2&#34;&gt;运行结果:&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;使用synchronized修饰一个全局方法(static修饰), synchronized默认使用类作为锁对象&lt;br&gt;
我是类锁的第一种形式: static形式, 我叫 Thread-0&lt;br&gt;
Thread-0运行结束&lt;br&gt;
我是类锁的第一种形式: static形式, 我叫 Thread-1&lt;br&gt;
Thread-1运行结束&lt;br&gt;
finished&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;类锁同步一个代码块&#34;&gt;类锁同步一个代码块&lt;/h2&gt;
&lt;h3 id=&#34;代码展示-3&#34;&gt;代码展示&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public class SynchronizedClassClass5 implements Runnable {

    static SynchronizedClassClass5 instance1 = new SynchronizedClassClass5();
    static SynchronizedClassClass5 instance2 = new SynchronizedClassClass5();

    @Override
    public void run() {
        method();
    }

    private void method() {
        synchronized(SynchronizedClassClass5.class) {
            System.out.println(&amp;quot;类锁的第二种表现形式, synchronized(*.class)的形式, 这是&amp;quot; + Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &amp;quot;运行结束&amp;quot;);
        }
    }

    public static void main(String[] args) {

        Thread thread1 = new Thread(instance1);
        Thread thread2 = new Thread(instance2);

        thread1.start();
        thread2.start();

        while (thread1.isAlive() || thread2.isAlive()) {

        }

        System.out.println(&amp;quot;finished&amp;quot;);

    }


}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运行结果-3&#34;&gt;运行结果:&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;尽管Thread使用的不同的instance对象, 但是使用了*.class类锁之后, 代码也会按照期望值运行.&lt;br&gt;
类锁的第二种表现形式, synchronized(&lt;em&gt;.class)的形式, 这是Thread-0&lt;br&gt;
Thread-0运行结束&lt;br&gt;
类锁的第二种表现形式, synchronized(&lt;/em&gt;.class)的形式, 这是Thread-1&lt;br&gt;
Thread-1运行结束&lt;br&gt;
finished&lt;/p&gt;
&lt;/blockquote&gt;
">synchronized</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/springboot2-bian-xie-zi-ding-yi-autoconfig/"" data-c="
          &lt;h1 id=&#34;什么是spring-autoconfig&#34;&gt;什么是Spring AutoConfig&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added. For example, if HSQLDB is on your classpath, and you have not manually configured any database connection beans, then Spring Boot auto-configures an in-memory database.&lt;br&gt;
You need to opt-in to auto-configuration by adding the &lt;code&gt;@EnableAutoConfiguration &lt;/code&gt; or &lt;code&gt;@SpringBootApplication&lt;/code&gt; annotations to one of your &lt;code&gt;@Configuration&lt;/code&gt; classes.&lt;br&gt;
引用自: &lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html&#34;&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;怎样编写springboot2-autoconfig&#34;&gt;怎样编写SpringBoot2 AutoConfig&lt;/h1&gt;
&lt;p&gt;使用自动配置&lt;code&gt;HttpClient&lt;/code&gt;作为例子.&lt;/p&gt;
&lt;h2 id=&#34;编写一个属性配置类&#34;&gt;编写一个属性配置类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@ConfigurationProperties(prefix = &amp;quot;spring.httpclient&amp;quot;)
@Data
public class HttpClientProperties {
    private Integer connectTimeOut = 1000;
    private Integer socketTimeOut = 10000;
    private String agent = &amp;quot;agent&amp;quot;;
    private Integer maxConnPerRoute = 10;
    private Integer maxConnTotal = 50;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 的 &lt;code&gt;prefix&lt;/code&gt; 提示Spring在启动时将配置文件中 &lt;code&gt;spring.httpclient&lt;/code&gt; 的与本类属性相对应的属性自动加载进来.&lt;br&gt;
&lt;code&gt;@Data&lt;/code&gt; 是lombok的注解.&lt;/p&gt;
&lt;h2 id=&#34;编写自动配置核心类&#34;&gt;编写自动配置核心类&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
@ConditionalOnClass({HttpClient.class})
@EnableConfigurationProperties(HttpClientProperties.class)
public class HttpClientAutoConfiguration {

    private final HttpClientProperties properties;

    public HttpClientAutoConfiguration(HttpClientProperties properties) {
        this.properties = properties;
    }


    /**
     * httpclient bean的定义
     * @return Http Client
     *
     * ConditionalOnMissingBean -&amp;gt; 当用户未定义的时候才会创建
     */
    @Bean
    @ConditionalOnMissingBean(HttpClient.class)
    public HttpClient httpClient() {
        RequestConfig requestConfig = RequestConfig.custom()
                .setConnectTimeout(properties.getConnectTimeOut())
                .setSocketTimeout(properties.getSocketTimeOut())
                .build();
        return HttpClientBuilder.create()
                .setDefaultRequestConfig(requestConfig)
                .setUserAgent(properties.getAgent())
                .setMaxConnPerRoute(properties.getMaxConnPerRoute())
                .setMaxConnTotal(properties.getMaxConnTotal())
                // 防止重试
                .setConnectionReuseStrategy(new NoConnectionReuseStrategy())
                .build();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;@Configuration： 将本类标识为SpringBoot的Java配置类&lt;/li&gt;
&lt;li&gt;@ConditionalOnClass({HttpClient.class})： 只有在HttpClient.class存在时才会加载java config&lt;/li&gt;
&lt;li&gt;@EnableConfigurationProperties(HttpClientProperties.class)：本类加载时注入 &lt;code&gt;HttpClientProperties&lt;/code&gt; 属性配置的bean&lt;/li&gt;
&lt;li&gt;httpClient()的@ConditionalOnMissingBean(HttpClient.class)：只有当没有创建HttpClient bean的时候，才会执行 httpClient()方法创建一个HttpClient bean&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;使spring感知自动配置类&#34;&gt;使Spring感知自动配置类.&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;spring-boot-autoconfigure&lt;/code&gt; 的 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 中, 编写了非常多的开源软件的自动配置类. 而如果我们自己编写自动配置类. 有以下几种方式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;方式一&#34;&gt;方式一&lt;/h2&gt;
&lt;p&gt;autoconfig在本项目的 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 目录下，不需要其他配置, 可以直接通过 &lt;code&gt;@AutoWired&lt;/code&gt; 注入 &lt;code&gt;HttpClient&lt;/code&gt;，如：&lt;br&gt;
···&lt;br&gt;
@RunWith(SpringRunner.class)&lt;br&gt;
@SpringBootTest&lt;br&gt;
public class HouseApplicationTests {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
private HttpClient httpClient;

@Test
public void contextLoads() throws IOException {
	String toString = httpClient.execute(new HttpGet(&amp;quot;http://www.imyzt.top&amp;quot;)).getEntity().toString();
	System.out.println(toString);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br&gt;
···&lt;/p&gt;
&lt;h2 id=&#34;方式二&#34;&gt;方式二&lt;/h2&gt;
&lt;p&gt;autoconfig不在本项目的 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 目录下，可以有两种方式自动配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在本项目的resources下编写 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 文件.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
top1.imyzt.autoconfig.HttpClientAutoConfiguration
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;[推荐] 编写 &lt;code&gt;@EnableHttpClient&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(HttpClientAutoConfiguration.class)
public @interface EnableHttpClient {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在启动类上加上注解, 即可开启HttpClient配置.&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;教程是在学习慕课网上的 &lt;a href=&#34;https://coding.imooc.com/class/174.html&#34;&gt;Java从单体到微服务打造房产销售平台&lt;/a&gt; 时学习到的, 在此博客做一个总结, 以便后面复习.&lt;/p&gt;
&lt;p&gt;上述代码在我的 &lt;a href=&#34;https://github.com/imyzt/houses&#34;&gt;Github&lt;/a&gt; 上可以找到.&lt;/p&gt;
">SpringBoot2 编写自定义AutoConfig</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;该站是我通过Gridea搭建的小站。感谢&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea&lt;/a&gt;&lt;br&gt;
通过CloudFlare提供的免费服务，加速了本网站的访问，&lt;a href=&#34;https://imyzt.top/post/shi-yong-cloudflare-jia-su-github-pages/&#34;&gt;使用Cloudflare加速Github Pages&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;我叫杨镇涛，是一名Java程序员。&lt;br&gt;
现阶段本职工作是Java服务端开发, 平时会花一些时间做 Kubernetes 方面的学习研究。&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;爬山，徒步&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/imyzt&#34;&gt;github.com/imyzt&lt;/a&gt;&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-8-guide-e4/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本篇接着上篇来, 继续学习java8新特性&lt;br&gt;
&lt;a href=&#34;http://blog.didispace.com/books/java8-tutorial/&#34;&gt;Java 8 简明教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;map&#34;&gt;Map&lt;/h1&gt;
&lt;h1 id=&#34;putifabsent&#34;&gt;putIfAbsent&lt;/h1&gt;
&lt;h2 id=&#34;代码展示&#34;&gt;代码展示&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; hashMap = new LinkedHashMap&amp;lt;&amp;gt;();

hashMap.put(&amp;quot;val_1&amp;quot;, 1);
hashMap.put(&amp;quot;val_2&amp;quot;, 2L);
hashMap.put(&amp;quot;val_3&amp;quot;, null);


System.out.println(hashMap);

Object val_1 = hashMap.putIfAbsent(&amp;quot;val_1&amp;quot;, 111);
System.out.println(val_1);
Object val_3 = hashMap.putIfAbsent(&amp;quot;val_3&amp;quot;, 3);
System.out.println(val_3);
Object val_4 = hashMap.putIfAbsent(&amp;quot;val_4&amp;quot;, 4);
System.out.println(val_4);

System.out.println(hashMap);

输出: 
{val_1=1, val_2=2, val_3=null}
1
null
null
{val_1=1, val_2=2, val_3=3, val_4=4}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;对比&#34;&gt;对比&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在之前如果我们存储一个key时, 需要判断是否存在, 不存在时添加. 我们需要先判断再添加. 在jdk1.8之后, 我们只需要 &lt;code&gt;putIfAbsent(k,v)&lt;/code&gt; 方法就可以完成.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;if (!hashMap.containsKey(&amp;quot;val_3&amp;quot;)) {
    hashMap.put(&amp;quot;val_3&amp;quot;, &amp;quot;val_3&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方法详解&#34;&gt;方法详解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hashMap.putIfAbsent(&amp;quot;val_1&amp;quot;, 111);&lt;/code&gt;, 存在key时, 如果 &lt;strong&gt;value != null&lt;/strong&gt;, 不替换, 返回原本存储的 value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hashMap.putIfAbsent(&amp;quot;val_3&amp;quot;, 3);&lt;/code&gt;, 存在key时, 如果 &lt;strong&gt;value == null&lt;/strong&gt;, 替换value, 返回 &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hashMap.putIfAbsent(&amp;quot;val_4&amp;quot;, 4);&lt;/code&gt;, 不存在key时, 直接put进去.&lt;/li&gt;
&lt;/ul&gt;
">Java 8 Guide E4</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-8-guide-e3/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本篇接着上篇来, 继续学习java8新特性&lt;br&gt;
&lt;a href=&#34;http://blog.didispace.com/books/java8-tutorial/&#34;&gt;Java 8 简明教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;stream-介绍&#34;&gt;Stream 介绍&lt;/h1&gt;
&lt;p&gt;Stream (流) 操作算是对集合的大大增强, 很多之前很复杂需要很多代码量的逻辑在此终结.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个Collection(集合)可以通过调用 &lt;code&gt;stream()&lt;/code&gt; 和 &lt;code&gt;parallelStream()&lt;/code&gt; 两个方法获得 &lt;code&gt;stream&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;stream()方法返回一个 &lt;code&gt;顺序流&lt;/code&gt;, 所有的操作必须等待上一步的完成.&lt;/li&gt;
&lt;li&gt;parallelStream()方法返回一个 &lt;code&gt;并行流&lt;/code&gt;, 操作会更高效, 考虑业务使用不同的流.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;流的操作分为 &lt;code&gt;中间操作&lt;/code&gt; 和 &lt;code&gt;终止操作&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;中间操作: 对流的处理还在进行中, 不会中指当前流. 可以返回一个流进行其他操作. 就像StringBuffer的append()一样&lt;/li&gt;
&lt;li&gt;终止操作: 对流的处理将会终结, 当前流将不能继续使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;中间操作&#34;&gt;中间操作&lt;/h1&gt;
&lt;h2 id=&#34;filter&#34;&gt;Filter&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Filter接收一个 &lt;code&gt;Predicate&amp;lt;? super T&amp;gt;&lt;/code&gt; 接口的参数进行过滤操作&lt;/p&gt;
&lt;h2 id=&#34;sorted&#34;&gt;Sorted&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Stream&amp;lt;T&amp;gt; sorted(Comparator&amp;lt;? super T&amp;gt; comparator);  
Stream&amp;lt;T&amp;gt; sorted();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sorted()方法自然排序. 即调用对象本身的compareTo()方法排序.&lt;br&gt;
sorted(Comparator&amp;lt;? super T&amp;gt; comparator);  接受一个 Comparator对象进行排序&lt;/p&gt;
&lt;h2 id=&#34;map&#34;&gt;Map&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper);
IntStream mapToInt(ToIntFunction&amp;lt;? super T&amp;gt; mapper);
LongStream mapToLong(ToLongFunction&amp;lt;? super T&amp;gt; mapper);
DoubleStream mapToDouble(ToDoubleFunction&amp;lt;? super T&amp;gt; mapper);
&amp;lt;U&amp;gt; Stream&amp;lt;U&amp;gt; mapToObj(IntFunction&amp;lt;? extends U&amp;gt; mapper);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;map有上述几个方法, 可以转换为指定的类型, 方法参数都是接受一个 &lt;code&gt;xxxFunction&lt;/code&gt; 的转换器.  下面有一个演示.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list.stream()
        .filter(s -&amp;gt; s.startsWith(&amp;quot;1&amp;quot;))
        .sorted(String::compareTo)
        .mapToInt(Integer::valueOf)
        .mapToObj(String::valueOf)
        .mapToLong(Long::valueOf);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;终止操作&#34;&gt;终止操作&lt;/h1&gt;
&lt;h2 id=&#34;match&#34;&gt;Match&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;boolean anyMatch(Predicate&amp;lt;? super T&amp;gt; predicate);
boolean allMatch(Predicate&amp;lt;? super T&amp;gt; predicate);
boolean noneMatch(Predicate&amp;lt;? super T&amp;gt; predicate);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Match方法有三个, 都接受一个 &lt;code&gt;Predicate&lt;/code&gt; 条件来决定返回true or false&lt;/p&gt;
&lt;h2 id=&#34;count&#34;&gt;Count&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;long count();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;count()计算集合大小, 这个方法很简单.&lt;/p&gt;
&lt;h2 id=&#34;reduce&#34;&gt;Reduce&lt;/h2&gt;
&lt;p&gt;有了Map, 那肯定是有Reduce, 不过Reduce是一个终止操作. 它接收一个 &lt;code&gt;xxxOperator&lt;/code&gt; 的操作函数.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;U&amp;gt; U reduce(U identity,
                 BiFunction&amp;lt;U, ? super T, U&amp;gt; accumulator,
                 BinaryOperator&amp;lt;U&amp;gt; combiner);
T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);
Optional&amp;lt;T&amp;gt; reduce(BinaryOperator&amp;lt;T&amp;gt; accumulator);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面有一个操作的演示.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list.stream()
        .sorted((s1, s2) -&amp;gt; s1.compareTo(s2) &amp;gt; 0 ? -1 : 0)
        .reduce((i, j) -&amp;gt; i + &amp;quot;#&amp;quot; + j)
        .ifPresent(System.out::println);

System.out.println(&amp;quot;---------------------------&amp;quot;);
final String join = &amp;quot;#&amp;quot;;
String joinReduce = list.stream()
        .reduce(join, (s1, s2) -&amp;gt; s1 + join + s2);
System.out.println(joinReduce);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;所有操作的代码&#34;&gt;所有操作的代码&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {

    ArrayList &amp;lt;String&amp;gt; list = new ArrayList &amp;lt;&amp;gt;();
    list.add(&amp;quot;11&amp;quot;);
    list.add(&amp;quot;12&amp;quot;);
    list.add(&amp;quot;13&amp;quot;);
    list.add(&amp;quot;14&amp;quot;);

    Comparator&amp;lt;String&amp;gt; comparator = String::compareTo;
    Predicate&amp;lt;String&amp;gt; predicate = s -&amp;gt; s.startsWith(&amp;quot;1&amp;quot;);
    IntUnaryOperator intUnaryOperator = i -&amp;gt; i + 1;
    ToIntFunction&amp;lt;String&amp;gt; toIntFunction = Integer::valueOf;
    IntConsumer consumer = System.out::println;

    list.stream()
            .filter(predicate)
            .sorted(comparator)
            .mapToInt(toIntFunction)
            .map(intUnaryOperator)
            .forEach(consumer);


    boolean anyMatch = list.stream()
            .filter(s -&amp;gt; s.startsWith(&amp;quot;1&amp;quot;))
            .sorted(String::compareTo)
            .mapToInt(Integer::valueOf)
            .mapToObj(String::valueOf)
            .mapToLong(Long::valueOf)
            .anyMatch(i -&amp;gt; i &amp;gt; 10);
    System.out.println(anyMatch);

    long count = list.stream().count();
    System.out.println(count);

    list.stream()
            .sorted((s1, s2) -&amp;gt; s1.compareTo(s2) &amp;gt; 0 ? -1 : 0)
            .reduce((i, j) -&amp;gt; i + &amp;quot;#&amp;quot; + j)
            .ifPresent(System.out::println);

    System.out.println(&amp;quot;---------------------------&amp;quot;);
    final String join = &amp;quot;#&amp;quot;;
    String joinReduce = list.stream()
            .reduce(join, (s1, s2) -&amp;gt; s1 + join + s2);
    System.out.println(joinReduce);

}
&lt;/code&gt;&lt;/pre&gt;
">Java 8 Guide E3</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-8-guide-e2/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本篇接着上篇来, 继续学习java8新特性&lt;br&gt;
&lt;a href=&#34;http://blog.didispace.com/books/java8-tutorial/&#34;&gt;Java 8 简明教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;自定义一个函数式接口&#34;&gt;自定义一个函数式接口&lt;/h1&gt;
&lt;h2 id=&#34;代码展示&#34;&gt;代码展示&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/1/17 18:23
 * @description 自定义函数式接口
 */
public class FunctionInterfaceDemo {
    public static void main(String[] args) {

        Person&amp;lt;Boolean&amp;gt; person = Objects::nonNull;
        Boolean aaa = person.say(&amp;quot;aaa&amp;quot;);
        System.out.println(&amp;quot;传入的信息是否不为空: &amp;quot; + aaa);

        Person&amp;lt;String&amp;gt; person1 = (msg) -&amp;gt; &amp;quot;Hello &amp;quot;+msg;
        String say = person1.say(&amp;quot;World&amp;quot;);
        System.out.println(say);
    }
}

@FunctionalInterface
interface Person&amp;lt;T extends Object&amp;gt; {
    T say(String msg);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;讲解&#34;&gt;讲解&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;代&lt;/em&gt; 码中定义了一个接口 &lt;strong&gt;Person&lt;/strong&gt;, 接口上使用了 &lt;strong&gt;@FunctionalInterface&lt;/strong&gt; 注解, 接口泛型Object是一个约束, 在这里只是演示. 实际场景中可以写需要被约束的父类.&lt;br&gt;
&lt;em&gt;使&lt;/em&gt; 用的时候, 实例 &lt;strong&gt;person&lt;/strong&gt; 的泛型是 &lt;strong&gt;Boolean&lt;/strong&gt; 布尔类型, 所以在表达式的右边, 也就是具体的实现上我调用了Objects的nonNull方法.  &lt;strong&gt;::&lt;/strong&gt; 表达式可以直接引用对象的方法.&lt;br&gt;
&lt;em&gt;实&lt;/em&gt; 例 &lt;strong&gt;person1&lt;/strong&gt; 的泛型是 &lt;strong&gt;String&lt;/strong&gt;  字符串类型, 所以在表达式的右边可以定义对 &lt;strong&gt;say(String msg)&lt;/strong&gt;  中msg的操作, 然后调用say()方法时就会执行上述操作.&lt;/p&gt;
&lt;h2 id=&#34;结果输出&#34;&gt;结果输出&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;传入的信息是否不为空: true
Hello World
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;内置函数式接口&#34;&gt;内置函数式接口&lt;/h1&gt;
&lt;p&gt;Java8内置了很多函数式接口便于我们使用；&lt;br&gt;
当然,我们也可以自定义函数式接口通过**@FunctionalInterface**注解声明.&lt;br&gt;
java.util.function下的接口最多支持到二元运算。有了这些接口，我们就可以省去创建接口的功夫，而直接使用lambda了。&lt;br&gt;
Nilary 零元，Unary 一元，Binary 二元，Ternary 三元，Quaternary 四元。对于一个算子来说，一个参数，就是一元运算；2个参数就是二元运算。&lt;/p&gt;
&lt;h2 id=&#34;predicate&#34;&gt;Predicate&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Predicate是一个布尔类型的函数，该函数只有一个输入参数。&lt;br&gt;
Predicate接口包含了多种默认方法，用于处理复杂的逻辑动词（and, or，negate）&lt;br&gt;
摘抄自 &lt;a href=&#34;http://blog.didispace.com/books/java8-tutorial/ch1.html&#34;&gt;http://blog.didispace.com/books/java8-tutorial/ch1.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Predicate&amp;lt;String&amp;gt; predicate = (a) -&amp;gt; a.startsWith(&amp;quot;a&amp;quot;);
Predicate&amp;lt;String&amp;gt; predicate2 = Objects::nonNull;

boolean test = predicate.negate().and(predicate2).test(&amp;quot;abc&amp;quot;);
System.out.println(test);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;consumer&#34;&gt;Consumer&lt;/h2&gt;
&lt;p&gt;Consumer 消费target type。参数 T，无返回值（void）。&lt;br&gt;
Consumer可以理解为一个消费者, 因为他没有返回值, 只接收一个参数, 按照重写的方法执行完成后即完成操作.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; consumer = System.out::println;
consumer.accept(&amp;quot;hello world&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;function&#34;&gt;Function&lt;/h2&gt;
&lt;p&gt;Function 对target type做转换。参数T，返回R。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Predicate&amp;lt;String&amp;gt; predicate = s -&amp;gt; null != s &amp;amp;&amp;amp; s.startsWith(v26);

Function&amp;lt;String, String&amp;gt; function = s -&amp;gt; predicate.test(pageInfo) ?
sdkHttpKit.ipPort().append(s).toString() :
sdkHttpKit.uri().append(&amp;quot;face/meta/&amp;quot;).append(URLUtil.encode(meta)).toString();

String url = function.apply(pageInfo);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;supplier&#34;&gt;Supplier&lt;/h2&gt;
&lt;p&gt;Supplier 供应target，可以理解为target的factory。无参，返回T。&lt;br&gt;
Supplier 可以理解为工厂类, 通过下面的演示可以看出它能够创建对象.不过我看了别人的博客, 理解为这个方法可以将耗时的操作放进去. 在没有调用get()方法之前, 是不会执行的.可以降低系统运行时间.&lt;br&gt;
Main.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Supplier&amp;lt;People&amp;gt; supplier = People::new;
// 在需要的时候可以调用get()方法获得一个新的People对象.
People people = supplier.get();
people.hello();

输出: hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;People.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class People {
    void hello() {
        System.out.println(&amp;quot;hello&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unaryoperator&#34;&gt;UnaryOperator&lt;/h2&gt;
&lt;p&gt;UnaryOperator 一元运算。继承Function接口。参数T，返回T。&lt;br&gt;
UnaryOperator 可以理解为对参数T进行处理.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UnaryOperator&amp;lt;String&amp;gt; unaryOperator = s -&amp;gt; s + &amp;quot;___&amp;quot;;
System.out.println(unaryOperator.apply(&amp;quot;hello&amp;quot;));

输出: hello___
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;binaryoperator&#34;&gt;BinaryOperator&lt;/h2&gt;
&lt;p&gt;BinaryOperator 二元运算。参数 T,返回R。&lt;br&gt;
BinaryOperator为UnaryOperator的二元运算, 它接收两个T参数, 返回的也是T参数, 可以理解对两个参数的条件操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BiPredicate&amp;lt;String, String&amp;gt; biPredicate =
    (s1, s2) -&amp;gt; s1.startsWith(&amp;quot;s1&amp;quot;) &amp;amp;&amp;amp; s2.endsWith(&amp;quot;s2&amp;quot;);

BinaryOperator&amp;lt;String&amp;gt; binaryOperator =
    // 当条件满足时, 执行三目运算的第一个操作. 否则第二个操作执行.
    (s1, s2) -&amp;gt; biPredicate.test(s1, s2) ?
    s2 + &amp;quot;_&amp;quot; + s1 : s1 + &amp;quot;_&amp;quot; + s2;
        
System.out.println(binaryOperator.apply(&amp;quot;s1&amp;quot; , &amp;quot;s2&amp;quot;));

输出: s2_s1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;comparator&#34;&gt;Comparator&lt;/h2&gt;
&lt;p&gt;这个可以用来做比较. 在上一篇已经有使用过了. 此处添加一点演示代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Supplier&amp;lt;People&amp;gt; supplier = People::new;

People people1 = supplier.get();
people1.setPeopleId(10);
People people2 = supplier.get();
people2.setPeopleId(100);

Comparator&amp;lt;People&amp;gt; comparator1 = Comparator.comparing(People::getPeopleId);
System.out.println(comparator1.compare(people2, people1));

Comparator&amp;lt;People&amp;gt; comparator2 = (p1, p2) -&amp;gt; p1.getPeopleId() &amp;gt; p2.getPeopleId() ? 1 : 0;
System.out.println(comparator2.compare(people1, people2));

第一个输出: 1  
第二个输出: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;binary&#34;&gt;Binary&lt;/h2&gt;
&lt;p&gt;Consumer、Function、Predicate分别还对应了Bi的函数式接口。&lt;br&gt;
它们的操作与对应的一元运算也是大同小异, 只是参数多了一个. 就不细讲了&lt;br&gt;
对应的也就是二元运算函数。分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BiConsumer&amp;lt;T, U&amp;gt;  接收T对象和U对象，不返回值&lt;/li&gt;
&lt;li&gt;BiPredicate&amp;lt;T, U&amp;gt; 接收T对象和U对象，返回boolean&lt;/li&gt;
&lt;li&gt;BiFunction&amp;lt;T, U, R&amp;gt; 接收T对象和U对象，返回R对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;接口一大堆, 我所理解的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Consumer, BiConsumer: 消费&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Predicate, BiPredicate: 条件判断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function, BiFunction, UnaryOperator, BinaryOperator: 参数处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Supplier: 工厂&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Java 8 Guide E2</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-8-guide-e1/"" data-c="
          &lt;h1 id=&#34;文章系学习java8新特性&#34;&gt;文章系学习Java8新特性&lt;/h1&gt;
&lt;p&gt;教程地址: &lt;a href=&#34;http://blog.didispace.com/books/java8-tutorial/&#34;&gt;Java8简明教程&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;在接口中定义默认方法&#34;&gt;在接口中定义默认方法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;通过static修饰, 该方法不可被重写.&lt;/li&gt;
&lt;li&gt;通过default修饰, 该方法不仅仅默认实现, 还可以被实现类重写&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;示例代码&#34;&gt;示例代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Created by imyzt on 2019/1/17 10:59
 * 可以在接口中定义默认方法
 */
public interface Formula {

    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }

    static int abs (int b) {
        return Math.abs(b);
    }
}

class Main {
    public static void main(String[] args) {
        Formula formula = new Formula() {
            @Override
            public double calculate(int a) {
                return sqrt(a * 1000);
            }
        };

        double calculate = formula.calculate(1);
        System.out.println(calculate);              //31.622776601683793

        double sqrt = formula.sqrt(1000);
        System.out.println(sqrt);                   //31.622776601683793

        int abs = Formula.abs(1000);
        System.out.println(abs);                    //1000
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;lambda表达式&#34;&gt;Lambda表达式&lt;/h1&gt;
&lt;p&gt;Lambda表达式是java8最大的更新了, 使得一些操作十分简单明了.&lt;/p&gt;
&lt;h2 id=&#34;不使用lambda表达式进行集合排序&#34;&gt;不使用lambda表达式进行集合排序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; names = Arrays.asList(&amp;quot;peter&amp;quot;, &amp;quot;anna&amp;quot;, &amp;quot;mike&amp;quot;, &amp;quot;xenia&amp;quot;);
Collections.sort(names, new Comparator &amp;lt;String&amp;gt;() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});        
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用lambda表达式进行集合排序&#34;&gt;使用Lambda表达式进行集合排序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; Collections.sort(names, (String a, String b) -&amp;gt; {
     return b.compareTo(a);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;不过，还可以省去返回值的表述&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Collections.sort(names, (String a, String b) -&amp;gt; b.compareTo(a));
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Lambda可以自动识别类型, 因此我们可以删除掉类型声明&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Collections.sort(names, (a, b) -&amp;gt; b.compareTo(a));
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当然, 也可以将具体动作简化&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Collections.sort(names, Comparator.reverseOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;最后, java8的jdk集合中实现了sort方法, 因此我们可以用最后这句话来实现集合的排序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;names.sort(Comparator.reverseOrder());
&lt;/code&gt;&lt;/pre&gt;
">Java 8 Guide E1</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/spring-aop-shi-xian/"" data-c="
          &lt;h1 id=&#34;常用aop代理形式&#34;&gt;常用AOP代理形式&lt;/h1&gt;
&lt;p&gt;AOP常见有静态代理和动态代理&lt;br&gt;
静态代理代表为AspectJ；&lt;br&gt;
动态代理有jdk动态代理， cglib动态代理。&lt;/p&gt;
&lt;h1 id=&#34;静态代理&#34;&gt;静态代理&lt;/h1&gt;
&lt;p&gt;AspectJ是静态代理的增强， 即编译时生成代理类， 也成为编译时增强。性能较好。 不过由于需要特定的编译器进行处理。&lt;/p&gt;
&lt;h1 id=&#34;动态代理&#34;&gt;动态代理&lt;/h1&gt;
&lt;p&gt;动态代理是每次运行的时候生成代理AOP代理类，不会修改字节码文件。代理对象创建在内存中。&lt;br&gt;
由于是在运行的时候生成代理，故性能稍差一点。&lt;/p&gt;
&lt;h1 id=&#34;jdk动态代理实例&#34;&gt;JDK动态代理实例&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author imyzt
 * @date 2019/1/17 9:51
 * @description JDK动态代理演示
 */
public class JdkDynamicProxyDemo {

    public static void main(String[] args) {

        // 创建需要被代理的实例对象
        JdkDynamicProxyClass jdkDynamicProxyClass = new JdkDynamicProxyClass();

        JdkDynamicProxyInvocationHandler invocationHandler =
                new JdkDynamicProxyInvocationHandler(jdkDynamicProxyClass);

        // 增强代理类
        // Proxy.newProxyInstance();
        JdkDynamicProxyInterface proxyInstance = (JdkDynamicProxyInterface) Proxy.newProxyInstance(
                jdkDynamicProxyClass.getClass().getClassLoader(),
                jdkDynamicProxyClass.getClass().getInterfaces(),
                invocationHandler);

        // 执行被增强的方法
        proxyInstance.proxyMethod();
    }

}

interface JdkDynamicProxyInterface {
    void proxyMethod();
}

class JdkDynamicProxyClass implements JdkDynamicProxyInterface {

    @Override
    public void proxyMethod() {
        System.out.println(&amp;quot;JDK Dynamic Proxy Method is running&amp;quot;);
    }
}

class JdkDynamicProxyInvocationHandler implements InvocationHandler {

    private Object target;

    public JdkDynamicProxyInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        String name = method.getName();

        System.out.println(&amp;quot;execute before JDK Dynamic Method = &amp;quot; + name);
        Object invoke = method.invoke(target, args);
        System.out.println(&amp;quot;execute after JDK Dynamic Method = &amp;quot; + name);

        return invoke;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果展示&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/01/snshnohgkuidrpn93pkdtlpeji.jpg&#34; alt=&#34;JDK动态代理&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;cglib-动态代理&#34;&gt;CGLIB 动态代理&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @author imyzt
 * @date 2019/1/17 10:05
 * @description CGLIB 动态代理演示
 */
public class CglibDynamicProxyDemo {

    public static void main(String[] args) {

        CglibDynamicProxy cglibDynamicProxy = new CglibDynamicProxy();

        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(CglibDynamicClass.class);
        enhancer.setCallback(cglibDynamicProxy);

        CglibDynamicClass cglibDynamicClass = (CglibDynamicClass) enhancer.create();

        String yyy = cglibDynamicClass.proxyMethod(&amp;quot;yyy&amp;quot;);

        System.out.println(yyy);


    }
}
class CglibDynamicClass {
    public String proxyMethod(String message){
        System.out.println(&amp;quot;hello! you say &amp;quot; + message);
        return message;
    }
}
class CglibDynamicProxy implements MethodInterceptor {

    @Override
    public Object intercept(Object proxyClass, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {

        String name = method.getName();

        System.out.println(&amp;quot;execute before CGLIB Dynamic Method = &amp;quot; + name);
        Object invoke = **methodProxy.invokeSuper**(proxyClass, args);
        System.out.println(&amp;quot;execute after CGLIB Dynamic Method = &amp;quot; + name);

        return invoke;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果展示&lt;br&gt;
&lt;img src=&#34;http://blog.imyzt.top/upload/2019/01/5g7aind0nsj9noqhbc3c69qd48.jpg&#34; alt=&#34;请输入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;spring-aop&#34;&gt;Spring AOP&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring AOP在使用的时候会判断，如果需要代理的类实现了接口， 则会使用JDK代理，如果没有实现接口， 则使用CGLIB代理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;JDK动态代理通过反射来接收被代理的类&lt;/strong&gt;，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。&lt;br&gt;
如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类（通过修改字节码来实现代理）。&lt;br&gt;
注意，&lt;strong&gt;CGLIB是通过继承的方式做的动态代理&lt;/strong&gt;，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。&lt;/p&gt;
&lt;p&gt;文章中部分内容转载自掘金-&lt;a href=&#34;https://juejin.im/post/5c3e9c37f265da61263862f1&#34;&gt;年糕妈妈技术团队&lt;/a&gt;&lt;/p&gt;
">Spring AOP 实现</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/powerdesigner-chang-yong-bei-wang/"" data-c="
          &lt;h2 id=&#34;创建一个实体关系&#34;&gt;创建一个实体关系&lt;/h2&gt;
&lt;p&gt;File -&amp;gt; New Model -&amp;gt; Model types -&amp;gt; Physical Data Model -&amp;gt; Physical Diagram&lt;/p&gt;
&lt;h2 id=&#34;修改code-不随着name一起改变&#34;&gt;修改code 不随着name一起改变&lt;/h2&gt;
&lt;p&gt;Tools -&amp;gt; General Options -&amp;gt; Dialog 取消勾选 Name to Code mirroring&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://blog.imyzt.top/upload/2019/01/38686k222qhk9p85h3rjbe39r4.png&#34; alt=&#34;文章配图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">PowerDesigner常用备忘</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-shi-xian-dai-ding-shi-xiao-guo-de-cache/"" data-c="
          &lt;h2 id=&#34;原文链接&#34;&gt;原文链接&lt;/h2&gt;
&lt;p&gt;CSDN:  &lt;a href=&#34;https://blog.csdn.net/qq_35030994/article/details/80871279&#34;&gt;https://blog.csdn.net/qq_35030994/article/details/80871279&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;修改了以下内容&#34;&gt;修改了以下内容&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将定时扫描过期Key的任务使用Spring注解&lt;code&gt;@Scheduled&lt;/code&gt;的cron实现&lt;/li&gt;
&lt;li&gt;将Cache改变为支持泛型，调整为单例模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;cache源代码&#34;&gt;Cache源代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package cn.anytec.cloud.bus.utils;

import cn.anytec.cloud.bus.service.ScheduledService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Cache缓存
 * @author imyzt
 */
public class Cache&amp;lt;K, V&amp;gt; {

    private static Logger LOGGER = LoggerFactory.getLogger(Cache.class);

    /**
     * 缓存最大个数
     */
    private static final Integer CACHE_MAX_NUMBER = Constant.DEFAULT_CACHE_MAX_NUMBER;
    /**
     * 当前缓存个数
     */
    private static Integer CURRENT_SIZE = 0;
    /**
     * 缓存对象
     */
    private final Map&amp;lt;K, CacheObj&amp;lt;V&amp;gt;&amp;gt; CACHE_OBJECT_MAP = new ConcurrentHashMap&amp;lt;&amp;gt;();
    /**
     * 这个记录了缓存使用的最后一次的记录，最近使用的在最前面
     */
    private final List&amp;lt;K&amp;gt; CACHE_USE_LOG_LIST = new LinkedList&amp;lt;&amp;gt;();

    /**
     * 默认Key
     */
    private final String DEFAULT_VALUE = &amp;quot;DEFAULT_VALUE&amp;quot;;

    private Cache() { }
    private static Cache cache = new Cache();

    public static Cache defaultCache() {
        return cache;
    }

    /**
     * 设置缓存
     */
    public void set(K cacheKey, V cacheValue, long cacheTime) {
        Long ttlTime = null;
        if (cacheTime &amp;lt;= 0L) {
            if (cacheTime == -1L) {
                ttlTime = -1L;
            } else {
                return;
            }
        }
        checkSize();
        saveCacheUseLog(cacheKey);
        CURRENT_SIZE = CURRENT_SIZE + 1;
        if (ttlTime == null) {
            ttlTime = System.currentTimeMillis() + cacheTime;
        }
        CacheObj&amp;lt;V&amp;gt; cacheObj = new CacheObj(cacheValue, ttlTime);
        CACHE_OBJECT_MAP.put(cacheKey, cacheObj);
        LOGGER.info(&amp;quot;have set key :&amp;quot; + cacheKey);
    }

    /**
     * 设置缓存
     */
    public void set(K cacheKey, V cacheValue) {
        set(cacheKey, cacheValue, -1L);
    }

    /**
     * 设置缓存
     */
    public void set(K cacheKey, long cacheTime) {
        set(cacheKey, (V) DEFAULT_VALUE, cacheTime);
    }

    /**
     * 获取缓存
     */
    public Object get(K cacheKey) {
        if (checkCache(cacheKey)) {
            saveCacheUseLog(cacheKey);
            return CACHE_OBJECT_MAP.get(cacheKey).getCacheValue();
        }
        return null;
    }

    /**
     * 是否包含某一个Key值
     * @param cacheKey
     * @return
     */
    public  boolean containsKey(K cacheKey) {
        return checkCache(cacheKey);
    }

    /**
     * 删除所有缓存
     */
    public void clear() {
        LOGGER.info(&amp;quot;have clean all key !&amp;quot;);
        CACHE_OBJECT_MAP.clear();
        CURRENT_SIZE = 0;
    }

    /**
     * 删除某个缓存
     */
    public void del(K cacheKey) {
        Object cacheValue = CACHE_OBJECT_MAP.remove(cacheKey);
        if (cacheValue != null) {
            LOGGER.info(&amp;quot;have delete key :&amp;quot; + cacheKey);
            CURRENT_SIZE = CURRENT_SIZE - 1;
        }
    }

    /**
     * 判断缓存在不在,过没过期
     */
    private boolean checkCache(K cacheKey) {
        CacheObj cacheObj = CACHE_OBJECT_MAP.get(cacheKey);
        if (cacheObj == null) {
            return false;
        }
        if (cacheObj.getTtlTime() == -1L) {
            return true;
        }
        if (cacheObj.getTtlTime() &amp;lt; System.currentTimeMillis()) {
            del(cacheKey);
            return false;
        }
        return true;
    }

    /**
     * 删除最近最久未使用的缓存
     */
    private void deleteLRU() {
        LOGGER.info(&amp;quot;delete Least recently used run!&amp;quot;);
        K cacheKey = CACHE_USE_LOG_LIST.remove(CACHE_USE_LOG_LIST.size() - 1);
        del(cacheKey);
    }

    /**
     * 删除过期的缓存
     * 禁止手动调用! 由定时任务定时拉起
     * @see ScheduledService#deleteTimeOut()
     */
    public void deleteTimeOut() {
        LOGGER.info(&amp;quot;delete time out run!&amp;quot;);
        List&amp;lt;K&amp;gt; deleteKeyList = new LinkedList&amp;lt;&amp;gt;();
        for(Map.Entry&amp;lt;K, CacheObj&amp;lt;V&amp;gt;&amp;gt; entry : CACHE_OBJECT_MAP.entrySet()) {
            if (entry.getValue().getTtlTime() &amp;lt; System.currentTimeMillis() &amp;amp;&amp;amp; entry.getValue().getTtlTime() != -1L) {
                deleteKeyList.add(entry.getKey());
            }
        }

        for (K deleteKey : deleteKeyList) {
            del(deleteKey);
        }
        LOGGER.info(&amp;quot;delete cache count is :&amp;quot; + deleteKeyList.size());

    }

    /**
     * 检查大小
     * 当当前大小如果已经达到最大大小
     * 首先删除过期缓存，如果过期缓存删除过后还是达到最大缓存数目
     * 删除最久未使用缓存
     */
    private  void checkSize() {
        if (CURRENT_SIZE &amp;gt;= CACHE_MAX_NUMBER) {
            deleteTimeOut();
        }
        if (CURRENT_SIZE &amp;gt;= CACHE_MAX_NUMBER) {
            deleteLRU();
        }
    }

    /**
     * 保存缓存的使用记录
     */
    private synchronized void saveCacheUseLog(K cacheKey) {
        CACHE_USE_LOG_LIST.remove(cacheKey);
        CACHE_USE_LOG_LIST.add(0, cacheKey);
    }

    public  void showUtilsInfo() {
        System.out.println(&amp;quot;cache max count is :&amp;quot; + CACHE_MAX_NUMBER);
        System.out.println(&amp;quot;cache current count is :&amp;quot; + CURRENT_SIZE);
        System.out.println(&amp;quot;cache object map is :&amp;quot; + CACHE_OBJECT_MAP.toString());
        System.out.println(&amp;quot;cache use log list is :&amp;quot; + CACHE_USE_LOG_LIST.toString());

    }

}

class CacheObj&amp;lt;V&amp;gt; {
    /**
     * 缓存对象
     */
    private V cacheValue;
    /**
     * 缓存过期时间
     */
    private Long ttlTime;

    CacheObj(V cacheValue, Long ttlTime) {
        this.cacheValue = cacheValue;
        this.ttlTime = ttlTime;
    }

    Object getCacheValue() {
        return cacheValue;
    }

    Long getTtlTime() {
        return ttlTime;
    }

    @Override
    public String toString() {
        return &amp;quot;CacheObj{&amp;quot; +
                &amp;quot;cacheValue=&amp;quot; + cacheValue +
                &amp;quot;, ttlTime=&amp;quot; + ttlTime +
                &#39;}&#39;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定时任务&#34;&gt;定时任务&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class ScheduledService {

    @Scheduled(cron = &amp;quot;${bus.cache-delete-cycle}&amp;quot;)
    public void deleteTimeOut() {
        Cache.defaultCache().deleteTimeOut();
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Java实现带定时效果的Cache</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/ping-bi-bai-jia-hao/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;自从百家号发布后，使用百度搜索内容，前几条全部都是百家号的抄袭文章。使用体验非常不爽。&lt;/p&gt;
&lt;h2 id=&#34;寻找解决方法&#34;&gt;寻找解决方法&lt;/h2&gt;
&lt;p&gt;前段时间看到有人用&lt;a href=&#34;https://tampermonkey.net/&#34;&gt;油猴&lt;/a&gt;写了一个&lt;a href=&#34;https://greasyfork.org/zh-CN/scripts/13468-ac-csdn%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80-csdn%E8%87%AA%E5%8A%A8%E8%AF%84%E8%AE%BA&#34;&gt;自动展开CSDN【阅读全文】&lt;/a&gt;的脚本，大有启发，然后用油猴写了几句非常简单的js脚本，结合&lt;a href=&#34;https://www.baidu.com/gaoji/advanced.html&#34;&gt;百度高级搜索&lt;/a&gt;的 &lt;code&gt;-()&lt;/code&gt; 命令，解决了这个烦恼许久问题。&lt;/p&gt;
&lt;p&gt;代码如下，导入油猴即可使用（非常简单，主要提供了思路，路过大神勿喷）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ==UserScript==
// @author        imyzt
// @namespace     http://imyzt.top/28
// @version       1.0
// @name          exclude baijiahao
// @namespace     http://imyzt.top
// @description   屏蔽百家号
// @include       https://www.baidu.com/*
// ==/UserScript==

// 文本框的值
var wd = document.getElementById(&#39;kw&#39;).value;
// 当输入框中有值或者 文本框不包含-(baijiahao)字眼时, 执行变更, 然后刷新页面
if (wd !== &#39;&#39; &amp;amp;&amp;amp; wd.indexOf(&#39;-(baijiahao)&#39;) == -1) {
    changeValAndReload(wd)
}

// 监听在文本框加入内容的事件
$(&#39;#kw&#39;).on(&#39;change&#39;, function() {
    var value = document.getElementById(&#39;kw&#39;).value;
    var rep = value.replace(&amp;quot;-(baijiahao)&amp;quot;,&amp;quot;&amp;quot;);
    changeValAndReload(rep)
});

// 修改值
function changeValAndReload(val) {
    document.getElementById(&#39;kw&#39;).value = val + &#39; -(baijiahao)&#39;;
    document.getElementById(&#39;su&#39;).click()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;授人以渔&#34;&gt;授人以渔&lt;/h2&gt;
&lt;p&gt;油猴的脚本更多就是JavaScript的操作，如果需要学习，可以 &lt;a href=&#34;http://old.sebug.net/paper/books/greasemonkey/&#34;&gt;点击这里&lt;/a&gt;, 前往学习.&lt;/p&gt;
">屏蔽百家号</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/ji-lu-cong-github-qian-yi-dao-gitlabfei-zui-you-jie/"" data-c="
          &lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;
&lt;p&gt;公司搭建了自己的代码仓库，使用的gitlab，需要将github上面的代码迁移至本地gitlab仓库。&lt;/p&gt;
&lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;
&lt;p&gt;1.在公司代码库建立一个新的代码库&lt;br&gt;
2. 修改本地代码库的git remote地址&lt;br&gt;
3. 提交代码到新的gitlab代码库&lt;/p&gt;
&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;因为公司使用git提交流程,需要先设置公司主仓库为上游，然后fetch，merge完成提交。所以还修改了git upstream地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先在gitlab上面新建主仓库，使用自己的账号fork主仓库代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地修改git remote地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git remote remove origin # 删除远程仓库别名  
git remote remove upstream # 删除上游仓库别名  
git remote add origin git@....... # 添加新的仓库地址  
git remote add upstream git@...... # 添加新的上游仓库地址  
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;拉取上游和远程仓库&lt;br&gt;
git pull origin master # 拉取远程仓库&lt;br&gt;
git fetch upstream  # fetch源分支的新版本到本地, 也就是更新upstream主仓库的代码.&lt;br&gt;
git merge upstream/master  # 合并主仓库更新的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提交本地未提交代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git add . # 提交所有未提交内容到缓存区  
git commit -m &#39;xxxx&#39; # 为本次提交撰写评论信息&amp;lt;fort clolr=&#39;red&#39;&amp;gt;! 必须&amp;lt;/fort&amp;gt;  
git push origin master # 提交代码到远程仓库  
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;在gitlab界面提交PR请求.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;遇到的问题&#34;&gt;遇到的问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在上述第三步操作时，遇到了问题，错误信息如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$ git pull upstream   
remote: HTTP Basic: Access denied   
fatal: Authentication failed for &#39;git仓库地址&#39;   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误原因：访问被拒绝，本地最好配置ssh连接，不要使用http拉取。gitlab都有密码的。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在进行git push时遇到的问题，错误信息如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$ git push origin master   
To git仓库地址 
 ! [rejected]        master -&amp;gt; master (fetch first)  
error: failed to push some refs to &#39;git仓库地址&#39;   
hint: Updates were rejected because the remote contains work that you do   
hint: not have locally. This is usually caused by another repository pushing   
hint: to the same ref. You may want to first integrate the remote changes   
hint: (e.g., &#39;git pull ...&#39;) before pushing again.   
hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误原因：本地代码相对于远程仓库不是最新的代码，需要使用git pull origin xxx  先拉取最新代码&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;在进行git pull时又遇到了问题.错误信息如下:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$ git pull origin master  
From git仓库地址  
 * branch            master     -&amp;gt; FETCH_HEAD    
fatal: refusing to merge unrelated histories  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误原因：因为我们是在gitlab新建了一个仓库，然后将本地本身是github的代码提交过去，git提示我们不能将两个完全不相干的仓库合并。&lt;br&gt;
解决方法就是加上·--allow-unrelated-histories·参数，参数含义是：&lt;strong&gt;强制&lt;/strong&gt;将两个不相干的仓库合并。&lt;br&gt;
&lt;fort clolr=&#39;red&#39;&gt;! 此操作风险较大，必须保证gitlab新仓库没有代码，不然合并过程中可能出现冲突&lt;/fort&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，迁移仓库的不完美解决方案就算完成了。&lt;/p&gt;
&lt;p&gt;上述只是git操作中的沧海一粟，只有通过不断的学习，才能进步。&lt;/p&gt;
">记录从Github迁移到Gitlab(非最优解)</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/java-jar-qi-dong-springboot-xian-shang-bao-cuo-filenotfoundexception/"" data-c="
          &lt;h2 id=&#34;发现问题&#34;&gt;发现问题&lt;/h2&gt;
&lt;p&gt;今天在将项目打包放在线上后，遇到了一个问题，错误堆栈如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.io.FileNotFoundException: /tmp/tomcat.3411451253170172517.9998/work/Tomcat/localhost/ROOT/upload_95a9f6c4_32ff_4372_a19b_c447216971a3_00000017.tmp (No such file or directory)
	at java.io.FileInputStream.open0(Native Method)
	at java.io.FileInputStream.open(FileInputStream.java:195)
	at java.io.FileInputStream.&amp;lt;init&amp;gt;(FileInputStream.java:138)
	at org.apache.tomcat.util.http.fileupload.disk.DiskFileItem.getInputStream(DiskFileItem.java:194)
	at org.apache.catalina.core.ApplicationPart.getInputStream(ApplicationPart.java:100)
	at org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile.getInputStream(StandardMultipartHttpServletRequest.java:250)
	at cn.anytec.anguan.util.SpringAsyncUtil.analyseDataPersistence(SpringAsyncUtil.java:33)
	at cn.anytec.anguan.util.SpringAsyncUtil$$FastClassBySpringCGLIB$$9155c306.invoke(&amp;lt;generated&amp;gt;)
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.aop.interceptor.AsyncExecutionInterceptor.lambda$invoke$0(AsyncExecutionInterceptor.java:115)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.lang.Thread.run(Thread.java:748)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分析问题&#34;&gt;分析问题&lt;/h2&gt;
&lt;p&gt;代码逻辑主要是将摄像头传递过来的图片进行保存，在开发机win上面没有问题，并且在Linux线上，&lt;strong&gt;第一次报错&lt;/strong&gt;，&lt;strong&gt;第二次不会报错&lt;/strong&gt;，成功运行。&lt;/p&gt;
&lt;h2 id=&#34;寻找解决方案&#34;&gt;寻找解决方案&lt;/h2&gt;
&lt;p&gt;问题比较离奇，遂Google寻找解决方案。&lt;/p&gt;
&lt;p&gt;发现已经有大神遇到过此问题，并且给出了完整的解决方案和错误原理分析。&lt;br&gt;
链接：&lt;a href=&#34;https://blog.csdn.net/superlover_/article/details/80895946&#34;&gt;superlovelei&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;解决方案及总结&#34;&gt;解决方案及总结&lt;/h2&gt;
&lt;p&gt;虽然大神已经给出了原因，我再次再做一次表述吧。&lt;br&gt;
在Linux系统中，通过java -jar 运行的项目，会在操作系统的 &lt;code&gt;/tmp/tomcat...&lt;/code&gt; 目录下新建一个目录，上传的文件都会先临时存放在此，而由于linux的系统机制，如果&lt;strong&gt;超过10天&lt;/strong&gt;没有操作过此文件目录，会将目录删除，所以如果当前linux主机第一次运行上传相关的程序或者很久（超过10天）没有操作过此临时目录，就会出现报错。&lt;/p&gt;
&lt;p&gt;而通过配置springboot的yml文件，修改server的配置文件，手动指定临时目录（不会被机制删除的路径），此问题就迎刃而解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server:
  tomcat:
    basedir: /tmp
&lt;/code&gt;&lt;/pre&gt;
">java -jar 启动Springboot线上报错FileNotFoundException</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mongodb-xue-xi-bi-ji-ru-men/"" data-c="
          &lt;h3 id=&#34;教程的主要内容&#34;&gt;教程的主要内容&lt;/h3&gt;
&lt;p&gt;MongoDB的基础概念，数据库、集合的创建、基础的增删改查、高级查询的聚合管道&lt;/p&gt;
&lt;h3 id=&#34;mongodb是什么它有什么优势为什么要用它&#34;&gt;MongoDB是什么？它有什么优势（为什么要用它）？&lt;/h3&gt;
&lt;h4 id=&#34;mongodb是什么&#34;&gt;MongoDB是什么：&lt;/h4&gt;
&lt;p&gt;MongoDB是一款为web应用程序和互联网基础设施设计的数据库管理系统。是&lt;strong&gt;NoSQL&lt;/strong&gt;类型的数据库。同时也是最像关系型数据库的非关系型数据库。&lt;/p&gt;
&lt;h4 id=&#34;为什么要用mongodb&#34;&gt;为什么要用MongoDB：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;MongoDB提出的是文档、集合的概念，使用BSON（类JSON）作为其数据模型结构，其结构是面向对象的而不是二维表，存储一个用户在MongoDB中是这样子的。&lt;/p&gt;
&lt;p&gt;{&lt;br&gt;
username: &#39;imyzt&#39;,&lt;br&gt;
password: &#39;123&#39;&lt;br&gt;
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用这样的数据模型，使得MongoDB能在生产环境中提供高读写的能力，吞吐量较于mysql等SQL数据库大大增强。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;易伸缩，自动故障转移。易伸缩指的是提供了分片能力，能对数据集进行分片，数据的存储压力分摊给多台服务器。自动故障转移是副本集的概念，MongoDB能检测主节点是否存活，当失活时能自动提升从节点为主节点，达到故障转移。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据模型因为是面向对象的，所以可以表示丰富的、有层级的数据结构，比如博客系统中能把“评论”直接嵌入“文章“的文档中，而不必像myqsl一样创建三张表来描述这样的关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">MongoDB学习笔记(入门)</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/mysql-sql-yu-ju-zhi-xing-xiao-lu-fen-xi/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;今天在掘金看到了一篇关于SQL优化的文章(&lt;a href=&#34;https://juejin.im/post/5bcc2935f265da0ac66987c9?utm_source=gold_browser_extension&#34;&gt;原文在此&lt;/a&gt;)，了解到了Explain工具。本文则是对Explain工具的学习和总结。&lt;/p&gt;
&lt;h3 id=&#34;sql语句性能分析工具explain&#34;&gt;SQL语句性能分析工具Explain&lt;/h3&gt;
&lt;p&gt;Explain的作用是生成一个QEP（查询执行计划），可以帮助我们在不真正执行SQL的情况下，就能看到SQL怎样执行。&lt;/p&gt;
&lt;p&gt;执行以下语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXPLAIN SELECT * FROM t_options WHERE `name` IS NOT NULL GROUP BY `name`   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到如下结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://www.imyzt.top/upload/2018/10/q15jvjiuliifcpsncbsdvqpipk.jpg&#34; alt=&#34;SQL执行结果&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对于返回信息，主要关注点在如下几个字段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Type&lt;br&gt;
ALL是全表扫描，效率低；其它的index、range、const、ref、system则是比较好的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Possible_keys&lt;br&gt;
可能被用到的索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Key&lt;br&gt;
查询过程中用到的索引，当为null时，表示没有使用索引，通常是不好的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ken_len&lt;br&gt;
索引字段最大可能使用的长度，也叫索引基数。索引基数越大，表示可能查询的行数越多，查询效率越低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rows&lt;br&gt;
MySQL估计的需要扫描的行数，只是估计，越多表示查询的行数越大，自然越慢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Extra&lt;br&gt;
显示上述信息之外的其它信息，非常重要。其主要有一下返回结果。&lt;/p&gt;
&lt;p&gt;Usingindex&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;表明此查询使用了覆盖索引(CoveringIndex)，即通过索引就能返回结果，无需访问表。（覆盖索引是一种非常优秀的索引，其使用见http://blog.csdn.net/hzy38324/article/details/44857721）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;若没显示&amp;quot;Usingindex&amp;quot;表示读取了表数据。&lt;br&gt;
Usingindex condition&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    可能会使用索引    

Usingwhere    

    表示 MySQL 服务器先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。效率较慢。
Usingfilesort    

    表示Mysql会按查询所需的顺序对结果进行排序，这时就会出现 Usingfilesort 。排序自然会增加查询时间，导致效率变慢。解决方法是利用索引进行排序。若查询所需的排序与使用的索引的排序一致，因为索引是已排序的，因此按索引的顺序读取结果返回，此时就不会出现Using filesort。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于“Using index” 和 “Using index condition”的区别，笔者参考了一下&lt;a href=&#34;http://stackoverflow.com/questions/1687548/mysql-explain-using-index-vs-using-index-condition&#34;&gt;stackoverflow&lt;/a&gt;上的一篇文章&lt;br&gt;
简单的说&lt;br&gt;
Using index就是一定使用索引，这种索引成为覆盖索引，Using index condition则是在必要的时候才使用索引&lt;br&gt;
怎样才能让Usingindex condition变成Using index，答案自然是创建一个覆盖索引，同样，笔者将会在之后章节介绍覆盖索引如何创建。&lt;/p&gt;
&lt;p&gt;参考链接： &lt;a href=&#34;https://blog.csdn.net/hzy38324/article/details/44921299&#34;&gt;CSDN&lt;/a&gt;&lt;/p&gt;
">MySQL SQL语句执行效率分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/deng-shan-zu-dui/"" data-c="
          &lt;h3 id=&#34;七娘山介绍&#34;&gt;七娘山介绍&lt;/h3&gt;
&lt;p&gt;七娘山位于龙岗区南澳镇新大村，是大鹏半岛南岛的主要山峰，是深圳市内山脉中仅次于梧桐山的第二高峰。它有七个山峰，主峰海拔高度867米。传说有七个仙女下凡到山上游玩而得名。在抗日战争时期东江纵队曾在山北鸡公秃村办兵工厂，并在山下种过粮食。&lt;/p&gt;
&lt;h3 id=&#34;活动时间&#34;&gt;活动时间&lt;/h3&gt;
&lt;p&gt;2018年11月24日 - 2018年11月25日&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;行程不是固定的，大家讨论后决定时间。此时间只做参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;山车地点&#34;&gt;山车地点&lt;/h3&gt;
&lt;p&gt;深圳市地铁三号线爱联地铁站&lt;/p&gt;
&lt;h3 id=&#34;出行方式&#34;&gt;出行方式&lt;/h3&gt;
&lt;p&gt;打车前往&lt;/p&gt;
&lt;h3 id=&#34;预计费用&#34;&gt;预计费用&lt;/h3&gt;
&lt;p&gt;150/人，不包含烧烤等餐饮。&lt;/p&gt;
&lt;h3 id=&#34;天气预报&#34;&gt;天气预报&lt;/h3&gt;
&lt;p&gt;深圳天气：&lt;a href=&#34;http://www.weather.com.cn/html/weather/101280601.shtml&#34;&gt;http://www.weather.com.cn/html/weather/101280601.shtml&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;行程及路线安排&#34;&gt;行程及路线安排&lt;/h3&gt;
&lt;h5 id=&#34;路线一&#34;&gt;路线一&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;第一天&lt;strong&gt;中午&lt;/strong&gt;市内爱联站集合，打车前往到杨梅坑（预计1小时13分钟，见附图四），然后在杨梅坑腐败一天，杨梅坑5KM处鹿嘴山庄是《美人鱼》拍摄取景地，杨梅坑附近还有著名的露天烧烤。&lt;/li&gt;
&lt;li&gt;第二天早上出发按照&lt;a href=&#34;http://www.foooooot.com/trip/863749/&#34;&gt;轨迹一&lt;/a&gt;（见附图五）开始登山。下午三点左右就能到大鹏半岛地质公园。然后选择公交或打车回到市内。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;选择大鹏半岛地质公园为下山点，回程较为便利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;路线二&#34;&gt;路线二&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;第一天同路线一。&lt;/li&gt;
&lt;li&gt;第二天早上出发按照&lt;a href=&#34;http://www.foooooot.com/trip/119446/&#34;&gt;轨迹二&lt;/a&gt;（见附图六）开始登山。预计下午两点左右就能回到深圳东冲海岸。欣赏一下大海景后选择公交或打车回到市内。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;东冲为深圳最美海岸，可以欣赏海景。但是东冲作为深圳最后一个没有省级公路的村，做为下山点可能回程不是特别便利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;路线三&#34;&gt;路线三&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;第一天&lt;strong&gt;上午&lt;/strong&gt;市内爱联站集合，打车前往大鹏半岛地质公园（预计1小时9分钟，见附图五），然后按照&lt;a href=&#34;http://www.foooooot.com/trip/127325/&#34;&gt;轨迹三&lt;/a&gt;(见附图八)开始登山，当天晚上能到杨梅坑。然后可以选择&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;继续腐败，然后露营，BBQ。第二天通过打车或公交从杨梅坑返回市内。&lt;/li&gt;
&lt;li&gt;下山后返回市内。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;此路线轨迹类似于路线一，但是大有不同。此路线走的山脊线，攀登较为容易。大部分地段已铺石台阶。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;路线四&#34;&gt;路线四&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;第一天同路线一。&lt;/li&gt;
&lt;li&gt;第二天早上出发按照&lt;a href=&#34;http://www.foooooot.com/trip/258524/&#34;&gt;轨迹四&lt;/a&gt;（见附图九）开始登山。预计中午能到地质公园。然后选择公交或打车回到市内。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;路线比较短，耗时少。走的另一座山谷，风景不必路线一差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;线路对比&#34;&gt;线路对比&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;路线距离：线路一（14.3 公里） &amp;gt; 线路三（12.9 公里） &amp;gt;  线路二（13 公里）  &amp;gt; 路线四(7.6 公里)&lt;/li&gt;
&lt;li&gt;耗时对比：线路一（2天）== 线路二（2天） &amp;gt; 线路四（2天） &amp;gt; 线路三(1天或2天)&lt;/li&gt;
&lt;li&gt;难度级别：线路一 &amp;gt; 线路三 &amp;gt; 线路二 &amp;gt; 路线四&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;个人装备&#34;&gt;个人装备&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;普通装备：双肩背包、手机、雨具；&lt;/li&gt;
&lt;li&gt;服装：徒步鞋或者军胶、长袖衣裤、太阳帽、手套、毛巾；&lt;/li&gt;
&lt;li&gt;食品：一餐干粮、3升以上饮用水、功能饮料、榨菜、水果等零食；&lt;/li&gt;
&lt;li&gt;药品：蛇药、马蜂药、创可贴、蚊怕水、个人特殊品 、十滴水、霍香正气水等防暑用品；&lt;/li&gt;
&lt;li&gt;其他：头灯、手电、垃圾袋（自己带走垃圾）、个人证件 、少量现金；&lt;/li&gt;
&lt;li&gt;露营装备：帐篷，睡袋（15度以下），防潮垫。&lt;/li&gt;
&lt;li&gt;务必购买户外运动保险，保险不是万能的，但少了保险是万万不能的！建议买一份保险做一个有责任心的人&lt;br&gt;
&lt;font color=&#39;red&#39;&gt;活动自愿，风险自担，雨天顺延&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;本次活动无领队，属约伴同行，共同学习 。&lt;/li&gt;
&lt;li&gt;请报名前做好功课，了解线路的行程线（下撤路线）、难度和强度再决定是否参加。&lt;/li&gt;
&lt;li&gt;活动所有集体行为全部AA。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;免责声明&#34;&gt;免责声明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;本活动为非盈利性质的自助游活动并有一定的危险性，凡报名参加者均视为具有完全民事行为能力人，参加者须对自己的安全负责；凡报名者均视为已接受放弃损害赔偿 。&lt;/li&gt;
&lt;li&gt;本次活动约伴人与同行驴友均为无偿提供活动的援助、支持者。如在活动中发生人身损害后果，赔偿责任领队不承担，由受损害人依据法律规定和本领队声明依法解决。&lt;/li&gt;
&lt;li&gt;凡报名者均视为接受声明。代他人报名者，被代报名参加者如遭受人身损害，赔偿责任约伴人同样不承担。&lt;/li&gt;
&lt;li&gt;本声明中关于免除领队赔偿责任之约定效力，同样及于同行的副领队.协助.财务。&lt;/li&gt;
&lt;li&gt;启程后，本声明将自动生效并表明你接受本声明，否则，请在启程前退出本次活动。&lt;/li&gt;
&lt;li&gt;任何法律纠纷在出发地所在法院处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;攻略参考文档&#34;&gt;攻略参考文档&lt;/h2&gt;
&lt;p&gt;8264：&lt;a href=&#34;http://bbs.8264.com/thread-2113100-1-1.html&#34;&gt;http://bbs.8264.com/thread-2113100-1-1.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;附图&#34;&gt;附图&lt;/h2&gt;
&lt;h4 id=&#34;附图三七娘山地图&#34;&gt;附图三：七娘山地图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;http://imyzt.top/upload/2018/10/7kg9dntqimi5tolgdafebtjghr.jpg&#34; alt=&#34;七娘山地图&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1699751313457.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;附图四爱联站-杨梅坑&#34;&gt;附图四：爱联站-杨梅坑&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://www.imyzt.top/upload/2018/11/on0a1d4g1kjjarv9tkjoslugtk.jpg&#34; alt=&#34;爱联站-杨梅坑&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;附图五-轨迹一&#34;&gt;附图五： 轨迹一&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://www.imyzt.top/upload/2018/11/ttvmvifde8hljqiepu5up78icp.jpg&#34; alt=&#34;轨迹一&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;附图六-轨迹二&#34;&gt;附图六： 轨迹二&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://www.imyzt.top/upload/2018/11/uafoe9dan4ib4ogsgqcaop03gt.jpg&#34; alt=&#34;轨迹二&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;附图七-爱联站-地质公园&#34;&gt;附图七： 爱联站-地质公园&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://www.imyzt.top/upload/2018/11/00d0175vgqgs7o6qavuv9njgr7.jpg&#34; alt=&#34;爱联站-地质公园&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;附图八轨迹三&#34;&gt;附图八：轨迹三&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://www.imyzt.top/upload/2018/11/s79uqfkb62ihqrkqj94cmior2h.jpg&#34; alt=&#34;轨迹三&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;附图九轨迹四&#34;&gt;附图九：轨迹四&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://www.imyzt.top/upload/2018/11/0s5kuudcfsia9rlueao34btqgn.jpg&#34; alt=&#34;轨迹四&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">登山组队</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/hello-world/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1699755949931.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;关于我&#34;&gt;关于我&lt;/h2&gt;
&lt;p&gt;我叫杨镇涛，是一名Java程序员。&lt;br&gt;
现阶段本职工作是Java服务端开发, 平时会花一些时间做 Kubernetes 以及 Spring Cloud 方面的学习研究.&lt;/p&gt;
&lt;h2 id=&#34;关于项目&#34;&gt;关于项目&lt;/h2&gt;
&lt;p&gt;项目fork 自 &lt;a href=&#34;https://github.com/ZHENFENG13&#34;&gt;ZHENFENG13&lt;/a&gt; 大神的 &lt;a href=&#34;https://github.com/ZHENFENG13/My-Blog&#34;&gt;My-Blog&lt;/a&gt;， 我对它做了一些私人订制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mybatis -&amp;gt; Mybatis Plus&lt;/li&gt;
&lt;li&gt;实体类使用lombok&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;开源&#34;&gt;开源&lt;/h2&gt;
&lt;p&gt;感谢原作者 tale 的项目， 也感谢 &lt;a href=&#34;https://github.com/ZHENFENG13&#34;&gt;ZHENFENG13&lt;/a&gt; 将其改版为Spring版本。&lt;br&gt;
我的修改版本在我的 &lt;a href=&#34;https://github.com/imyzt/My-Blog&#34;&gt;Github&lt;/a&gt; 上。有问题欢迎留言。&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;WeChat&lt;br&gt;
&lt;img src=&#34;https://imyzt.top/post-images/1699755922644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Hello World</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://imyzt.top/post/ni-hao/"" data-c="
          &lt;p&gt;这是我的个人博客,正在建设中...&lt;br&gt;
欢迎你的来访.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://imyzt.top/post-images/1699755680060.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">你好</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;关于 &lt;code&gt;MCP&lt;/code&gt; 是什么就不在此赘述，可以看这篇文章：&lt;a href=\&#34;https://docs.trae.com.cn/ide/model-context-protocol\&#34;&gt;模型上下文协议（MCP）&lt;br&gt;\n&lt;/a&gt;，目前 &lt;code&gt;Trae&lt;/code&gt; 已经支持 &lt;code&gt;MCP&lt;/code&gt;，网上还没有什么教程，本文记录下自己安装的过程。&lt;/p&gt;\n&lt;h1 id=\&#34;1-首先安装-trae-海外版\&#34;&gt;1. 首先安装 Trae 海外版&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.trae.ai/\&#34;&gt;https://www.trae.ai/&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;2-在-chat-中通过-唤起-添加智能体\&#34;&gt;2. 在 &lt;code&gt;Chat&lt;/code&gt; 中通过 &lt;code&gt;@&lt;/code&gt; 唤起: &lt;code&gt;添加智能体&lt;/code&gt;&lt;/h1&gt;\n&lt;p&gt;按照下面的步骤添加一个 &lt;code&gt;MCP Server&lt;/code&gt;，此处以 &lt;code&gt;MySQL MCP Server&lt;/code&gt; 为例。&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1749265319195.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1749265326233.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1749265331930.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1749265337881.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;3-根据-mysql-mcp-server-的-github-page-页面安装依赖\&#34;&gt;3. 根据 MySQL MCP Server 的 Github Page 页面安装依赖&lt;/h1&gt;\n&lt;p&gt;安装完成后，点击上图预览，即可打开Github查看该MCP Server的安装教程。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1749265511011.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;官方使用 &lt;code&gt;pip install mysql-mcp-server&lt;/code&gt; 进行安装，但我安装老是失败，通过搜索issue，发现也有类似的情况， &lt;a href=\&#34;https://github.com/designcomputer/mysql_mcp_server/issues/33\&#34;&gt;issue&lt;/a&gt; 建议使用 &lt;code&gt;uv pip install mysql-mcp-server&lt;/code&gt; 进行安装，我切换为 &lt;code&gt;uv&lt;/code&gt; 之后就安装成功了。&lt;/p&gt;\n&lt;h1 id=\&#34;4-配置-mcp-server\&#34;&gt;4. 配置 MCP Server&lt;/h1&gt;\n&lt;p&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1749265854609.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n点击编辑按钮，因为我们使用的是 &lt;code&gt;uv&lt;/code&gt; 安装的 &lt;code&gt;MySQL MCP Server&lt;/code&gt;，所以需要将下面的JSON替换掉官方的默认JSON，然后替换自己的数据库信息。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-json\&#34;&gt;{\n  &amp;quot;mcpServers&amp;quot;: {\n    &amp;quot;MySQL Server&amp;quot;: {\n      &amp;quot;command&amp;quot;: &amp;quot;uvx&amp;quot;,\n      &amp;quot;args&amp;quot;: [\n        &amp;quot;--from&amp;quot;,\n        &amp;quot;mysql-mcp-server&amp;quot;,\n        &amp;quot;mysql_mcp_server&amp;quot;\n      ],\n      &amp;quot;env&amp;quot;: {\n        &amp;quot;MYSQL_DATABASE&amp;quot;: &amp;quot;dbname&amp;quot;,\n        &amp;quot;MYSQL_HOST&amp;quot;: &amp;quot;host&amp;quot;,\n        &amp;quot;MYSQL_PASSWORD&amp;quot;: &amp;quot;password&amp;quot;,\n        &amp;quot;MYSQL_PORT&amp;quot;: &amp;quot;3306&amp;quot;,\n        &amp;quot;MYSQL_USER&amp;quot;: &amp;quot;username&amp;quot;\n      }\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;5-使用mcp\&#34;&gt;5. 使用MCP&lt;/h1&gt;\n&lt;p&gt;配置上面的信息后，就可以在 Chat 中和 MCP 进行对话了，他会协助我们查询数据库。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1749266042790.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1749266277703.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;mcp-chu-ti-yan-trae-jie-ru-mysql-mcp-server&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MCP初体验，Trae接入MySQL MCP Server&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MCP&#34;,&#34;slug&#34;:&#34;cq1zuJAJwA&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/cq1zuJAJwA/&#34;},{&#34;name&#34;:&#34;AI&#34;,&#34;slug&#34;:&#34;a3ySf_aXex&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/a3ySf_aXex/&#34;},{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;uTOj96mue&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/uTOj96mue/&#34;}],&#34;date&#34;:&#34;2025-06-07 10:55:12&#34;,&#34;dateFormat&#34;:&#34;2025-06-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mcp-chu-ti-yan-trae-jie-ru-mysql-mcp-server/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:90000,&#34;words&#34;:357,&#34;minutes&#34;:2},&#34;description&#34;:&#34;关于 MCP 是什么就不在此赘述，可以看这篇文章：模型上下文协议（MCP）\n，目前 Trae 已经支持 MCP，网上还没有什么教程，本文记录下自己安装的过程。\n1. 首先安装 Trae 海外版\nhttps://www.trae.ai/\n2....&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E9%A6%96%E5%85%88%E5%AE%89%E8%A3%85-trae-%E6%B5%B7%E5%A4%96%E7%89%88\&#34;&gt;1. 首先安装 Trae 海外版&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%9C%A8-chat-%E4%B8%AD%E9%80%9A%E8%BF%87-%E5%94%A4%E8%B5%B7-%E6%B7%BB%E5%8A%A0%E6%99%BA%E8%83%BD%E4%BD%93\&#34;&gt;2. 在 &lt;code&gt;Chat&lt;/code&gt; 中通过 &lt;code&gt;@&lt;/code&gt; 唤起: &lt;code&gt;添加智能体&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E6%A0%B9%E6%8D%AE-mysql-mcp-server-%E7%9A%84-github-page-%E9%A1%B5%E9%9D%A2%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96\&#34;&gt;3. 根据 MySQL MCP Server 的 Github Page 页面安装依赖&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E9%85%8D%E7%BD%AE-mcp-server\&#34;&gt;4. 配置 MCP Server&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E4%BD%BF%E7%94%A8mcp\&#34;&gt;5. 使用MCP&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;近期和arthas-idea-plugin插件社区沟通，为插件贡献了部分功能，下文为全文转载：&lt;br&gt;\n原文链接：&lt;a href=\&#34;https://www.yuque.com/arthas-idea-plugin/help/oo75vhvqs6n9gof8?singleDoc#\&#34;&gt;《在IDEA中管理和监听arthas应用》&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;arthas idea plugin&lt;/code&gt; 插件方便了我们使用 &lt;code&gt;Arthas&lt;/code&gt;，对于命令不熟悉同学也可以快速上手排查问题。但是当一个应用有多个实例时，为了监听某一个请求我们通常会打开多个浏览器窗口来启动监听，使用起来多少有点不方便。故扩展了在 &lt;code&gt;IDEA&lt;/code&gt; 内部直接监听的功能。社区内相关 Issue：&lt;a href=\&#34;https://github.com/WangJi92/arthas-idea-plugin/issues/92\&#34;&gt;https://github.com/WangJi92/arthas-idea-plugin/issues/92&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;如果团队的工作模式是进入宿主机手动启动&lt;code&gt;Arthas&lt;/code&gt;命令来监听本机应用，那么该插件并不能帮助到这部分用户。插件适用的工作模式是使用&lt;code&gt;Tunnel-Server&lt;/code&gt;和&lt;code&gt;arthas-spring-boot-starter&lt;/code&gt;，将应用注册到&lt;code&gt;Tunnel-Server&lt;/code&gt;且应用部署了多个实例，每次执行监听需要去多个机器监听的痛点场景。&lt;/p&gt;\n&lt;h2 id=\&#34;插件特性\&#34;&gt;插件特性&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;基于 &lt;code&gt;arthas idea plugin&lt;/code&gt;，不打断原插件的使用流程，润物细无声。&lt;/li&gt;\n&lt;li&gt;在 &lt;code&gt;IDEA&lt;/code&gt; 内直连 &lt;code&gt;Tunnel-Server&lt;/code&gt;，无需打开浏览器，代码异常可快速定位行号。&lt;/li&gt;\n&lt;li&gt;同时连接单应用多实例，无需拷贝命令后打开多个浏览器窗口监听。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;配置插件\&#34;&gt;配置插件&lt;/h2&gt;\n&lt;h3 id=\&#34;添加arthas-tunnel-server地址\&#34;&gt;添加Arthas Tunnel-Server地址&lt;/h3&gt;\n&lt;p&gt;点击Add按钮，添加&lt;code&gt;Tunnel-Server&lt;/code&gt;(插件不校验地址的正确性，请保证填写的地址准确无误）。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;ol&gt;\n&lt;li&gt;Name：可根据自己的情况命名&lt;/li&gt;\n&lt;li&gt;TunnelAddress：HTTP服务器地址，插件通过&lt;code&gt;Tunnel-Server&lt;/code&gt;的Web端口获取信息，根据服务器部署填写HTTP/HTTPS协议&lt;/li&gt;\n&lt;li&gt;WsAddress：Socket服务器地址，插件和&lt;code&gt;Tunnel-Server Web&lt;/code&gt;端原理一致，伪装成&lt;code&gt;Socket&lt;/code&gt;客户端获取信息和发送指令，根据服务器部署填写WS/WSS协议&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1728813373952.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;从列表中删除tunnel-server\&#34;&gt;从列表中删除Tunnel-Server&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;选中待删除的行，点击删除即可&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1728813400527.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;直接修改单元格配置\&#34;&gt;直接修改单元格配置&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;点击Apply或OK后生效&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1728813427232.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;命令窗口打开选择\&#34;&gt;命令窗口打开选择&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;可选择弹出命令发送窗口，如果不勾选则此功能不会启用。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1728813447318.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1728813466340.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;使用插件\&#34;&gt;使用插件&lt;/h2&gt;\n&lt;h3 id=\&#34;1-选择待监听的应用执行监听\&#34;&gt;1. 选择待监听的应用，执行监听&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;ol&gt;\n&lt;li&gt;选择 NameServer 用以切换环境（Tunnel-Server）&lt;/li&gt;\n&lt;li&gt;选择 App 用以切换应用&lt;/li&gt;\n&lt;li&gt;选择 Agent 用以切换实例（可选all agents来监听所有实例）&lt;br&gt;\n📢：当App/Agent未出现可选项时，请检查配置的TunnelAddress地址是否正确。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1728813504156.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;工具栏介绍\&#34;&gt;工具栏介绍&lt;/h3&gt;\n&lt;h4 id=\&#34;重启rerun\&#34;&gt;重启（Rerun）&lt;/h4&gt;\n&lt;blockquote&gt;\n&lt;p&gt;类似于 watch、trace 等指令，一般通过 -n 指定了执行几次，如果执行完毕，可以通过此按钮重新开始一次监听。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;调整命令modify\&#34;&gt;调整命令（Modify）&lt;/h4&gt;\n&lt;blockquote&gt;\n&lt;p&gt;类似于 watch、trace 等指令，假如一开始 -x 的深度不够，需要调整时使用，或监听某些参数时，需要调整SpEL表达式时可以使用。&lt;br&gt;\n📢：如需要调整监听的方法或切换其它指令时，建议重新开始而非通过此按钮，操作会更顺畅。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;停止stop\&#34;&gt;停止（Stop）&lt;/h4&gt;\n&lt;p&gt;立即停止监听，类似于 Web UI 上面的 Ctrl+C。&lt;/p&gt;\n&lt;h4 id=\&#34;清空输出面板clear-all\&#34;&gt;清空输出面板（Clear ALL）&lt;/h4&gt;\n&lt;blockquote&gt;\n&lt;p&gt;清空输出面板，不会停止监听。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;演示\&#34;&gt;演示&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1728813572945.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;执行自定义指令\&#34;&gt;执行自定义指令&lt;/h3&gt;\n&lt;h4 id=\&#34;执行过程中调整其他指令\&#34;&gt;执行过程中调整其他指令&lt;/h4&gt;\n&lt;blockquote&gt;\n&lt;p&gt;插件保留了用户自定义输入的入口，可以用于拷贝 Get All Available Command处拷贝的指令。&lt;br&gt;\n通过键盘 ↑ ↓键，可以快速切换历史已执行的指令。&lt;br&gt;\n回车或点击按钮 Exec 可执行指令。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1728813603660.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;直接执行自定义指令\&#34;&gt;直接执行自定义指令&lt;/h4&gt;\n&lt;blockquote&gt;\n&lt;p&gt;为方便直接拷贝指令发送至多个实例执行，在右键菜单注册了 OpenArthasTerminal 用于打开一个空白的对话窗口。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1728813642897.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1728813647297.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;异常定位行号\&#34;&gt;异常定位行号&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1728813654738.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;部署tunnel-server\&#34;&gt;部署Tunnel-Server&lt;/h2&gt;\n&lt;p&gt;在大部分单机的场景下，我们可能直接在机器上运行 java -jar arthas-boot.jar 来运行一个单机版的 Arthas 来监听应用，但在微服务架构下，一个服务可能部署了多个实例，分布在不同的机器上，再登录到机器上挨个运行单机版就较为不便了。&lt;br&gt;\n官方也考虑到了这种情况，所以也提供了对应的解决方案，那就是 Arthas Tunnel-Server，下文摘自官网：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;通过 Arthas Tunnel Server/Client 来远程管理/连接多个 Agent。&lt;br&gt;\n比如，在流式计算里，Java 进程可以是在不同的机器启动的，想要使用 Arthas 去诊断会比较麻烦，因为用户通常没有机器的权限，即使登陆机器也分不清是哪个 Java 进程。&lt;br&gt;\n在这种情况下，可以使用 Arthas Tunnel Server/Client。&lt;br&gt;\n参考:&lt;br&gt;\n● 1: Web Console&lt;br&gt;\n● 2: Arthas Spring Boot Starter&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;下载并部署-tunnel-server\&#34;&gt;下载并部署 Tunnel-Server&lt;/h3&gt;\n&lt;p&gt;下载Tunnel-Server（https://github.com/alibaba/arthas/releases），因为Server本身也是一个 jar 包，所以可以直接通过命令启动。&lt;br&gt;\n具体细节见官方文档：&lt;a href=\&#34;https://arthas.aliyun.com/doc/tunnel.html#tunnel-server-%E7%9A%84%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2\&#34;&gt;arthas 官网&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;java -Darthas.enable-detail-pages=true -jar ~/.arthas/arthas-tunnel-server.jar\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1728813731283.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;默认情况下，Arthas Tunnel-Server 的 web 端口是8080，arthas agent连接的端口是7777。&lt;/p&gt;\n&lt;h3 id=\&#34;启动应用并连接至tunnel-server\&#34;&gt;启动应用并连接至Tunnel-Server&lt;/h3&gt;\n&lt;p&gt;通常情况下，我们是通过 &lt;code&gt; java -jar arthas-boot.jar&lt;/code&gt; 启动一个 &lt;code&gt;Arthas&lt;/code&gt; 应用来监听本机的 &lt;code&gt;Java&lt;/code&gt; 应用。但如果我们是使用 &lt;code&gt;SpringBoot&lt;/code&gt; 来构建应用，那么更推荐使用 &lt;code&gt;Arthas Spring Boot Starter&lt;/code&gt;（只支持SpringBoot2.+） ，应用启动后，&lt;code&gt;Spring&lt;/code&gt; 会启动 &lt;code&gt;Arthas&lt;/code&gt;，并且 &lt;code&gt;Arrach&lt;/code&gt; 自身的进程。&lt;/p&gt;\n&lt;h4 id=\&#34;jar-jar-连接-tunnel-server\&#34;&gt;jar -jar 连接 tunnel-server&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;java -jar arthas-boot.jar --tunnel-server &#39;ws://127.0.0.1:7777/ws&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;springboot-starter-连接-tunnel-server\&#34;&gt;SpringBoot Starter 连接 tunnel-server&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;创建一个SpringBoot的Demo应用。&lt;/li&gt;\n&lt;li&gt;引入 Starter 的依赖（当前最新版本 4.0.0）。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-xml\&#34;&gt;&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;com.taobao.arthas&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;arthas-spring-boot-starter&amp;lt;/artifactId&amp;gt;\n  &amp;lt;version&amp;gt;4.0.0&amp;lt;/version&amp;gt;\n&amp;lt;/dependency&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;再在 application.properties 文件中指定几个参数。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-properties\&#34;&gt;arthas.http-port=0\narthas.telnet-port=0\narthas.app-name=${spring.application.name}-${spring.profiles.active}\narthas.tunnel-server=ws://127.0.0.1:7777/ws\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;4\&#34;&gt;\n&lt;li&gt;启动应用，发现日志中有如下参数就说明配置完成。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-log\&#34;&gt;2024-09-21T23:11:48.536+08:00  INFO 90583 --- [arthas-terminal-demo] [           main] c.a.arthas.spring.ArthasConfiguration    : Arthas agent start success.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;tunnel-server的管理页面\&#34;&gt;Tunnel-Server的管理页面&lt;/h3&gt;\n&lt;p&gt;完成上面的两个步骤之后，打开浏览器访问 http://localhost:8080/apps.html，就可以看到下面的内容了，最终实现在浏览器中监听应用。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1728813863049.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1728813866629.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1728813870329.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;建议\&#34;&gt;建议&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;Tunnel-Server 具备较高权限，官方不建议部署到公网可访问的地址上。&lt;/li&gt;\n&lt;li&gt;Tunnel-Server 为内部诊断工具，没有开发对应的权限控制能力，需注意风险。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;工作原理\&#34;&gt;工作原理&lt;/h2&gt;\n&lt;p&gt;插件主要通过Tunnel-Server Web UI所使用的接口，将其利用起来在IDEA中使用，仅使用其三个接口：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;/api/tunnelApps&lt;/code&gt; 获取所有App&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;/api/tunnelAgentInfo?app=&lt;/code&gt; 获取App的所有Agent&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;ws?method=connectArthas&amp;amp;id=&amp;amp;targetServer=&lt;/code&gt; 通过WS连接tunnel-server实时通信&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;整体的交互流程如下序列图：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1728813920966.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;其它&lt;br&gt;\n目前仅支持部分常用菜单，其它菜单在 IDEA 内呈现不够优雅或无法满足，故未做支持。&lt;br&gt;\n支持的菜单列表：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;watch&lt;/li&gt;\n&lt;li&gt;trace&lt;/li&gt;\n&lt;li&gt;stack&lt;/li&gt;\n&lt;li&gt;sc&lt;/li&gt;\n&lt;li&gt;sm&lt;/li&gt;\n&lt;li&gt;getstatic&lt;/li&gt;\n&lt;li&gt;jad&lt;/li&gt;\n&lt;li&gt;thread&lt;/li&gt;\n&lt;li&gt;monitor&lt;/li&gt;\n&lt;li&gt;vmoption&lt;br&gt;\n对于不支持的菜单，其中部分也可以通过【执行自定义指令】自行拷贝执行，当然，后续也可以考虑补充部分菜单。&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;zai-idea-zhong-guan-li-he-jian-ting-arthas-ying-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;在IDEA中管理和监听arthas应用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Arthas&#34;,&#34;slug&#34;:&#34;8NNFU0jVs&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/8NNFU0jVs/&#34;}],&#34;date&#34;:&#34;2024-10-13 17:53:32&#34;,&#34;dateFormat&#34;:&#34;2024-10-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/zai-idea-zhong-guan-li-he-jian-ting-arthas-ying-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:417000,&#34;words&#34;:1803,&#34;minutes&#34;:7},&#34;description&#34;:&#34;近期和arthas-idea-plugin插件社区沟通，为插件贡献了部分功能，下文为全文转载：\n原文链接：《在IDEA中管理和监听arthas应用》\narthas idea plugin 插件方便了我们使用 Arthas，对于命令不熟悉同学...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E4%BB%B6%E7%89%B9%E6%80%A7\&#34;&gt;插件特性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E6%8F%92%E4%BB%B6\&#34;&gt;配置插件&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B7%BB%E5%8A%A0arthas-tunnel-server%E5%9C%B0%E5%9D%80\&#34;&gt;添加Arthas Tunnel-Server地址&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4tunnel-server\&#34;&gt;从列表中删除Tunnel-Server&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E5%8D%95%E5%85%83%E6%A0%BC%E9%85%8D%E7%BD%AE\&#34;&gt;直接修改单元格配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4%E7%AA%97%E5%8F%A3%E6%89%93%E5%BC%80%E9%80%89%E6%8B%A9\&#34;&gt;命令窗口打开选择&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6\&#34;&gt;使用插件&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E9%80%89%E6%8B%A9%E5%BE%85%E7%9B%91%E5%90%AC%E7%9A%84%E5%BA%94%E7%94%A8%E6%89%A7%E8%A1%8C%E7%9B%91%E5%90%AC\&#34;&gt;1. 选择待监听的应用，执行监听&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E5%85%B7%E6%A0%8F%E4%BB%8B%E7%BB%8D\&#34;&gt;工具栏介绍&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E5%90%AFrerun\&#34;&gt;重启（Rerun）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E6%95%B4%E5%91%BD%E4%BB%A4modify\&#34;&gt;调整命令（Modify）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%81%9C%E6%AD%A2stop\&#34;&gt;停止（Stop）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B8%85%E7%A9%BA%E8%BE%93%E5%87%BA%E9%9D%A2%E6%9D%BFclear-all\&#34;&gt;清空输出面板（Clear ALL）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%BC%94%E7%A4%BA\&#34;&gt;演示&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%A7%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4\&#34;&gt;执行自定义指令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E6%95%B4%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4\&#34;&gt;执行过程中调整其他指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4\&#34;&gt;直接执行自定义指令&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%82%E5%B8%B8%E5%AE%9A%E4%BD%8D%E8%A1%8C%E5%8F%B7\&#34;&gt;异常定位行号&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%83%A8%E7%BD%B2tunnel-server\&#34;&gt;部署Tunnel-Server&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E8%BD%BD%E5%B9%B6%E9%83%A8%E7%BD%B2-tunnel-server\&#34;&gt;下载并部署 Tunnel-Server&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E5%B9%B6%E8%BF%9E%E6%8E%A5%E8%87%B3tunnel-server\&#34;&gt;启动应用并连接至Tunnel-Server&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#jar-jar-%E8%BF%9E%E6%8E%A5-tunnel-server\&#34;&gt;jar -jar 连接 tunnel-server&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#springboot-starter-%E8%BF%9E%E6%8E%A5-tunnel-server\&#34;&gt;SpringBoot Starter 连接 tunnel-server&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tunnel-server%E7%9A%84%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2\&#34;&gt;Tunnel-Server的管理页面&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%BA%E8%AE%AE\&#34;&gt;建议&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\&#34;&gt;工作原理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在阅读VIVO的博客&lt;a href=\&#34;https://mp.weixin.qq.com/s/YKZ1n5O30nowOrfmjMcmOw\&#34;&gt;高性能无锁队列 Disruptor 核心原理分析及其在i主题业务中的应用&lt;/a&gt;的时候，了解到 &lt;code&gt;Disruptor&lt;/code&gt; 高性能的核心原因：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;空间预分配&lt;/li&gt;\n&lt;li&gt;避免伪共享&lt;/li&gt;\n&lt;li&gt;无锁&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;其中 &lt;strong&gt;伪共享&lt;/strong&gt; 的概念之前没有了解过，故特地了解学习了下，主要涉及到一些基础的概念：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;CPU的分级缓存机制&lt;/li&gt;\n&lt;li&gt;volatile的内存可见性&lt;/li&gt;\n&lt;li&gt;Java long类型/Long类型的字节大小&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;众所周知，CPU在读取内存中的数据时，并不是读取的直接内存，而是从L1/L2/L3缓存中读取数据，而读取缓存也并非按&lt;code&gt;1字节&lt;/code&gt;的读取，而是按照&lt;code&gt;缓存行&lt;/code&gt;(通常64字节)一块一块的读取，以此来提高读取效率。&lt;/p&gt;\n&lt;p&gt;周所也周知，现代计算机都是多核CPU在运行，线程都会被分配CPU来执行，所以线程内的变量数据是需要读取到CPU Cache中才能够对CPU可见的，为了解决内存在CPU1中修改后CPU2不可见（脏读）的问题，在Java中有设计变量修饰符&lt;code&gt;volatile&lt;/code&gt;来修饰变量，以此来实现数据在多个CPU之间不会产生脏读问题，内存在任何一个CPU上发生修改后，在其他CPU上均不可用而丢弃重新从内存中获取。&lt;/p&gt;\n&lt;p&gt;当然，也正是因为以上设计，带来了一些预期外的结果（不是问题或bug），如下代码所示：&lt;/p&gt;\n&lt;p&gt;对于下面的代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class FalseSharing {\n    public static void main(String[] args) throws InterruptedException {\n        int num = 100000000;\n        Pointer pointer1 = new Pointer();\n        long start = System.currentTimeMillis();\n        Thread t1 = new Thread(() -&amp;gt; {\n            for(int i = 0; i &amp;lt; num; i++){\n                pointer1.x++;\n            }\n        });\n        Thread t2 = new Thread(() -&amp;gt; {\n            for(int i = 0; i &amp;lt; num; i++){\n                pointer1.y++;\n            }\n        });\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(&amp;quot;pointer1=&amp;quot; + (System.currentTimeMillis() - start));\n    }\n}\n\nclass Pointer {\n    volatile long x;\n    volatile long y;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述代码在我的电脑上执行，&lt;code&gt;需要3.5秒+&lt;/code&gt;，多次执行亦然如此，而我们只需稍作调整，改成如下代码，则只需要&lt;code&gt;0.5秒左右&lt;/code&gt;即可执行完毕，这是为何？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class FalseSharing {\n\n    public static void main(String[] args) throws InterruptedException {\n        int num = 100000000;\n        Pointer2 pointer2 = new Pointer2();\n        long start2 = System.currentTimeMillis();\n        Thread t3 = new Thread(() -&amp;gt; {\n            for(int i = 0; i &amp;lt; num; i++){\n                pointer2.x++;\n            }\n        });\n        Thread t4 = new Thread(() -&amp;gt; {\n            for(int i = 0; i &amp;lt; num; i++){\n                pointer2.y++;\n            }\n        });\n        t3.start();\n        t4.start();\n        t3.join();\n        t4.join();\n        System.out.println(&amp;quot;pointer2=&amp;quot; + (System.currentTimeMillis() - start2));\n    }\n}\n\nclass Pointer2 {\n    volatile long x;\n    // long p1, p2, p3, p4, p5, p6, p7;\n    Long z1, z2; long z3;\n    volatile long y;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;以上现象对应的机制，正是因为缓存行的设计。&lt;/p&gt;\n&lt;p&gt;在上面的代码中，包含了线程t1/t2（t3和t4等同）两组线程，分别对x和y进行累加操作，看似是两个线程（CPU在分别对两块内存中的变量执行累加），但是因为CPU是以缓存行的方式读取内存，&lt;code&gt;Pointer1&lt;/code&gt;中的x和y在内存中时相邻的两块内存，Java的基本数据类型&lt;code&gt;long类型，占用8字节&lt;/code&gt;，所以x和y(加起来16字节)被放到同一个缓存行了，当CPU1对x做了修改后，CPU2读取到y时发现，对应&lt;strong&gt;缓存行已经失效&lt;/strong&gt;了，所以不得不重新从内存中重新读取数据，从而导致了效率降低。&lt;/p&gt;\n&lt;p&gt;而我们下面给出的代码，&lt;code&gt;Pointer2&lt;/code&gt;的x和y变量间，被塞了两组变量：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;long p1, p2, p3, p4, p5, p6, p7; --long类型,占用8个字节, 8*7=56&lt;/li&gt;\n&lt;li&gt;Long z1, z2; long z3; --包装Long类型,根据计算机不同有所不同,在我电脑上占用24字节, 24+24+8=56&lt;br&gt;\n两组变量任何一组都可以解决伪共享的问题，之所以塞两组变量，都是为了验证缓存行的存在和解决方案。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;方案一直接使用&lt;code&gt;7个基本数据类型&lt;/code&gt;，占用了56个字节，加上x变量自身，刚好占用一个完整的缓存行64字节，y只能在另一个缓存行了。&lt;br&gt;\n方案二使用了&lt;code&gt;2组包装数据类型，1组基本数据类型&lt;/code&gt;，加起来依旧占用的是56个字节，依旧能将一个缓存行占满，解决缓存行失效问题。&lt;/p&gt;\n&lt;p&gt;通过对这块的学习，对基础知识又做了一个巩固，造火箭的知识又增加了。🤡&lt;/p&gt;\n&lt;p&gt;博文参考：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;美团：&lt;a href=\&#34;https://tech.meituan.com/2016/11/18/disruptor.html\&#34;&gt;高性能队列——Disruptor&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;VIVO：&lt;a href=\&#34;https://mp.weixin.qq.com/s/YKZ1n5O30nowOrfmjMcmOw\&#34;&gt;高性能无锁队列 Disruptor 核心原理分析及其在i主题业务中的应用&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;实操代码：&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/blob/master/framework-in-java/disruptor-demo/src/main/java/top/imyzt/learning/disruptor/FalseSharing.java\&#34;&gt;FalseSharing&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;false-sharing&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;False-Sharing&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Disruptor&#34;,&#34;slug&#34;:&#34;B-w2Ph39V&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/B-w2Ph39V/&#34;},{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;rsjM0rjtG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/rsjM0rjtG/&#34;}],&#34;date&#34;:&#34;2024-08-21 22:41:24&#34;,&#34;dateFormat&#34;:&#34;2024-08-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/false-sharing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:266000,&#34;words&#34;:1118,&#34;minutes&#34;:5},&#34;description&#34;:&#34;在阅读VIVO的博客高性能无锁队列 Disruptor 核心原理分析及其在i主题业务中的应用的时候，了解到 Disruptor 高性能的核心原因：\n\n空间预分配\n避免伪共享\n无锁\n\n其中 伪共享 的概念之前没有了解过，故特地了解学习了下，主...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;此篇文章主要用于讲解使用Spring进行编码时，核心与非核心代码解耦合常用的观察者模式&lt;code&gt;@EventListener&lt;/code&gt;的使用方法，以及不常用的&lt;code&gt;@TransactionalEventListener&lt;/code&gt;的使用场景和注意事项。&lt;/p&gt;\n&lt;h1 id=\&#34;常规情况\&#34;&gt;常规情况&lt;/h1&gt;\n&lt;p&gt;在我们常规的业务开发中，有很多场景都会使用到观察者模式来解耦合，将非核心流程剥离到主流程之外，提高代码的可读性，举例：用户注册流程，当用户注册完成之后，需要给用户发送一个注册成功的短信通知，核心流程是存储用户信息，次要流程是发送短信通知。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722759866465.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;由于本文主要是用来介绍SpringEvent的使用，所以另外的方案就不做介绍了，接下来让我们来初始化一个项目来模拟这部分业务代码的实现：&lt;/p&gt;\n&lt;p&gt;对于这样一个流程，我们常规的设计方案有以下几种：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;设计一个有界队列线程池，将发送短信流程提交给异步线程执行。&lt;/li&gt;\n&lt;li&gt;使用SpringEvent，发布用户注册成功事件，由监听器执行（也可以选择执行线程）。&lt;/li&gt;\n&lt;li&gt;使用MQ，由消费者负责执行。（最重，最稳妥的方案）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;entity\&#34;&gt;Entity&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class User {\n    @TableId(type = IdType.ASSIGN_ID)\n    private String id;\n    private String username;\n    private String address;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;service\&#34;&gt;Service&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public interface UserService extends IService&amp;lt;User&amp;gt; {\n    String addUser(String username, String address);\n}\n\npublic class UserServiceImpl extends ServiceImpl&amp;lt;UserMapper, User&amp;gt; implements UserService {\n\n    private final ApplicationContext applicationContext;\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public String addUser(String username, String address) {\n        User user = User.builder().username(username).address(address).build();\n        log.info(&amp;quot;添加用户开始&amp;quot;);\n        super.save(user);\n        log.info(&amp;quot;添加用户成功, 发送事件开始&amp;quot;);\n        applicationContext.publishEvent(new AddUserEvent(this, user));\n        log.info(&amp;quot;添加用户成功, 发送事件结束&amp;quot;);\n        return user.getId();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;listener\&#34;&gt;Listener&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class UserListener {\n    @EventListener(AddUserEvent.class)\n    public void addHandler(AddUserEvent event) {\n        User user = event.getUser();\n        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 Normal, user={}&amp;quot;, user.toString());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;controller\&#34;&gt;Controller&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@RequestMapping(&amp;quot;user&amp;quot;)\npublic class UserController {\n    private final UserService userService;\n    @PostMapping(&amp;quot;/add&amp;quot;)\n    public String add(String username, String address) {\n        return userService.addUser(username, address);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;db\&#34;&gt;DB&lt;/h3&gt;\n&lt;p&gt;ORM框架我们使用Mybatis-Plus，数据库我们使用db2作为临时数据库，目前没有数据。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722760277166.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;2024-08-04 16:31:45.590  INFO 55648 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户开始\nCreating a new SqlSession\nRegistering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]\nJDBC Connection [HikariProxyConnection@1603671607 wrapping conn0: url=jdbc:h2:~/mydb user=ROOT] will be managed by Spring\n==&amp;gt;  Preparing: INSERT INTO user ( id, username, address ) VALUES ( ?, ?, ? )\n==&amp;gt; Parameters: 1820014751548219393(String), yzt(String), shenzhen(String)\n&amp;lt;==    Updates: 1\nReleasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]\n2024-08-04 16:31:45.705  INFO 55648 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件开始\n2024-08-04 16:31:45.708  INFO 55648 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 Normal, user=User(id=1820014751548219393, username=yzt, address=shenzhen)\n2024-08-04 16:31:45.709  INFO 55648 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件结束\nTransaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]\nTransaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]\nTransaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6e3d4aa9]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;再次查看数据\&#34;&gt;再次查看数据&lt;/h3&gt;\n&lt;p&gt;select * from user;&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;ID&lt;/th&gt;\n&lt;th&gt;USERNAME&lt;/th&gt;\n&lt;th&gt;ADDRESS&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;1820014751548219393&lt;/td&gt;\n&lt;td&gt;yzt&lt;/td&gt;\n&lt;td&gt;shenzhen&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;(1 row, 2 ms)&lt;/p&gt;\n&lt;h3 id=\&#34;小结\&#34;&gt;小结&lt;/h3&gt;\n&lt;p&gt;为了更好的呈现执行过程，上面的代码没有添加异步，通过上面的代码日志，可以看到整个过程大概如下图所示&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722760898291.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;一般我们的业务编码都是使用&lt;code&gt;@EventListener&lt;/code&gt;来实现，在正常情况下不会有什么问题。但是在某些特殊场景下，可能会出现预期之外的结果。&lt;/p&gt;\n&lt;h1 id=\&#34;场景2事务异常\&#34;&gt;场景2，事务异常&lt;/h1&gt;\n&lt;p&gt;上面我们演示的更多是业务正常的情况，但通常情况下，添加用户不仅仅只有这么简单的业务，在存储之后，可能还有其他的业务，比如为邀请人结算奖励之类（举例），那么流程长了之后总会有异常的可能，比如我们用&lt;code&gt;address=shanghai&lt;/code&gt;来模拟业务异常：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class UserServiceImpl extends ServiceImpl&amp;lt;UserMapper, User&amp;gt; implements UserService {\n    private final ApplicationContext applicationContext;\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public String addUser(String username, String address) {\n        User user = User.builder().username(username).address(address).build();\n        log.info(&amp;quot;添加用户开始&amp;quot;);\n        super.save(user);\n        log.info(&amp;quot;添加用户成功, 发送事件开始&amp;quot;);\n        applicationContext.publishEvent(new AddUserEvent(this, user));\n        log.info(&amp;quot;添加用户成功, 发送事件结束&amp;quot;);\n        \n        // 模拟异常场景\n        if (address.equals(&amp;quot;shanghai&amp;quot;)) {\n            throw new RuntimeException(&amp;quot;rollback&amp;quot;);\n        }\n        return user.getId();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;再次查看日志&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;2024-08-04 16:47:30.838  INFO 55648 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户开始\nCreating a new SqlSession\nRegistering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7900e41a]\nJDBC Connection [HikariProxyConnection@1080868530 wrapping conn0: url=jdbc:h2:~/mydb user=ROOT] will be managed by Spring\n==&amp;gt;  Preparing: INSERT INTO user ( id, username, address ) VALUES ( ?, ?, ? )\n==&amp;gt; Parameters: 1820018715891113985(String), yzt1(String), shanghai(String)\n&amp;lt;==    Updates: 1\nReleasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7900e41a]\n2024-08-04 16:47:30.839  INFO 55648 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件开始\n2024-08-04 16:47:30.840  INFO 55648 --- [nio-8080-exec-7] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 Normal, user=User(id=1820018715891113985, username=yzt1, address=shanghai)\n2024-08-04 16:47:30.840  INFO 55648 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件结束\nTransaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7900e41a]\nTransaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7900e41a]\n2024-08-04 16:47:30.842 ERROR 55648 --- [nio-8080-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: rollback] with root cause\n\njava.lang.RuntimeException: rollback\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为下游的异常，导致事务并没有成功提交，但是前面的事件监听器已经被执行了，此时数据库未正确写入用户，但是短信已经发送出去了，在业务上肯定是不可接受的。&lt;br&gt;\n&lt;strong&gt;当然也可以说&lt;/strong&gt;，把注册用户成功事件放到代码的最后面，这当然也是一种方案，但始终无法做到最完美的&lt;strong&gt;一致性&lt;/strong&gt;问题，因为用户最终事务提交还是有可能失败（超时、重复写入等）。&lt;br&gt;\n&lt;strong&gt;或者说&lt;/strong&gt;，将注册成功事件放到事务注解的外部，在确保事务提交之后，再发送事件，就像之前将的Redis的分布式锁解锁一样 &lt;a href=\&#34;https://imyzt.top/post/shi-yong-redis-shi-xian-fen-bu-shi-suo-de-keng/#3-%E4%BA%8B%E5%8A%A1%E6%9C%AA%E6%8F%90%E4%BA%A4%E9%94%81%E5%B0%B1%E9%87%8A%E6%94%BE%E4%BA%86\&#34;&gt;使用Redis实现分布式锁的坑#3-事务未提交锁就释放了&lt;/a&gt;，这种方案固然可以，但体现到业务代码上，就需要再另一个被Spring代理了的bean上来操作，比较麻烦。&lt;/p&gt;\n&lt;p&gt;其实Spring是为这种场景提供了解决方案的，那就是&lt;code&gt;@TransactionalEventListener&lt;/code&gt;，通过注解的名称就可以看出来，他是为了解决事务问题来提供的注解，它的使用和&lt;code&gt;@EventListener&lt;/code&gt;完全一致，只是多了一个参数&lt;code&gt;phase&lt;/code&gt;，共有4个选择：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;TransactionPhase.AFTER_COMMIT，事务提交之后&lt;/li&gt;\n&lt;li&gt;TransactionPhase.BEFORE_COMMIT，事务提交之前&lt;/li&gt;\n&lt;li&gt;TransactionPhase.AFTER_COMPLETION，事务完成之后&lt;/li&gt;\n&lt;li&gt;TransactionPhase.AFTER_ROLLBACK，事务回滚之后&lt;br&gt;\n通过名称可以很直观的看到他的作用，接下来我们添加5个事件监听器，分别来看看他们具体的执行时机：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class UserListener {\n\n    @EventListener(AddUserEvent.class)\n    public void addHandler(AddUserEvent event) {\n        User user = event.getUser();\n        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 Normal, user={}&amp;quot;, user.toString());\n    }\n\n    @TransactionalEventListener(value = AddUserEvent.class, phase = TransactionPhase.AFTER_COMMIT)\n    public void addHandlerAfterCommit(AddUserEvent event) {\n        User user = event.getUser();\n        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 AFTER_COMMIT, user={}&amp;quot;, user.toString());\n    }\n\n    @TransactionalEventListener(value = AddUserEvent.class, phase = TransactionPhase.BEFORE_COMMIT)\n    public void addHandlerBeforeCommit(AddUserEvent event) {\n        User user = event.getUser();\n        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 BEFORE_COMMIT, user={}&amp;quot;, user.toString());\n    }\n\n    @TransactionalEventListener(value = AddUserEvent.class, phase = TransactionPhase.AFTER_COMPLETION)\n    public void addHandlerAfterCompletion(AddUserEvent event) {\n        User user = event.getUser();\n        log.info(&amp;quot;接收到添加用户事件, 发送短信完成 AFTER_COMPLETION, user={}&amp;quot;, user.toString());\n    }\n\n    @TransactionalEventListener(value = AddUserEvent.class, phase = TransactionPhase.AFTER_ROLLBACK)\n    public void addHandlerAfterRollback(AddUserEvent event) {\n        User user = event.getUser();\n        log.info(&amp;quot;添加用户事务执行失败, AFTER_ROLLBACK, user={}&amp;quot;, user.toString());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;执行一次成功的写入看看日志\&#34;&gt;执行一次成功的写入，看看日志。&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;2024-08-04 17:02:09.069  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户开始\nCreating a new SqlSession\nRegistering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]\nJDBC Connection [HikariProxyConnection@879009595 wrapping conn0: url=jdbc:h2:~/mydb user=ROOT] will be managed by Spring\n==&amp;gt;  Preparing: INSERT INTO user ( id, username, address ) VALUES ( ?, ?, ? )\n==&amp;gt; Parameters: 1820022399454720001(String), yzt1(String), shenzhen(String)\n&amp;lt;==    Updates: 1\nReleasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]\n2024-08-04 17:02:09.070  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件开始\n2024-08-04 17:02:09.070  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 Normal, user=User(id=1820022399454720001, username=yzt1, address=shenzhen)\n2024-08-04 17:02:09.071  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件结束\nTransaction synchronization committing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]\n2024-08-04 17:02:09.071  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 BEFORE_COMMIT, user=User(id=1820022399454720001, username=yzt1, address=shenzhen)\nTransaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]\nTransaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e9cf44b]\n2024-08-04 17:02:09.072  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 AFTER_COMMIT, user=User(id=1820022399454720001, username=yzt1, address=shenzhen)\n2024-08-04 17:02:09.072  INFO 56859 --- [nio-8080-exec-4] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 AFTER_COMPLETION, user=User(id=1820022399454720001, username=yzt1, address=shenzhen)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;再执行一次失败的写入看看日志\&#34;&gt;再执行一次失败的写入，看看日志：&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;2024-08-04 17:09:30.720  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户开始\nCreating a new SqlSession\nRegistering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4ef5b6da]\nJDBC Connection [HikariProxyConnection@566058297 wrapping conn0: url=jdbc:h2:~/mydb user=ROOT] will be managed by Spring\n==&amp;gt;  Preparing: INSERT INTO user ( id, username, address ) VALUES ( ?, ?, ? )\n==&amp;gt; Parameters: 1820024251877470209(String), yzt1(String), shanghai(String)\n&amp;lt;==    Updates: 1\nReleasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4ef5b6da]\n2024-08-04 17:09:30.722  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件开始\n2024-08-04 17:09:30.722  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 Normal, user=User(id=1820024251877470209, username=yzt1, address=shanghai)\n2024-08-04 17:09:30.722  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.d.service.impl.UserServiceImpl   : 添加用户成功, 发送事件结束\nTransaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4ef5b6da]\nTransaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4ef5b6da]\n2024-08-04 17:09:30.723  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.demos.listener.UserListener      : 接收到添加用户事件, 发送短信完成 AFTER_COMPLETION, user=User(id=1820024251877470209, username=yzt1, address=shanghai)\n2024-08-04 17:09:30.723  INFO 56859 --- [nio-8080-exec-7] t.i.l.s.demos.listener.UserListener      : 添加用户事务执行失败, AFTER_ROLLBACK, user=User(id=1820024251877470209, username=yzt1, address=shanghai)\n2024-08-04 17:09:30.725 ERROR 56859 --- [nio-8080-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: rollback] with root cause\n\njava.lang.RuntimeException: rollback\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;执行流程\&#34;&gt;执行流程&lt;/h3&gt;\n&lt;p&gt;通过上面的日志可以看到整个执行过程如下图所示：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722762788539.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;由此可知，有了&lt;code&gt;@TransactionalEventListener&lt;/code&gt;，我们不用确定事务的提交时机以及是否成功，只需要编写对应的监听器处理器，并指定执行时事务的时机即可在正确的时间点被调用，这一切都是Spring的AOP在帮我们处理。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;TransactionalApplicationListenerMethodAdapter&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void onApplicationEvent(ApplicationEvent event) {\n    if (TransactionSynchronizationManager.isSynchronizationActive() &amp;amp;&amp;amp;\n            TransactionSynchronizationManager.isActualTransactionActive()) {\n        TransactionSynchronizationManager.registerSynchronization(\n                new TransactionalApplicationListenerSynchronization&amp;lt;&amp;gt;(event, this, this.callbacks));\n    }\n    else if (this.annotation.fallbackExecution()) {\n        if (this.annotation.phase() == TransactionPhase.AFTER_ROLLBACK &amp;amp;&amp;amp; logger.isWarnEnabled()) {\n            logger.warn(&amp;quot;Processing &amp;quot; + event + &amp;quot; as a fallback execution on AFTER_ROLLBACK phase&amp;quot;);\n        }\n        processEvent(event);\n    }\n    else {\n        // No transactional event execution at all\n        if (logger.isDebugEnabled()) {\n            logger.debug(&amp;quot;No transaction is active - skipping &amp;quot; + event);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果有事务在进行中，就将其监听器处理器先放到&lt;code&gt;TransactionSynchronizationManager&lt;/code&gt;注册一个同步队列，在事务执行到对应的阶段，再回调每个监听了对应阶段的事务处理器。&lt;/p&gt;\n&lt;p&gt;在&lt;code&gt;AbstractPlatformTransactionManager#processCommit&lt;/code&gt;中&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;protected final void triggerBeforeCommit(DefaultTransactionStatus status) {\n    if (status.isNewSynchronization()) {\n        TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly());\n    }\n}\nprotected final void triggerBeforeCompletion(DefaultTransactionStatus status) {\n    if (status.isNewSynchronization()) {\n        TransactionSynchronizationUtils.triggerBeforeCompletion();\n    }\n}\nprivate void triggerAfterCommit(DefaultTransactionStatus status) {\n    if (status.isNewSynchronization()) {\n        TransactionSynchronizationUtils.triggerAfterCommit();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;小结-2\&#34;&gt;小结&lt;/h1&gt;\n&lt;p&gt;通过本篇文章，我们大致了解了&lt;code&gt;@TransactionalEventListener&lt;/code&gt;注解的使用场景和注意事项，也了解了其大概的实现原理，其实SpringEvent的相关源码看起来非常容易，只要稍微看过Spring相关源码，并且对SpringAOP相关逻辑了解的，就可以很容易的看懂，因为他的调用过程没那么多弯弯绕绕，只要看着&lt;code&gt;applicationContext.publishEvent&lt;/code&gt;方法一直往下盯，很快就能够看完整个的执行过程。&lt;/p&gt;\n&lt;p&gt;本篇博客对应的源码，希望能对你有所帮助：&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-boot-events\&#34;&gt;spring-boot-events&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-events-shi-yong-xiang-jie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring Events使用和问题分析&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Spring&#34;,&#34;slug&#34;:&#34;r_PTn6Nd-&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/r_PTn6Nd-/&#34;}],&#34;date&#34;:&#34;2024-08-04 16:16:39&#34;,&#34;dateFormat&#34;:&#34;2024-08-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-events-shi-yong-xiang-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;15 min read&#34;,&#34;time&#34;:885000,&#34;words&#34;:3140,&#34;minutes&#34;:15},&#34;description&#34;:&#34;此篇文章主要用于讲解使用Spring进行编码时，核心与非核心代码解耦合常用的观察者模式@EventListener的使用方法，以及不常用的@TransactionalEventListener的使用场景和注意事项。\n常规情况\n在我们常规的业...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E8%A7%84%E6%83%85%E5%86%B5\&#34;&gt;常规情况&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#entity\&#34;&gt;Entity&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#service\&#34;&gt;Service&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#listener\&#34;&gt;Listener&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#controller\&#34;&gt;Controller&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#db\&#34;&gt;DB&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%8D%E6%AC%A1%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE\&#34;&gt;再次查看数据&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%8F%E7%BB%93\&#34;&gt;小结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%BA%E6%99%AF2%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8\&#34;&gt;场景2，事务异常&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E6%88%90%E5%8A%9F%E7%9A%84%E5%86%99%E5%85%A5%E7%9C%8B%E7%9C%8B%E6%97%A5%E5%BF%97\&#34;&gt;执行一次成功的写入，看看日志。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%8D%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%86%99%E5%85%A5%E7%9C%8B%E7%9C%8B%E6%97%A5%E5%BF%97\&#34;&gt;再执行一次失败的写入，看看日志：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\&#34;&gt;执行流程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%8F%E7%BB%93-2\&#34;&gt;小结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;事情的起因还要从 &lt;code&gt;Transaction rolled back because it has been marked as rollback-only] with root cause&lt;/code&gt; 说起，公司的一个业务，Kafka Consumer消费了来自上游的消息处理并写入数据，整个逻辑很复杂，由最外层的方法注解 &lt;code&gt;@Transactional(rollbackFor = Exception.class)&lt;/code&gt; 来保证整个过程数据的一致性，但其中有一个业务不需要事务保证，所以&lt;strong&gt;前人&lt;/strong&gt;写了一个 &lt;code&gt;try catch&lt;/code&gt; 来防止子业务流异常阻断全局事务的提交。简化后大概类似于这样：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Service\npublic class ServiceA {\n\n    @Resource\n    private ServiceB serviceB;\n    @Resource\n    private CompanyService companyService;\n\n    /**\n     * 模拟消费外部的消息, 调用者A\n     */\n    @Transactional(rollbackFor = Exception.class)\n    public void test(String username) {\n        // 1. 首先保存自己的数据, 模拟业务操作\n        Company company = new Company();\n        company.setName(&amp;quot;家里蹲&amp;quot;);\n        company.setAddress(&amp;quot;localhost&amp;quot;);\n        companyService.save(company);\n\n        // 2. 然后调用Spring的代理方法B\n        serviceB.doBusiness(username);\n    }\n}\n\n@Service\npublic class ServiceB {\n\n    @Resource\n    private UserService userService;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void doBusiness(String username) {\n        // 3. 这里还有一系列事务操作, 但和这次问题无关, 就不放这里干扰了\n        try {\n            User user = new User();\n            user.setUsername(username);\n            user.setAddress(&amp;quot;shenzhen&amp;quot;);\n            // 4. 罪魁祸首的代码, 此处前人为了不干扰主逻辑, catch了异常\n            // 为了达到&amp;quot;以为的&amp;quot;异常不干扰外部事务\n            userService.saveBatch(Collections.singletonList(user));\n        } catch (DuplicateKeyException e) {\n            // 5. 此处有日志 log.error(&amp;quot;xxx业务异常&amp;quot;, e)\n            e.printStackTrace();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的代码看起来平平无奇，按照“常规”理解，&lt;strong&gt;代码块4&lt;/strong&gt;位置的流程异常，不会干扰&lt;strong&gt;代码块1、3&lt;/strong&gt;处的事务提交，达到编写者的目的。&lt;/p&gt;\n&lt;p&gt;但如果是这么简单，我也不会有这次问题的排查过程，也不会有这篇笔记了...&lt;/p&gt;\n&lt;h1 id=\&#34;现象\&#34;&gt;现象&lt;/h1&gt;\n&lt;p&gt;我们从日志监控注意到，&lt;strong&gt;代码块5&lt;/strong&gt;有频繁的异常，并且&lt;strong&gt;代码块1、3&lt;/strong&gt;的数据最终并未写入成功，通过MySQL追踪事务发现，1、3处的语句执行后，均被&lt;code&gt;rollback&lt;/code&gt;了。&lt;br&gt;\n这就引出了前言中的问题分析来了，在没有确认问题出现在&lt;strong&gt;代码块4&lt;/strong&gt;时，还在找哪些地方有异常可能造成回滚，但通过跟踪程序日志发现，1、3处被回滚的数据，基本都发生在代码块5的日志打印出来之后，并且程序中也发现了下面的异常：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\norg.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only\n.......\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Transaction rolled back because it has been marked as rollback-only&lt;/strong&gt;，说明事务被标记为只能回滚，并且根据行号（上述堆栈未标注业务行号）推断出，是发生代码块2处，调用&lt;code&gt;doBusiness&lt;/code&gt;方法发生了回滚。&lt;/p&gt;\n&lt;h1 id=\&#34;分析\&#34;&gt;分析&lt;/h1&gt;\n&lt;p&gt;我们都知道，Spring本身没有事务，只有数据库有事务，Spring提供&lt;code&gt;@Transactional&lt;/code&gt;以及事务传播机制，只是利用数据库给我们提供的 &lt;code&gt;begin/commit/rollback&lt;/code&gt; 来结合 Spring AOP 实现的&lt;strong&gt;统一事务管理&lt;/strong&gt;，通过 &lt;code&gt;PlatformTransactionManager&lt;/code&gt; 工具类来实现对事务的管理。（这方面网上优秀的博客太多了，就不细讲了，相信每一个Spring Boy都熟知）&lt;/p&gt;\n&lt;p&gt;那么，结合对Spring事务管理器和AOP的理解，我们画一张图来理解上面这个“嵌套事务”的过程。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722091980572.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;结合流程图来分析，按“常理”理解的话，&lt;code&gt;catch&lt;/code&gt; 了 &lt;code&gt;userService.saveBatch&lt;/code&gt;，内部的异常就不会造成外面的回滚，因为异常“被”吞了。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;但实则不然&lt;/strong&gt;，Spring事务管理器采用的是 &lt;strong&gt;标记位Savepoint&lt;/strong&gt; 方法，只要被事务管理器感知到了异常出现，就会将当前线程的事务标记成为&lt;code&gt;rollbackOnly&lt;/code&gt;状态，后面的事务再想提交就不行了。这也就导致了&lt;code&gt;ServiceB.doBusiness&lt;/code&gt;方法在“想要”提交事务时，发现了事务已经被标记了，就抛出了&lt;code&gt;UnexpectedRollbackException&lt;/code&gt;异常，该异常进一步的造成了&lt;code&gt;ServiceA.test&lt;/code&gt;方法的代理类检测到了异常，&lt;code&gt;ServiceA.test&lt;/code&gt;的代理类也开始处理回滚，进一步造成了整个 &lt;code&gt;Kafka Consumer&lt;/code&gt;的事务造成了回滚。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1722092797622.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;源码\&#34;&gt;源码&lt;/h1&gt;\n&lt;p&gt;通过搜索“Transaction rolled back because it has been marked as rollback-only”异常，可以很快定位到异常流程在源码中的位置，&lt;code&gt;org.springframework.transaction.support.AbstractPlatformTransactionManager#processRollback&lt;/code&gt;&lt;br&gt;\n而通过跟踪该方法的调用方，可以很快定位到&lt;code&gt;org.springframework.transaction.support.AbstractPlatformTransactionManager#commit&lt;/code&gt;方法，该方法正印证我们上方的 &lt;code&gt;ServiceB.doBusiness&lt;/code&gt;想要 &lt;code&gt;commit&lt;/code&gt;的时候，&lt;code&gt;defStatus.isGlobalRollbackOnly()&lt;/code&gt;检测到当前事务已经被标记了&lt;code&gt;rollbackOnly&lt;/code&gt;(&lt;code&gt;org.springframework.transaction.support.ResourceHolderSupport#rollbackOnly&lt;/code&gt;)&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1722094564627.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;解决\&#34;&gt;解决&lt;/h1&gt;\n&lt;p&gt;其实该问题在分析之初，大家并没有定位到是因为&lt;code&gt;userService.saveBatch()&lt;/code&gt;上面有Mybatis-Plus加的&lt;code&gt;@Transactional&lt;/code&gt;注解干扰到 &lt;code&gt;catch&lt;/code&gt; 异常这么顺利，而是都在怀疑：为什么我catch了，还把我上层的事务给回滚了！后面虽然怀疑到&lt;code&gt;userService.saveBatch()&lt;/code&gt;的事务注解了，又觉得 &lt;code&gt;try&lt;/code&gt; 里面的事务，不会影响到外层（没有想到标记位rollbackOnly这里），后面又想到是不是可以在&lt;code&gt;ServiceB.doBusiness()&lt;/code&gt;上调整事务传播机制为&lt;code&gt;Propagation.REQUIRES_NEW&lt;/code&gt;，但其实都是徒劳，因为始终都已经被Mybatis-Plus的&lt;code&gt;@Transactional&lt;/code&gt;标记为&lt;code&gt;rollbackOnly&lt;/code&gt;了。&lt;/p&gt;\n&lt;p&gt;解决方案：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;调用无事务注解的&lt;code&gt;save()&lt;/code&gt;方法&lt;/li&gt;\n&lt;li&gt;改用&lt;code&gt;Db.saveBatch&lt;/code&gt;方法&lt;/li&gt;\n&lt;li&gt;改用异步线程（切换了事务管理器）处理 try 中的流程&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;后记\&#34;&gt;后记&lt;/h1&gt;\n&lt;p&gt;下面这篇文章，在我们排查问题的过程中，给了很大的帮助，帮我们确定了问题的方向：&lt;br&gt;\n&lt;a href=\&#34;https://blog.csdn.net/github_38592071/article/details/131950392\&#34;&gt;告警：MyBatis-Plus中慎用@Transactional注解，坑的差点被开了...&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;关于是否可以取消&lt;code&gt;saveBatch&lt;/code&gt;方法上事务注解的讨论，可以看Mybatis-Plus官方的issue区：&lt;br&gt;\n（3.5.7之后，取消了IService，都使用Mapper方法，彻底解决.......）&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=\&#34;https://github.com/baomidou/mybatis-plus/issues/6333\&#34;&gt;建议取消数据层的saveBatch等方法的@Transactional注解，交由业务层自行管理 #6333&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://github.com/baomidou/mybatis-plus/issues/5108\&#34;&gt;saveBatch下的事务问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;我新建了一个工程，用来复现该问题：&lt;br&gt;\n&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/error-case-analysis/adoptopenjdk-poi-crash-demo\&#34;&gt;复现定位Spring多层嵌套事务问题&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;dang-spring-duo-ceng-qian-tao-shi-wu-yu-dao-mybatis-plus-de-savebatch&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;当Spring多层嵌套事务遇到Mybatis-Plus的saveBatch&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;问题解决&#34;,&#34;slug&#34;:&#34;KjxmDkyMU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/KjxmDkyMU/&#34;},{&#34;name&#34;:&#34;数据库&#34;,&#34;slug&#34;:&#34;_LPtQMqgT&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/_LPtQMqgT/&#34;}],&#34;date&#34;:&#34;2024-07-27 18:48:23&#34;,&#34;dateFormat&#34;:&#34;2024-07-27&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/dang-spring-duo-ceng-qian-tao-shi-wu-yu-dao-mybatis-plus-de-savebatch/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:341000,&#34;words&#34;:1481,&#34;minutes&#34;:6},&#34;description&#34;:&#34;前言\n事情的起因还要从 Transaction rolled back because it has been marked as rollback-only] with root cause 说起，公司的一个业务，Kafka Consum...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%8E%B0%E8%B1%A1\&#34;&gt;现象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E6%9E%90\&#34;&gt;分析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%BA%90%E7%A0%81\&#34;&gt;源码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3\&#34;&gt;解决&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E8%AE%B0\&#34;&gt;后记&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;在MySQL的老版本（MySQL5.7及以前）中， &lt;code&gt;GROUP BY xxx&lt;/code&gt; 等同于 &lt;code&gt;GROUP BY xxx ORDER BY xxx&lt;/code&gt;，在 &lt;code&gt;GROUP BY&lt;/code&gt; 的同时，会自带排序的效果。包括也可以手动排序 &lt;code&gt;GROUP BY xxx DESC&lt;/code&gt;，等同于 &lt;code&gt;GROUP BY xxx ORDER BY xxx DESC&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;MySQL8.0 版本删除了隐式排序，包括显示排序也报错。在升级到MySQL8.0之后，由于缺少了隐式排序，可能会造成查询结果返回的顺序不稳定，造成结果不满足预期。&lt;/p&gt;\n&lt;h1 id=\&#34;问题现象\&#34;&gt;问题现象&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;aliyun PolarDB MySQL 版 8.0.1.1.40版本，在DMS查询时，&lt;strong&gt;返回的顺序稳定&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;在程序JDBC查询时（连接的集群地址），返回的结果多次查询顺序不一致。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;由于我们使用的是PolarDB 8.0+，首先开始怀疑是不是aliyun做了什么操作，查到他们的更新日志：https://help.aliyun.com/zh/polardb/polardb-for-mysql/polardb-for-mysql-8-0-1，发现他们在8.0版本中，将隐式排序的功能又加了回来，那么更进一步证明问题出现在数据库层面了。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1721315576799.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;有了上面的分析和更新日志，我们又进行了接下来的几次测试，进一步缩小问题范围，定位问题的根本原因。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;通过MySQL命令行，连接到集群地址，返回的结果多次查询顺序不一致。&lt;/li&gt;\n&lt;li&gt;通过MySQL命令行，连接到主节点地址，&lt;strong&gt;返回的顺序稳定&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;通过MySQL命令行，连接到只读从节点地址，返回的结果多次查询顺序不一致。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;通过咨询aliyun工程师，了解到DMS默认是直连主库的，结合上述三个执行结果来看，似乎问题出现在了从库，当请求从从库执行来看，顺序总是不一致。&lt;/p&gt;\n&lt;p&gt;有了上述的结论，通过进一步咨询aliyun的工程师，最终定位到问题是因为其中有台从库开启了并行查询，导致了返回顺序会存在多次查询不一致的问题。&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1721489241076.jpeg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1721489235249.jpeg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;虽然最终定位到了原因是并行查询导致的问题，但是我还是认为，既然aliyun的版本公告中已经说明了加回了 &lt;code&gt;GROUP BY&lt;/code&gt; 隐式排序功能，那么不管是并行查询还是什么原因，就算是在 MySQL Server层进行汇总排序，也需要保证最终结果和预期一致，否则会造成使用方的预期不满足。&lt;br&gt;\n其次，对于隐式排序肯定不能进行依赖，还是回归到程序上，不论什么情况肯定不能依赖于约定俗成的一些功能，应该强依赖自己写下的指令，比如手动指定 &lt;code&gt;ORDER BY&lt;/code&gt;  比事后去分析还是好很多。但整个过程还是学习到不少东西，还是有一定收获的。&lt;/p&gt;\n&lt;h1 id=\&#34;扩展\&#34;&gt;扩展&lt;/h1&gt;\n&lt;h2 id=\&#34;旧版本为什么会有排序\&#34;&gt;旧版本为什么会有排序？&lt;/h2&gt;\n&lt;p&gt;因为要对数据进行分组的话，本身也会对分组前的数据进行排序，降低数据复杂度，所以原始数据本身就已经有序了。&lt;br&gt;\n其次，如果是 &lt;code&gt;GROUP BY&lt;/code&gt; 的一个索引字段，那么索引字段本身是 B+ Trree，本身也是有序的，且平时 &lt;code&gt;GROUP BY&lt;/code&gt;的字段大概率是有索引的（否则效率太低了），所以绝大部分情况下，旧版本的 &lt;code&gt;GROUP BY&lt;/code&gt; 就为我们保留了排序。&lt;/p&gt;\n&lt;h2 id=\&#34;为什么要删除隐式排序\&#34;&gt;为什么要删除隐式排序？&lt;/h2&gt;\n&lt;p&gt;会造成预期外的结果，比如没有明确指定&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-group-by-yin-shi-pai-xu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL GROUP BY 隐式排序&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2024-07-17 23:33:42&#34;,&#34;dateFormat&#34;:&#34;2024-07-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-group-by-yin-shi-pai-xu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:192000,&#34;words&#34;:892,&#34;minutes&#34;:4},&#34;description&#34;:&#34;前言\n在MySQL的老版本（MySQL5.7及以前）中， GROUP BY xxx 等同于 GROUP BY xxx ORDER BY xxx，在 GROUP BY 的同时，会自带排序的效果。包括也可以手动排序 GROUP BY xxx D...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1\&#34;&gt;问题现象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%A9%E5%B1%95\&#34;&gt;扩展&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%97%A7%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%8E%92%E5%BA%8F\&#34;&gt;旧版本为什么会有排序？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%A0%E9%99%A4%E9%9A%90%E5%BC%8F%E6%8E%92%E5%BA%8F\&#34;&gt;为什么要删除隐式排序？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;官方文档： &lt;a href=\&#34;https://docs.spring.io/spring-data/neo4j/docs/current-SNAPSHOT/reference/html/\&#34;&gt;Spring Data Neo4j&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;基于官方文档，基本就能完成基本的接入，Neo4j的版本很乱，如果使用SpringBoot2.+的话，一定要注意Neo4j Server的版本与Driver的匹配关系，否则很容易踩坑。 由于我不是生产使用，直接用官方最新反倒是没遇到此类问题，但网上对于这个问题遇到的很多。&lt;/p&gt;\n&lt;h1 id=\&#34;简单接入\&#34;&gt;简单接入&lt;/h1&gt;\n&lt;p&gt;写了几个单测，看了下流程，得益于SpringBoot-Data的封装，和操作MongoDB、MySQL等关系型数据库基本无异，使用过程很丝滑。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Test\n    public void readAll() {\n        List&amp;lt;Person&amp;gt; personList = personRepository.findAll();\n        Assert.isTrue(!personList.isEmpty(), &amp;quot;isEmpty&amp;quot;);\n    }\n\n    @Test\n    public void delById() {\n        personRepository.findById(71L).ifPresent(person -&amp;gt; {\n            System.out.println(&amp;quot;before delete: &amp;quot; + person.getName());\n        });\n        personRepository.deleteById(71L);\n        Person person = personRepository.findById(71L).orElse(null);\n        System.out.println(&amp;quot;after delete: &amp;quot; + person);\n    }\n\n    @Test\n    public void save() {\n        Person person = new Person();\n        person.setName(&amp;quot;人参果树&amp;quot;);\n        personRepository.save(person);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol&gt;\n&lt;li&gt;findAll&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719738560721.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;delById&lt;br&gt;\n删除前：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719738566977.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n删除后：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719738573248.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;saveOne&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719738577960.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;关系的创建\&#34;&gt;关系的创建&lt;/h1&gt;\n&lt;p&gt;对于节点的基本查询，由于其结构类似于结构性，和结构性数据库查询无异，但是对于N4o4j特殊的关系结构，就有一些不一样了。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\n@Repository\npublic interface PersonRepository extends Neo4jRepository&amp;lt;Person, Long&amp;gt; {\n\n    Person findByName(String name);\n\n    /**\n     * 创建人物关系\n     * @param from 源\n     * @param relation 关系\n     * @param to 目标\n     */\n    @Query(&amp;quot;match (n:person {name: $from}),(m:person {name: $to}) &amp;quot; +\n            &amp;quot;create (n)-[:西游人物关系{relation:$relation}]-&amp;gt;(m)&amp;quot;)\n    void createRelation(String from, String relation, String to);\n}\n\n\n@SpringBootTest\npublic class PersonRelationShipRepositoryTest {\n    @Resource\n    private PersonRepository personRepository;\n    @Test\n    public void addRelation() {\n        Person personYangjian = personRepository.findByName(&amp;quot;杨戬&amp;quot;);\n        Person person2 = new Person();\n        person2.setName(&amp;quot;玉鼎真人&amp;quot;);\n        PersonRelationShip relationShip = new PersonRelationShip();\n        relationShip.setChild(person2);\n        relationShip.setRelation(&amp;quot;师傅&amp;quot;);\n        personYangjian.getPersonRelationShips().add(relationShip);\n        personRepository.save(personYangjian);\n    }\n    @Test\n    public void addRelation2() {\n        personRepository.createRelation(&amp;quot;玉皇大帝&amp;quot;, &amp;quot;妻子&amp;quot;, &amp;quot;王母娘娘&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;创建关系第一种方式&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719748762850.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n创建关系第二种方式&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719748767396.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;坑\&#34;&gt;坑&lt;/h1&gt;\n&lt;h2 id=\&#34;坑1\&#34;&gt;坑1&lt;/h2&gt;\n&lt;p&gt;spring-boot-data 3.+的很多注解都改变了，例如：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;在老版本中标注节点使用的是&lt;code&gt;@NodeEntity&lt;/code&gt;，新版本被替换为&lt;code&gt;@Node(labels = &amp;quot;person&amp;quot;)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;在老版本中，关系的表述是在关系对象中通过&lt;code&gt;@RelationshipEntity&lt;/code&gt;、&lt;code&gt;@StartNode&lt;/code&gt;、&lt;code&gt;@EndNode&lt;/code&gt;来描述，在新版这些都没有了。取而代之的是在源对象中补充属性&lt;code&gt;@Relationship(type = &amp;quot;师傅&amp;quot;, direction = Relationship.Direction.OUTGOING)&lt;/code&gt;来描述关系。&lt;br&gt;\n老关系：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Data\n@RelationshipEntity(type = &amp;quot;xxx&amp;quot;)\npublic class PersonRelationShip {\n    @Id\n    @GeneratedValue\n    private Long id;\n    @StartNode\n    private Person parent;\n    @TargetNode\n    private Person child;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;新关系：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Node(labels = &amp;quot;person&amp;quot;)\n@Data\npublic class Person {\n    @Id\n    @GeneratedValue\n    private Long id;\n    @Property\n    private String name;\n    @Relationship(type = &amp;quot;师傅&amp;quot;, direction = Relationship.Direction.OUTGOING)\n    private List&amp;lt;PersonRelationShip&amp;gt; personRelationShips;\n}\n@Data\n@RelationshipProperties\npublic class PersonRelationShip {\n    @Id\n    @GeneratedValue\n    private Long id;\n    @TargetNode\n    private Person child;\n    @Property\n    private String relation;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;坑2\&#34;&gt;坑2&lt;/h2&gt;\n&lt;p&gt;spring-boot-data 3.+的&lt;code&gt;@Query&lt;/code&gt;中想要获取参数，需要使用 &lt;code&gt;$fieldName&lt;/code&gt;，而不是 &lt;code&gt;{0}&lt;/code&gt; 的方式，如果自己写的时候一定要注意。比如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n    * 创建人物关系\n    * @param from 源\n    * @param relation 关系\n    * @param to 目标\n    */\n@Query(&amp;quot;match (n:person {name: $from}),(m:person {name: $to}) &amp;quot; +\n        &amp;quot;create (n)-[:西游人物关系{relation:$relation}]-&amp;gt;(m)&amp;quot;)\nvoid createRelation(String from, String relation, String to);\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;springboot-33-neo4j-51-java17-jie-ru-jiao-cheng&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;SpringBoot 3.3 + Neo4j 5.1 + Java17 接入教程&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Neo4j&#34;,&#34;slug&#34;:&#34;XM6uOsCyh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/XM6uOsCyh/&#34;}],&#34;date&#34;:&#34;2024-06-30 17:00:27&#34;,&#34;dateFormat&#34;:&#34;2024-06-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/springboot-33-neo4j-51-java17-jie-ru-jiao-cheng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:201000,&#34;words&#34;:723,&#34;minutes&#34;:4},&#34;description&#34;:&#34;官方文档： Spring Data Neo4j\n基于官方文档，基本就能完成基本的接入，Neo4j的版本很乱，如果使用SpringBoot2.+的话，一定要注意Neo4j Server的版本与Driver的匹配关系，否则很容易踩坑。 由于我不...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E5%8D%95%E6%8E%A5%E5%85%A5\&#34;&gt;简单接入&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E7%B3%BB%E7%9A%84%E5%88%9B%E5%BB%BA\&#34;&gt;关系的创建&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9D%91\&#34;&gt;坑&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9D%911\&#34;&gt;坑1&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9D%912\&#34;&gt;坑2&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;之前就有了解过Cloudflare，但是一直没有去实践，最近了解到它提供了免费的CDN可以加速，所以想找个教程按流程试一下，一个是确实Github Pages访问太慢了（虽说Cloudflare在国内也没有节点...但聊胜于无），另一个主要是也可以学习拓展下知识。其实使用起来整个过程还是挺简单的，基本无脑操作。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;注册Cloudflare的账号，填写你的域名，交给它托管（打开官网，点击就送）&lt;/li&gt;\n&lt;li&gt;拷贝Cloudflare提供的DNS解析，替换你的域名服务商提供的解析（我使用的aliyun，在域名-管理-DNS解析）处可替换&lt;/li&gt;\n&lt;li&gt;等待几分钟，即可失效。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;上面的步骤更像是把大象放进冰箱的步骤，过于简单，主要是网络上针对此流程提供的优秀博客数不胜数，没必要再产生一篇重复的内容，并且文章也主要是用于记录自己接入的过程和遇到的坑。&lt;/p&gt;\n&lt;p&gt;我看的博客是： &lt;a href=\&#34;https://www.jun997.xyz/2022/05/18/62ef741104da.html\&#34;&gt;使用cdn加速Github Pages的访问速度&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;跟着这个博客基本就可以把域名完成托管，整个过程主要是遇到一个坑，在配置完成之后，发现本来通过aliyun解析的网站还能打开，托管之后反倒是打不开了，Chrome提示“重定向的次数过多”，这一步主要是因为解析配置的问题，可以登陆Cloudflare，然后再SSL/TLS菜单里调整下面的配置即可：&lt;br&gt;\n原本选中的是“灵活的”，调整为“严谨”即可。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719579571878.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;shi-yong-cloudflare-jia-su-github-pages&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;使用Cloudflare加速Github Pages&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2024-06-28 20:50:23&#34;,&#34;dateFormat&#34;:&#34;2024-06-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/shi-yong-cloudflare-jia-su-github-pages/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:85000,&#34;words&#34;:412,&#34;minutes&#34;:2},&#34;description&#34;:&#34;之前就有了解过Cloudflare，但是一直没有去实践，最近了解到它提供了免费的CDN可以加速，所以想找个教程按流程试一下，一个是确实Github Pages访问太慢了（虽说Cloudflare在国内也没有节点...但聊胜于无），另一个主要...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;字符串函数\&#34;&gt;字符串函数&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;match (n:Lianhuachi) where n.name = &#39;去种田的向凹凸&#39; return n.name,substring(n.name, 0,3)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1719414420545.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;aggregation聚合函数\&#34;&gt;AGGREGATION聚合函数&lt;/h1&gt;\n&lt;p&gt;和普通SQL一致的含义&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;match (n:Lianhuachi) return count(n),max(n.age),min(n.age),avg(n.age),sum(n.age)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1719414601279.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;关系函数\&#34;&gt;关系函数&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;match (x)-[n:`莲花池人物关系`]-&amp;gt;(y) return id(n),n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1719414748513.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;备份\&#34;&gt;备份&lt;/h1&gt;\n&lt;p&gt;Neo4j 官方文档： &lt;a href=\&#34;https://neo4j.com/docs/operations-manual/current/backup-restore/modes/\&#34;&gt;Backup modes&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;➜  bin ./neo4j-admin database dump neo4j --to-path=/tmp\n2024-06-26 15:24:15.414+0000 INFO  [o.n.c.d.DumpCommand] Starting dump of database &#39;neo4j&#39;\nDone: 37 files, 2.993MiB processed.\n2024-06-26 15:24:19.338+0000 INFO  [o.n.c.d.DumpCommand] Dump completed successfully\n\n\n➜  bin ll /tmp/ |grep &amp;quot;neo4j.dump&amp;quot;\n-rw-r--r--  1 imyzt   wheel   305K Jun 26 23:24 neo4j.dump\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;恢复\&#34;&gt;恢复&lt;/h1&gt;\n&lt;p&gt;Neo4j 官方文档： &lt;a href=\&#34;https://neo4j.com/docs/operations-manual/current/backup-restore/restore-dump/\&#34;&gt;Restore a database dump&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;➜  bin ./neo4j-admin database load --from-path=/tmp/ neo4j --overwrite-destination=true\nDone: 37 files, 2.993MiB processed.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到，数据恢复了过来。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719735796053.png\&#34; alt=\&#34;neo4j_restore\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;neo4j-chang-yong-han-shu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Neo4j常用函数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Neo4j&#34;,&#34;slug&#34;:&#34;XM6uOsCyh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/XM6uOsCyh/&#34;}],&#34;date&#34;:&#34;2024-06-26 23:05:34&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/neo4j-chang-yong-han-shu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:64000,&#34;words&#34;:199,&#34;minutes&#34;:2},&#34;description&#34;:&#34;字符串函数\nmatch (n:Lianhuachi) where n.name = &#39;去种田的向凹凸&#39; return n.name,substring(n.name, 0,3)\n\n\nAGGREGATION聚合函数\n和普通SQL一致的含义\nm...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0\&#34;&gt;字符串函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#aggregation%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0\&#34;&gt;AGGREGATION聚合函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E7%B3%BB%E5%87%BD%E6%95%B0\&#34;&gt;关系函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%87%E4%BB%BD\&#34;&gt;备份&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%81%A2%E5%A4%8D\&#34;&gt;恢复&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;unique约束\&#34;&gt;UNIQUE约束&lt;/h1&gt;\n&lt;p&gt;避免重复时使用（姓名、身份证不能重复）&lt;/p&gt;\n&lt;h2 id=\&#34;旧版本\&#34;&gt;旧版本&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;create constraint on (n:Lianhuachi) assert n.name is unique\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;新版本\&#34;&gt;新版本&lt;/h2&gt;\n&lt;p&gt;如果再执行上面的语法时报错，说明你使用的是新版本的Neo4j，变更了命令语法。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;create constraint uniq_name for (n:Lianhuachi) require n.name is unique\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在加了唯一索引后，可以看到，在添加重复数据时会报错：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719409875933.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;删除唯一约束\&#34;&gt;删除唯一约束&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;drop constraint uniq_name \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到，在删除之后再进行添加，是可以添加进去的。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;create (n:Lianhuachi {name: &amp;quot;我是野农&amp;quot;, &amp;quot;field&amp;quot;: &amp;quot;test&amp;quot;}) return n\nmatch (n:Lianhuachi {name: &amp;quot;我是野农&amp;quot;&amp;quot;}) return n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1719410056076.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;distinct去重\&#34;&gt;distinct去重&lt;/h1&gt;\n&lt;p&gt;和SQL一致，对内容进行去重&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;match (n:Lianhuachi) return distinct(n.name)\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;neo-chang-yong-ming-ling-er&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Neo常用命令 二&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Neo4j&#34;,&#34;slug&#34;:&#34;XM6uOsCyh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/XM6uOsCyh/&#34;}],&#34;date&#34;:&#34;2024-06-26 21:57:44&#34;,&#34;dateFormat&#34;:&#34;2024-06-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/neo-chang-yong-ming-ling-er/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:46000,&#34;words&#34;:184,&#34;minutes&#34;:1},&#34;description&#34;:&#34;UNIQUE约束\n避免重复时使用（姓名、身份证不能重复）\n旧版本\ncreate constraint on (n:Lianhuachi) assert n.name is unique\n\n新版本\n如果再执行上面的语法时报错，说明你使用的是新...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#unique%E7%BA%A6%E6%9D%9F\&#34;&gt;UNIQUE约束&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%97%A7%E7%89%88%E6%9C%AC\&#34;&gt;旧版本&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E7%89%88%E6%9C%AC\&#34;&gt;新版本&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F\&#34;&gt;删除唯一约束&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#distinct%E5%8E%BB%E9%87%8D\&#34;&gt;distinct去重&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;当一开始听说Spring-AI项目时是很懵的，什么？Spring开始训练模型了？不应该啊，Java还能卷模型赛道了吗？...&lt;br&gt;\n打开官网了解了下，才知道原来是缝合怪：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Spring AI is an application framework for AI engineering. Its goal is to apply to the AI domain Spring ecosystem design principles such as portability and modular design and promote using POJOs as the building blocks of an application to the AI domain.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;官网地址：&lt;a href=\&#34;https://spring.io/projects/spring-ai\&#34;&gt;https://spring.io/projects/spring-ai&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;换言之就是虽然Java不能卷算法，但是我可以提供一套封装来让你们调用模型提供的API服务，众所周知，我的抽象封装能力还是很强的。你看你们现在这么多厂商提供服务，不得需要一个统一的门面来减少接入成本嘛...&lt;/p&gt;\n&lt;p&gt;官网列举了目前国外主流的平台：&lt;br&gt;\n&lt;strong&gt;Chat Models&lt;/strong&gt;&lt;br&gt;\nOpenAI&lt;br&gt;\nAzure Open AI&lt;br&gt;\nAmazon Bedrock&lt;br&gt;\nCohere&#39;s Command&lt;br&gt;\nAI21 Labs&#39; Jurassic-2&lt;br&gt;\nMeta&#39;s LLama 2&lt;br&gt;\nAmazon&#39;s Titan&lt;br&gt;\nGoogle Vertex AI Palm&lt;br&gt;\nGoogle Gemini&lt;br&gt;\nHuggingFace - access thousands of models, including those from Meta such as Llama2&lt;br&gt;\nOllama - run AI models on your local machine&lt;br&gt;\nMistralAI&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Text-to-image Models&lt;/strong&gt;&lt;br&gt;\nOpenAI with DALL-E&lt;br&gt;\nStabilityAI&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Transcription (audio to text) Models&lt;/strong&gt;&lt;br&gt;\nOpenAI&lt;br&gt;\n... 数不胜数，更何况还有很多国内大厂开源的模型。&lt;/p&gt;\n&lt;p&gt;所以Spring提供了一套统一的封装门面，其他的厂商也可以基于门面来实现自己的Client，比如Alibaba就接入了&lt;code&gt;com.alibaba.cloud.ai.tongyi.chat.TongYiChatClient&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;这就引申出了本博客，记录了下我接入Spring-Ai（OpenAI）、Spring-Ai-Alibaba（TongYi）的过程。&lt;/p&gt;\n&lt;h1 id=\&#34;接入spring-ai\&#34;&gt;接入Spring-Ai&lt;/h1&gt;\n&lt;p&gt;Spring-Ai的接入相对简单，因为最新的&lt;code&gt;start.spring.io&lt;/code&gt;已经维护了&lt;code&gt;OpenAI&lt;/code&gt;的依赖包，在IDEA使用&lt;code&gt;Spring-Initializr&lt;/code&gt;即可完成初始化。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1718893769472.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;完成Gradle的初始化之后，得到了一个标准的Spring项目，只需要做一个简单的配置:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-properties\&#34;&gt;spring.application.name=spring-ai-demo\n# 生成结果多样性参数，值在0~2之间，值越大越随机越小越固定，但就算为0也会有随机性\nspring.ai.openai.chat.temperature=0.7\nspring.ai.chat.client.enabled=true\n# 如果你需要代理的话\nspring.ai.openai.base-url=https://api.xty.app\n# 填写自己的key\nspring.ai.openai.api-key=${OPENAI_API_KEY}\n# 填写你需要使用的模型（也可以使用时代码指定）\nspring.ai.openai.chat.options.model=gpt-3.5-turbo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;接下来只需要编写一个Java的控制器，来接收HTTP请求，就可以完成对OpenAI的对话。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2024/06/19\n * @description AI 入口\n */\n@RestController\n@RequestMapping\npublic class AiController {\n\n    @Resource\n    private ChatClient chatClient;\n\n    @GetMapping(&amp;quot;/ai/chat&amp;quot;)\n    Map&amp;lt;String, Object&amp;gt; chat(@RequestParam String question) {\n        ChatClient.ChatClientRequest.CallPromptResponseSpec call = chatClient.prompt(new Prompt(question)).call();\n        return Map.of(&amp;quot;question&amp;quot;, question, &amp;quot;answer&amp;quot;, call.chatResponse());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;整体接入还是比较简单的，但是这里踩了一个坑，不知道是我引入的版本比较新还是什么缘故，它的&lt;code&gt;ChatClient&lt;/code&gt; Bean 竟然没有自动注册！所以我还手动注册了一个Bean，代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Bean\npublic ChatClient chatClient(@Autowired OpenAiChatModel openAiChatModel) {\n    return ChatClient.builder(openAiChatModel).build();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;代码\&#34;&gt;代码&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-ai-demo/spring-ai-demo\&#34;&gt;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-ai-demo/spring-ai-demo&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;spring-ai-alibaba\&#34;&gt;Spring-Ai-Alibaba&lt;/h1&gt;\n&lt;p&gt;OpenAI由于API-KEY的费用蛮高，虽然完成了代码的接入，但是最终我还是没有购买它的API...所以又看了国内的厂商，目前主要是Alibaba完成了Spring-Ai的接入，整体接入其实也很简单，建议首先看一遍&lt;a href=\&#34;https://sca.aliyun.com/docs/2023/user-guide/ai/quick-start/\&#34;&gt;官网的例子&lt;/a&gt;，接下来可以跟着步骤走一下试试。&lt;/p&gt;\n&lt;h1 id=\&#34;创建项目引入依赖\&#34;&gt;创建项目，引入依赖&lt;/h1&gt;\n&lt;p&gt;首先完成一个普通SpringBootWeb项目创建，然后引入Alibaba-Ai的依赖&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-xml\&#34;&gt;&amp;lt;dependencies&amp;gt;\n    &amp;lt;dependency&amp;gt;\n        &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;\n        &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-ai&amp;lt;/artifactId&amp;gt;\n        &amp;lt;exclusions&amp;gt;\n            &amp;lt;exclusion&amp;gt;\n                &amp;lt;artifactId&amp;gt;spring-ai-core&amp;lt;/artifactId&amp;gt;\n                &amp;lt;groupId&amp;gt;org.springframework.ai&amp;lt;/groupId&amp;gt;\n            &amp;lt;/exclusion&amp;gt;\n        &amp;lt;/exclusions&amp;gt;\n    &amp;lt;/dependency&amp;gt;\n    &amp;lt;dependency&amp;gt;\n        &amp;lt;groupId&amp;gt;io.springboot.ai&amp;lt;/groupId&amp;gt;\n        &amp;lt;artifactId&amp;gt;spring-ai-core&amp;lt;/artifactId&amp;gt;\n        &amp;lt;version&amp;gt;1.0.3&amp;lt;/version&amp;gt;\n    &amp;lt;/dependency&amp;gt;\n\n&amp;lt;/dependencies&amp;gt;\n\n&amp;lt;dependencyManagement&amp;gt;\n    &amp;lt;dependencies&amp;gt;\n        &amp;lt;dependency&amp;gt;\n            &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;\n            &amp;lt;artifactId&amp;gt;spring-cloud-alibaba-dependencies&amp;lt;/artifactId&amp;gt;\n            &amp;lt;version&amp;gt;2023.0.1.0&amp;lt;/version&amp;gt;\n            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;\n            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;\n        &amp;lt;/dependency&amp;gt;\n    &amp;lt;/dependencies&amp;gt;\n&amp;lt;/dependencyManagement&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的内容，我把无关紧要的依赖去除了，只保留了核心部分，其中有一个关键点是&lt;code&gt;exclusions&lt;/code&gt;了&lt;code&gt;spring-ai-core&lt;/code&gt;，因为Alibaba引入的版本太老了。改为自己重新引入最新的版本，其他的和官方文档无差别。&lt;/p&gt;\n&lt;h2 id=\&#34;配置\&#34;&gt;配置&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-yml\&#34;&gt;spring:\n  application:\n    name: spring-ai-alibaba-demo\n  cloud:\n    ai:\n      tongyi:\n        api-key: ${TONGYI_KEY}\n        images:\n         enabled: true\n        chat:\n          enabled: true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;编写控制器\&#34;&gt;编写控制器&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Slf4j\n@RestController\n@RequestMapping\npublic class AiController {\n\n    @Resource\n    private ChatClient chatClient;\n    @Resource\n    private ImageClient imageClient;\n\n    @GetMapping(&amp;quot;/ai/chat&amp;quot;)\n    public String chat(@RequestParam String question) {\n        ChatResponse call = chatClient.call(new Prompt(question));\n        return call.getResult().getOutput().getContent();\n    }\n\n    @GetMapping(&amp;quot;/ai/aigc&amp;quot;)\n    public String aigc(@RequestParam String question) {\n        ImageResponse call = imageClient.call(new ImagePrompt(question));\n        return call.getResult().getOutput().getUrl();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;完成上面的步骤，基本就完成了接入，在&lt;code&gt;postman&lt;/code&gt;上面输入地址，就可以进行测试了。因为通义不仅有chat，还可以文生图，所以我完成下演示：&lt;/p&gt;\n&lt;h3 id=\&#34;文生文\&#34;&gt;文生文&lt;/h3&gt;\n&lt;p&gt;（质量不予置评）&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1718894828906.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;文生图\&#34;&gt;文生图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1718894931102.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;Spring-Ai-Alibaba还提供了一些示例，在他们的&lt;a href=\&#34;https://github.com/alibaba/spring-cloud-alibaba/tree/2023.x/spring-cloud-alibaba-examples/ai-example/spring-cloud-ai-example\&#34;&gt;官方Github&lt;/a&gt;上，可以参考。&lt;br&gt;\n官方还提供了一个简单的HTML来进行页面展示，也可以自己跑一下看看，最终效果如下：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1718895254096.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;代码-2\&#34;&gt;代码&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-ai-alibaba-demo/spring-ai-alibaba-demo\&#34;&gt;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-ai-alibaba-demo/spring-ai-alibaba-demo&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;参考博客\&#34;&gt;参考博客&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.cnblogs.com/xiezhr/p/18251683#!comments\&#34;&gt;阿里也出手了！Spring CloudAlibaba AI问世了 &lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.cnblogs.com/jingzh/p/18235636\&#34;&gt;AI框架之Spring AI与Spring Cloud Alibaba AI使用讲解 &lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-ai&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring AI&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Alibaba&#34;,&#34;slug&#34;:&#34;Q7Z8AksP6&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/Q7Z8AksP6/&#34;},{&#34;name&#34;:&#34;AI&#34;,&#34;slug&#34;:&#34;a3ySf_aXex&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/a3ySf_aXex/&#34;},{&#34;name&#34;:&#34;Spring&#34;,&#34;slug&#34;:&#34;r_PTn6Nd-&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/r_PTn6Nd-/&#34;}],&#34;date&#34;:&#34;2024-06-19 23:17:18&#34;,&#34;dateFormat&#34;:&#34;2024-06-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-ai/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:371000,&#34;words&#34;:1361,&#34;minutes&#34;:7},&#34;description&#34;:&#34;前言\n当一开始听说Spring-AI项目时是很懵的，什么？Spring开始训练模型了？不应该啊，Java还能卷模型赛道了吗？...\n打开官网了解了下，才知道原来是缝合怪：\n\nSpring AI is an application frame...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%85%A5spring-ai\&#34;&gt;接入Spring-Ai&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81\&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#spring-ai-alibaba\&#34;&gt;Spring-Ai-Alibaba&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\&#34;&gt;创建项目，引入依赖&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE\&#34;&gt;配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E6%8E%A7%E5%88%B6%E5%99%A8\&#34;&gt;编写控制器&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E7%94%9F%E6%96%87\&#34;&gt;文生文&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E7%94%9F%E5%9B%BE\&#34;&gt;文生图&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81-2\&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2\&#34;&gt;参考博客&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;什么是CDS？CDS即 &lt;code&gt;Class-Data Sharing&lt;/code&gt;，类数据共享功能，该功能可以减少Java应用程序的启动时间和内存占用。&lt;/p&gt;\n&lt;p&gt;类数据共享功能有助于减少多个Java虚拟机之间的启动时间和内存占用，从JDK12开始，默认的CDS归档文件和JDK二进制文件预先打包，我是用的JDK为OpenJDK &lt;code&gt;OpenJDK 64-Bit Server VM Zulu17.42+19-CA (build 17.0.7+7-LTS, mixed mode, sharing)&lt;/code&gt;，是支持CDS的。&lt;/p&gt;\n&lt;h1 id=\&#34;使用\&#34;&gt;使用&lt;/h1&gt;\n&lt;h2 id=\&#34;训练应用程序\&#34;&gt;训练应用程序&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;首先初始化一个标准的SpringBoot应用，使用 &lt;code&gt;SpringBoot-3.3.0&lt;/code&gt; + &lt;code&gt;Java17&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;├── pom.xml\n├── src\n│   ├── main\n│   │   ├── java\n│   │   │   └── top\n│   │   │       └── imyzt\n│   │   │           └── learning\n│   │   │               └── cds\n│   │   │                   └── Java12NewFuturesCdsApplication.java\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@SpringBootApplication\npublic class Java12NewFuturesCdsApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Java12NewFuturesCdsApplication.class, args);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;将其执行&lt;code&gt;Maven&lt;/code&gt;打包成&lt;code&gt;jar&lt;/code&gt;文件&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;➜  mvn package -DskipTests=true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;执行训练命令&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;➜  cd target\n➜  target ✗ java -Djarmode=tools -jar java12-new-futures-cds-0.0.1-SNAPSHOT.jar extract --destination application  \n➜  cd application\n➜  application ✗ java -XX:ArchiveClassesAtExit=application.jsa -Dspring.context.exit=onRefresh -jar java12-new-futures-cds-0.0.1-SNAPSHOT.jar\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;训练完成后，&lt;code&gt;application&lt;/code&gt;目录下，生成了一系列文件：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;➜  application git:(master) ✗ tree\n.\n├── application.jsa\n├── java12-new-futures-cds-0.0.1-SNAPSHOT.jar\n└── lib\n    ├── jackson-annotations-2.17.1.jar\n    ├── jackson-core-2.17.1.jar\n    ├── jackson-databind-2.17.1.jar\n    ├── jackson-datatype-jdk8-2.17.1.jar\n    ├── jackson-datatype-jsr310-2.17.1.jar\n    ├── jackson-module-parameter-names-2.17.1.jar\n    ├── jakarta.annotation-api-2.1.1.jar\n    ├── jul-to-slf4j-2.0.13.jar\n    ├── log4j-api-2.23.1.jar\n    ├── log4j-to-slf4j-2.23.1.jar\n    ├── logback-classic-1.5.6.jar\n    ├── logback-core-1.5.6.jar\n    ├── micrometer-commons-1.13.0.jar\n    ├── micrometer-observation-1.13.0.jar\n    ├── slf4j-api-2.0.13.jar\n    ├── snakeyaml-2.2.jar\n    ├── spring-aop-6.1.8.jar\n    ├── spring-beans-6.1.8.jar\n    ├── spring-boot-3.3.0.jar\n    ├── spring-boot-autoconfigure-3.3.0.jar\n    ├── spring-boot-jarmode-tools-3.3.0.jar\n    ├── spring-context-6.1.8.jar\n    ├── spring-core-6.1.8.jar\n    ├── spring-expression-6.1.8.jar\n    ├── spring-jcl-6.1.8.jar\n    ├── spring-web-6.1.8.jar\n    ├── spring-webmvc-6.1.8.jar\n    ├── tomcat-embed-core-10.1.24.jar\n    ├── tomcat-embed-el-10.1.24.jar\n    └── tomcat-embed-websocket-10.1.24.jar\n1 directory, 32 files\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;4\&#34;&gt;\n&lt;li&gt;使用训练的缓存，在启动应用程序时，补充&lt;code&gt;-XX:SharedArchiveFile&lt;/code&gt;参数即可。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;➜  application ✗ java -XX:SharedArchiveFile=application.jsa -jar java12-new-futures-cds-0.0.1-SNAPSHOT.jar\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;启动日志：&lt;br&gt;\nStarted Java12NewFuturesCdsApplication in &lt;strong&gt;2.262 seconds&lt;/strong&gt; (process running for 2.805)&lt;/p&gt;\n&lt;p&gt;对比不使用CDS缓存的启动日志：&lt;br&gt;\nStarted Java12NewFuturesCdsApplication in &lt;strong&gt;4.464 seconds&lt;/strong&gt; (process running for 5.341)&lt;/p&gt;\n&lt;p&gt;可以看出来，尽管只是一个空项目，但是相同配置情况下启动速度都有倍增。&lt;/p&gt;\n&lt;h1 id=\&#34;结语\&#34;&gt;结语&lt;/h1&gt;\n&lt;p&gt;从上面的测试可以看出来，项目的启动速度是有成本的效率增长的，但同时也存在弊端，就是每次应用程序发生变更时，需要冲洗进行jsa文件的训练。&lt;/p&gt;\n&lt;p&gt;不管是native-jar还是CDS，都是Java在云原生时代解决应用启动过程慢的探索，在应用的自动扩容领域，还是有不少的应用场景。&lt;/p&gt;\n&lt;h1 id=\&#34;参考\&#34;&gt;参考&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s/pRzztgb_lnob552QM_3ixA\&#34;&gt;Spring Boot 3.3.0 新特性| 使用 CDS 优化启动时间&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.cnblogs.com/use-D/p/17206585.html\&#34;&gt;CDS即Class-Data Sharing&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;java-new-future-cds&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java New Future CDS&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;},{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;rsjM0rjtG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/rsjM0rjtG/&#34;}],&#34;date&#34;:&#34;2024-06-01 23:06:04&#34;,&#34;dateFormat&#34;:&#34;2024-06-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-new-future-cds/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:206000,&#34;words&#34;:705,&#34;minutes&#34;:4},&#34;description&#34;:&#34;什么是CDS？CDS即 Class-Data Sharing，类数据共享功能，该功能可以减少Java应用程序的启动时间和内存占用。\n类数据共享功能有助于减少多个Java虚拟机之间的启动时间和内存占用，从JDK12开始，默认的CDS归档文件和...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8\&#34;&gt;使用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%AD%E7%BB%83%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F\&#34;&gt;训练应用程序&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E8%AF%AD\&#34;&gt;结语&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在Spring6.2版本后，支持了异步初始化。&lt;br&gt;\n什么是异步初始化？见名知意，就是将Spring项目的初始化过程中的Bean通过异步加载的方式提高启动速度。&lt;br&gt;\n在业务系统中通常启动不会特别耗时，但也可以将系统启动过程中需要耗时初始化的Bean通过异步将其并行初始化，节省部分启动时间。本文作为学习Why哥文章之后的简单使用记录。&lt;/p&gt;\n&lt;h1 id=\&#34;模拟初始化bean耗时\&#34;&gt;模拟初始化Bean耗时&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;ABean&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Slf4j\npublic class TestABean {\n    @SneakyThrows\n    public TestABean() {\n        log.info(&amp;quot;A Bean开始初始化&amp;quot;);\n        TimeUnit.SECONDS.sleep(5);\n        log.info(&amp;quot;A Bean初始化完成&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;BBean&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Slf4j\npublic class TestBBean {\n    @SneakyThrows\n    public TestBBean() {\n        log.info(&amp;quot;B Bean开始初始化&amp;quot;);\n        TimeUnit.SECONDS.sleep(6);\n        log.info(&amp;quot;B Bean初始化完成&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;配置类&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Configuration\npublic class RegisterConfiguration {\n    @Bean\n    public TestABean testABean() {\n        return new TestABean();\n    }\n    @Bean\n    public TestBBean testBBean() {\n        return new TestBBean();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;4\&#34;&gt;\n&lt;li&gt;启动类&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Slf4j\n@ComponentScan(&amp;quot;top.imyzt.learning.spring.startup&amp;quot;)\npublic class Application {\n    public static void main(String[] args) {\n        StopWatch stopWatch = new StopWatch(&amp;quot;Spring启动&amp;quot;);\n        stopWatch.start();\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Application.class);\n        stopWatch.stop();\n        System.out.println(stopWatch.prettyPrint());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;5\&#34;&gt;\n&lt;li&gt;启动日志&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-log\&#34;&gt;21:39:33.658 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;testABean&#39;\n21:39:33.663 [main] INFO top.imyzt.learning.spring.startup.core.TestABean - A Bean开始初始化\n21:39:38.667 [main] INFO top.imyzt.learning.spring.startup.core.TestABean - A Bean初始化完成\n21:39:38.669 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;testBBean&#39;\n21:39:38.670 [main] INFO top.imyzt.learning.spring.startup.core.TestBBean - B Bean开始初始化\n21:39:44.673 [main] INFO top.imyzt.learning.spring.startup.core.TestBBean - B Bean初始化完成\nStopWatch &#39;Spring启动&#39;: 11.555947229 seconds\n------------------------------------------\nSeconds       %       Task name\n------------------------------------------\n11.55594723   100%    \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;6\&#34;&gt;\n&lt;li&gt;小结&lt;br&gt;\n可以看到，在常规情况下，A和B Bean是串行初始化的，整个初始化耗时11.5s。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;异步初始化\&#34;&gt;异步初始化&lt;/h1&gt;\n&lt;p&gt;在Spring6.2版本中，&lt;code&gt;@Bean&lt;/code&gt;注解引入了一个新的属性：&lt;code&gt;bootstrap&lt;/code&gt;，默认&lt;code&gt;Bean.Bootstrap.DEFAULT&lt;/code&gt;时为串行初始化，当指定为&lt;code&gt;Bean.Bootstrap.BACKGROUND&lt;/code&gt;时，Spring会尝试异步初始化该Bean，但是需要配置一个名为&lt;code&gt;bootstrapExecutor&lt;/code&gt;的线程池，用作异步初始化时所需的线程。&lt;br&gt;\n只需要将配置类稍作修改，就可以将指定的Bean进行异步初始化：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Configuration\npublic class RegisterConfiguration {\n\n    @Bean(bootstrap = Bean.Bootstrap.BACKGROUND)\n    public TestABean testABean() {\n        return new TestABean();\n    }\n\n    @Bean(bootstrap = Bean.Bootstrap.BACKGROUND)\n    public TestBBean testBBean() {\n        return new TestBBean();\n    }\n\n    @Bean()\n    public Executor bootstrapExecutor() {\n        return new ThreadPoolExecutor(2, 10, 1, TimeUnit.MINUTES, new ArrayBlockingQueue&amp;lt;&amp;gt;(1024));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后我们再查看启动效果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-log\&#34;&gt;21:53:49.023 [pool-1-thread-1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;testABean&#39;\n21:53:49.024 [pool-1-thread-1] INFO top.imyzt.learning.spring.startup.core.TestABean - A Bean开始初始化\n21:53:49.025 [pool-1-thread-2] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;testBBean&#39;\n21:53:49.026 [pool-1-thread-2] INFO top.imyzt.learning.spring.startup.core.TestBBean - B Bean开始初始化\n21:53:54.029 [pool-1-thread-1] INFO top.imyzt.learning.spring.startup.core.TestABean - A Bean初始化完成\n21:53:55.031 [pool-1-thread-2] INFO top.imyzt.learning.spring.startup.core.TestBBean - B Bean初始化完成\nStopWatch &#39;Spring启动&#39;: 6.740055683 seconds\n-----------------------------------------\nSeconds       %       Task name\n-----------------------------------------\n6.740055683   100%    \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到启动时间从11.5s降为6.7s，效果十分显著，在部分需要依赖外部或已知需要耗时初始化的Bean，可以通过此方法进行优化。“我可以不用，你不能没有”。&lt;/p&gt;\n&lt;h1 id=\&#34;参考\&#34;&gt;参考&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s/FVHURjv5QZ3oYW4n8-kpLw\&#34;&gt;13年过去了，Spring官方竟然真的支持Bean的异步初始化了！&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/dive-in-springboot-projects/spring-async-startup\&#34;&gt;博客对应代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-yi-bu-chu-shi-hua&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring 异步初始化&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Spring&#34;,&#34;slug&#34;:&#34;r_PTn6Nd-&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/r_PTn6Nd-/&#34;},{&#34;name&#34;:&#34;Java developer&#34;,&#34;slug&#34;:&#34;Lix1FDBfB&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/Lix1FDBfB/&#34;}],&#34;date&#34;:&#34;2024-05-22 21:39:45&#34;,&#34;dateFormat&#34;:&#34;2024-05-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-yi-bu-chu-shi-hua/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:240000,&#34;words&#34;:840,&#34;minutes&#34;:5},&#34;description&#34;:&#34;在Spring6.2版本后，支持了异步初始化。\n什么是异步初始化？见名知意，就是将Spring项目的初始化过程中的Bean通过异步加载的方式提高启动速度。\n在业务系统中通常启动不会特别耗时，但也可以将系统启动过程中需要耗时初始化的Bean通...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A8%A1%E6%8B%9F%E5%88%9D%E5%A7%8B%E5%8C%96bean%E8%80%97%E6%97%B6\&#34;&gt;模拟初始化Bean耗时&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%82%E6%AD%A5%E5%88%9D%E5%A7%8B%E5%8C%96\&#34;&gt;异步初始化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在分析&lt;code&gt;内存泄漏&lt;/code&gt;领域的问题时，时常会提到的就是&lt;strong&gt;非静态内部类持有外部类的引用&lt;/strong&gt;导致的内存泄漏，因为内部类持有了外部类的引用，导致垃圾回收器无法回收外部类对象，久而久之就会存在内存泄漏的隐患。&lt;/p&gt;\n&lt;p&gt;我们在使用非静态内部类的时候，并不是说我们不手动编码引用外部类对象属性就不存在引用关系，实际上这层关系是通过隐式引用来实现的。&lt;/p&gt;\n&lt;h1 id=\&#34;静态内部类持有外部类的引用\&#34;&gt;静态内部类持有外部类的引用&lt;/h1&gt;\n&lt;p&gt;我们写一个非静态内部类对象示例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2024/05/13\n * @description 非静态内部类,匿名持有外部类的引用\n */\npublic class NonStaticInnerClazz {\n    private final String name;\n    public NonStaticInnerClazz(String name) {\n        this.name = name;\n    }\n    public class Inner {\n        public void print() {\n            System.out.println(name);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到javac之后的代码中，第九行方法形参将外部类&lt;code&gt;NonStaticInnerClazz&lt;/code&gt;传入给了内部类的&lt;code&gt;this.this$0&lt;/code&gt;属性进行引用。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1715606537329.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;非静态内部类无法引用外部类的属性\&#34;&gt;非静态内部类无法引用外部类的属性&lt;/h1&gt;\n&lt;p&gt;而非静态内部类则没有这种情况。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2024/05/13\n * @description 静态内部类,无法引用外部类的属性\n */\npublic class StaticInnerClazz {\n    private final String name;\n    public StaticInnerClazz(String name) {\n        this.name = name;\n    }\n    public static class Inner2 {\n        public void print2() {\n            // Non-static field &#39;name&#39; cannot be referenced from a static context\n            // System.out.println(name);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1715606551056.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;其他非静态内部类引用的情况\&#34;&gt;其他非静态内部类引用的情况&lt;/h1&gt;\n&lt;p&gt;而其他非静态内部类的情况也有类似的问题：&lt;br&gt;\n编写测试类：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2024/05/13\n * @description 描述信息\n */\npublic class NonStaticFieldClazz {\n    // 成员变量-匿名内部类的非static实例\n    private Inner3 inner3_1 = new Inner3() {\n        private Integer field_111;\n    };\n    // 成员变量-非静态内部类的非static实例\n    private Inner3 inner3_2 = new Inner3();\n    public void print() {\n        // 局部变量-匿名内部类的非static实例\n        Inner3 inner3_3 = new Inner3() {\n            private Integer field_333;\n        };\n        // 局部变量-非静态内部类的非static实例\n        Inner3 inner3_4 = new Inner3();\n    }\n    public class Inner3 {\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;1-成员变量-匿名内部类的非static实例\&#34;&gt;1. 成员变量-匿名内部类的非static实例&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class NonStaticFieldClazz$1 extends NonStaticFieldClazz.Inner3 {\n    private Integer field_111;\n    NonStaticFieldClazz$1(NonStaticFieldClazz var1) {\n        super(var1);\n        this.this$0 = var1;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-局部变量-匿名内部类的非static实例\&#34;&gt;2. 局部变量-匿名内部类的非static实例&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class NonStaticFieldClazz$2 extends NonStaticFieldClazz.Inner3 {\n    private Integer field_333;\n    NonStaticFieldClazz$2(NonStaticFieldClazz var1) {\n        super(var1);\n        this.this$0 = var1;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;3-局部变量和成员变量的非static内部类的非static实例\&#34;&gt;3. 局部变量和成员变量的非static内部类的非static实例&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class NonStaticFieldClazz$Inner3 {\n    public NonStaticFieldClazz$Inner3(NonStaticFieldClazz var1) {\n        this.this$0 = var1;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;参考\&#34;&gt;参考：&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://blog.csdn.net/whurs/article/details/103231427\&#34;&gt;内存泄漏-内部类持有外部类引用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;fei-jing-tai-nei-bu-lei-chi-you-wai-bu-lei-de-yin-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;非静态内部类持有外部类的引用&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2024-05-13 21:16:11&#34;,&#34;dateFormat&#34;:&#34;2024-05-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/fei-jing-tai-nei-bu-lei-chi-you-wai-bu-lei-de-yin-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:152000,&#34;words&#34;:605,&#34;minutes&#34;:3},&#34;description&#34;:&#34;在分析内存泄漏领域的问题时，时常会提到的就是非静态内部类持有外部类的引用导致的内存泄漏，因为内部类持有了外部类的引用，导致垃圾回收器无法回收外部类对象，久而久之就会存在内存泄漏的隐患。\n我们在使用非静态内部类的时候，并不是说我们不手动编码引...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%8C%81%E6%9C%89%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8\&#34;&gt;静态内部类持有外部类的引用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%97%A0%E6%B3%95%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7\&#34;&gt;非静态内部类无法引用外部类的属性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B6%E4%BB%96%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%BC%95%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5\&#34;&gt;其他非静态内部类引用的情况&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E9%9D%9Estatic%E5%AE%9E%E4%BE%8B\&#34;&gt;1. 成员变量-匿名内部类的非static实例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E9%9D%9Estatic%E5%AE%9E%E4%BE%8B\&#34;&gt;2. 局部变量-匿名内部类的非static实例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E9%9D%9Estatic%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E9%9D%9Estatic%E5%AE%9E%E4%BE%8B\&#34;&gt;3. 局部变量和成员变量的非static内部类的非static实例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;where\&#34;&gt;WHERE&lt;/h1&gt;\n&lt;p&gt;可以类似于SQL的写法来实现，首先通过&lt;code&gt;match&lt;/code&gt;将节点查询出来(n,m)，然后通过&lt;code&gt;WHERE&lt;/code&gt;将数据&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;match (n:Lianhuachi),(m:Lianhuachi) where n.name = &#39;去种田的向凹凸&#39; and m.name = &amp;quot;向云朵&amp;quot;\nreturn id(n),n.name,id(m),m.name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;match (n:Lianhuachi {name: &amp;quot;去种田的向凹凸&amp;quot;}),(m:Lianhuachi {name: &amp;quot;向云朵&amp;quot;})\nreturn id(n),n.name,id(m),m.name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;delete-删除节点\&#34;&gt;DELETE-删除节点&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;删除节点（如果节点存在关系时，是无法删除的）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;match (n: Person {name: &amp;quot;xxx&amp;quot;}) delete n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;删除关系&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;match (n: Person {name: &amp;quot;小红&amp;quot;})-[r]-&amp;gt;(m: Person {name: &amp;quot;小明&amp;quot;}) delete r\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;remove-删除属性\&#34;&gt;REMOVE-删除属性&lt;/h1&gt;\n&lt;h2 id=\&#34;首先在student和person标签创建1一个节点\&#34;&gt;首先，在student和person标签创建1一个节点&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-cql\&#34;&gt;create (n:student:person {name: &amp;quot;张三&amp;quot;, age: 18}) return n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;查询节点\&#34;&gt;查询节点&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;MATCH (n:person) where n.name = &amp;quot;张三&amp;quot; RETURN n LIMIT 25&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1715301497013.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;code&gt;MATCH (n:student) RETURN n LIMIT 25&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1715301490854.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;删除标签中的节点\&#34;&gt;删除标签中的节点&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;MATCH (n:person) where n.name = &amp;quot;张三&amp;quot; remove n&lt;/code&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;删除标签中节点的属性\&#34;&gt;删除标签中节点的属性&lt;/h2&gt;\n&lt;p&gt;删除前，age=18 &lt;code&gt;MATCH (n:student) where n.name = &amp;quot;张三&amp;quot; return n&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1715301732611.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n删除后，age无了 &lt;code&gt;MATCH (n:student) where n.name = &amp;quot;张三&amp;quot; remove n.age return n&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1715301781763.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;修改标签中节点的属性\&#34;&gt;修改标签中节点的属性&lt;/h2&gt;\n&lt;p&gt;修改后，age回来了 &lt;code&gt;MATCH (n:student) where n.name = &amp;quot;张三&amp;quot; set n.age=18 return n&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1715301862819.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n给榜首增加一个属性 &lt;code&gt;match (n:Lianhuachi {name: &amp;quot;我是野农&amp;quot;}) set n.title = &#39;虾米榜榜首&#39; return n&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1719409420804.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;order-by-排序\&#34;&gt;ORDER BY - 排序&lt;/h1&gt;\n&lt;p&gt;补充测试数据&lt;br&gt;\n&lt;code&gt;create (n:student {name: &amp;quot;张三&amp;quot;, age: 18}),(m:student {name: &amp;quot;李四&amp;quot;, age: 22}) return n,m&lt;/code&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;排序\&#34;&gt;排序&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;match (n:student) return id(n), n.name,n.age order by n.age desc &lt;/code&gt;&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;id(n)&lt;/th&gt;\n&lt;th&gt;n.name&lt;/th&gt;\n&lt;th&gt;n.age&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;120&lt;/td&gt;\n&lt;td&gt;&amp;quot;李四&amp;quot;&lt;/td&gt;\n&lt;td&gt;22&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;119&lt;/td&gt;\n&lt;td&gt;&amp;quot;张三&amp;quot;&lt;/td&gt;\n&lt;td&gt;18&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h1 id=\&#34;null-null属性\&#34;&gt;NULL - NULL属性&lt;/h1&gt;\n&lt;p&gt;查询&lt;code&gt;name&lt;/code&gt;属性不为空的节点&lt;br&gt;\n&lt;code&gt;match (n:student) where n.name is not null return n.name,n.label&lt;/code&gt;&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;n.name&lt;/th&gt;\n&lt;th&gt;n.label&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;&amp;quot;张三&amp;quot;&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&amp;quot;李四&amp;quot;&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;查询&lt;code&gt;sex&lt;/code&gt;属性为空的节点&lt;br&gt;\n&lt;code&gt;match (n:student) where n.sex is null return n.name,n.label&lt;/code&gt;&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;n.name&lt;/th&gt;\n&lt;th&gt;n.label&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;&amp;quot;张三&amp;quot;&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&amp;quot;李四&amp;quot;&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;给&lt;strong&gt;张三&lt;/strong&gt;设置&lt;code&gt;sex&lt;/code&gt;属性，注意&lt;code&gt;where&lt;/code&gt;在前，&lt;code&gt;set&lt;/code&gt;在后，和&lt;code&gt;MySQL&lt;/code&gt;等相反&lt;br&gt;\n&lt;code&gt;match (n:student)  where n.name=&#39;张三&#39; set n.sex=&#39;男&#39; return n.name,n.sex,n.age&lt;/code&gt;&lt;br&gt;\n查询结果：&lt;code&gt;match (n:student) return n&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1715526279128.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;in-查询多个\&#34;&gt;IN - 查询多个&lt;/h1&gt;\n&lt;p&gt;查询&lt;code&gt;name&lt;/code&gt;等于张三或李四的人：&lt;br&gt;\n&lt;code&gt;match (n:student) where n.name in [&amp;quot;张三&amp;quot;, &amp;quot;李四&amp;quot;] return n&lt;/code&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;索引\&#34;&gt;索引&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://neo4j.com/docs/cypher-manual/current/indexes/search-performance-indexes/managing-indexes/\&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;旧版本\&#34;&gt;旧版本&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;创建索引：&lt;br&gt;\n&lt;code&gt;create index on :节点 (属性)&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除索引：&lt;br&gt;\n&lt;code&gt;drop index on :节点(属性)&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;新版本5或更高版本\&#34;&gt;新版本(5或更高版本)&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;创建索引：&lt;br&gt;\n缺省索引名称：&lt;br&gt;\n&lt;code&gt;CREATE INDEX [index_name（可缺省）] FOR (n:person) ON (n.name)&lt;/code&gt;&lt;br&gt;\n指定索引名称：&lt;br&gt;\n&lt;code&gt;create index index_test for (n:person) on (n.name)&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;Added 1 index, completed after 992 ms.&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查询所有索引：&lt;br&gt;\n&lt;code&gt;show indexes&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;id&lt;/th&gt;\n&lt;th&gt;name&lt;/th&gt;\n&lt;th&gt;state&lt;/th&gt;\n&lt;th&gt;populationPercent&lt;/th&gt;\n&lt;th&gt;type&lt;/th&gt;\n&lt;th&gt;entityType&lt;/th&gt;\n&lt;th&gt;labelsOrTypes&lt;/th&gt;\n&lt;th&gt;properties&lt;/th&gt;\n&lt;th&gt;indexProvider&lt;/th&gt;\n&lt;th&gt;owningConstraint&lt;/th&gt;\n&lt;th&gt;lastRead&lt;/th&gt;\n&lt;th&gt;readCount&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;&amp;quot;index_343aff4e&amp;quot;&lt;/td&gt;\n&lt;td&gt;&amp;quot;ONLINE&amp;quot;&lt;/td&gt;\n&lt;td&gt;100&lt;/td&gt;\n&lt;td&gt;&amp;quot;LOOKUP&amp;quot;&lt;/td&gt;\n&lt;td&gt;&amp;quot;NODE&amp;quot;&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;td&gt;&amp;quot;token-lookup-1.0&amp;quot;&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;td&gt;&amp;quot;2024-05-18T13:26:33.878000000Z&amp;quot;&lt;/td&gt;\n&lt;td&gt;571&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;3&lt;/td&gt;\n&lt;td&gt;&amp;quot;index_a302cc54&amp;quot;&lt;/td&gt;\n&lt;td&gt;&amp;quot;ONLINE&amp;quot;&lt;/td&gt;\n&lt;td&gt;100&lt;/td&gt;\n&lt;td&gt;&amp;quot;RANGE&amp;quot;&lt;/td&gt;\n&lt;td&gt;&amp;quot;NODE&amp;quot;&lt;/td&gt;\n&lt;td&gt;[&amp;quot;person&amp;quot;]&lt;/td&gt;\n&lt;td&gt;[&amp;quot;name&amp;quot;]&lt;/td&gt;\n&lt;td&gt;&amp;quot;range-1.0&amp;quot;&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;2&lt;/td&gt;\n&lt;td&gt;&amp;quot;index_f7700477&amp;quot;&lt;/td&gt;\n&lt;td&gt;&amp;quot;ONLINE&amp;quot;&lt;/td&gt;\n&lt;td&gt;100&lt;/td&gt;\n&lt;td&gt;&amp;quot;LOOKUP&amp;quot;&lt;/td&gt;\n&lt;td&gt;&amp;quot;RELATIONSHIP&amp;quot;&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;td&gt;&amp;quot;token-lookup-1.0&amp;quot;&lt;/td&gt;\n&lt;td&gt;null&lt;/td&gt;\n&lt;td&gt;&amp;quot;2024-05-10T00:48:00.395000000Z&amp;quot;&lt;/td&gt;\n&lt;td&gt;67&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;ul&gt;\n&lt;li&gt;删除索引：&lt;br&gt;\n&lt;code&gt;drop index index_a302cc54&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;Removed 1 index, completed after 5 ms.&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;neo4j-chang-yong-ming-ling&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Neo4j 常用命令 一&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Neo4j&#34;,&#34;slug&#34;:&#34;XM6uOsCyh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/XM6uOsCyh/&#34;}],&#34;date&#34;:&#34;2024-05-08 23:08:23&#34;,&#34;dateFormat&#34;:&#34;2024-05-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/neo4j-chang-yong-ming-ling/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:235000,&#34;words&#34;:779,&#34;minutes&#34;:4},&#34;description&#34;:&#34;WHERE\n可以类似于SQL的写法来实现，首先通过match将节点查询出来(n,m)，然后通过WHERE将数据\nmatch (n:Lianhuachi),(m:Lianhuachi) where n.name = &#39;去种田的向凹凸&#39; and...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#where\&#34;&gt;WHERE&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#delete-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9\&#34;&gt;DELETE-删除节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#remove-%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7\&#34;&gt;REMOVE-删除属性&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A6%96%E5%85%88%E5%9C%A8student%E5%92%8Cperson%E6%A0%87%E7%AD%BE%E5%88%9B%E5%BB%BA1%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9\&#34;&gt;首先，在student和person标签创建1一个节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E8%AF%A2%E8%8A%82%E7%82%B9\&#34;&gt;查询节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9\&#34;&gt;删除标签中的节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7\&#34;&gt;删除标签中节点的属性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9%E6%A0%87%E7%AD%BE%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7\&#34;&gt;修改标签中节点的属性&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#order-by-%E6%8E%92%E5%BA%8F\&#34;&gt;ORDER BY - 排序&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%92%E5%BA%8F\&#34;&gt;排序&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#null-null%E5%B1%9E%E6%80%A7\&#34;&gt;NULL - NULL属性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#in-%E6%9F%A5%E8%AF%A2%E5%A4%9A%E4%B8%AA\&#34;&gt;IN - 查询多个&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B4%A2%E5%BC%95\&#34;&gt;索引&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%97%A7%E7%89%88%E6%9C%AC\&#34;&gt;旧版本&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E7%89%88%E6%9C%AC5%E6%88%96%E6%9B%B4%E9%AB%98%E7%89%88%E6%9C%AC\&#34;&gt;新版本(5或更高版本)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;最近关注了沅陵的莲花池，整个村子都是钓鱼佬，人均up主，基本都是沾亲带故的，错综复杂，恰逢正在学习Neo4j，可以借此机会将人物关系通过图谱的方式呈现出来。&lt;/p&gt;\n&lt;h1 id=\&#34;人物标签创建\&#34;&gt;人物标签创建&lt;/h1&gt;\n&lt;p&gt;首先将人物关系建立出来，利用&lt;code&gt;create&lt;/code&gt;来创建效率实在太低了 ，所以决定采用数据导入的方式。&lt;/p&gt;\n&lt;details&gt;\n&lt;summary&gt;点击查看莲花池人物详情&lt;/summary&gt;\n&lt;div&gt;\n  去种田的向凹凸  \n  &lt;div&gt;\n    小白兔的胡萝卜甜（冉甜）\n  &lt;/div&gt;\n  &lt;div&gt;\n    向云朵\n  &lt;/div&gt;\n  &lt;div&gt;\n    我是野农\n  &lt;/div&gt;\n  &lt;div&gt;\n    画燕儿\n  &lt;/div&gt;\n  &lt;div&gt;\n    向鹿鸣\n  &lt;/div&gt;\n  &lt;div&gt;\n    路人阿丙X\n  &lt;/div&gt;\n  &lt;div&gt;\n    大明星（冉蜜）\n  &lt;/div&gt;\n  &lt;div&gt;\n    向偶然\n  &lt;/div&gt;\n  &lt;div&gt;\n    荷塘星星\n  &lt;/div&gt;\n  &lt;div&gt;\n    向尘俊\n  &lt;/div&gt;\n  &lt;div&gt;\n    向星言\n  &lt;/div&gt;\n  &lt;div&gt;\n    多肉葡萄肉多多\n  &lt;/div&gt;\n  &lt;div&gt;\n    白叔\n  &lt;/div&gt;\n  &lt;div&gt;\n    播音哥\n  &lt;/div&gt;\n  &lt;div&gt;\n    三叔\n  &lt;/div&gt;\n  &lt;div&gt;\n    丹宝\n  &lt;/div&gt;\n  &lt;div&gt;\n    守山人阿亮\n  &lt;/div&gt;\n&lt;/div&gt;  \n&lt;/details&gt;\n&lt;p&gt;导入数据：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;load csv from &amp;quot;file:///莲花池人物.csv&amp;quot; as line \ncreate (:Lianhuachi {name: line[0]})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最终效果图：&lt;br&gt;\n&lt;code&gt;MATCH (n:Lianhuachi) RETURN n LIMIT 25&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1713798289894.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;人物关系标签创建\&#34;&gt;人物关系标签创建&lt;/h1&gt;\n&lt;details&gt;\n&lt;summary&gt;莲花池人物关系（简版）&lt;/summary&gt;\n  &lt;div&gt;小白兔的胡萝卜甜（冉甜）,丈夫,去种田的向凹凸&lt;/div&gt;\n  &lt;div&gt;去种田的向凹凸,妻子,小白兔的胡萝卜甜（冉甜）&lt;/div&gt;\n  &lt;div&gt;小白兔的胡萝卜甜（冉甜）,女儿,向云朵&lt;/div&gt;\n  &lt;div&gt;去种田的向凹凸,女儿,向云朵&lt;/div&gt;\n  &lt;div&gt;画燕儿,丈夫,我是野农&lt;/div&gt;\n  &lt;div&gt;我是野农,妻子,画燕儿&lt;/div&gt;\n  &lt;div&gt;画燕儿,儿子,向鹿鸣&lt;/div&gt;\n  &lt;div&gt;我是野农,儿子,向鹿鸣&lt;/div&gt;\n  &lt;div&gt;大明星（冉蜜）,丈夫,路人阿丙X&lt;/div&gt;\n  &lt;div&gt;路人阿丙X,妻子,大明星（冉蜜）&lt;/div&gt;\n  &lt;div&gt;大明星（冉蜜）,女儿,向偶然&lt;/div&gt;\n  &lt;div&gt;路人阿丙X,女儿,向偶然&lt;/div&gt;\n  &lt;div&gt;多肉葡萄肉多多,丈夫,荷塘星星&lt;/div&gt;\n  &lt;div&gt;荷塘星星,妻子,多肉葡萄肉多多&lt;/div&gt;\n  &lt;div&gt;荷塘星星,儿子,向尘俊&lt;/div&gt;\n  &lt;div&gt;多肉葡萄肉多多,儿子,向尘俊&lt;/div&gt;\n  &lt;div&gt;荷塘星星,女儿,向星言&lt;/div&gt;\n  &lt;div&gt;多肉葡萄肉多多,女儿,向星言&lt;/div&gt;\n  &lt;div&gt;向星言,亲哥,向尘俊&lt;/div&gt;\n  &lt;div&gt;向尘俊,亲妹,向星言&lt;/div&gt;\n  &lt;div&gt;荷塘星星,父亲,三叔&lt;/div&gt;\n  &lt;div&gt;三叔,儿子,荷塘星星&lt;/div&gt;\n  &lt;div&gt;荷塘星星,表哥,守山人阿亮&lt;/div&gt;\n  &lt;div&gt;守山人阿亮,表弟,荷塘星星&lt;/div&gt;\n  &lt;div&gt;我是野农,亲弟,路人阿丙X&lt;/div&gt;\n  &lt;div&gt;路人阿丙X,亲哥,我是野农&lt;/div&gt;\n  &lt;div&gt;我是野农,钓友,去种田的向凹凸&lt;/div&gt;\n  &lt;div&gt;去种田的向凹凸,钓友,我是野农&lt;/div&gt;\n  &lt;div&gt;去种田的向凹凸,同村,荷塘星星&lt;/div&gt;\n  &lt;div&gt;我是野农,钓友,荷塘星星&lt;/div&gt;\n  &lt;div&gt;荷塘星星,钓友,我是野农&lt;/div&gt;\n  &lt;div&gt;去种田的向凹凸,同村,荷塘星星&lt;/div&gt;\n&lt;/details&gt;\n&lt;p&gt;导入数据：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;load csv from &amp;quot;file:///莲花池人物关系.csv&amp;quot; as line \ncreate (n:LianhuachiRelation {from: line[0], relation: line[1], to: line[2]})\nreturn n.from, n.relation, n.to\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最终效果：&lt;br&gt;\n&lt;code&gt;MATCH (n:LianhuachiRelation) RETURN n.from, n.relation, n.to&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1714056955094.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;借助人物关系标签创建人物关系\&#34;&gt;借助人物关系标签，创建人物关系&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;match (f:Lianhuachi),(r:LianhuachiRelation),(t:Lianhuachi) where f.name=r.from and t.name=r.to\ncreate (f)-[rr:莲花池人物关系 {relation: r.relation}]-&amp;gt;(t)\nreturn f.name, rr.relation, t.name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最终效果：&lt;br&gt;\n&lt;code&gt;MATCH p=()-[r:&lt;/code&gt;莲花池人物关系&lt;code&gt;]-&amp;gt;() RETURN p LIMIT 25&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1714057384358.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;查询人物关系\&#34;&gt;查询人物关系&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;match (n:Lianhuachi {name: &amp;quot;向云朵&amp;quot;}),(m:LianhuachiRelation) where m.from=&#39;向云朵&#39;\n    return n.name, m.relation, m.to\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1713968908751.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;在现有的基础上补充人物关系\&#34;&gt;在现有的基础上，补充人物关系&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;match (n:Lianhuachi{name:&amp;quot;大明星（冉蜜）&amp;quot;}),(m:Lianhuachi{name:&amp;quot;小白兔的胡萝卜甜（冉甜）&amp;quot;})\ncreate (n)-[r:`莲花池人物关系`{relation:&amp;quot;亲姐&amp;quot;}]-&amp;gt;(m)\n\nmatch (n:Lianhuachi{name:&amp;quot;大明星（冉蜜）&amp;quot;}),(m:Lianhuachi{name:&amp;quot;小白兔的胡萝卜甜（冉甜）&amp;quot;})\ncreate (m)-[r:`莲花池人物关系`{relation:&amp;quot;亲妹&amp;quot;}]-&amp;gt;(n)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1714204509855.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;删除重建人物关系\&#34;&gt;删除重建人物关系&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;MATCH (n:Lianhuachi {name:&amp;quot;去种田的向凹凸&amp;quot;})-[r:`莲花池人物关系` {relation: &amp;quot;钓友&amp;quot;}]-&amp;gt;(m:Lianhuachi {name:&amp;quot;我是野农&amp;quot;})\ndelete r\nMATCH (n:Lianhuachi {name:&amp;quot;我是野农&amp;quot;})-[r:`莲花池人物关系` {relation: &amp;quot;钓友&amp;quot;}]-&amp;gt;(m:Lianhuachi {name:&amp;quot;去种田的向凹凸&amp;quot;})\ndelete r\n\nMATCH (n:Lianhuachi {name:&amp;quot;去种田的向凹凸&amp;quot;}),(m:Lianhuachi {name:&amp;quot;我是野农&amp;quot;})\ncreate (n)-[r2:`莲花池人物关系` {relation: &amp;quot;表哥&amp;quot;}]-&amp;gt;(m)\ncreate (m)-[r3:`莲花池人物关系` {relation: &amp;quot;表弟&amp;quot;}]-&amp;gt;(n)\n return r2.relation,r3.relation\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1715004118846.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;shi-yong-neo4j-jian-li-lian-hua-chi-ren-wu-guan-xi-tu-he-xin-ren-wu-jian-ban&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;使用Neo4j建立莲花池人物关系图（核心人物，简版）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Neo4j&#34;,&#34;slug&#34;:&#34;XM6uOsCyh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/XM6uOsCyh/&#34;}],&#34;date&#34;:&#34;2024-04-22 22:17:43&#34;,&#34;dateFormat&#34;:&#34;2024-04-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/shi-yong-neo4j-jian-li-lian-hua-chi-ren-wu-guan-xi-tu-he-xin-ren-wu-jian-ban/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:241000,&#34;words&#34;:1005,&#34;minutes&#34;:5},&#34;description&#34;:&#34;最近关注了沅陵的莲花池，整个村子都是钓鱼佬，人均up主，基本都是沾亲带故的，错综复杂，恰逢正在学习Neo4j，可以借此机会将人物关系通过图谱的方式呈现出来。\n人物标签创建\n首先将人物关系建立出来，利用create来创建效率实在太低了 ，所以...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%BA%E7%89%A9%E6%A0%87%E7%AD%BE%E5%88%9B%E5%BB%BA\&#34;&gt;人物标签创建&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB%E6%A0%87%E7%AD%BE%E5%88%9B%E5%BB%BA\&#34;&gt;人物关系标签创建&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%80%9F%E5%8A%A9%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB%E6%A0%87%E7%AD%BE%E5%88%9B%E5%BB%BA%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB\&#34;&gt;借助人物关系标签，创建人物关系&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E8%AF%A2%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB\&#34;&gt;查询人物关系&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E7%8E%B0%E6%9C%89%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%A1%A5%E5%85%85%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB\&#34;&gt;在现有的基础上，补充人物关系&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E9%87%8D%E5%BB%BA%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB\&#34;&gt;删除重建人物关系&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;项目需要整理所有依赖的外部Feign调用，整理成一份文档，类似于：&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;远程接口&lt;/th&gt;\n&lt;th&gt;调用位置&lt;/th&gt;\n&lt;th&gt;作用&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;xxx/zzz&lt;/td&gt;\n&lt;td&gt;top.imyzt.xxx#methodName&lt;/td&gt;\n&lt;td&gt;用作xxx&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h1 id=\&#34;方案\&#34;&gt;方案&lt;/h1&gt;\n&lt;p&gt;因为项目过多，且依赖的外部服务接口众多，不想一个个去整理，故想直接读取所有的Feign接口，直接扫描出方法注释，将上述表格完成。&lt;/p&gt;\n&lt;p&gt;Java是编译型语言，当代码从&lt;code&gt;.java&lt;/code&gt;编译成&lt;code&gt;.class&lt;/code&gt;后，代码中的注释将会清空，所以说，项目打包之后，就无法再进行注释的解析了，所以反射等方案不可行，通过在Google搜索，发现了&lt;code&gt;com.sun.tools.javadoc.Main&lt;/code&gt;工具类，可以直接读取文件的形式读取&lt;code&gt;.java&lt;/code&gt;文件，然后解析其中的各类注释信息，使用起来也很简单，下面举个例子：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * 类注释\n * @author imyzt\n * @date 2024/04/10\n */\npublic class Demo {\n\n    /**\n     * 方法注释\n     */\n    public void demo() {\n\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面是一个简单的带注释的类，通过sun公司的工具类，可以直接读取：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Doclet {\n    public static Logger logger = LoggerFactory.getLogger(Doclet.class);\n\n    private static RootDoc rootDoc;\n    private final String clsFilePath;\n\n    public static boolean start(RootDoc root) {\n        rootDoc = root;\n        return true;\n    }\n\n    public Doclet(String clsFilePath) {\n        this.clsFilePath = clsFilePath;\n    }\n\n    public void exec() {\n        com.sun.tools.javadoc.Main.execute(\n                new String[]{&amp;quot;-doclet&amp;quot;, Doclet.class.getName(),\n                        &amp;quot;-docletpath&amp;quot;, Doclet.class.getResource(&amp;quot;/&amp;quot;).getPath(),\n                        &amp;quot;-encoding&amp;quot;, &amp;quot;utf-8&amp;quot;,\n                        clsFilePath});\n        ClassDoc[] classes = rootDoc.classes();\n\n        if (classes == null || classes.length == 0) {\n            logger.warn(clsFilePath + &amp;quot; 无ClassDoc信息&amp;quot;);\n            return;\n        }\n\n        ClassDoc classDoc = classes[0];\n        // 获取类的名称\n        System.err.println(&amp;quot;类名：&amp;quot; + classDoc.name());\n        // 获取类的注释\n        String classComment = Reflect.on(classDoc).field(&amp;quot;documentation&amp;quot;).get().toString();\n        System.err.println(&amp;quot;类注释：&amp;quot; + classComment);\n        // 获取属性名称和注释\n        for (FieldDoc field : classDoc.fields(false)) {\n            System.err.printf(&amp;quot;属性名：%s, 属性类型：%s, 注释：%s%n&amp;quot;, field.name(), field.type().typeName(), field.commentText());\n        }\n\n        for (MethodDoc method : classDoc.methods(false)) {\n            System.err.printf(&amp;quot;方法名：%s, 方法返回类型：%s, 注释：%s%n&amp;quot;, method.name(), method.returnType().typeName(), method.commentText());\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最终的运行效果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class CommentReader {\n\n    public static void main(String[] args) {\n        Doclet doclet = new Doclet(&amp;quot;/Users/.../java-reader-classormethod-comment/src/main/java/top/imyzt/learing/readercomment/Demo.java&amp;quot;);\n        doclet.exec();\n        // 正在构造 Javadoc 信息...\n        // 类名：Demo\n        // 类注释： 类注释\n        //  @author imyzt\n        //  @date 2024/04/10\n        //\n        // 方法名：demo, 方法返回类型：void, 注释：方法注释\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过这个工具类，可以快速的读取，解析各类注释信息，进行资料的整理。&lt;br&gt;\n工具类还有很多其他的API，网上资料也很多，这里只是记录做一个备忘，具体的使用时进行Google搜索即可。&lt;/p&gt;\n&lt;h1 id=\&#34;示例代码\&#34;&gt;示例代码&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/framework-in-java/java-reader-classormethod-comment\&#34;&gt;java-reader-classormethod-comment&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;java8-shi-yong-suntoolsjavadoc-du-qu-zhu-shi-xin-xi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java8 使用sun.tools.javadoc 读取注释信息&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2024-04-10 23:27:35&#34;,&#34;dateFormat&#34;:&#34;2024-04-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java8-shi-yong-suntoolsjavadoc-du-qu-zhu-shi-xin-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:168000,&#34;words&#34;:632,&#34;minutes&#34;:3},&#34;description&#34;:&#34;前言\n项目需要整理所有依赖的外部Feign调用，整理成一份文档，类似于：\n\n\n\n远程接口\n调用位置\n作用\n\n\n\n\nxxx/zzz\ntop.imyzt.xxx#methodName\n用作xxx\n\n\n\n方案\n因为项目过多，且依赖的外部服务接口众...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%A1%88\&#34;&gt;方案&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\&#34;&gt;示例代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;ul&gt;\n&lt;li&gt;图数据模型：与关系型数据库使用表格存储数据不同，图数据库通过节点（Node）和关系（Relationship）来表示数据和它们之间的联系。&lt;/li&gt;\n&lt;li&gt;节点：代表实体，如人、地点、物品等。&lt;/li&gt;\n&lt;li&gt;关系：定义节点之间的连接，可以有方向和属性。&lt;/li&gt;\n&lt;li&gt;属性：节点和关系的附加信息，如人的姓名、年龄等。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;CREATE (person1:Person {name: &#39;Alice&#39;, age: 30})\nCREATE (person2:Person {name: &#39;Bob&#39;, age: 25})\nCREATE (person1)-[:KNOWS]-&amp;gt;(person2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;person1/person2：节点&lt;/li&gt;\n&lt;li&gt;Person：标签&lt;/li&gt;\n&lt;li&gt;name/age：属性&lt;/li&gt;\n&lt;li&gt;KNOWS：关系&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;导入数据\&#34;&gt;导入数据&lt;/h1&gt;\n&lt;p&gt;通过GPT，生成《西游记》的人物关系图和人物名单，案例数据如下：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1713108314033.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;将文件放置于Neo4j的&lt;code&gt;Home/import&lt;/code&gt;目录下，然后执行导入命令：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;load csv from &amp;quot;file:///西游记.csv&amp;quot; as line\ncreate (:xiyouRelation {from:line[1], relation:line[3],to:line[0]})\n\nload csv from &amp;quot;file:///人物.csv&amp;quot; as line\ncreate (:person {name:line[0]})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行&lt;code&gt;match (person) return person&lt;/code&gt;，查看数据：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1713108420084.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;创建人物和关系\&#34;&gt;创建人物和关系&lt;/h1&gt;\n&lt;p&gt;创建人物和关系&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;创建人物\ncreate (:student {name: &#39;小明&#39;}),(:student {name : &#39;小红&#39;}),(:student {name: &#39;小李&#39;})\n创建人物关系，并且返回人物关系\nmatch (n:student {name: &#39;小明&#39;}),(m:student {name: &#39;小红&#39;})\ncreate (n)-[r:同学]-&amp;gt;(m) return n.name,type(r),m.name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1713194179719.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;显示人物关系&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;MATCH p=()-[r:`同学`]-&amp;gt;() RETURN p LIMIT 25\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1713194172638.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;删除标签\&#34;&gt;删除标签&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;match (n:LianhuachiPerson)\ndetach delete n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1713795379714.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;删除关系\&#34;&gt;删除关系&lt;/h1&gt;\n&lt;p&gt;命令：&lt;br&gt;\n&lt;code&gt;match (n)-[r:&lt;/code&gt;西游人物关系&lt;code&gt;]-(s) delete r&lt;/code&gt;&lt;br&gt;\n结果：&lt;br&gt;\n&lt;code&gt;Deleted 18 relationships, completed after 6 ms.&lt;/code&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;neo4j-shi-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Neo4j 使用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Neo4j&#34;,&#34;slug&#34;:&#34;XM6uOsCyh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/XM6uOsCyh/&#34;}],&#34;date&#34;:&#34;2024-04-07 23:33:32&#34;,&#34;dateFormat&#34;:&#34;2024-04-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/neo4j-shi-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:91000,&#34;words&#34;:354,&#34;minutes&#34;:2},&#34;description&#34;:&#34;\n图数据模型：与关系型数据库使用表格存储数据不同，图数据库通过节点（Node）和关系（Relationship）来表示数据和它们之间的联系。\n节点：代表实体，如人、地点、物品等。\n关系：定义节点之间的连接，可以有方向和属性。\n属性：节点和关...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE\&#34;&gt;导入数据&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E4%BA%BA%E7%89%A9%E5%92%8C%E5%85%B3%E7%B3%BB\&#34;&gt;创建人物和关系&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE\&#34;&gt;删除标签&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E5%85%B3%E7%B3%BB\&#34;&gt;删除关系&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1711466708760.jpg\&#34; alt=\&#34;花\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1711466753884.jpg\&#34; alt=\&#34;花\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;-- 2024-03-24 摄于荷兰花卉小镇&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;hua-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;花市&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;生活记录&#34;,&#34;slug&#34;:&#34;U4HAFHPoI&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/U4HAFHPoI/&#34;}],&#34;date&#34;:&#34;2024-03-26 23:20:32&#34;,&#34;dateFormat&#34;:&#34;2024-03-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/hua-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:2000,&#34;words&#34;:11,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n\n-- 2024-03-24 摄于荷兰花卉小镇\n...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;p&gt;在DDD项目中，为了方便参数的传递，通常会使用&lt;code&gt;ThreadLocal&lt;/code&gt;来保存一个&lt;code&gt;对象&lt;/code&gt;来实现对参数的跨方法传递，避免通过形参的形式传递。在内部项目中，有一个项目使用的是 alibaba开源的 &lt;code&gt;transmittable-thread-local&lt;/code&gt;来存储参数，新建了一个上下文对象（&lt;code&gt;AbilityContext.java&lt;/code&gt;），使用&lt;code&gt;HashMap&lt;/code&gt;来临时存储和获取参数。&lt;/p&gt;\n&lt;details&gt;\n&lt;summary&gt;AbilityContext 示例&lt;/summary&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class AbilityContext {\n    private static final ThreadLocal&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; CONTEXT = new TransmittableThreadLocal&amp;lt;&amp;gt;();\n\n    private AbilityContext() {\n    }\n\n    /**\n     * 初始化上下文\n     */\n    public static void initContext() {\n        Map&amp;lt;String, Object&amp;gt; con = CONTEXT.get();\n        if (con == null) {\n            CONTEXT.set(new HashMap&amp;lt;&amp;gt;(8));\n        } else {\n            CONTEXT.get().clear();\n        }\n    }\n\n    /**\n     * 清除上下文\n     */\n    public static void clearContext() {\n        CONTEXT.remove();\n    }\n\n    public static Map&amp;lt;String, Object&amp;gt; getInnerMap() {\n        return CONTEXT.get();\n    }\n\n    /**\n     * 获取上下文内容\n     */\n    public static &amp;lt;T&amp;gt; T getValue(String key) {\n        Map&amp;lt;String, Object&amp;gt; con = CONTEXT.get();\n        if (con == null) {\n            return null;\n        }\n        return (T) con.get(key);\n    }\n\n    /**\n     * 设置上下文参数\n     */\n    public static void putValue(String key, Object value) {\n        Map&amp;lt;String, Object&amp;gt; con = CONTEXT.get();\n        if (con == null) {\n            CONTEXT.set(new HashMap&amp;lt;&amp;gt;(8));\n            con = CONTEXT.get();\n        }\n        con.put(key, value);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/details&gt;\n&lt;h2 id=\&#34;项目情况介绍\&#34;&gt;项目情况介绍&lt;/h2&gt;\n&lt;p&gt;通常来说，DDD项目的基本流程是由&lt;code&gt;interface-&amp;gt;application&lt;/code&gt;，中间封装一层来集中处理上下文的初始化和清空动作，如下图：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1709967464622.png\&#34; alt=\&#34;ddd\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;在正常情况下，上述流程可以正确的完成参数的写入和获取，但是，在项目运行过程中遇到了一个bug，正常写入参数后，偶现性（低频）获取值为NULL，导致程序出错，示例代码如下（隐去业务代码，重新写的伪代码）：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;其中&lt;code&gt;demo()&lt;/code&gt;方法为当时复现的方法&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;demo2()&lt;/code&gt;为伪代码，是业务代码中调用了另一个&lt;code&gt;application&lt;/code&gt;，假设其逻辑和&lt;code&gt;demo()&lt;/code&gt;方法一致的业务代码。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Slf4j\npublic class AlibabaTtlWrongUsageExampleApplication {\n\n    public static void main(String[] args) {\n        demo(i);\n    }\n\n    private static void demo(int idx) {\n        // 初始化\n        AbilityContext.initContext();\n        // 赋业务值\n        AbilityContext.putValue(&amp;quot;main&amp;quot;, &amp;quot;mainValue&amp;quot;);\n\n        // 这里简化了代码，实际上经过了很多层业务代码调用后才出现了此方法\n        ThreadUtil.execute(() -&amp;gt; {\n            execute-&amp;gt;demo2();\n        });\n\n        // do something\n\n        // 主线程再次获取业务值(偶现为null)\n        String value = AbilityContext.getValue(&amp;quot;main&amp;quot;);\n        if (Objects.isNull(value)) {\n            log.warn(&amp;quot;lastGetNullValue, idx={}&amp;quot;, idx);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述代码运行设置了一个&lt;code&gt;key=main&lt;/code&gt;，值为&lt;code&gt;mainValue&lt;/code&gt;。在下方&lt;code&gt;AbilityContext.getValue(&amp;quot;main&amp;quot;)&lt;/code&gt;偶现获取==NULL。&lt;/p&gt;\n&lt;h2 id=\&#34;展开分析\&#34;&gt;展开分析&lt;/h2&gt;\n&lt;p&gt;当时在分析的开始有推测是业务代码中参数被重新赋值为NULL，但通过对后续业务代码逐行查看，并没有找到重新赋值的逻辑。&lt;br&gt;\n在深入业务代码分析的过程中，发现主流程中有一个异步方法调用（&lt;code&gt;ThreadUtil.execute()&lt;/code&gt;），再次调用了另一个&lt;strong&gt;领域服务&lt;/strong&gt;（这是不符合DDD规范的！），而&lt;strong&gt;领域服务的入口都会&lt;code&gt;AbilityContext.initContext()&lt;/code&gt;的逻辑&lt;/strong&gt;，通过这个线索 ，继续展开了深入分析。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1709970122111.png\&#34; alt=\&#34;ddd\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;编码者的初衷可能是想到&lt;strong&gt;异步线程已经脱离了当前线程，再次调用 &lt;code&gt;initContext()&lt;/code&gt;方法是初始化了一个新的对象上下文&lt;/strong&gt;，&lt;strong&gt;但是&lt;/strong&gt;由于项目使用的是 &lt;code&gt;alibaba TTL&lt;/code&gt;，能够实现跨线程的传递，所以在子线程中依旧能拿到父线程的&lt;code&gt;HashMap&lt;/code&gt;。并且&lt;strong&gt;TTL默认是使用的浅拷贝对象&lt;/strong&gt;。由于&lt;code&gt;initContext()&lt;/code&gt;中，调用了&lt;code&gt;HashMap.clear()&lt;/code&gt;方法，&lt;strong&gt;相当于将父线程的&lt;code&gt;HashMap&lt;/code&gt;给清空了！&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;通过比对父子线程的hashCode值确定为同一对象&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// 主线程获取hashCode\nfinal int hashCode = AbilityContext.getInnerMap().hashCode();\nThreadUtil.execute(() -&amp;gt; {\n    // 子线程对比hashCode\n    log.info(&amp;quot;{}, ThreadUtil hashCode={}&amp;quot;, idx, AbilityContext.getInnerMap().hashCode() == hashCode);\n    // 子线程再次初始化(错误的根源)\n    AbilityContext.initContext();\n    // do something\n});\n14:42:28.198 [pool-1-thread-26] INFO top.imyzt.learning.caseanalysis.ttl.AlibabaTtlWrongUsageExampleApplication -- 25, ThreadUtil hashCode=true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;持续分析\&#34;&gt;持续分析&lt;/h2&gt;\n&lt;p&gt;有了上述的线索，基本把问题原因找到了，&lt;strong&gt;但是为什么是偶现的呢&lt;/strong&gt;？&lt;br&gt;\n因为使用了异步线程，而线程的调度由操作系统的线程调度算法来决定，并不是一定保证顺序的，所以只要当操作系统优先调度异步线程，那么&lt;code&gt;HashMap&lt;/code&gt;就被清空了，如果主线程优先往下走，那么就能够获取到完整的&lt;code&gt;HashMap&lt;/code&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;后记\&#34;&gt;后记&lt;/h2&gt;\n&lt;p&gt;至此，问题分析就告一段落了，整个过程中涉及到 TTL值的父子线程传递、对象浅拷贝、线程的调度，还涉及到了DDD的不规范逻辑编排，整个分析下来花费了一上午的时间，收获还是很大的。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=\&#34;https://github.com/alibaba/transmittable-thread-local\&#34;&gt;transmittable-thread-local&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://github.com/alibaba/transmittable-thread-local/issues/111\&#34;&gt;TransmittableThreadLocal的传递只有浅拷贝吗？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://redspider.gitbook.io/concurrent/di-yi-pian-ji-chu-pian/3#id-3.2-xian-cheng-de-you-xian-ji\&#34;&gt;线程的优先级&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;我将源代码上传了&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/error-case-analysis/alibaba-ttl-wrong-usage-example\&#34;&gt;GitHub&lt;/a&gt;，如果你想在本地调试运行上述案例，可以下载到本地调试，有问题可以评论区沟通。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ye-wu-luo-ji-bian-pai-cuo-wu-and-ttl-qian-kao-bei-dao-zhi-can-shu-diu-shi-wen-ti&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;业务逻辑编排错误 &amp; TTL浅拷贝导致参数丢失问题&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ThreadLocal&#34;,&#34;slug&#34;:&#34;_KxCNznKV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/_KxCNznKV/&#34;},{&#34;name&#34;:&#34;线程池&#34;,&#34;slug&#34;:&#34;sob7n9Mdo&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/sob7n9Mdo/&#34;},{&#34;name&#34;:&#34;问题解决&#34;,&#34;slug&#34;:&#34;KjxmDkyMU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/KjxmDkyMU/&#34;}],&#34;date&#34;:&#34;2024-03-09 14:40:35&#34;,&#34;dateFormat&#34;:&#34;2024-03-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/ye-wu-luo-ji-bian-pai-cuo-wu-and-ttl-qian-kao-bei-dao-zhi-can-shu-diu-shi-wen-ti/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:282000,&#34;words&#34;:1170,&#34;minutes&#34;:5},&#34;description&#34;:&#34;前言\n在DDD项目中，为了方便参数的传递，通常会使用ThreadLocal来保存一个对象来实现对参数的跨方法传递，避免通过形参的形式传递。在内部项目中，有一个项目使用的是 alibaba开源的 transmittable-thread-lo...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A1%B9%E7%9B%AE%E6%83%85%E5%86%B5%E4%BB%8B%E7%BB%8D\&#34;&gt;项目情况介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%95%E5%BC%80%E5%88%86%E6%9E%90\&#34;&gt;展开分析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%81%E7%BB%AD%E5%88%86%E6%9E%90\&#34;&gt;持续分析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E8%AE%B0\&#34;&gt;后记&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;分布式锁的关键在于对单一资源的竞争。获得资源的实例将继续执行，其余实例要么退出（互斥锁），要么等待（阻塞锁）。&lt;br&gt;\n实现分布式锁的方案有很多，既可以直接使用&lt;code&gt;MySQL&lt;/code&gt;作为分布式锁（例如&lt;code&gt;xxl-job&lt;/code&gt;），也可以利用&lt;code&gt;ZooKeeper&lt;/code&gt;、&lt;code&gt;Redis&lt;/code&gt;等。&lt;br&gt;\n在基于&lt;code&gt;Spring Cloud&lt;/code&gt;的业务系统中，一般都会引入&lt;code&gt;Redis&lt;/code&gt;作为分布式缓存中间件，因此更多的人会选择使用&lt;code&gt;Redis&lt;/code&gt;来实现分布式锁。本文将介绍使用&lt;code&gt;Redis&lt;/code&gt;作为分布式锁时常见的问题和解决方法。&lt;/p&gt;\n&lt;h1 id=\&#34;1-没有使用原子操作指令\&#34;&gt;1. 没有使用原子操作指令&lt;/h1&gt;\n&lt;h2 id=\&#34;错误写法\&#34;&gt;错误写法&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    Boolean tryLock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue);\n    stringRedisTemplate.expire(lockKey, Duration.ofSeconds(expireTime));\n    if (!tryLock) {\n        return;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述操作通常出现在新手阶段，在写入锁对象时，没有考虑到原子性问题。在&lt;code&gt;Redis&lt;/code&gt;中有提供&lt;code&gt;SET NX PX&lt;/code&gt;指令，支持在设置锁的同时指定过期时间，并且支持原子性判断&lt;code&gt;key&lt;/code&gt;是否已存在。&lt;/p&gt;\n&lt;p&gt;NX 和 PX 是 Redis 命令中用于设置 key 的两个选项。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;NX: 当指定 NX 选项时，只有在 key 不存在的情况下才会设置 key 的值。如果 key 已经存在，则不进行任何操作。&lt;/li&gt;\n&lt;li&gt;PX: PX 选项用于设置 key 的过期时间（以毫秒为单位）。例如，PX 10000 表示在 10 秒后将 key 设置为过期状态。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;正确写法\&#34;&gt;正确写法：&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Boolean tryLock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, expireTime, TimeUnit.MILLISECONDS);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;2-释放了别人的锁\&#34;&gt;2. 释放了别人的锁&lt;/h1&gt;\n&lt;h2 id=\&#34;错误写法-2\&#34;&gt;错误写法&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;try {\n    Boolean tryLock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, expireTime, TimeUnit.MILLISECONDS);\n    if (!tryLock) {\n        return;\n    }\n\n    // do something\n    } finally {\n    stringRedisTemplate.delete(lockKey);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在加锁的过程中，没有设定唯一值作为&lt;code&gt;Value&lt;/code&gt;存储到Redis中，在释放时，不判断直接对锁进行释放。其二，将获取锁的代码放在了&lt;code&gt;try&lt;/code&gt;代码块中。&lt;/p&gt;\n&lt;p&gt;在上述代码中存在两个问题：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;不该执行到&lt;code&gt;finlly&lt;/code&gt;代码块：A请求获得了锁正在执行业务代码，而B请求没有获得锁，但是因为获取锁的代码在&lt;code&gt;try&lt;/code&gt;代码块中，导致&lt;code&gt;finally&lt;/code&gt;一定会执行，B请求就会将A请求的锁释放，而如果A请求依旧未执行完毕，此时C请求过来时，&lt;strong&gt;则C请求错误的拿到了锁&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;不该删除别人的锁：在删除锁时，应该判断自己是否是上锁人，由于多次执行&lt;code&gt;Redis&lt;/code&gt;指令不具备原子性，所以一般是交由&lt;code&gt;LUA&lt;/code&gt;脚本来实现的。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-lua\&#34;&gt;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1]\n    then\n        return redis.call(&#39;del&#39;, KEYS[1])\n    else\n        return 0\nend\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;正确写法-2\&#34;&gt;正确写法&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;提前将LUA脚本载入到&lt;code&gt;Redis&lt;/code&gt;服务端&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;script = new DefaultRedisScript&amp;lt;&amp;gt;();\nscript.setResultType(Long.class);\nscript.setScriptSource(new ResourceScriptSource(new ClassPathResource(&amp;quot;release_lock.lua&amp;quot;)));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;获取和释放锁示例&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Boolean tryLock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, expireTime, TimeUnit.MILLISECONDS);\nif (!tryLock) {\n    return;\n}\ntry {\n\n    // do something\n} finally {\n    ArrayList&amp;lt;String&amp;gt; keys = new ArrayList&amp;lt;&amp;gt;();\n    keys.add(context.getLockKey());\n    stringRedisTemplate.execute(this.script, keys, context.getLockValue());\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;3-事务未提交锁就释放了\&#34;&gt;3. 事务未提交锁就释放了&lt;/h1&gt;\n&lt;h2 id=\&#34;错误代码\&#34;&gt;错误代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n    * 事务内获取分布式锁\n    */\n@Transactional(rollbackFor = Exception.class)\npublic void saveUserWithDistributedLock(String name) {\n\n    String lockKey = &amp;quot;lock_key:&amp;quot; + name;\n    RedisLock.LockContext lockContext = redisLock.tryLock(lockKey, 10000L);\n    if (!lockContext.getTryLock()) {\n        // printLog(&amp;quot;没拿到锁&amp;quot;);\n        return;\n    }\n\n    printLog(&amp;quot;拿到锁了&amp;quot; + lockKey);\n\n    try {\n        this.save(name);\n    } finally {\n        redisLock.release(lockContext);\n        printLog(&amp;quot;释放锁了&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;MySQL常规情况下是&lt;code&gt;RR&lt;/code&gt;的隔离级别，只有等到事务提交数据才对其他事务可见，存在**“读视图”&lt;strong&gt;，在上述的代码中，A请求拿到了锁执行了业务代码，执行到&lt;code&gt;redisLock.release&lt;/code&gt;时将锁释放了，但Spring的&lt;code&gt;@Transactional&lt;/code&gt;依赖的是AOP，其需要等到方法执行完毕才会提交事务，在这个临界点，B请求可以正常拿到锁，但是A请求的事务还未提交，B请求的&lt;/strong&gt;读视图**中还未查询到A请求提交的数据，最终造成了数据的不一致性。&lt;/p&gt;\n&lt;h2 id=\&#34;正确代码\&#34;&gt;正确代码&lt;/h2&gt;\n&lt;p&gt;正确的情况是在另一个方法中获取到锁之后，再调用包含事务的业务代码。此时需要注意SpringAOP在本方法内代理失效的问题，通常需要新建一个Service来处理。&lt;/p&gt;\n&lt;h1 id=\&#34;业务代码执行超过锁过期时间\&#34;&gt;业务代码执行超过锁过期时间&lt;/h1&gt;\n&lt;h2 id=\&#34;错误代码-2\&#34;&gt;错误代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// Domain-Service\npublic void save(String name) {\n\n    String lockKey = &amp;quot;lock_key:&amp;quot; + name;\n    RedisLock.LockContext lockContext = redisLock.tryLock(lockKey, 10000L);\n    if (!lockContext.getTryLock()) {\n        printLog(&amp;quot;没拿到锁&amp;quot;);\n        return;\n    }\n\n    printLog(&amp;quot;拿到锁了&amp;quot; + lockKey);\n    try {\n        userService.save(name);\n    } finally {\n        redisLock.release(lockContext);\n        printLog(&amp;quot;释放锁了&amp;quot;);\n    }\n}\n\n// UserService\n@Transactional(rollbackFor = Exception.class)\npublic void save(String name) {\n\n    List&amp;lt;User&amp;gt; users = userRepository.findUsersByName(name);\n    if (CollUtil.isNotEmpty(users)) {\n        printLog(&amp;quot;已经写入, 不再写入&amp;quot; + users);\n        return;\n    }\n\n    // 业务保存模拟执行很慢\n    TimeUnit.SECONDS.sleep(70);\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述代码中，锁对象只有10s的时间，但是业务代码执行却需要70s，A请求虽然拿到了锁，此时后续10秒其他请求均无法获取锁，但是从第11秒开始的请求将可以拿到锁，而此时A请求还未执行完毕，此时开始出现错误的获取锁，最终造成数据的不一致。&lt;/p&gt;\n&lt;h2 id=\&#34;正确写法-3\&#34;&gt;正确写法&lt;/h2&gt;\n&lt;p&gt;参考&lt;code&gt;Redisson&lt;/code&gt;的&lt;code&gt;WatchDog&lt;/code&gt;机制，另外开辟线程每隔 10s 就给还未执行完毕的 &lt;code&gt;Key&lt;/code&gt; 自动续期 30s，保证业务代码能够安全的执行完毕再自行释放锁对象。&lt;/p&gt;\n&lt;p&gt;示例代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// watch dog\nExecutors.newScheduledThreadPool(1).scheduleAtFixedRate(() -&amp;gt; {\n    if (!LOCK_CONTEXTS.isEmpty()) {\n        for (LockContext lockContext : LOCK_CONTEXTS) {\n            // 如果执行线程还未释放锁, 续期30s(模拟Redisson)\n            stringRedisTemplate.expire(lockContext.getLockKey(), Duration.ofSeconds(30));\n            Long expire = stringRedisTemplate.getExpire(lockContext.getLockKey());\n            log.info(&amp;quot;WatchDog, expire 30s, lockKey={}, ttl={}&amp;quot;, lockContext.getLockKey(), expire);\n        }\n    }\n        }, 0,\n        // 10秒检测一次\n        10, TimeUnit.SECONDS);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;后记\&#34;&gt;后记&lt;/h1&gt;\n&lt;p&gt;分布式锁的错误还有很多，本篇主要是自己在工作过程中遇到的一些坑，着重介绍新手阶段在编写分布式锁时遇到的比较基础的问题，后面有空再进行其他场景的逐个介绍。&lt;/p&gt;\n&lt;p&gt;本文参考：&lt;a href=\&#34;https://juejin.cn/post/7011503283768393736\&#34;&gt;聊聊redis分布式锁的8大坑&lt;/a&gt;&lt;br&gt;\n本文代码：&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/in-action/redis-lua-distributed-lock\&#34;&gt;redis-lua-distributed-lock&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;shi-yong-redis-shi-xian-fen-bu-shi-suo-de-keng&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;使用Redis实现分布式锁的坑&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Redis&#34;,&#34;slug&#34;:&#34;cZVWiX7Fs&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/cZVWiX7Fs/&#34;},{&#34;name&#34;:&#34;分布式锁&#34;,&#34;slug&#34;:&#34;pOZSPM4n_2&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/pOZSPM4n_2/&#34;},{&#34;name&#34;:&#34;问题解决&#34;,&#34;slug&#34;:&#34;KjxmDkyMU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/KjxmDkyMU/&#34;}],&#34;date&#34;:&#34;2024-03-04 21:39:52&#34;,&#34;dateFormat&#34;:&#34;2024-03-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/shi-yong-redis-shi-xian-fen-bu-shi-suo-de-keng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:355000,&#34;words&#34;:1465,&#34;minutes&#34;:6},&#34;description&#34;:&#34;分布式锁的关键在于对单一资源的竞争。获得资源的实例将继续执行，其余实例要么退出（互斥锁），要么等待（阻塞锁）。\n实现分布式锁的方案有很多，既可以直接使用MySQL作为分布式锁（例如xxl-job），也可以利用ZooKeeper、Redis等...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4\&#34;&gt;1. 没有使用原子操作指令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%94%99%E8%AF%AF%E5%86%99%E6%B3%95\&#34;&gt;错误写法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95\&#34;&gt;正确写法：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E9%87%8A%E6%94%BE%E4%BA%86%E5%88%AB%E4%BA%BA%E7%9A%84%E9%94%81\&#34;&gt;2. 释放了别人的锁&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%94%99%E8%AF%AF%E5%86%99%E6%B3%95-2\&#34;&gt;错误写法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95-2\&#34;&gt;正确写法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E4%BA%8B%E5%8A%A1%E6%9C%AA%E6%8F%90%E4%BA%A4%E9%94%81%E5%B0%B1%E9%87%8A%E6%94%BE%E4%BA%86\&#34;&gt;3. 事务未提交锁就释放了&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81\&#34;&gt;错误代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%A3%E7%A1%AE%E4%BB%A3%E7%A0%81\&#34;&gt;正确代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%B6%85%E8%BF%87%E9%94%81%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4\&#34;&gt;业务代码执行超过锁过期时间&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81-2\&#34;&gt;错误代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95-3\&#34;&gt;正确写法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E8%AE%B0\&#34;&gt;后记&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;事件中心在私有化环境下，只要server一启动过几秒就oom，查看日志是 &lt;code&gt;Failed to create a thread: retVal -1073741830, errno 11&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;异常堆栈：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Caused by: java.lang.OutOfMemoryError: Failed to create a thread: retVal -1073741830, errno 11   \n    at java.lang.Thread.startImpl(Native Method) \n    at java.lang.Thread.start(Thread.java:993) \n    at io.netty.util.HashedWheelTimer.start(HashedWheelTimer.java:366) \n    at io.netty.util.HashedWheelTimer.newTimeout(HashedWheelTimer.java:447) \n    at 业务调用代码省略\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在标品环境下没有问题，在其他KA客户上也没有问题&lt;br&gt;\n通过对日志的分析，最终发现是事件中心的延迟消息代码存在缺陷，使用了&lt;code&gt;Netty&lt;/code&gt;的&lt;code&gt;HashedWheelTimer&lt;/code&gt;，但是语法存在问题，理论上应该是new一个&lt;code&gt;HashedWheelTimer&lt;/code&gt;来处理所有时间延迟，但是错用程每次new一个新的&lt;code&gt;HashedWheelTimer&lt;/code&gt;，&lt;code&gt;HashedWheelTimer&lt;/code&gt;内部每次都会new一个新的线程来处理做调度，一个线程占用1MB，最终内存资源被耗尽。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;io.netty.util.HashedWheelTimer#HashedWheelTimer&lt;/code&gt;源码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public HashedWheelTimer(\n    ThreadFactory threadFactory,\n    long tickDuration, TimeUnit unit, int ticksPerWheel, boolean leakDetection,\n    long maxPendingTimeouts, Executor taskExecutor) {\n\n    checkNotNull(threadFactory, &amp;quot;threadFactory&amp;quot;);\n    checkNotNull(unit, &amp;quot;unit&amp;quot;);\n    checkPositive(tickDuration, &amp;quot;tickDuration&amp;quot;);\n    checkPositive(ticksPerWheel, &amp;quot;ticksPerWheel&amp;quot;);\n    this.taskExecutor = checkNotNull(taskExecutor, &amp;quot;taskExecutor&amp;quot;);\n\n    // Normalize ticksPerWheel to power of two and initialize the wheel.\n    wheel = createWheel(ticksPerWheel);\n    mask = wheel.length - 1;\n\n    // Convert tickDuration to nanos.\n    long duration = unit.toNanos(tickDuration);\n\n    // Prevent overflow.\n    if (duration &amp;gt;= Long.MAX_VALUE / wheel.length) {\n        throw new IllegalArgumentException(String.format(\n                &amp;quot;tickDuration: %d (expected: 0 &amp;lt; tickDuration in nanos &amp;lt; %d&amp;quot;,\n                tickDuration, Long.MAX_VALUE / wheel.length));\n    }\n\n    if (duration &amp;lt; MILLISECOND_NANOS) {\n        logger.warn(&amp;quot;Configured tickDuration {} smaller then {}, using 1ms.&amp;quot;,\n                    tickDuration, MILLISECOND_NANOS);\n        this.tickDuration = MILLISECOND_NANOS;\n    } else {\n        this.tickDuration = duration;\n    }\n\n    // 每次都new一个线程来处理\n    workerThread = threadFactory.newThread(worker);\n\n    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(this) : null;\n\n    this.maxPendingTimeouts = maxPendingTimeouts;\n\n    if (INSTANCE_COUNTER.incrementAndGet() &amp;gt; INSTANCE_COUNT_LIMIT &amp;amp;&amp;amp;\n        WARNED_TOO_MANY_INSTANCES.compareAndSet(false, true)) {\n        reportTooManyInstances();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为标品和其他KA使用的是阿里云RocketMQ，此客户使用的是自建的开源版RocketMQ，开源RocketMQ是没有自定义时长的延迟消息的，所以我们自己实现了一套时间轮来实现任意时长的延迟消息，当小于60s的延迟消息会丢入我们的时间轮来处理延迟投递，当时此客户的环境中有大量的60s内的延迟消息，导致一启动就会崩溃。&lt;br&gt;\n不过在RocketMQ5.0也支持任意时长了。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;cuo-yong-hashedwheeltimer-dao-zhi-de-oom-wen-ti&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;错用HashedWheelTimer导致的OOM问题&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;RabbitMQ&#34;,&#34;slug&#34;:&#34;CbzZOlvAr&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/CbzZOlvAr/&#34;},{&#34;name&#34;:&#34;问题解决&#34;,&#34;slug&#34;:&#34;KjxmDkyMU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/KjxmDkyMU/&#34;},{&#34;name&#34;:&#34;TimeingWheel&#34;,&#34;slug&#34;:&#34;i73r1WX7G&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/i73r1WX7G/&#34;}],&#34;date&#34;:&#34;2024-02-04 23:04:56&#34;,&#34;dateFormat&#34;:&#34;2024-02-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/cuo-yong-hashedwheeltimer-dao-zhi-de-oom-wen-ti/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:145000,&#34;words&#34;:530,&#34;minutes&#34;:3},&#34;description&#34;:&#34;事件中心在私有化环境下，只要server一启动过几秒就oom，查看日志是 Failed to create a thread: retVal -1073741830, errno 11。\n异常堆栈：\nCaused by: java.lang...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;背景\&#34;&gt;背景&lt;/h1&gt;\n&lt;p&gt;使用&lt;code&gt;OpenFeign&lt;/code&gt;时，通常会实现&lt;code&gt;RequestInterceptor&lt;/code&gt;接口来自定义&lt;code&gt;FeignConfiguration&lt;/code&gt;，&lt;code&gt;OpenFeign&lt;/code&gt;暴露了&lt;code&gt;feign.RequestTemplate&lt;/code&gt;信息，给到我们在发送请求前自定义参数信息的扩展点。&lt;/p&gt;\n&lt;p&gt;在分布式系统中，通常会将本服务的信息（&lt;code&gt;UserInfo&lt;/code&gt;、&lt;code&gt;RequestId&lt;/code&gt;）透传至下游服务，从而实现分布式链路追踪等功能，对于像用户信息等，在Web系统中通常使用 &lt;code&gt;ThreadLocal&lt;/code&gt; 来存储信息，在自定义的&lt;code&gt;FeignConfiguration&lt;/code&gt;中获取&lt;code&gt;ThreadLocal&lt;/code&gt;再塞入到&lt;code&gt;feign.RequestTemplate&lt;/code&gt;中，实现向下游服务的传递，示例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class FeignConfiguration implements RequestInterceptor {\n    @Override\n    public void apply(RequestTemplate template) {\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        String userId = SubjectContext.get().getUserId();\n        if (null != attributes) {\n            HttpServletRequest request = attributes.getRequest();\n            template.header(&amp;quot;token&amp;quot;, request.getHeader(&amp;quot;TOKEN&amp;quot;));\n            template.header(&amp;quot;userId&amp;quot;, userId);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;简单的Context示例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class SubjectContext {\n    protected static ThreadLocal&amp;lt;UserInfo&amp;gt; subjectContext = new ThreadLocal();\n    public static void remove() {\n        subjectContext.remove();\n    }\n    public static void set(UserInfo uerInfo) {\n        subjectContext.set(uerInfo);\n    }\n    public static UserInfo get() {\n        return (UserInfo)subjectContext.get();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;出现错误\&#34;&gt;出现错误&lt;/h1&gt;\n&lt;p&gt;上述代码在常规情况下，是能够按照预期执行的。&lt;/p&gt;\n&lt;p&gt;但是最近项目引入了&lt;code&gt;CircuitBreaker&lt;/code&gt;作为服务熔断的断路器之后，上述代码在执行到&lt;code&gt;SubjectContext.get()&lt;/code&gt;时，会抛出空指针，拿不到用户信息。&lt;/p&gt;\n&lt;p&gt;通过分析&lt;code&gt;CircuitBreaker&lt;/code&gt;的源码，最终定位到代码出现在&lt;code&gt;Resilience4JCircuitBreaker&lt;/code&gt;内部，在&lt;code&gt;Resilience4JCircuitBreaker&lt;/code&gt;中有一个&lt;code&gt;public &amp;lt;T&amp;gt; T run(Supplier&amp;lt;T&amp;gt; toRun, Function&amp;lt;Throwable, T&amp;gt; fallback)&lt;/code&gt;方法，方法入参的&lt;code&gt;toRun&lt;/code&gt;就是封装过的我们定义的Feign接口，其包装过程在&lt;code&gt;FeignCircuitBreakerInvocationHandler#asSupplier&lt;/code&gt;代码中，如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private Supplier&amp;lt;Object&amp;gt; asSupplier(final Method method, final Object[] args) {\n    final RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n    return () -&amp;gt; {\n        try {\n            RequestContextHolder.setRequestAttributes(requestAttributes);\n            // 执行我们的真正方法\n            return dispatch.get(method).invoke(args);\n        }\n        catch (RuntimeException throwable) {\n            throw throwable;\n        }\n        catch (Throwable throwable) {\n            throw new RuntimeException(throwable);\n        }\n    };\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Spring Cloud CircuitBreaker Resilience4j 提供了两种实现：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;使用 Semaphores 的 SemaphoreBulkhead。&lt;/li&gt;\n&lt;li&gt;一个 FixedThreadPoolBulkhead，它使用一个有界队列和一个固定的线程池。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;默认情况下，Spring Cloud CircuitBreaker Resilience4j 使用 &lt;code&gt;FixedThreadPoolBulkhead&lt;/code&gt;。要修改默认行为以使用 &lt;code&gt;SemaphoreBulkhead&lt;/code&gt;，请将属性 &lt;code&gt;spring.cloud.circuitbreaker.resilience4j.enableSemaphoreDefaultBulkhead&lt;/code&gt; 设为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;正是由于上述原因，默认将我们的FeignConfiguration提交给了线程池，由于我们使用的是&lt;code&gt;ThreadLocal&lt;/code&gt;导致&lt;strong&gt;线程本地变量&lt;/strong&gt;没有向子线程传递，在执行FeignConfiguration时子线程无法拿到&lt;code&gt;Context&lt;/code&gt;信息，最终导致程序的报错。&lt;/p&gt;\n&lt;h1 id=\&#34;解决办法\&#34;&gt;解决办法&lt;/h1&gt;\n&lt;p&gt;通过分析源码我们发现，执行任务的线程池&lt;code&gt;Resilience4JCircuitBreaker#executorService&lt;/code&gt;是由外部传递过来进行初始化的，调用方在&lt;code&gt;Resilience4JCircuitBreakerFactory#create(java.lang.String, java.lang.String, java.util.concurrent.ExecutorService)&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;在&lt;code&gt;Resilience4JCircuitBreakerFactory&lt;/code&gt;中发现，是由本实例在&lt;code&gt;create&lt;/code&gt;方法被调用时传入的本类的成员变量，即：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;private ExecutorService executorService = Executors.newCachedThreadPool();&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;private ConcurrentHashMap&amp;lt;String, ExecutorService&amp;gt; executorServices = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1706198428487.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;而我们在没有定义自定义Feign Group时，默认使用的就是&lt;code&gt;executorService&lt;/code&gt;，在本类中有一个&lt;code&gt;Resilience4JCircuitBreakerFactory#configureExecutorService&lt;/code&gt;方法专门保留了外部传入自定义线程池的扩展，我们可以自己实现创建一个支持传递&lt;code&gt;Context&lt;/code&gt;到子线程的线程池，即可将参数向下传递，比如像这样：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Configurable\n@AllArgsConstructor\npublic class CircuitBreakerConfiguration implements ApplicationRunner {\n\n    private final Resilience4JCircuitBreakerFactory factory;\n    \n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n\n        ContextThreadPoolExecutor contextThreadPoolExecutor = \n                new ContextThreadPoolExecutor(2, 5, 1, TimeUnit.MINUTES, new ArrayBlockingQueue&amp;lt;&amp;gt;(1024));\n\n        // **change ThreadPoolExecutor**\n        factory.configureExecutorService(contextThreadPoolExecutor);\n    }\n    \n    public static class ContextThreadPoolExecutor extends ThreadPoolExecutor {\n\n        public ContextThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) {\n            super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);\n        }\n\n        public void execute(Runnable command) {\n            super.execute(wrap(command));\n        }\n\n        private static Runnable wrap(Runnable runnable) {\n            **SubjectContext context = SubjectContext.getContext();**\n            return () -&amp;gt; {\n                // 将参数向下传递\n                **SubjectContext.setContext(context);**\n                try {\n                    runnable.run();\n                } finally {\n                    **SubjectContext.clear();**\n                }\n            };\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;后记\&#34;&gt;后记&lt;/h1&gt;\n&lt;p&gt;上述的方案只解决了没有自定义Group的情况，官方在自定义Group的情况下是没有保留扩展位的，所以给官方提了一个MR并且已成功合并到主分支，如下：&lt;br&gt;\n&lt;a href=\&#34;https://github.com/spring-cloud/spring-cloud-circuitbreaker/pull/181\&#34;&gt;Customizable groupExecutorService #180&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;circuitbreak-dao-zhi-threadlocal-can-shu-diu-shi-wen-ti&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;CircuitBreak导致ThreadLocal参数丢失问题&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ThreadLocal&#34;,&#34;slug&#34;:&#34;_KxCNznKV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/_KxCNznKV/&#34;},{&#34;name&#34;:&#34;问题解决&#34;,&#34;slug&#34;:&#34;KjxmDkyMU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/KjxmDkyMU/&#34;},{&#34;name&#34;:&#34;Spring&#34;,&#34;slug&#34;:&#34;r_PTn6Nd-&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/r_PTn6Nd-/&#34;}],&#34;date&#34;:&#34;2024-01-25 23:27:15&#34;,&#34;dateFormat&#34;:&#34;2024-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/circuitbreak-dao-zhi-threadlocal-can-shu-diu-shi-wen-ti/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:238000,&#34;words&#34;:917,&#34;minutes&#34;:4},&#34;description&#34;:&#34;背景\n使用OpenFeign时，通常会实现RequestInterceptor接口来自定义FeignConfiguration，OpenFeign暴露了feign.RequestTemplate信息，给到我们在发送请求前自定义参数信息的扩展...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%83%8C%E6%99%AF\&#34;&gt;背景&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF\&#34;&gt;出现错误&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\&#34;&gt;解决办法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E8%AE%B0\&#34;&gt;后记&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;编码类\&#34;&gt;编码类&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;Generate All Getter And Setter 如其名&lt;/li&gt;\n&lt;li&gt;AceJump 快速将光标导航到编辑器中可见的任何位置,ctrl+,然后输入字符，进行高亮定位&lt;/li&gt;\n&lt;li&gt;GsonFormat 将JSONObject格式的String 解析成实体。&lt;/li&gt;\n&lt;li&gt;Lombok 针对模型对象精简代码&lt;/li&gt;\n&lt;li&gt;MybatisCodeHelperPro 通过方法名来生成sql，全自动提示，自动检测&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;工具类\&#34;&gt;工具类&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;any-rule 可以搜索正则表达式&lt;/li&gt;\n&lt;li&gt;CamelCase 变量名转驼峰&lt;/li&gt;\n&lt;li&gt;Jrebel 快速实现热部署，跳过了构建和部署的过程，可以省去大量的部署用的时间。&lt;/li&gt;\n&lt;li&gt;jrebel-mybatisplus-extension 热部署中mybatis的扩展，他的功能就是配合 Jrebel 一起使用，修改 mybatis 的 mapper.xml 文件不用重启项目&lt;/li&gt;\n&lt;li&gt;CodeGlance 显示代码地图插件,进行语法突出显示&lt;/li&gt;\n&lt;li&gt;RestfulToolKit 可以搜索接口&lt;/li&gt;\n&lt;li&gt;POJO TO JSON 将pojo类转换为json&lt;/li&gt;\n&lt;li&gt;Translation 翻译插件&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;maven类\&#34;&gt;Maven类&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;Maven Helper 依赖冲突分析利器&lt;/li&gt;\n&lt;li&gt;Maven Dependency Helper Maven中央仓库搜索&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;规范类\&#34;&gt;规范类&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;P3C 编码规范的一个插件，高亮提示违规代码&lt;/li&gt;\n&lt;li&gt;SonarLint 打开文件的时候自动进行代码审查&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;提效类\&#34;&gt;提效类&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;Key Promoter X 在IDEA里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代，此插件会进行提示&lt;/li&gt;\n&lt;li&gt;POJO TO JSON 将pojo类转换为json&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;装修类\&#34;&gt;装修类&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;Nyan Progress Bar 漂亮的进度条&lt;/li&gt;\n&lt;li&gt;Rainbow Brackets 配对括号相同颜色，并且实现选中区域代码高亮的功能&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;idea-chang-yong-cha-jian&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;IDEA 常用插件&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;IDEA&#34;,&#34;slug&#34;:&#34;uWJlyqIS1&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/uWJlyqIS1/&#34;}],&#34;date&#34;:&#34;2024-01-14 23:30:09&#34;,&#34;dateFormat&#34;:&#34;2024-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/idea-chang-yong-cha-jian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:81000,&#34;words&#34;:361,&#34;minutes&#34;:2},&#34;description&#34;:&#34;编码类\n\nGenerate All Getter And Setter 如其名\nAceJump 快速将光标导航到编辑器中可见的任何位置,ctrl+,然后输入字符，进行高亮定位\nGsonFormat 将JSONObject格式的String ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E7%A0%81%E7%B1%BB\&#34;&gt;编码类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E5%85%B7%E7%B1%BB\&#34;&gt;工具类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#maven%E7%B1%BB\&#34;&gt;Maven类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%84%E8%8C%83%E7%B1%BB\&#34;&gt;规范类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%90%E6%95%88%E7%B1%BB\&#34;&gt;提效类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A3%85%E4%BF%AE%E7%B1%BB\&#34;&gt;装修类&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;配置文件全部使用UTF-8&lt;br&gt;\n&lt;code&gt;Editor-File Encodings&lt;/code&gt;，将所有内容均设置为UTF-8。&lt;br&gt;\n&lt;code&gt;Create UTF-8 files&lt;/code&gt; 选择 &lt;code&gt;with NO BOM&lt;/code&gt;，避免在创建文件前3个字节来标志为UTF-8文件。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;参数提示&lt;br&gt;\n默认情况下，是没有参数提示的，需要手动开启。&lt;br&gt;\n&lt;code&gt;Editor-General-Code Completion-Parameter Info&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1704534882953.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1704534890065.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;注释默认在当前缩进&lt;br&gt;\n默认情况下，自动补全注释是在最前面，可以通过：&lt;br&gt;\n&lt;code&gt;Editor-Code Style-Java(其它语言位置类似)-Code Generation-Comment Code&lt;/code&gt;按如下图配置进行处理。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1704535032674.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;如果配置的内容，在新项目不生效，则注意此处&lt;br&gt;\n除了字体样式字体大小外，其它的配置IDEA官方认为，每个项目在创建时，可能都需要一些不同的配置，所以有很多内容都是跨项目不生效的（Maven、文件格式等），需要在此处配置（点进去和Settings一模一样，但是对应的是Next Project（新项目）的配置）&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1704535443448.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;idea-2023-fei-chang-yong-pei-zhi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34; IDEA 2023 非常用配置&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;IDEA&#34;,&#34;slug&#34;:&#34;uWJlyqIS1&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/uWJlyqIS1/&#34;},{&#34;name&#34;:&#34;Java developer&#34;,&#34;slug&#34;:&#34;Lix1FDBfB&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/Lix1FDBfB/&#34;}],&#34;date&#34;:&#34;2024-01-06 17:49:24&#34;,&#34;dateFormat&#34;:&#34;2024-01-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/idea-2023-fei-chang-yong-pei-zhi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:55000,&#34;words&#34;:248,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n\n配置文件全部使用UTF-8\nEditor-File Encodings，将所有内容均设置为UTF-8。\nCreate UTF-8 files 选择 with NO BOM，避免在创建文件前3个字节来标志为UTF-8文件。\n\n\n参数提示\n...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Gridea的Lemon主题，默认不支持代码高亮，需要自己补充。目前开源的&lt;code&gt;highlight.js&lt;/code&gt;正合适。记录下处理的过程&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;打开官网，挑选自己喜欢的风格&lt;br&gt;\n&lt;a href=\&#34;https://highlightjs.org/examples\&#34;&gt;highlightjs.org/examples&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;找一个CDN托管网站，避免走自己的小油管，这里推荐bootcdn（这么多年了，还是如此坚挺）&lt;br&gt;\n&lt;a href=\&#34;https://www.bootcdn.cn/highlight.js/\&#34;&gt;www.bootcdn.cn/highlight.js&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;将上述找到的代码，应用在自己主题下的&lt;code&gt;post.ejs&lt;/code&gt;的 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 代码块中。&lt;br&gt;\n1.&lt;br&gt;\n&lt;code&gt;~/Gridea/themes/gridea-theme-lemon&lt;/code&gt;，找到自己的主题目录，&lt;code&gt;gridea-theme-lemon&lt;/code&gt;是我的&lt;code&gt;Lemon&lt;/code&gt;主题目录。&lt;br&gt;\n2. 编辑&lt;code&gt;post.ejs&lt;/code&gt;文件，&lt;code&gt;vim templates/post.ejs&lt;/code&gt;&lt;br&gt;\n3. 在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中补充如下代码&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;&amp;lt;link href=&amp;quot;https://cdn.bootcdn.net/ajax/libs/highlight.js/11.8.0/styles/此处选择自己喜欢的主题.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;\n&amp;lt;script src=&amp;quot;https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;\n&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;      \n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;shi-yong-highlightjs-rang-gridea-zhi-chi-dai-ma-gao-liang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;使用highlightjs让Gridea支持代码高亮&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2023-12-21 22:17:58&#34;,&#34;dateFormat&#34;:&#34;2023-12-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/shi-yong-highlightjs-rang-gridea-zhi-chi-dai-ma-gao-liang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:61000,&#34;words&#34;:230,&#34;minutes&#34;:2},&#34;description&#34;:&#34;Gridea的Lemon主题，默认不支持代码高亮，需要自己补充。目前开源的highlight.js正合适。记录下处理的过程\n\n\n打开官网，挑选自己喜欢的风格\nhighlightjs.org/examples\n\n\n找一个CDN托管网站，避免走...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;Java 20没有发布重要的新特性，本文以Java21版本为主。&lt;br&gt;\nJava 21 是新的LTS版本，其中发布了众多新的特性。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;字符串模板预览版\&#34;&gt;字符串模板（预览版）&lt;/h1&gt;\n&lt;h2 id=\&#34;使用官方的str-fmt\&#34;&gt;使用官方的STR、FMT&lt;/h2&gt;\n&lt;p&gt;支持通过&lt;code&gt;STR&lt;/code&gt;、&lt;code&gt;FMT&lt;/code&gt;来实现字符串拼接，可以自定义模板处理器组织字符串输出形式。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\nimport static java.util.FormatProcessor.FMT;\n\n/**\n * @author imyzt\n * @date 2023/12/19\n * @description 模板字符串\n */\npublic class TemplateString {\n\n    public static void main(String[] args) {\n\n        String str = &amp;quot;world&amp;quot;;\n        String result = STR.&amp;quot;hello \\{str}&amp;quot;;\n        System.out.println(result);\n        System.out.println(STR);\n\n        String name = &amp;quot;yzt&amp;quot;;\n        String[] blogAddress = {&amp;quot;imyzt.top&amp;quot;, &amp;quot;blog.imyzt.top&amp;quot;};\n        String text = FMT.&amp;quot;&amp;quot;&amp;quot;\n                My name is \\{name}\n                My blog address is \\{blogAddress[0].toUpperCase()}, \\{blogAddress[1].toLowerCase()}&amp;quot;&amp;quot;&amp;quot;;\n        System.out.println(text);\n\n        System.out.println(STR.&amp;quot;\\{Math.random()}&amp;quot;);\n        System.out.println(STR.&amp;quot;\\{Integer.MAX_VALUE}&amp;quot;);\n        System.out.println(STR.&amp;quot;\\{index++}, \\{++index}&amp;quot;);\n\n        //hello world\n        //java.lang.StringTemplate$$Lambda/0x00000001260457f0@33c7353a\n        //My name is yzt\n        //My blog address is IMYZT.TOP, blog.imyzt.top\n        //0.9361799484353136\n        //2147483647\n        //现在的时间是: 2023-12-20\n        //0, 2\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;自定义stringtemplate\&#34;&gt;自定义StringTemplate&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\nimport java.util.Iterator;\n\n/**\n * @author imyzt\n * @date 2023/12/20\n * @description 自定义StringTemplate\n */\npublic class CustomTemplate {\n\n    public static void main(String[] args) {\n\n        var INTER = StringTemplate.Processor.of((StringTemplate st) -&amp;gt; {\n            StringBuilder sb = new StringBuilder();\n            Iterator&amp;lt;String&amp;gt; fragments = st.fragments().iterator();\n            for (Object value : st.values()) {\n                sb.append(fragments.next());\n                sb.append(value);\n            }\n            sb.append(fragments.next());\n            return sb.toString();\n        });\n\n        String name = &amp;quot;yzt&amp;quot;;\n        int index = 0;\n        String text = INTER.&amp;quot;&amp;quot;&amp;quot;\n                {\n                &amp;quot;name&amp;quot;:\\{name},\n                &amp;quot;index&amp;quot;:\\{++index}\n                }\n                &amp;quot;&amp;quot;&amp;quot;;\n        System.out.println(text);\n        //{\n        //&amp;quot;name&amp;quot;:yzt,\n        //&amp;quot;index&amp;quot;:1\n        //}\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;record-patterns\&#34;&gt;Record Patterns&lt;/h1&gt;\n&lt;p&gt;记录模式更强大了，支持直接在表达式中创建和使用。还支持嵌套&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/19\n * @description 记录模式\n */\npublic class RecordPatterns {\n\n    public static void main(String[] args) {\n\n        Object p = new Point(1, 2);\n        if (p instanceof Point(int x, int y)) {\n            System.out.println(x + y);\n        }\n\n        Object w = new Window(new Point(1, 2), 3);\n        if (w instanceof Window(Point(int x, int y), int z)) {\n            System.out.println(x + y + z);\n        }\n\n    }\n}\nrecord Point(int x, int y) {}\nrecord Window(Point p, int z) {}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;scopedvalue\&#34;&gt;ScopedValue&lt;/h1&gt;\n&lt;p&gt;&lt;code&gt;ScopedValue&lt;/code&gt;是一个隐藏的方法参数，只有方法可以访问&lt;code&gt;ScopedValue&lt;/code&gt;，它可以让两个方法传递参数时&lt;strong&gt;无需声明形参&lt;/strong&gt;（对于Web项目中传递用户信息是非常场景的操作）&lt;/p&gt;\n&lt;h2 id=\&#34;threadlocal的问题\&#34;&gt;ThreadLocal的问题&lt;/h2&gt;\n&lt;p&gt;通常对于上述场景，都会采用&lt;code&gt;ThreadLocal&lt;/code&gt;来解决，但是由于&lt;code&gt;ThreadLocal&lt;/code&gt;在设计上的瑕疵，导致一直有以下问题：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;内存泄露，在使用完&lt;code&gt;ThreadLocal&lt;/code&gt;之后，若没有调用&lt;code&gt;remove&lt;/code&gt;方法，会出现内存泄漏。&lt;/li&gt;\n&lt;li&gt;增加开销，在具有继承关系的线程中，子线程需要为父线程中&lt;code&gt;ThreadLocal&lt;/code&gt;里面的数据分配内存&lt;/li&gt;\n&lt;li&gt;不是不可变对象，在方法中可以随意调用&lt;code&gt;set&lt;/code&gt;方法篡改。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;随着虚拟线程的到来，内存泄漏问题不用担心了，因为虚拟线程会很快的终止，此时会自动删除&lt;code&gt;ThreadLocal&lt;/code&gt;中的数据，这样就不用调用&lt;code&gt;remove&lt;/code&gt;方法了。&lt;br&gt;\n但是虚拟线程的数量是非常多的，假如有上百万个虚拟线程都要拷贝一份&lt;code&gt;ThreadLocal&lt;/code&gt;中的变量（问题2），&lt;span style=\&#34;color: red\&#34;&gt;内存将会被严重的浪费掉&lt;/span&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;示例\&#34;&gt;示例&lt;/h2&gt;\n&lt;p&gt;示例代码中通过模拟一个“送礼物”的场景，来演示&lt;code&gt;ScopedValue&lt;/code&gt;。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;在 &lt;code&gt;giveGift&lt;/code&gt; 方法中，将礼物送出，是500元&lt;/li&gt;\n&lt;li&gt;在 &lt;code&gt;receiveMiddleMan&lt;/code&gt; 方法模拟中间人抽成的场景，抽成后送出仅 200元&lt;/li&gt;\n&lt;li&gt;在 &lt;code&gt;receiveGift&lt;/code&gt; 方法中 ，对 &lt;code&gt;ScopedValue&lt;/code&gt; 进行获取，得到的就是200元&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;但整个过程中，中间人 &lt;code&gt;receiveMiddleMan&lt;/code&gt; 在送出前后获取到的信息都是 500元，这正是 &lt;code&gt;Scope&lt;/code&gt; 的含义，&lt;strong&gt;修改只在本作用域（方法）中生效&lt;/strong&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/20\n * @description ScopedValue\n */\npublic class ScopedValueTest {\n\n    private static final ScopedValue&amp;lt;String&amp;gt; GIFT = ScopedValue.newInstance();\n\n    public static void main(String[] args) {\n\n        ScopedValueTest test = new ScopedValueTest();\n        test.giveGift();\n        //中间人开始: 500\n        //收礼物: 200\n        //中间人结束: 500\n    }\n\n    private void giveGift() {\n        ScopedValue.where(GIFT, &amp;quot;500&amp;quot;).run(this::receiveMiddleMan);\n    }\n\n    private void receiveMiddleMan() {\n        System.out.println(STR.&amp;quot;中间人开始: \\{GIFT.get()}&amp;quot;);\n        ScopedValue.where(GIFT, &amp;quot;200&amp;quot;).run(this::receiveGift);\n        System.out.println(STR.&amp;quot;中间人结束: \\{GIFT.get()}&amp;quot;);\n    }\n\n    private void receiveGift() {\n        System.out.println(STR.&amp;quot;收礼物: \\{GIFT.get()}&amp;quot;);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;switch-又升级了支持when关键字了\&#34;&gt;Switch 又升级了，支持when关键字了&lt;/h1&gt;\n&lt;p&gt;switch 可谓是升级升级再升级，我还是在用 if/else 啊。&lt;br&gt;\n从12开始，一路升级。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;支持 &lt;code&gt;-&amp;gt;&lt;/code&gt; 表达式（Java 12）&lt;/li&gt;\n&lt;li&gt;支持返回值（Java 12）&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;case&lt;/code&gt;支持单行写多个条件（Java 12）&lt;/li&gt;\n&lt;li&gt;新增&lt;code&gt;yield&lt;/code&gt;关键字返回&lt;code&gt;switch&lt;/code&gt;的值（Java 12）&lt;/li&gt;\n&lt;li&gt;引入模式匹配（Java 15）&lt;/li&gt;\n&lt;li&gt;这回又新增了一个&lt;code&gt;when&lt;/code&gt;关键字（都快改成SQL了） （Java 21）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;a href=\&#34;https://developer.aliyun.com/article/1357316\&#34;&gt;Java switch升级之路&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/20\n * @description Switch 又升级了~, 这次支持when关键字了\n */\npublic class SwitchFuture {\n\n    void main() {\n\n        var str = &amp;quot;yes&amp;quot;;\n\n        var result = switch (str) {\n            case null -&amp;gt; &amp;quot;空对象&amp;quot;;\n            case String s\n                    when &amp;quot;yes&amp;quot;.equals(s) -&amp;gt; {\n                System.out.println(&amp;quot;确定&amp;quot;);\n                yield &amp;quot;字符串的Yes&amp;quot;;\n            }\n            case String s\n                    when &amp;quot;no&amp;quot;.equals(s) -&amp;gt; {\n                System.out.println(&amp;quot;取消&amp;quot;);\n                yield &amp;quot;字符串的No&amp;quot;;\n            }\n            default -&amp;gt; &amp;quot;default&amp;quot;;\n        };\n\n        System.out.println(result);\n        //确定\n        //字符串的Yes\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;简化了main方法注意看上一个章节的main方法\&#34;&gt;简化了main方法（注意看上一个章节的main方法）&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;Class声明和强制的public访问修饰符是必须的。当用在外部组件定义良好的接口封装代码单元时，它们很有用。但在这个小例子中，它们毫无意义。&lt;/li&gt;\n&lt;li&gt;String[]参数主要用于将代码与外部组件（在本例中为操作系统的shell，接收命令传入的参数）连接。它在这里很神秘且无用，尤其是它从未被使用过。&lt;/li&gt;\n&lt;li&gt;static修饰符是Java类和对象模型的一部分。对于新手来说，这不仅是神秘的，而且是有害的：要添加更多可以调用和使用的方法或字段，学​​生必须要么将它们全部声明（传播一种既不常见也不是好习惯的用法），或者就要面对是否有static修饰的区别问题，并学习如何实例化对象。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;未命名模式和变量go和我有点像\&#34;&gt;未命名模式和变量（Go：和我有点像）&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/21\n * @description 像golang学习, 支持不使用的变量不命名了\n */\npublic class UnnamedVariable {\n\n    void main() {\n\n        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();\n        list.add(&amp;quot;first&amp;quot;);\n        list.add(&amp;quot;last&amp;quot;);\n\n        try {\n            System.out.println(STR.&amp;quot;first -&amp;gt; \\{list.getFirst()}&amp;quot;);\n            System.out.println(STR.&amp;quot;last -&amp;gt; \\{list.getLast()}&amp;quot;);\n            System.out.println(&amp;quot;try&amp;quot;);\n        } catch (Exception _) {\n            System.out.println(&amp;quot;异常了, 但是我没有 Exception&amp;quot;);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;有序集合\&#34;&gt;有序集合&lt;/h1&gt;\n&lt;h2 id=\&#34;sequenced-collections\&#34;&gt;Sequenced Collections&lt;/h2&gt;\n&lt;p&gt;Sequenced Collections引入了三个新接口：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;SequencedCollection&lt;/li&gt;\n&lt;li&gt;SequencedMap&lt;/li&gt;\n&lt;li&gt;SequencedSet&lt;br&gt;\n接口都附带了一些新方法，可以提高操作集合的效率。比如：&lt;code&gt;java.util.SequencedCollection#reversed&lt;/code&gt;等等。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;集合补充了获取收尾元素的方法hutool当我不存在\&#34;&gt;集合补充了获取收尾元素的方法（hutool：当我不存在？）&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();\nlist.add(&amp;quot;first&amp;quot;);\nlist.add(&amp;quot;last&amp;quot;);\nSystem.out.println(STR.&amp;quot;first -&amp;gt; \\{list.getFirst()}&amp;quot;);\nSystem.out.println(STR.&amp;quot;last -&amp;gt; \\{list.getLast()}&amp;quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;加了一些工具类\&#34;&gt;加了一些工具类&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;StringBuilder中的repeat方法&lt;/li&gt;\n&lt;li&gt;补充&lt;code&gt;java.lang.Character#isEmoji&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;等等&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/21\n * @description 加了些新方法\n */\npublic class SomethingExample {\n\n    void main() {\n\n        System.out.println(STR.&amp;quot;repeat =&amp;gt; \\{new StringBuffer().repeat(&amp;quot;*&amp;quot;, 10)}&amp;quot;);\n        //repeat =&amp;gt; **********\n\n        var happy = &amp;quot;你开心吗? 😄&amp;quot;;\n        System.out.println(STR.&amp;quot;isEmoji =&amp;gt; \\{happy.codePoints().anyMatch(Character::isEmoji)}&amp;quot;);\n        //isEmoji =&amp;gt; true\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-20~21-xin-te-xing&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 20~21 新特性&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;}],&#34;date&#34;:&#34;2023-12-19 23:34:39&#34;,&#34;dateFormat&#34;:&#34;2023-12-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-20~21-xin-te-xing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:472000,&#34;words&#34;:1730,&#34;minutes&#34;:8},&#34;description&#34;:&#34;\nJava 20没有发布重要的新特性，本文以Java21版本为主。\nJava 21 是新的LTS版本，其中发布了众多新的特性。\n\n字符串模板（预览版）\n使用官方的STR、FMT\n支持通过STR、FMT来实现字符串拼接，可以自定义模板处理器组...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF%E9%A2%84%E8%A7%88%E7%89%88\&#34;&gt;字符串模板（预览版）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9%E7%9A%84str-fmt\&#34;&gt;使用官方的STR、FMT&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%AE%9A%E4%B9%89stringtemplate\&#34;&gt;自定义StringTemplate&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#record-patterns\&#34;&gt;Record Patterns&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#scopedvalue\&#34;&gt;ScopedValue&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#threadlocal%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;ThreadLocal的问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E4%BE%8B\&#34;&gt;示例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#switch-%E5%8F%88%E5%8D%87%E7%BA%A7%E4%BA%86%E6%94%AF%E6%8C%81when%E5%85%B3%E9%94%AE%E5%AD%97%E4%BA%86\&#34;&gt;Switch 又升级了，支持when关键字了&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E5%8C%96%E4%BA%86main%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E7%9C%8B%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%AB%A0%E8%8A%82%E7%9A%84main%E6%96%B9%E6%B3%95\&#34;&gt;简化了main方法（注意看上一个章节的main方法）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AA%E5%91%BD%E5%90%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%98%E9%87%8Fgo%E5%92%8C%E6%88%91%E6%9C%89%E7%82%B9%E5%83%8F\&#34;&gt;未命名模式和变量（Go：和我有点像）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88\&#34;&gt;有序集合&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#sequenced-collections\&#34;&gt;Sequenced Collections&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9B%86%E5%90%88%E8%A1%A5%E5%85%85%E4%BA%86%E8%8E%B7%E5%8F%96%E6%94%B6%E5%B0%BE%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95hutool%E5%BD%93%E6%88%91%E4%B8%8D%E5%AD%98%E5%9C%A8\&#34;&gt;集合补充了获取收尾元素的方法（hutool：当我不存在？）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A0%E4%BA%86%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB\&#34;&gt;加了一些工具类&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;Java 19 最核心的特性就是&lt;strong&gt;虚拟线程（Virtual Threads）&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;简介\&#34;&gt;简介&lt;/h1&gt;\n&lt;p&gt;该特性在Java19中是预览特性，虚拟线程是用户态下的线程，和&lt;code&gt;go&lt;/code&gt;语言中的&lt;code&gt;goroutines&lt;/code&gt;，&lt;code&gt;Erlang&lt;/code&gt;中的&lt;code&gt;processes&lt;/code&gt;类似，虚拟线程并非比线程快，而是提高了应用的吞吐量，相比于传统的线程是由操作系统调度来看，虚拟线程是我们自己程序调度的线程。虚拟线程的出现并没有修改Java原有的并发模型，也不会替代原有的线程，&lt;strong&gt;虚拟线程主要作用是提高服务器端的吞吐量（主要解决IO密集型而非CPU密集型任务）&lt;/strong&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;吞吐量的瓶颈\&#34;&gt;吞吐量的瓶颈&lt;/h1&gt;\n&lt;p&gt;服务器应用程序的伸缩性受&lt;code&gt;利特尔法则（Little&#39;s Law）&lt;/code&gt;的制约，与下面三点有关：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;延迟：请求处理的耗时&lt;/li&gt;\n&lt;li&gt;并发量：同一时刻处理的请求数量&lt;/li&gt;\n&lt;li&gt;吞吐量：单位时间内处理的数据数量&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;如果一个服务处理延迟是&lt;code&gt;50ms&lt;/code&gt;，处理10个并发请求，则吞吐量是200请求/秒（10/0.05），如果吞吐量要达到2000请求/秒，则处理的并发请求数量是100. 如果按照1个请求一个线程来看，要想提高吞吐量，线程数量也要增加。&lt;/p&gt;\n&lt;p&gt;Java中的线程在操作系统线程（OS Thread）进行了一层封装，而操作系统重线程是重量级资源，在硬件配置确定的前提下，不能无限制创建线程。&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1702907700240.png\&#34; alt=\&#34;os thread\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1702907767424.png\&#34; alt=\&#34;virtual thread\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;与虚拟地址可以映射到物理内存类似，Java将大量的虚拟线程映射到少量的操作系统线程上，虚拟线程的生命周期短暂，不会有很深的栈调用，一个虚拟线程的生命周期只运行一个任务，因此可以大量创建虚拟线程，&lt;strong&gt;且无需池化&lt;/strong&gt;。&lt;/p&gt;\n&lt;h1 id=\&#34;虚拟线程的应用场景\&#34;&gt;虚拟线程的应用场景&lt;/h1&gt;\n&lt;p&gt;在服务器端的应用程序中，虚拟线程能够明显提高应用的吞吐量：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;至少几千的并发任务量&lt;/li&gt;\n&lt;li&gt;任务是IO密集型&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;平台线程和虚拟线程\&#34;&gt;平台线程和虚拟线程&lt;/h1&gt;\n&lt;p&gt;平台线程（platform thread）：指Java中的线程，比如通过&lt;code&gt;new Thread()&lt;/code&gt;创建的线程。&lt;br&gt;\n虚拟线程并不会直接分配给CPU执行，而是通过&lt;code&gt;调度器&lt;/code&gt;分配给平台线程，平台线程再被调度器管理。Java中的虚拟线程的调度器采用了工作窃取的模式进行FIFO的操作，调度器的并行书默认是jvm获取的处理器数量（&lt;code&gt;Runtime.getRuntime().availableProcessors()&lt;/code&gt;），调度器并非分时（&lt;code&gt;time sharing&lt;/code&gt;）的。在使用虚拟线程编写程序时，不能控制虚拟线程合适分配给平台线程，也不能控制平台线程合适分配给CPU。&lt;/p&gt;\n&lt;p&gt;以前任务和平台线程的关系：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1702908144716.png\&#34; alt=\&#34;old mode\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n在使用虚拟线程之后，任务-虚拟线程-调度器-平台线程的关系，1个平台线程可以被调度器分配不同的虚拟线程：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1702908151069.png\&#34; alt=\&#34;new mode\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;携带器\&#34;&gt;携带器&lt;/h1&gt;\n&lt;p&gt;调度器将虚拟线程挂载到平台线程之后，该平台线程叫做虚拟线程的携带器，调度器并不维护虚拟线程和携带器的关联关系，&lt;span style=\&#34;color: red\&#34;&gt;&lt;strong&gt;因此在一个虚拟线程的生命周期可以被分配到不同的携带器&lt;/strong&gt;&lt;/span&gt;，即虚拟线程运行了一小段代码后，可能会脱离携带器，此时其他的虚拟线程会被分配到这个携带器上。&lt;/p&gt;\n&lt;p&gt;携带器和虚拟线程是相互独立的，比如：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;虚拟线程不能使用携带器的标识，&lt;code&gt;Thread.current()&lt;/code&gt;方法获取的是虚拟线程本身。&lt;/li&gt;\n&lt;li&gt;两者有各自的栈空间。&lt;/li&gt;\n&lt;li&gt;两者不能访问对方的&lt;code&gt;ThreadLocal&lt;/code&gt;变量&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在程序的执行过程中，虚拟线程遇到阻塞的操作是大部分情况下会被解除挂载，阻塞结束后，虚拟线程会被调度器重新挂载到携带器上，因此虚拟线程会频繁的挂载和解除挂载，这并不会导致操作系统线程的阻塞。&lt;br&gt;\n有些阻塞操作并不会导致虚拟线程接触挂载，这样会同时阻塞携带器和操作系统线程，例如：操作系统基本的文件操作，Java的&lt;code&gt;Object.wait()&lt;/code&gt;方法，下面两种情况下不会导致虚拟线程的解除挂载：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;执行&lt;code&gt;synchronized&lt;/code&gt;同步代码（会导致携带器阻塞，所以建议使用&lt;code&gt;ReentrantLock&lt;/code&gt;替换掉&lt;code&gt;Synchronized&lt;/code&gt;）&lt;/li&gt;\n&lt;li&gt;执行本地方法或外部函数&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;虚拟线程和平台线程api的区别\&#34;&gt;虚拟线程和平台线程api的区别&lt;/h1&gt;\n&lt;p&gt;从内存空间上来说，虚拟线程的栈空间可以看做是一个大块的站对象，他被存储在Java堆中，相比于单独存储对象，堆中存储虚拟线程会造成一些空间的浪费，这点在后续的Java版本中应该会得到改善，当然也有一些好处，就是可以重复利用这部分栈空间，不用多次申请开辟新的内存地址，虚拟线程的栈空间最大可以达到平台线程的栈空间容量。&lt;br&gt;\n&lt;strong&gt;虚拟线程并不是&lt;code&gt;GC root&lt;/code&gt;，其中的引用不会出现&lt;code&gt;Stop World&lt;/code&gt;，当虚拟线程阻塞之后比如&lt;code&gt;BlockingQueue.take()&lt;/code&gt;，平台线程既不能获取到虚拟线程，也不能获取到&lt;code&gt;queue&lt;/code&gt;队列，这样该平台线程可能被回收掉，虚拟线程在运行或阻塞时不会被GC&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;通过Thread构造方法创建的线程都是平台线程&lt;/li&gt;\n&lt;li&gt;虚拟线程是守护线程，不能通过&lt;code&gt;setDaemon&lt;/code&gt;方法改为非守护线程&lt;/li&gt;\n&lt;li&gt;虚拟线程的优先级是默认的5，不能被修改，将来版本可能允许修改&lt;/li&gt;\n&lt;li&gt;虚拟线程不支持&lt;code&gt;stop()&lt;/code&gt;, &lt;code&gt;suspend()&lt;/code&gt;,&lt;code&gt;resume()&lt;/code&gt;方法&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;创建虚拟线程的方式\&#34;&gt;创建虚拟线程的方式&lt;/h1&gt;\n&lt;p&gt;Java中创建的虚拟线程本质都是通过&lt;code&gt;Thread.Builder.OfVirtual&lt;/code&gt;对象进行创建的，有如下三种方式：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Thread.startVirtualThread()&lt;/code&gt;直接创建一个虚拟线程&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Thread.ofVirtual().name(&amp;quot;virtual-thread-&amp;quot;).unstarted(r)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;示例代码\&#34;&gt;示例代码&lt;/h1&gt;\n&lt;h2 id=\&#34;虚拟线程池\&#34;&gt;虚拟线程池&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.time.Duration;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.stream.IntStream;\n\n/**\n * @author imyzt\n * @date 2023/12/18\n * @description VirtualThread 1\n */\npublic class VirtualThread {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        // 通过线程池创建虚拟线程池\n        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            IntStream.range(0, 10000000).forEach(i -&amp;gt; {\n                executor.submit(() -&amp;gt; {\n                    try {\n                        Thread.sleep(Duration.ofSeconds(1));\n                        System.out.println(&amp;quot;执行任务: &amp;quot; + i);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                });\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;创建虚拟线程\&#34;&gt;创建虚拟线程&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.util.concurrent.TimeUnit;\n\n/**\n * @author imyzt\n * @date 2023/12/18\n * @description VirtualThread 2\n */\npublic class CreateVirtualThread {\n    public static void main(String[] args) throws InterruptedException {\n\n        Runnable r = () -&amp;gt; System.out.println(Thread.currentThread().getName() + &amp;quot; --- 执行了&amp;quot;);\n\n        // 创建虚拟线程, 方式1\n        Thread.startVirtualThread(r);\n\n        Thread virtualThread = Thread.ofVirtual().name(&amp;quot;virtual-thread-&amp;quot;).unstarted(r);\n        virtualThread.start();\n        System.out.println(&amp;quot;是虚拟线程吗? &amp;quot; + virtualThread.isVirtual());\n\n        Thread platformThread = Thread.ofPlatform().priority(0).daemon(true).name(&amp;quot;platform-thread-&amp;quot;).unstarted(r);\n        platformThread.start();\n        System.out.println(&amp;quot;是虚拟线程吗? &amp;quot; + platformThread.isVirtual());\n\n        // --- 执行了\n        //virtual-thread- --- 执行了\n        //是虚拟线程吗? true\n        //platform-thread- --- 执行了\n        //是虚拟线程吗? false\n\n        // 主线程休眠\n        TimeUnit.SECONDS.sleep(1);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;其它\&#34;&gt;其它&lt;/h1&gt;\n&lt;p&gt;除了提出虚拟线程外，还提出来新的并发编程模型&lt;strong&gt;结构化并发&lt;/strong&gt;，&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;java-19-xin-te-xing&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 19 新特性&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;}],&#34;date&#34;:&#34;2023-12-18 21:46:24&#34;,&#34;dateFormat&#34;:&#34;2023-12-18&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-19-xin-te-xing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:406000,&#34;words&#34;:1811,&#34;minutes&#34;:7},&#34;description&#34;:&#34;\nJava 19 最核心的特性就是虚拟线程（Virtual Threads）\n\n简介\n该特性在Java19中是预览特性，虚拟线程是用户态下的线程，和go语言中的goroutines，Erlang中的processes类似，虚拟线程并非比线程...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E4%BB%8B\&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%9E%E5%90%90%E9%87%8F%E7%9A%84%E7%93%B6%E9%A2%88\&#34;&gt;吞吐量的瓶颈&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\&#34;&gt;虚拟线程的应用场景&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B9%B3%E5%8F%B0%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B\&#34;&gt;平台线程和虚拟线程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%90%BA%E5%B8%A6%E5%99%A8\&#34;&gt;携带器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E7%BA%BF%E7%A8%8Bapi%E7%9A%84%E5%8C%BA%E5%88%AB\&#34;&gt;虚拟线程和平台线程api的区别&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F\&#34;&gt;创建虚拟线程的方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\&#34;&gt;示例代码&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0\&#34;&gt;虚拟线程池&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B\&#34;&gt;创建虚拟线程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B6%E5%AE%83\&#34;&gt;其它&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;特性列表\&#34;&gt;特性列表&lt;/h1&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;版本&lt;/th&gt;\n&lt;th&gt;特性&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Java 17（&lt;strong&gt;LTS&lt;/strong&gt;）&lt;/td&gt;\n&lt;td&gt;1. &lt;code&gt;switch&lt;/code&gt; 类型推断 &lt;br/&gt; 2. 伪随机数变化&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Java 18&lt;/td&gt;\n&lt;td&gt;1. 使用&lt;code&gt;UTF-8&lt;/code&gt;编码&lt;br/&gt; 2. &lt;code&gt;jwebserver&lt;/code&gt; &lt;br/&gt; 3. Object、Thread部分方法标记废弃&lt;br/&gt; 4. 增加&lt;code&gt;@snippet&lt;/code&gt;注解&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h1 id=\&#34;java-17\&#34;&gt;Java 17&lt;/h1&gt;\n&lt;h2 id=\&#34;switch-类型推断伪随机数变化\&#34;&gt;switch 类型推断，伪随机数变化&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;\nimport java.util.random.RandomGenerator;\nimport java.util.random.RandomGeneratorFactory;\n\n/**\n * @author imyzt\n * @date 2023/12/17\n * @description switch 类型推断\n */\npublic class SwitchFuture {\n\n    public static void main(String[] args) {\n\n        Animal animal = new Cat();\n        switch (animal) {\n            case Cat c -&amp;gt; c.say();\n            case Dog d -&amp;gt; d.say();\n            case null -&amp;gt; System.out.println(&amp;quot;null&amp;quot;);\n            default -&amp;gt; System.out.println(&amp;quot;default&amp;quot;);\n        }\n\n        /*\n        ➜  java17 git:(master) ✗ java -version\n        openjdk version &amp;quot;21.0.1&amp;quot; 2023-10-17 LTS\n        OpenJDK Runtime Environment Corretto-21.0.1.12.1 (build 21.0.1+12-LTS)\n        OpenJDK 64-Bit Server VM Corretto-21.0.1.12.1 (build 21.0.1+12-LTS, mixed mode, sharing)\n        ➜  java17 git:(master) ✗ java SwitchFuture.java\n        汪汪汪\n         */\n\n        RandomGeneratorFactory&amp;lt;RandomGenerator&amp;gt; factory = RandomGeneratorFactory.getDefault();\n        RandomGenerator randomGenerator = factory.create();\n        randomGenerator.ints(10).forEach(System.out::println);\n        //261824154\n        //540138312\n        //-1600972486\n        //-467718820\n        //-660092685\n        //-1149689401\n        //-46916737\n        //2110685130\n        //-1910355456\n        //-814203516\n    }\n}\n\nclass Animal {\n\n}\n\nclass Cat extends Animal {\n    void say() {\n        System.out.println(&amp;quot;汪汪汪&amp;quot;);\n    }\n}\nclass Dog extends Animal {\n    void say() {\n        System.out.println(&amp;quot;喵喵喵&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;java-18\&#34;&gt;Java 18&lt;/h1&gt;\n&lt;h2 id=\&#34;默认使用utf-8字符编码\&#34;&gt;默认使用UTF-8字符编码&lt;/h2&gt;\n&lt;p&gt;从jdk18开始，默认使用UTF-8字符编码，如果需要修改为其他字符，可以使用命令 &lt;code&gt;-Dfile.encoding=UTF-8&lt;/code&gt;来指定。&lt;/p&gt;\n&lt;h2 id=\&#34;简单web服务器\&#34;&gt;简单web服务器&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;➜  java17 git:(master) ✗ jwebserver            \n默认情况下绑定到环回。如果要表示所有接口，请使用 &amp;quot;-b 0.0.0.0&amp;quot; 或 &amp;quot;-b ::&amp;quot;。\n为 127.0.0.1 端口 8000 上的 /xxxxxxxxx目录/java17 及子目录提供服务\nURL http://127.0.0.1:8000/\n127.0.0.1 - - [17/12月/2023:10:38:18 +0800] &amp;quot;GET / HTTP/1.1&amp;quot; 200 -\n127.0.0.1 - - [17/12月/2023:10:38:18 +0800] &amp;quot;GET /favicon.ico HTTP/1.1&amp;quot; 404 -\n127.0.0.1 - - [17/12月/2023:10:38:20 +0800] &amp;quot;GET /SwitchFuture.java HTTP/1.1&amp;quot; 200 -\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;将被废弃的方法\&#34;&gt;将被废弃的方法&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;java.lang.Object#finalize&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;java.lang.Thread#stop&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;新增snippet展示代码\&#34;&gt;新增@snippet展示代码&lt;/h2&gt;\n&lt;p&gt;之前需要用&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;标签框代码，不方便，现在通过&lt;code&gt;@snippet&lt;/code&gt;还是框代码&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1702781281538.png\&#34; alt=\&#34;snippet\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;java-17~18-xin-te-xing&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 17~18 新特性&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;}],&#34;date&#34;:&#34;2023-12-17 10:31:55&#34;,&#34;dateFormat&#34;:&#34;2023-12-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-17~18-xin-te-xing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:149000,&#34;words&#34;:480,&#34;minutes&#34;:3},&#34;description&#34;:&#34;特性列表\n\n\n\n版本\n特性\n\n\n\n\nJava 17（LTS）\n1. switch 类型推断  2. 伪随机数变化\n\n\nJava 18\n1. 使用UTF-8编码 2. jwebserver  3. Object、Thread部分方法标记废弃 ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%89%B9%E6%80%A7%E5%88%97%E8%A1%A8\&#34;&gt;特性列表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-17\&#34;&gt;Java 17&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#switch-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%98%E5%8C%96\&#34;&gt;switch 类型推断，伪随机数变化&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-18\&#34;&gt;Java 18&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8utf-8%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81\&#34;&gt;默认使用UTF-8字符编码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E5%8D%95web%E6%9C%8D%E5%8A%A1%E5%99%A8\&#34;&gt;简单web服务器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%86%E8%A2%AB%E5%BA%9F%E5%BC%83%E7%9A%84%E6%96%B9%E6%B3%95\&#34;&gt;将被废弃的方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E5%A2%9Esnippet%E5%B1%95%E7%A4%BA%E4%BB%A3%E7%A0%81\&#34;&gt;新增@snippet展示代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;主要特性\&#34;&gt;主要特性&lt;/h1&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;版本&lt;/th&gt;\n&lt;th&gt;特性&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;Java 10&lt;/td&gt;\n&lt;td&gt;1. &lt;code&gt;var&lt;/code&gt;声明局部变量&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Java 11 （&lt;strong&gt;LTS&lt;/strong&gt;）&lt;/td&gt;\n&lt;td&gt;1. 字符串补充工具方法 &lt;br/&gt; 2. lambda 类型推断&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Java 12&lt;/td&gt;\n&lt;td&gt;1. switch 箭头表达式&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Java 13&lt;/td&gt;\n&lt;td&gt;1. switch 支持返回值，增加yield关键字&lt;br/&gt; 2. 多行字符串&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Java 14&lt;/td&gt;\n&lt;td&gt;1. instanceof优化&lt;br/&gt; 2. NPE优化&lt;br/&gt;  3. record类型&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Java 15&lt;/td&gt;\n&lt;td&gt;1. scale密封类&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Java 16&lt;/td&gt;\n&lt;td&gt;1. 包装类构造方法警告&lt;br/&gt; 2. DateTimeFormatter增加匹配方式&lt;br/&gt; 3. InvocationHandler新增方法&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h1 id=\&#34;java-10\&#34;&gt;Java 10&lt;/h1&gt;\n&lt;h2 id=\&#34;var-声明局部变量\&#34;&gt;&lt;code&gt;var&lt;/code&gt; 声明局部变量&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2023/12/16\n * @description Var\n */\npublic class VarDemo {\n    public static void main(String[] args) {\n        var str = &amp;quot;hello world&amp;quot;;\n        var num = 10;\n\n        System.out.println(str);\n        System.out.println(num);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;java-11\&#34;&gt;Java 11&lt;/h1&gt;\n&lt;h2 id=\&#34;字符串补充工具方法-lambda-类型推断\&#34;&gt;字符串补充工具方法, lambda 类型推断&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/16\n * @description String 补充工具方法\n */\npublic class StrUtil {\n\n    public static void main(String[] args) {\n        //Unicode空白字符\n        char c = &#39;\\u2000&#39;;\n        String str = c + &amp;quot;abc&amp;quot; + c;\n        // 去除普通空白字符\n        System.out.println(str.trim());\n        // 去除Unicode空白字符\n        System.out.println(str.strip());\n        // 去除前面的空白字符\n        System.out.println(str.stripLeading());\n        // 去除后面的空白字符\n        System.out.println(str.stripTrailing());\n        // abc \n        //abc\n        //abc \n        // abc\n\n        // 判空\n        System.out.println(&amp;quot; &amp;quot;.isBlank());\n        // 支持直接定义常量使用format\n        System.out.println(&amp;quot;%s_%s&amp;quot;.formatted(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;));\n        // 重复字符串\n        System.out.println(&amp;quot;abc&amp;quot;.repeat(3));\n        //true\n        //a_b\n        //abcabcabc\n\n        // lambda 类型推断\n        // java11前\n        MyFunc s1 = (String a, Integer b) -&amp;gt; a + b;\n        MyFunc s2 = (a, b) -&amp;gt; a + b;\n        // java11后, 支持类型推断(作用不大)\n        MyFunc s3 = (var a, var b) -&amp;gt; a + b;\n    }\n}\n\n@FunctionalInterface\ninterface MyFunc {\n    String foo(String a, Integer b);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;java-12\&#34;&gt;Java 12&lt;/h1&gt;\n&lt;h2 id=\&#34;switch-箭头表达式\&#34;&gt;switch 箭头表达式&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/16\n * @description switch\n */\npublic class SwitchFuture {\n\n    public static void main(String[] args) {\n\n        int month = LocalDate.now().getMonthValue();\n\n        // java12 前 switch\n        switch (month) {\n            case 3:\n            case 4:\n            case 5:\n                System.out.println(&amp;quot;spring&amp;quot;);\n                break;\n            case 6:\n            case 7:\n            case 8:\n                System.out.println(&amp;quot;summer&amp;quot;);\n                break;\n            case 9:\n            case 10:\n            case 11:\n                System.out.println(&amp;quot;fall&amp;quot;);\n                break;\n            case 12:\n            case 1:\n            case 2:\n                System.out.println(&amp;quot;winter&amp;quot;);\n                break;\n            default:\n                System.out.println(&amp;quot;err&amp;quot;);\n        }\n\n        // java12 之后的switch\n        switch (month) {\n            case 3,4,5 -&amp;gt; System.out.println(&amp;quot;spring&amp;quot;);\n            case 6,7,8 -&amp;gt; System.out.println(&amp;quot;summer&amp;quot;);\n            case 9,10,11 -&amp;gt; System.out.println(&amp;quot;fall&amp;quot;);\n            case 12,1,2 -&amp;gt; System.out.println(&amp;quot;winter&amp;quot;);\n            default -&amp;gt; System.out.println(&amp;quot;err&amp;quot;);\n\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;java-13\&#34;&gt;Java 13&lt;/h1&gt;\n&lt;h2 id=\&#34;switch-箭头表达式支持返回值多行字符串增加yield关键字作为switch多行时的返回值\&#34;&gt;switch 箭头表达式支持返回值，多行字符串，增加yield关键字作为switch多行时的返回值&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.time.LocalDate;\n\n/**\n * @author imyzt\n * @date 2023/12/16\n * @description switch 返回值\n */\npublic class SwitchFuture {\n\n    public static void main(String[] args) {\n\n        int month = LocalDate.now().getMonthValue();\n        // java13 之后的switch\n        String str = switch (month) {\n            case 3, 4, 5 -&amp;gt; &amp;quot;spring&amp;quot;;\n            case 6, 7, 8 -&amp;gt; &amp;quot;summer&amp;quot;;\n            case 9, 10, 11 -&amp;gt; &amp;quot;fall&amp;quot;;\n            case 12, 1, 2 -&amp;gt; &amp;quot;winter&amp;quot;;\n            default -&amp;gt; {\n                System.out.println(&amp;quot;err&amp;quot;);\n                yield &amp;quot;err&amp;quot;;\n            }\n        };\n        System.out.println(str);\n        // winter\n\n        String strline = &amp;quot;&amp;quot;&amp;quot;\n                第一行\n                第二行\n                第三行&amp;quot;&amp;quot;&amp;quot;;\n        System.out.println(strline);\n        //第一行\n        //第二行\n        //第三行\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;java-14\&#34;&gt;Java 14&lt;/h1&gt;\n&lt;h2 id=\&#34;instanceof-优化\&#34;&gt;instanceof 优化&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/16\n * @description instanceof 优化\n */\npublic class InstanceofFuture {\n\n    public static void main(String[] args) {\n\n        // Java 14之前\n        Object o = &amp;quot;str&amp;quot;;\n        if (o instanceof String) {\n            String str = (String) o;\n            System.out.println(str);\n        }\n\n        // Java 14之后\n        if (o instanceof String str) {\n            System.out.println(str);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;npe优化在链式调用时-如果有空指针-可以明确是哪个变量空指针\&#34;&gt;NPE优化，在链式调用时, 如果有空指针, 可以明确是哪个变量空指针&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/16\n * @description 友好的NPE提示\n */\npublic class NpeFuture {\n\n    public static void main(String[] args) {\n        C c = new C();\n        // 在链式调用时, 如果有空指针, 可以明确是哪个变量空指针\n        String name = c.b.a.name;\n        System.out.println(name);\n        // Cannot read field &amp;quot;a&amp;quot; because &amp;quot;c.b&amp;quot; is null\n    }\n}\nclass A {\n    public String name;\n}\n\nclass B {\n    public A a;\n}\n\nclass C {\n    public B b;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;record模式\&#34;&gt;record模式&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/16\n * @description record模式\n */\npublic class RecordFuture {\n\n    public static void main(String[] args) {\n        Student student = new Student(&amp;quot;yzt&amp;quot;, 25);\n        System.out.println(student);\n        // Student[name=yzt, age=25]\n\n        student.study();\n        // good good study!\n    }\n}\n\nrecord Student(String name, Integer age) {\n    public void study() {\n        System.out.println(&amp;quot;good good study!&amp;quot;);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;java-15\&#34;&gt;Java 15&lt;/h1&gt;\n&lt;h2 id=\&#34;scale密封类\&#34;&gt;scale密封类&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;需要使用&lt;code&gt;sealed&lt;/code&gt;声明, 使用&lt;code&gt;permits&lt;/code&gt;指定&lt;/li&gt;\n&lt;li&gt;继承密封类，必须指定自己为final(Dog)，或选择继续将自己指定为密封类(Cat)&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/16\n * @description scale, permits\n */\npublic class ScaleFuture {\n}\n\n/**\n * 只希望Dog和Cat能继承, 需要使用sealed声明, 使用permits指定\n */\nsealed class Animal permits Dog, Cat {\n    \n}\n\n/**\n * 继承密封类,必须指定自己为final(Dog), 或继续将自己指定为密封类(Cat)\n */\nfinal class Dog extends Animal {\n    \n}\n\n/**\n * 将自己指定为密封类, 并且通过permits指定只有Cat2能够继承\n */\nsealed class Cat extends Animal permits Cat2 {\n    \n}\n\nfinal class Cat2 extends Cat {\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;java-16\&#34;&gt;Java 16&lt;/h1&gt;\n&lt;h2 id=\&#34;包装类型的构造方法被标记过期\&#34;&gt;包装类型的构造方法被标记过期&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n * @author imyzt\n * @date 2023/12/17\n * @description Integer\n */\npublic class IntegerFuture {\n\n    public static void main(String[] args) {\n        // &#39;Integer(int)&#39; is deprecated and marked for removal\n        Integer i = new Integer(2);\n        System.out.println(i);\n\n        // 不建议这样编写,因为数字在常量池中, 会和其他毫不相干的地方使用同一个锁对象\n        synchronized (i) {\n            System.out.println(1);\n        }\n\n        // time format\n        // All letters &#39;A&#39; to &#39;Z&#39; and &#39;a&#39; to &#39;z&#39; are reserved as pattern letters. The following pattern letters are defined:\n        System.out.println(DateTimeFormatter.ofPattern(&amp;quot;B&amp;quot;).format(LocalDateTime.now()));\n\n        //2\n        //1\n        //凌晨\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;datetimeformatter\&#34;&gt;DateTimeFormatter&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/format/DateTimeFormatter.html\&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Symbol&lt;/th&gt;\n&lt;th&gt;Meaning&lt;/th&gt;\n&lt;th&gt;Presentation&lt;/th&gt;\n&lt;th&gt;Examples&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;G&lt;/td&gt;\n&lt;td&gt;era&lt;/td&gt;\n&lt;td&gt;text&lt;/td&gt;\n&lt;td&gt;AD; Anno Domini; A&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;u&lt;/td&gt;\n&lt;td&gt;year&lt;/td&gt;\n&lt;td&gt;year&lt;/td&gt;\n&lt;td&gt;2004; 04&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;y&lt;/td&gt;\n&lt;td&gt;year-of-era&lt;/td&gt;\n&lt;td&gt;year&lt;/td&gt;\n&lt;td&gt;2004; 04&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;D&lt;/td&gt;\n&lt;td&gt;day-of-year&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;189&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;M/L&lt;/td&gt;\n&lt;td&gt;month-of-year&lt;/td&gt;\n&lt;td&gt;number/text&lt;/td&gt;\n&lt;td&gt;7; 07; Jul; July; J&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;d&lt;/td&gt;\n&lt;td&gt;day-of-month&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;10&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;g&lt;/td&gt;\n&lt;td&gt;modified-julian-day&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;2451334&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Q/q&lt;/td&gt;\n&lt;td&gt;quarter-of-year&lt;/td&gt;\n&lt;td&gt;number/text&lt;/td&gt;\n&lt;td&gt;3; 03; Q3; 3rd quarter&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Y&lt;/td&gt;\n&lt;td&gt;week-based-year&lt;/td&gt;\n&lt;td&gt;year&lt;/td&gt;\n&lt;td&gt;1996; 96&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;w&lt;/td&gt;\n&lt;td&gt;week-of-week-based-year&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;27&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;W&lt;/td&gt;\n&lt;td&gt;week-of-month&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;4&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;E&lt;/td&gt;\n&lt;td&gt;day-of-week&lt;/td&gt;\n&lt;td&gt;text&lt;/td&gt;\n&lt;td&gt;Tue; Tuesday; T&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;e/c&lt;/td&gt;\n&lt;td&gt;localized day-of-week&lt;/td&gt;\n&lt;td&gt;number/text&lt;/td&gt;\n&lt;td&gt;2; 02; Tue; Tuesday; T&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;F&lt;/td&gt;\n&lt;td&gt;day-of-week-in-month&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;3&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;a&lt;/td&gt;\n&lt;td&gt;am-pm-of-day&lt;/td&gt;\n&lt;td&gt;text&lt;/td&gt;\n&lt;td&gt;PM&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;B&lt;/td&gt;\n&lt;td&gt;period-of-day&lt;/td&gt;\n&lt;td&gt;text&lt;/td&gt;\n&lt;td&gt;in the morning&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;h&lt;/td&gt;\n&lt;td&gt;clock-hour-of-am-pm (1-12)&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;12&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;K&lt;/td&gt;\n&lt;td&gt;hour-of-am-pm (0-11)&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;k&lt;/td&gt;\n&lt;td&gt;clock-hour-of-day (1-24)&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;24&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;H&lt;/td&gt;\n&lt;td&gt;hour-of-day (0-23)&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;m&lt;/td&gt;\n&lt;td&gt;minute-of-hour&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;30&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;s&lt;/td&gt;\n&lt;td&gt;second-of-minute&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;55&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;S&lt;/td&gt;\n&lt;td&gt;fraction-of-second&lt;/td&gt;\n&lt;td&gt;fraction&lt;/td&gt;\n&lt;td&gt;978&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;A&lt;/td&gt;\n&lt;td&gt;milli-of-day&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;1234&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;n&lt;/td&gt;\n&lt;td&gt;nano-of-second&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;987654321&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;N&lt;/td&gt;\n&lt;td&gt;nano-of-day&lt;/td&gt;\n&lt;td&gt;number&lt;/td&gt;\n&lt;td&gt;1234000000&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;V&lt;/td&gt;\n&lt;td&gt;time-zone ID&lt;/td&gt;\n&lt;td&gt;zone-id&lt;/td&gt;\n&lt;td&gt;America/Los_Angeles; Z; -08:30&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;v&lt;/td&gt;\n&lt;td&gt;generic time-zone name&lt;/td&gt;\n&lt;td&gt;zone-name&lt;/td&gt;\n&lt;td&gt;Pacific Time; PT&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;z&lt;/td&gt;\n&lt;td&gt;time-zone name&lt;/td&gt;\n&lt;td&gt;zone-name&lt;/td&gt;\n&lt;td&gt;Pacific Standard Time; PST&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;O&lt;/td&gt;\n&lt;td&gt;localized zone-offset&lt;/td&gt;\n&lt;td&gt;offset-O&lt;/td&gt;\n&lt;td&gt;GMT+8; GMT+08:00; UTC-08:00&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;X&lt;/td&gt;\n&lt;td&gt;zone-offset &#39;Z&#39; for zero&lt;/td&gt;\n&lt;td&gt;offset-X&lt;/td&gt;\n&lt;td&gt;Z; -08; -0830; -08:30; -083015; -08:30:15&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;x&lt;/td&gt;\n&lt;td&gt;zone-offset&lt;/td&gt;\n&lt;td&gt;offset-x&lt;/td&gt;\n&lt;td&gt;+0000; -08; -0830; -08:30; -083015; -08:30:15&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Z&lt;/td&gt;\n&lt;td&gt;zone-offset&lt;/td&gt;\n&lt;td&gt;offset-Z&lt;/td&gt;\n&lt;td&gt;+0000; -0800; -08:00&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;p&lt;/td&gt;\n&lt;td&gt;pad next&lt;/td&gt;\n&lt;td&gt;pad modifier&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&#39;&lt;/td&gt;\n&lt;td&gt;escape for text&lt;/td&gt;\n&lt;td&gt;delimiter&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&#39;&#39;&lt;/td&gt;\n&lt;td&gt;single quote&lt;/td&gt;\n&lt;td&gt;literal&lt;/td&gt;\n&lt;td&gt;&#39;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[&lt;/td&gt;\n&lt;td&gt;optional section start&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;]&lt;/td&gt;\n&lt;td&gt;optional section end&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;#&lt;/td&gt;\n&lt;td&gt;reserved for future use&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;{&lt;/td&gt;\n&lt;td&gt;reserved for future use&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;}&lt;/td&gt;\n&lt;td&gt;reserved for future use&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h2 id=\&#34;invocationhandler新增方法\&#34;&gt;InvocationHandler新增方法&lt;/h2&gt;\n&lt;p&gt;该接口补充了新方法 &lt;code&gt;java.lang.reflect.InvocationHandler#invokeDefault&lt;/code&gt;，可以调用父接口中的&lt;code&gt;default&lt;/code&gt;方法。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@CallerSensitive\npublic static Object invokeDefault(Object proxy, Method method, Object... args)\n        throws Throwable {\n    Objects.requireNonNull(proxy);\n    Objects.requireNonNull(method);\n    return Proxy.invokeDefault(proxy, method, args, Reflection.getCallerClass());\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-10~16-xin-te-xing&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 10~16 新特性&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;}],&#34;date&#34;:&#34;2023-12-16 22:56:10&#34;,&#34;dateFormat&#34;:&#34;2023-12-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-10~16-xin-te-xing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:503000,&#34;words&#34;:1567,&#34;minutes&#34;:9},&#34;description&#34;:&#34;主要特性\n\n\n\n版本\n特性\n\n\n\n\nJava 10\n1. var声明局部变量\n\n\nJava 11 （LTS）\n1. 字符串补充工具方法  2. lambda 类型推断\n\n\nJava 12\n1. switch 箭头表达式\n\n\nJava 13\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7\&#34;&gt;主要特性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-10\&#34;&gt;Java 10&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#var-%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\&#34;&gt;&lt;code&gt;var&lt;/code&gt; 声明局部变量&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-11\&#34;&gt;Java 11&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A5%E5%85%85%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-lambda-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD\&#34;&gt;字符串补充工具方法, lambda 类型推断&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-12\&#34;&gt;Java 12&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#switch-%E7%AE%AD%E5%A4%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F\&#34;&gt;switch 箭头表达式&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-13\&#34;&gt;Java 13&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#switch-%E7%AE%AD%E5%A4%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%AF%E6%8C%81%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A2%9E%E5%8A%A0yield%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E4%B8%BAswitch%E5%A4%9A%E8%A1%8C%E6%97%B6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC\&#34;&gt;switch 箭头表达式支持返回值，多行字符串，增加yield关键字作为switch多行时的返回值&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-14\&#34;&gt;Java 14&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#instanceof-%E4%BC%98%E5%8C%96\&#34;&gt;instanceof 优化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#npe%E4%BC%98%E5%8C%96%E5%9C%A8%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%97%B6-%E5%A6%82%E6%9E%9C%E6%9C%89%E7%A9%BA%E6%8C%87%E9%92%88-%E5%8F%AF%E4%BB%A5%E6%98%8E%E7%A1%AE%E6%98%AF%E5%93%AA%E4%B8%AA%E5%8F%98%E9%87%8F%E7%A9%BA%E6%8C%87%E9%92%88\&#34;&gt;NPE优化，在链式调用时, 如果有空指针, 可以明确是哪个变量空指针&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#record%E6%A8%A1%E5%BC%8F\&#34;&gt;record模式&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-15\&#34;&gt;Java 15&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#scale%E5%AF%86%E5%B0%81%E7%B1%BB\&#34;&gt;scale密封类&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java-16\&#34;&gt;Java 16&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%A2%AB%E6%A0%87%E8%AE%B0%E8%BF%87%E6%9C%9F\&#34;&gt;包装类型的构造方法被标记过期&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#datetimeformatter\&#34;&gt;DateTimeFormatter&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#invocationhandler%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95\&#34;&gt;InvocationHandler新增方法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;主要特性\&#34;&gt;主要特性&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;接口中支持定义 &lt;code&gt;private&lt;/code&gt; 方法&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;try-with-resource&lt;/code&gt; 方式优化&lt;/li&gt;\n&lt;li&gt;不可以使用 “_”下划线命名变量&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;@Deprecated&lt;/code&gt; 注解支持指定废弃版本(&lt;code&gt;since&lt;/code&gt;), 以及标记未来版本是否删除(&lt;code&gt;forRemoval&lt;/code&gt;)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;String&lt;/code&gt;字符串的变化&lt;/li&gt;\n&lt;li&gt;模块化&lt;/li&gt;\n&lt;li&gt;jshell&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;接口定义private方法\&#34;&gt;接口定义&lt;code&gt;private&lt;/code&gt;方法&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.util.concurrent.TimeUnit;\n\n/**\n * @author imyzt\n * @date 2023/12/16\n * @description java 9 在接口中可以定义 private 方法, 只可在本接口中调用\n */\npublic interface InterfaceFuture {\n\n    void foo();\n\n    /**\n     * java 8\n     */\n    default void foo1() throws InterruptedException {\n        sleep();\n    }\n\n    /**\n     * java 8\n     */\n    static void foo2() throws InterruptedException {\n        sleep2();\n    }\n\n    /**\n     * java 9\n     */\n    private void sleep() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(1);\n    }\n\n    /**\n     * java 9\n     */\n    private static void sleep2() throws InterruptedException {\n        TimeUnit.SECONDS.sleep(1);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;try-with-resource-方式优化\&#34;&gt;&lt;code&gt;try-with-resource&lt;/code&gt; 方式优化&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;package top.imyzt.jdk.features.jdk9;\n\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\n\n/**\n * @author imyzt\n * @date 2023/12/16\n * @description 1. try 代码块简化, 2. 不可以再使用 &amp;quot;_&amp;quot;(下划线)命名变量\n */\npublic class TryWithResource {\n\n    public static void main(String[] args) throws FileNotFoundException {\n\n        // java 8\n        try (FileInputStream fis1 = new FileInputStream(&amp;quot;&amp;quot;);\n             FileOutputStream fos1 = new FileOutputStream(&amp;quot;&amp;quot;)) {\n            fis1.read();\n        } catch (Exception e) {\n\n        }\n\n        // java 9\n        // 可以将变量写到 try 代码块中, 让代码块更简洁\n        FileInputStream fis2 = new FileInputStream(&amp;quot;&amp;quot;);\n        FileOutputStream fos2 = new FileOutputStream(&amp;quot;&amp;quot;);\n        try (fis2; fos2) {\n\n        } catch (Exception e) {\n\n        }\n\n\n        // java 9 运行报错 As of Java 9, &#39;_&#39; is a keyword, and may not be used as an identifier\n        // String _ = &amp;quot;123&amp;quot;;\n\n    }\n\n    /**\n     * `@Deprecated` 注解支持指定废弃版本(since), 以及标记未来是否废弃(forRemoval)\n     */\n    @Deprecated(since = &amp;quot;9&amp;quot;, forRemoval = true)\n    private void test() {\n\n    }\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;deprecated-注解升级\&#34;&gt;&lt;code&gt;@Deprecated&lt;/code&gt; 注解升级&lt;/h1&gt;\n&lt;p&gt;例如&lt;code&gt;java.lang.Object#finalize&lt;/code&gt;方法就在 Java9 中被标记废弃，并且在未来可能会被删除。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Deprecated(since=&amp;quot;9&amp;quot;, forRemoval=true)\nprotected void finalize() throws Throwable { }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;string字符串的变化\&#34;&gt;String字符串的变化&lt;/h1&gt;\n&lt;p&gt;在 Java9 之前的版本中，&lt;code&gt;String&lt;/code&gt;内部使用&lt;code&gt;char&lt;/code&gt;数组存储，对于使用英语的人来说，一个字符用一个&lt;code&gt;byte&lt;/code&gt;就能存储，使用&lt;code&gt;char&lt;/code&gt;存储字符会&lt;strong&gt;浪费一半的内存空间&lt;/strong&gt;，因此在 Java9 中将String内部的&lt;code&gt;char&lt;/code&gt;数组改成了&lt;code&gt;byte&lt;/code&gt;数组，这样就节省了一半的内存占用。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;char c = &#39;a&#39;; // 2个字节\nbyte b = 97; // 1个字节\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;String中增加了2个成员变量&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;static final boolean COMPACT_STRINGS;&lt;/code&gt;：判断是否压缩，默认为true，如果=false，则不压缩，使用UTF-16编码。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;private final byte coder;&lt;/code&gt;：用来区分使用的字符编码\n&lt;ul&gt;\n&lt;li&gt;LATIN1，值为0，存储英文&lt;/li&gt;\n&lt;li&gt;UTF-16，值为1，存储中文，或夹杂中文的英文（为了区分字符边界，如果英文使用&lt;code&gt;1byte&lt;/code&gt;，则不利于字符串的&lt;code&gt;sub&lt;/code&gt;等操作，也无法计算长度）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Native static final byte LATIN1 = 0;\n@Native static final byte UTF16  = 1;\n\npublic int length() {\n    // 如果开启压缩，`coder()=0`，不进行位移，返回value数组长度\n    // 如果开启压缩，`coder()=1`，右移1=除以2，因为中文存储1个字符占用2个byte的空间\n    return value.length &amp;gt;&amp;gt; coder();\n}\nbyte coder() {\n    // 如果开启压缩，则`coder=LATIN1=0`，否则`coder=UTF16=1`\n    return COMPACT_STRINGS ? coder : UTF16;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;byte&lt;/code&gt;数组如何存储中文？通过源码 &lt;code&gt;java.lang.StringUTF16#toBytes(char[], int, int)&lt;/code&gt; 可以看到，1个中文会被存储到&lt;code&gt;byte&lt;/code&gt;数组中的两个元素上 ，即存储一个中文，&lt;code&gt;byte&lt;/code&gt;数组长度为2，存储2个中文，&lt;code&gt;byte&lt;/code&gt;数组长度为4.&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1702720593239.png\&#34; alt=\&#34;string_\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;code&gt;StringUTF16&lt;/code&gt; 部分源码截取，高八位和低八位分别存储，占用2个&lt;code&gt;byte&lt;/code&gt;数组的空间：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;static final int HI_BYTE_SHIFT;\nstatic final int LO_BYTE_SHIFT;\nstatic {\n    // CPU架构大小端\n    if (isBigEndian()) {\n        HI_BYTE_SHIFT = 8;\n        LO_BYTE_SHIFT = 0;\n    } else {\n        HI_BYTE_SHIFT = 0;\n        LO_BYTE_SHIFT = 8;\n    }\n}\n@IntrinsicCandidate\n// intrinsic performs no bounds checks\nstatic void putChar(byte[] val, int index, int c) {\n    assert index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; length(val) : &amp;quot;Trusted caller missed bounds check&amp;quot;;\n    index &amp;lt;&amp;lt;= 1;\n    val[index++] = (byte)(c &amp;gt;&amp;gt; HI_BYTE_SHIFT);\n    val[index]   = (byte)(c &amp;gt;&amp;gt; LO_BYTE_SHIFT);\n}\n\n@IntrinsicCandidate\n// intrinsic performs no bounds checks\nstatic char getChar(byte[] val, int index) {\n    assert index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; length(val) : &amp;quot;Trusted caller missed bounds check&amp;quot;;\n    index &amp;lt;&amp;lt;= 1;\n    return (char)(((val[index++] &amp;amp; 0xff) &amp;lt;&amp;lt; HI_BYTE_SHIFT) |\n                    ((val[index]   &amp;amp; 0xff) &amp;lt;&amp;lt; LO_BYTE_SHIFT));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;模块化\&#34;&gt;模块化&lt;/h1&gt;\n&lt;p&gt;Java8 和之前的版本中，主要源代码是放在 &lt;code&gt;rt.jar&lt;/code&gt; 中的，但是其中很多包是我们平时不会用到的，比如 &lt;code&gt;java.awt&lt;/code&gt; 如果全载入到内存中，会造成一定的浪费。&lt;br&gt;\n所以在 Java9 开始，将 &lt;code&gt;rt.jar&lt;/code&gt; 分成了不同的模块，一个模块下可以包含多个包，模块之间存在依赖关系。其中 &lt;code&gt;java.base&lt;/code&gt; 为基础模块（包含&lt;code&gt;java.lang&lt;/code&gt;,&lt;code&gt;java.util&lt;/code&gt;..），不依赖其他模块。&lt;br&gt;\n模块与包类似，只不过一个模块下可以包含多个包。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.oracle.com/javase/8/docs/api/\&#34;&gt;Java8文档&lt;/a&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1702722874295.png\&#34; alt=\&#34;Java8文档\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;a href=\&#34;https://docs.oracle.com/javase/9/docs/api/overview-summary.html\&#34;&gt;Java9文档&lt;/a&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1702722819500.png\&#34; alt=\&#34;Java9文档\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;.jar&lt;/code&gt;包中含有&lt;code&gt;.class&lt;/code&gt;文件，配置文件。&lt;br&gt;\n&lt;code&gt;.jmod&lt;/code&gt;除了上述文件外，还包含&lt;code&gt;navite library&lt;/code&gt;，&lt;code&gt;legal licenses&lt;/code&gt;等。&lt;br&gt;\n两者主要区别是&lt;code&gt;.jmod&lt;/code&gt;主要用在编译器和链接期，并非运行期，对于开发者来说，运行期任然需要使用jar包。&lt;/p&gt;\n&lt;h2 id=\&#34;模块化的优点\&#34;&gt;模块化的优点&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;精简JVM运行所需加载的class类，提升加载速度。&lt;/li&gt;\n&lt;li&gt;对包更精细的控制，提高安全。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;关键字\&#34;&gt;关键字&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;exports： 声明导出包，正常可使用，反射可以使用。&lt;/li&gt;\n&lt;li&gt;opens：声明导出包，只有反射可以使用，正常编写代码编译无法通过，报错 &lt;code&gt;Package &#39;package_name&#39; is declared in module &#39;develop&#39;, which does not export it to module &#39;test&#39;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;requires：声明依赖包。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;示例工程\&#34;&gt;示例工程&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;创建项目&lt;/li&gt;\n&lt;li&gt;创建模块 &lt;code&gt;develop&lt;/code&gt; 、 &lt;code&gt;test&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;在模块 &lt;code&gt;develop&lt;/code&gt; 下创建 &lt;code&gt;Cat.java&lt;/code&gt;, &lt;code&gt;Apple.java&lt;/code&gt;，创建 &lt;code&gt;module-info.java&lt;/code&gt;，声明 &lt;code&gt;export develop&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;package top.imyzt.learing.jdkfuture.dev1;\n\n\n/**\n * @author imyzt\n * @date 2023/12/16\n * @description Cat\n */\npublic class Cat {\n\n    public void eat() {\n        System.out.println(&amp;quot;吃鱼&amp;quot;);\n    }\n}\n\npackage top.imyzt.learing.jdkfuture.dev2;\n\n\n/**\n * @author imyzt\n * @date 2023/12/16\n * @description Apple\n */\npublic class Apple {\n    public Apple() {\n        System.out.println(&amp;quot;Apple Constructor&amp;quot;);\n    }\n}\n\nmodule develop {\n    // 导出包\n    exports top.imyzt.learing.jdkfuture.dev1;\n    // 导出包, 只能通过反射访问\n    opens top.imyzt.learing.jdkfuture.dev2;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;4\&#34;&gt;\n&lt;li&gt;在模块 &lt;code&gt;test&lt;/code&gt; 下创建 &lt;code&gt;Test.java&lt;/code&gt;，创建 &lt;code&gt;module-info.java&lt;/code&gt;，声明 &lt;code&gt;requie develop&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;package main.top.imyzt.learing.jdkfuture.test;\n\n\nimport top.imyzt.learing.jdkfuture.dev1.Cat;\n// Package &#39;top.imyzt.learing.jdkfuture.dev2&#39; is declared in module &#39;develop&#39;, which does not export it to module &#39;test&#39;\n// import top.imyzt.learing.jdkfuture.dev2.Apple;\n\n/**\n * @author imyzt\n * @date 2023/12/16\n * @description 描述信息\n */\npublic class Test {\n\n    public static void main(String[] args) throws Exception {\n        Cat cat = new Cat();\n        cat.eat();\n\n        Class&amp;lt;?&amp;gt; clazz = Class.forName(&amp;quot;top.imyzt.learing.jdkfuture.dev2.Apple&amp;quot;);\n        clazz.getDeclaredConstructor().newInstance();\n    }\n}\n\nmodule test {\n    requires develop;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;项目结构图\&#34;&gt;项目结构图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1702724406658.png\&#34; alt=\&#34;项目结构图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;源代码\&#34;&gt;源代码&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/framework-in-java/jdk-new-features/jdk9_module\&#34;&gt;示例项目&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;jshell\&#34;&gt;jshell&lt;/h1&gt;\n&lt;p&gt;作用不大，主要对于初学者可以学习语法。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;➜  jshell\n|  欢迎使用 JShell -- 版本 21.0.1\n|  要大致了解该版本, 请键入: /help intro\n\njshell&amp;gt; System.out.println(&amp;quot;hello world&amp;quot;);\nhello world\n\njshell&amp;gt; int a = 1;\na ==&amp;gt; 1\n\njshell&amp;gt; int b = 2;\nb ==&amp;gt; 2\n\njshell&amp;gt; System.out.println(a+b);\n3\n\njshell&amp;gt; /exit\n|  再见\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-9-xin-te-xing&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 9 新特性&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;}],&#34;date&#34;:&#34;2023-12-16 09:46:09&#34;,&#34;dateFormat&#34;:&#34;2023-12-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-9-xin-te-xing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:430000,&#34;words&#34;:1555,&#34;minutes&#34;:8},&#34;description&#34;:&#34;主要特性\n\n接口中支持定义 private 方法\ntry-with-resource 方式优化\n不可以使用 “_”下划线命名变量\n@Deprecated 注解支持指定废弃版本(since), 以及标记未来版本是否删除(forRemoval)...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7\&#34;&gt;主要特性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89private%E6%96%B9%E6%B3%95\&#34;&gt;接口定义&lt;code&gt;private&lt;/code&gt;方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#try-with-resource-%E6%96%B9%E5%BC%8F%E4%BC%98%E5%8C%96\&#34;&gt;&lt;code&gt;try-with-resource&lt;/code&gt; 方式优化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#deprecated-%E6%B3%A8%E8%A7%A3%E5%8D%87%E7%BA%A7\&#34;&gt;&lt;code&gt;@Deprecated&lt;/code&gt; 注解升级&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%98%E5%8C%96\&#34;&gt;String字符串的变化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A8%A1%E5%9D%97%E5%8C%96\&#34;&gt;模块化&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E4%BC%98%E7%82%B9\&#34;&gt;模块化的优点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E9%94%AE%E5%AD%97\&#34;&gt;关键字&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E4%BE%8B%E5%B7%A5%E7%A8%8B\&#34;&gt;示例工程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%9B%BE\&#34;&gt;项目结构图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%BA%90%E4%BB%A3%E7%A0%81\&#34;&gt;源代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jshell\&#34;&gt;jshell&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;读扩散、写扩散，主要应用在feed流场景中，什么是feed流？&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;微博&lt;/li&gt;\n&lt;li&gt;微信朋友圈&lt;br&gt;\n等都是典型的信息流业务，存在好友关系，如关注和粉丝，自己的主页由别人发布的内容组成。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;feed流业务最大的特点是&lt;strong&gt;自己的主页由别人的feed组成&lt;/strong&gt;，获得主页本质上就是在组装别人的内容。&lt;br&gt;\n从技术上主要有两种方式：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;拉取（读扩散）&lt;/li&gt;\n&lt;li&gt;推送（写扩散）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;拉模式读扩散\&#34;&gt;拉模式（读扩散）&lt;/h1&gt;\n&lt;p&gt;假设存在A关注BC，那么存储A关注B、A关注C；C的粉丝有A、B的粉丝有A，这么一组关系。&lt;br&gt;\n&lt;strong&gt;发布流程&lt;/strong&gt;：当B/C发布内容时，只需将自己的内容存储在自己的队列（feed记录）中。&lt;br&gt;\n&lt;strong&gt;查询个人主页流程&lt;/strong&gt;：当A查看自己的主页时：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;拉取A的关注列表：存在B、C&lt;/li&gt;\n&lt;li&gt;获取所关注列表中B、C的feed记录，判断是否有可见性设置&lt;/li&gt;\n&lt;li&gt;对消息进行 &lt;code&gt;order by time desc&lt;/code&gt;，分页取数据&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;缺点\&#34;&gt;缺点&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;拉取信息流时，业务非常复杂&lt;/li&gt;\n&lt;li&gt;多次访问时，每次都需要进行大量计算&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;优点\&#34;&gt;优点&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;存储结构简单，数据存储量较小，只存储一份不会冗余。&lt;/li&gt;\n&lt;li&gt;关注、取关、发布feed的流程都很简单&lt;/li&gt;\n&lt;li&gt;适合早期业务量不大的时候，可以快速实现&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;推模式写扩散\&#34;&gt;推模式（写扩散）&lt;/h1&gt;\n&lt;p&gt;这是&lt;strong&gt;蓝色&lt;/strong&gt;的文字&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;继续上面的假设，关注关系依旧不变，但与读扩散不同的是，每个用户还需要&lt;span style=\&#34;color:red\&#34;&gt;存储自己&lt;strong&gt;收到&lt;/strong&gt;的feed流&lt;/span&gt;&lt;br&gt;\n&lt;strong&gt;发布流程&lt;/strong&gt;：当B/C发布内容时，需要查询自己的粉丝列表，然后分别在粉丝A的feed中，写入B、C发布的feed信息。&lt;br&gt;\n&lt;strong&gt;查询个人主页的流程&lt;/strong&gt;：当A查看自己的主页时：&lt;strong&gt;直接拉取自己的feed记录即可&lt;/strong&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;缺点-2\&#34;&gt;缺点&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;实现关注取关时，关注时，需要将信息从写入到粉丝的feed记录中，移除时，同样需要将内容从feed记录中删除。&lt;/li&gt;\n&lt;li&gt;极大的存储资源消耗，需要存储多份feed信息。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;优点-2\&#34;&gt;优点&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;拉取信息时非常简单，只需直接查询feed记录。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;拉模式，读扩散，feed存一份，存储小，用户集中访问数据，性能差;&lt;/li&gt;\n&lt;li&gt;推模式，写扩散，feed存多份，用冗余存储换锁冲突，性能高;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;参考\&#34;&gt;参考&lt;/h1&gt;\n&lt;p&gt;全文参考自：&lt;a href=\&#34;https://www.51cto.com/article/697949.html\&#34;&gt;58沈剑-读扩散，写扩散，终于讲清楚了！&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;du-kuo-san-xie-kuo-san&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;读扩散、写扩散&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;设计方案&#34;,&#34;slug&#34;:&#34;2D49EPSEM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/2D49EPSEM/&#34;}],&#34;date&#34;:&#34;2023-12-07 22:12:55&#34;,&#34;dateFormat&#34;:&#34;2023-12-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/du-kuo-san-xie-kuo-san/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:132000,&#34;words&#34;:628,&#34;minutes&#34;:3},&#34;description&#34;:&#34;读扩散、写扩散，主要应用在feed流场景中，什么是feed流？\n\n微博\n微信朋友圈\n等都是典型的信息流业务，存在好友关系，如关注和粉丝，自己的主页由别人发布的内容组成。\n\nfeed流业务最大的特点是自己的主页由别人的feed组成，获得主页本...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8B%89%E6%A8%A1%E5%BC%8F%E8%AF%BB%E6%89%A9%E6%95%A3\&#34;&gt;拉模式（读扩散）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E7%82%B9\&#34;&gt;缺点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E7%82%B9\&#34;&gt;优点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%86%99%E6%89%A9%E6%95%A3\&#34;&gt;推模式（写扩散）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E7%82%B9-2\&#34;&gt;缺点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E7%82%B9-2\&#34;&gt;优点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;当数据库面临分库分表时，无法依赖数据库自增主键来生成业务标识，或业务场景设计时为了防止自增id被外部撞库猜测数据，通常会考虑引入&lt;strong&gt;全局唯一标识生成器&lt;/strong&gt;来解决此类问题。&lt;/p&gt;\n&lt;h1 id=\&#34;介绍\&#34;&gt;介绍&lt;/h1&gt;\n&lt;p&gt;目前市面上比较常见的基本为&lt;code&gt;Twitter&lt;/code&gt;开源的&lt;code&gt;Snowflake&lt;/code&gt;及其变种，&lt;code&gt;Snowflake&lt;/code&gt;的核心思想是将&lt;code&gt;64bit&lt;/code&gt;的二进制数字分为若干部分，每一部分都存储具有特定含义的数据，比如时间戳、机器ID、序列号等，最终&lt;strong&gt;生成全局唯一有序ID&lt;/strong&gt;，标准算法如下图：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1701578944155.jpeg\&#34; alt=\&#34;snowflake\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;41位的时间戳部分可以支撑&lt;code&gt;pow(2,41)/1000/60/60/24/365&lt;/code&gt; 年，约等于 69 年。&lt;/li&gt;\n&lt;li&gt;如果系统部署在多机房，那么 10 位的机器 ID 可以继续划分为 &lt;code&gt;2～3&lt;/code&gt; 位的 &lt;strong&gt;IDC&lt;/strong&gt; 标示（可以支撑 4 个或者 8 个 IDC 机房）和 &lt;code&gt;7～8&lt;/code&gt; 位的 &lt;strong&gt;机器 ID&lt;/strong&gt;（支持 128-256 台机器）。&lt;/li&gt;\n&lt;li&gt;12 位的序列号代表着每个节点每毫秒最多可以生成 4096 的 ID。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;部署方式\&#34;&gt;部署方式&lt;/h1&gt;\n&lt;p&gt;雪花ID具有两种使用方式，一种是独立部署一套&lt;strong&gt;发号器&lt;/strong&gt;，外部请求下发，另一种更为常见的做法是直接嵌入到应用内，使用&lt;code&gt;Snowflake&lt;/code&gt;工具类直接获取使用，当嵌入到应用内部时，可以考虑将&lt;strong&gt;机器ID&lt;/strong&gt;部分，分散标识到不同业务系统。&lt;/p&gt;\n&lt;h1 id=\&#34;缺点\&#34;&gt;缺点&lt;/h1&gt;\n&lt;h2 id=\&#34;时间回拨问题\&#34;&gt;时间回拨问题&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;Snowflake&lt;/code&gt;算法设计很简单和巧妙，性能高效，具有&lt;strong&gt;全局唯一性、单调递增性和有业务含义的ID&lt;/strong&gt;，但是它也有一定缺点，其中&lt;strong&gt;最大的缺点就是他依赖于系统的时间戳&lt;/strong&gt;，一旦时间不准，就有可能生成重复的ID。如果是独立部署的发号器，如果发现系统时间不准，可以直接暂停发号，知道时间准确为止。&lt;/p&gt;\n&lt;h2 id=\&#34;qps低引起单调重复\&#34;&gt;QPS低引起单调重复&lt;/h2&gt;\n&lt;p&gt;如果发号器的QPS不高，例如每毫秒只能发一个ID，就会造成ID的末尾永远是1，&lt;strong&gt;如果在分库分表系统中使用ID作为分区间，就会造成库表分配的不均匀&lt;/strong&gt;。&lt;br&gt;\n如何解决：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;时间戳不记录毫秒而是记录秒，这样在一个时间区间内可以多发几个号，避免出现分库分表时数据分配不均。&lt;/li&gt;\n&lt;li&gt;生成的序列号的起始号可以做一下随机，这一秒是21，下一秒可以是30，这样也会保证均衡。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;参考\&#34;&gt;参考&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=\&#34;https://zq99299.github.io/note-architect/hc/02/04.html#%E5%9F%BA%E4%BA%8E-snowflake-%E7%AE%97%E6%B3%95%E6%90%AD%E5%BB%BA%E5%8F%91%E5%8F%B7%E5%99%A8\&#34;&gt;发号器：如何保证分库分表后 ID 的全局唯一性？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s?__biz=MzI4NDMyNTU2Mw==&amp;amp;mid=2247483679&amp;amp;idx=1&amp;amp;sn=584dbd80aa08fa1188627ad725680928&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1208L9z4yXKLW60rPph2ZmMn#rd\&#34;&gt;万亿级调用系统：微信序列号生成器架构设计及演变&lt;br&gt;\n&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;fen-bu-shi-wei-yi-biao-shi-she-ji&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;分布式唯一标识设计&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Snowflake&#34;,&#34;slug&#34;:&#34;MnVakDRvV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/MnVakDRvV/&#34;}],&#34;date&#34;:&#34;2023-12-03 12:41:55&#34;,&#34;dateFormat&#34;:&#34;2023-12-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/fen-bu-shi-wei-yi-biao-shi-she-ji/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:145000,&#34;words&#34;:691,&#34;minutes&#34;:3},&#34;description&#34;:&#34;当数据库面临分库分表时，无法依赖数据库自增主键来生成业务标识，或业务场景设计时为了防止自增id被外部撞库猜测数据，通常会考虑引入全局唯一标识生成器来解决此类问题。\n介绍\n目前市面上比较常见的基本为Twitter开源的Snowflake及其变...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8B%E7%BB%8D\&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F\&#34;&gt;部署方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E7%82%B9\&#34;&gt;缺点&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%97%B6%E9%97%B4%E5%9B%9E%E6%8B%A8%E9%97%AE%E9%A2%98\&#34;&gt;时间回拨问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#qps%E4%BD%8E%E5%BC%95%E8%B5%B7%E5%8D%95%E8%B0%83%E9%87%8D%E5%A4%8D\&#34;&gt;QPS低引起单调重复&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;平时在使用线程池时，更多关注到的是coreSize、maxSize、blockQueue、RejectedExecutionHandler这些参数，但在线程池监控领域，还需要关注到其他的一些方法。在此处做统一记录和备忘：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static void main(String[] args) {\n\n    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 5, 1, TimeUnit.MINUTES, new ArrayBlockingQueue&amp;lt;&amp;gt;(1024), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    // 启动所有核心线程(预热)\n    threadPoolExecutor.prestartAllCoreThreads();\n    // 启动一个核心线程\n    threadPoolExecutor.prestartCoreThread();\n\n    // 默认情况下构造器中的keepAliveTime指定的是非核心线程的空闲时间, 通过如下方法, 可以允许核心线程超时\n    threadPoolExecutor.allowCoreThreadTimeOut(true);\n\n    // ⭐️ 动态线程池必备方法\n    // 启动后, 设置核心线程数量\n    threadPoolExecutor.setCorePoolSize(3);\n    // 启动后, 设置最大线程数量\n    threadPoolExecutor.setMaximumPoolSize(10);\n    // 已执行完的任务总数\n    threadPoolExecutor.getTaskCount();\n    // 获取工作队列剩余数量\n    threadPoolExecutor.getQueue().remainingCapacity();\n    }\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;后记\&#34;&gt;后记&lt;/h1&gt;\n&lt;p&gt;通过上面的代码可知，在运行过程中我们也是可以操作&lt;code&gt;coreSize&lt;/code&gt;和&lt;code&gt;maxSize&lt;/code&gt;的。那么如何才能实现对Queue的大小进行控制呢？目前开源届常用的是采取&lt;code&gt;RabbitMQ&lt;/code&gt;中的&lt;a href=\&#34;https://github.com/rabbitmq/rabbitmq-java-client/blob/main/src/main/java/com/rabbitmq/client/impl/VariableLinkedBlockingQueue.java\&#34;&gt;&lt;code&gt;VariableLinkedBlockingQueue&lt;/code&gt;&lt;/a&gt;来实现。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;threadpoolexecutor-fei-chang-yong-fang-fa&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;ThreadPoolExecutor “非常用” 方法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;RabbitMQ&#34;,&#34;slug&#34;:&#34;CbzZOlvAr&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/CbzZOlvAr/&#34;},{&#34;name&#34;:&#34;线程池&#34;,&#34;slug&#34;:&#34;sob7n9Mdo&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/sob7n9Mdo/&#34;},{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;rsjM0rjtG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/rsjM0rjtG/&#34;}],&#34;date&#34;:&#34;2023-11-29 22:47:11&#34;,&#34;dateFormat&#34;:&#34;2023-11-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/threadpoolexecutor-fei-chang-yong-fang-fa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:62000,&#34;words&#34;:270,&#34;minutes&#34;:2},&#34;description&#34;:&#34;平时在使用线程池时，更多关注到的是coreSize、maxSize、blockQueue、RejectedExecutionHandler这些参数，但在线程池监控领域，还需要关注到其他的一些方法。在此处做统一记录和备忘：\npublic st...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E8%AE%B0\&#34;&gt;后记&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;现象\&#34;&gt;现象&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;rocketmq-common-4.9.3&lt;/code&gt; 版本作为客户端消费数据时，从&lt;code&gt;MessageExt.getMsgId()&lt;/code&gt;获取消息ID时，会存在一个潜在的依赖冲突问题，最终导致方法执行失败，如下图：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1701179903562.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;从现象来看，&lt;code&gt;Could not initialize class org.apache.rocketmq.common.message.MessageClientIDSetter&lt;/code&gt; 表示 &lt;code&gt;MessageClientIDSetter&lt;/code&gt;类为正确被加载，通过搜索类似的资料找到了以下文章：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=\&#34;https://github.com/apache/rocketmq/issues/6264\&#34;&gt;Client dependency conflict, cause NoClassDefFoundError. Require for shaded client&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://blog.51cto.com/u_15127641/2875028\&#34;&gt;记一次RocketMQ消息消费异常&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;从51cto的文章来看，基本可以分析出是&lt;code&gt;MessageClientIDSetter&lt;/code&gt;的静态代码块在执行时异常导致类加载器加载类失败。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;static {\n        byte[] ip;\n        try {\n            // 执行异常，导致`MessageClientIDSetter`未成功被类加载器加载\n            ip = UtilAll.getIP();\n        } catch (Exception e) {\n            ip = createFakeIP();\n        }\n        LEN = ip.length + 2 + 4 + 4 + 2;\n        ByteBuffer tempBuffer = ByteBuffer.allocate(ip.length + 2 + 4);\n        tempBuffer.put(ip);\n        tempBuffer.putShort((short) UtilAll.getPid());\n        tempBuffer.putInt(MessageClientIDSetter.class.getClassLoader().hashCode());\n        FIX_STRING = UtilAll.bytes2string(tempBuffer.array()).toCharArray();\n        setStartTime(System.currentTimeMillis());\n        COUNTER = new AtomicInteger(0);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;分析\&#34;&gt;分析&lt;/h2&gt;\n&lt;p&gt;从上面的博客中已经可以得到结论是依赖冲突造成的，但问题是部分服务会出现，大多数服务不会出现，&lt;strong&gt;通过往深层次分析得出结论&lt;/strong&gt;：&lt;br&gt;\n&lt;code&gt;rocketmq-acl&lt;/code&gt; &lt;code&gt;rocketmq-client&lt;/code&gt; 均依赖于 &lt;code&gt;commons-validator-1.7&lt;/code&gt; 版本，而项目中如果有类似于 &lt;code&gt;aliyun-log-appender&lt;/code&gt; 老版本的依赖，会传递依赖于旧版本的 &lt;code&gt; commons-validator&lt;/code&gt; ，如下图所示：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1701179052568.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;Maven在遇到依赖冲突时，首先会采用&lt;strong&gt;就近原则&lt;/strong&gt;，上图中第一个传递依赖有&lt;strong&gt;5&lt;/strong&gt;个层级，而下一个传递依赖只有&lt;strong&gt;4&lt;/strong&gt;个层级，所以就近取到了&lt;strong&gt;错误的1.4.0版本&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;其它的服务更多是单模块项目，直接依赖于RocketMQ的client代码，而出现问题的服务是一个多模块依赖关系的服务，最终依赖传递了3层，导致依赖链路变长，最终优先依赖了链路更近的由 &lt;code&gt;log-appender&lt;/code&gt; 引入进来的 &lt;code&gt;1.4.0&lt;/code&gt; 版本。&lt;/p&gt;\n&lt;p&gt;相关文章： &lt;a href=\&#34;https://returnac.cn/pages/JAVA/maven/Maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97.html#%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6\&#34;&gt;Maven依赖冲突避坑指北&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;rocketmq-client-qi-dong-yi-chang-jie-jue&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;RocketMQ Client 启动异常解决&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;问题解决&#34;,&#34;slug&#34;:&#34;KjxmDkyMU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/KjxmDkyMU/&#34;},{&#34;name&#34;:&#34;RocketMQ&#34;,&#34;slug&#34;:&#34;YdtQW2aVg&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/YdtQW2aVg/&#34;}],&#34;date&#34;:&#34;2023-11-28 20:39:57&#34;,&#34;dateFormat&#34;:&#34;2023-11-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/rocketmq-client-qi-dong-yi-chang-jie-jue/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:118000,&#34;words&#34;:492,&#34;minutes&#34;:2},&#34;description&#34;:&#34;现象\nrocketmq-common-4.9.3 版本作为客户端消费数据时，从MessageExt.getMsgId()获取消息ID时，会存在一个潜在的依赖冲突问题，最终导致方法执行失败，如下图：\n\n从现象来看，Could not init...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%8E%B0%E8%B1%A1\&#34;&gt;现象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E6%9E%90\&#34;&gt;分析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;什么是hash冲突\&#34;&gt;什么是hash冲突？&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;hash冲突就是在操作哈希表（散列表）的时候，不同的key值经过hash函数（散列算法）之后得到相同的hash值，那么&lt;strong&gt;一个位置没法放置两份value&lt;/strong&gt;，这种情况就是hash冲突。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;hash冲突常用解决方法\&#34;&gt;Hash冲突常用解决方法&lt;/h1&gt;\n&lt;h2 id=\&#34;开放地址法open-addressing\&#34;&gt;开放地址法（open addressing）&lt;/h2&gt;\n&lt;p&gt;简单来说就是通过计算出来冲突的hash值进行再次的运算，直到得到可用的地址，主要有以下3种：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;线性探测再散列：发生冲突时，顺序查看哈希表下一单元是否可用，直到找到可用的单元&lt;/li&gt;\n&lt;li&gt;二次探测再散列：发生冲突时，以冲突的位置为中心向左右探测是否有可用单元&lt;/li&gt;\n&lt;li&gt;伪随机探测再散列：通过一组伪随机数列计算得到对应的单位位置&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;单独链表法\&#34;&gt;单独链表法&lt;/h2&gt;\n&lt;p&gt;就是在哈希表中，针对相同的hash值使用链表的方式来存放&lt;/p&gt;\n&lt;h2 id=\&#34;再hash\&#34;&gt;再Hash&lt;/h2&gt;\n&lt;p&gt;提供多个hash函数，冲突时使用其他的hash函数再次运算&lt;/p&gt;\n&lt;h2 id=\&#34;建立公共溢出区\&#34;&gt;建立公共溢出区&lt;/h2&gt;\n&lt;p&gt;建立一个溢出表，hash冲突的时候放入溢出表&lt;/p&gt;\n&lt;h1 id=\&#34;java中hashmap如何解决冲突\&#34;&gt;Java中HashMap如何解决冲突&lt;/h1&gt;\n&lt;p&gt;其实，Java中的HashMap采用的hash冲突解决方案就是单独链表法，也就是在hash表节点使用链表存储hash值相同的值&lt;/p&gt;\n&lt;p&gt;不过需要知道的是JDK8之后，如果链表长度超过8将会将链表转化为红黑树以便提高在hash冲突严重情况下的查询效率，也能够避免一定的hash碰撞攻击。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;hash-chong-tu-jie-jue-fang-fa&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Hash冲突解决方法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;rsjM0rjtG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/rsjM0rjtG/&#34;}],&#34;date&#34;:&#34;2023-11-27 23:39:27&#34;,&#34;dateFormat&#34;:&#34;2023-11-27&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/hash-chong-tu-jie-jue-fang-fa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:85000,&#34;words&#34;:407,&#34;minutes&#34;:2},&#34;description&#34;:&#34;什么是hash冲突？\n\nhash冲突就是在操作哈希表（散列表）的时候，不同的key值经过hash函数（散列算法）之后得到相同的hash值，那么一个位置没法放置两份value，这种情况就是hash冲突。\n\nHash冲突常用解决方法\n开放地址法...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFhash%E5%86%B2%E7%AA%81\&#34;&gt;什么是hash冲突？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#hash%E5%86%B2%E7%AA%81%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\&#34;&gt;Hash冲突常用解决方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95open-addressing\&#34;&gt;开放地址法（open addressing）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%95%E7%8B%AC%E9%93%BE%E8%A1%A8%E6%B3%95\&#34;&gt;单独链表法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%8Dhash\&#34;&gt;再Hash&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA\&#34;&gt;建立公共溢出区&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java%E4%B8%ADhashmap%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81\&#34;&gt;Java中HashMap如何解决冲突&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;Chrome flag&lt;br&gt;\n&lt;code&gt;chrome://flags/&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;搜索&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;Omnibox Zero Prefix Suggestion Prefetching on NTP\nEnables prefetching of the zero prefix suggestions for eligible users on the New Tab page. – Mac, Windows, Linux, ChromeOS, Android, Fuchsia, Lacros\n#omnibox-zero-suggest-prefetching\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1701010760712.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;DISABLE&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;chrome-guan-bi-di-zhi-lan-sou-suo-li-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Chrome关闭地址栏搜索历史&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2023-11-26 22:57:04&#34;,&#34;dateFormat&#34;:&#34;2023-11-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/chrome-guan-bi-di-zhi-lan-sou-suo-li-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:14000,&#34;words&#34;:40,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n\nChrome flag\nchrome://flags/\n\n\n搜索\n\n\nOmnibox Zero Prefix Suggestion Prefetching on NTP\nEnables prefetching of the zero p...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;设计模式的基本原则：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;开闭原则&lt;/li&gt;\n&lt;li&gt;单一职责原则&lt;/li&gt;\n&lt;li&gt;里氏替换原则&lt;/li&gt;\n&lt;li&gt;依赖倒置原则&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Spring中用到的模式：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;HandlerAdapter，适配器模式&lt;/li&gt;\n&lt;li&gt;BeanFactory，简单工厂模式&lt;/li&gt;\n&lt;li&gt;FactoryBean，工厂方法模式&lt;/li&gt;\n&lt;li&gt;Controller的单例模式，也可以是原型模式&lt;/li&gt;\n&lt;li&gt;Service@Transactional，代理模式&lt;/li&gt;\n&lt;li&gt;@EventListener，观察者模式&lt;/li&gt;\n&lt;li&gt;JdbcTemplate，RestTemplate，模板方法模式&lt;/li&gt;\n&lt;li&gt;TransactionAwareCacheDecorator，装饰器模式&lt;/li&gt;\n&lt;li&gt;AopProxy，策略模式&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;其他在业务中常用的模式：&lt;/p&gt;\n&lt;h3 id=\&#34;业务中涉及的模式\&#34;&gt;业务中涉及的模式：&lt;/h3&gt;\n&lt;p&gt;策略模式：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;不同数据的不同处理结果&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;观察者模式：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;事件监听和分发（不同处理类型）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;门面模式：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;不同活动的不同参数，统一门面，采用Jackson的类型映射子类&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;状态模式：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;支付的不同状态，通过事件和状态流转&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-zhong-shi-yong-dao-de-she-ji-mo-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring中使用到的设计模式&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;设计模式&#34;,&#34;slug&#34;:&#34;hheaoxZjL&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/hheaoxZjL/&#34;},{&#34;name&#34;:&#34;Spring&#34;,&#34;slug&#34;:&#34;r_PTn6Nd-&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/r_PTn6Nd-/&#34;}],&#34;date&#34;:&#34;2023-11-21 22:11:49&#34;,&#34;dateFormat&#34;:&#34;2023-11-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-zhong-shi-yong-dao-de-she-ji-mo-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:42000,&#34;words&#34;:202,&#34;minutes&#34;:1},&#34;description&#34;:&#34;设计模式的基本原则：\n\n开闭原则\n单一职责原则\n里氏替换原则\n依赖倒置原则\n\nSpring中用到的模式：\n\nHandlerAdapter，适配器模式\nBeanFactory，简单工厂模式\nFactoryBean，工厂方法模式\nControl...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%9A%E5%8A%A1%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E6%A8%A1%E5%BC%8F\&#34;&gt;业务中涉及的模式：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;讲完了消息的生产过程，接下来记录一下消息发送到&lt;code&gt;Broker&lt;/code&gt;后如何存储和分发。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;首先看下RocketMQ Broker的消息存储目录结构，RocketMQ的消息存储在本地文件系统中，默认在当前用户主目录下的&lt;code&gt;store&lt;/code&gt;目录中：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1700059028911.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;abort：该文件在Broker启动后自动创建，正常关闭自动消息，如果没有启动Broker的情况下看到此文件表示上次Broker是非正常关闭的&lt;/li&gt;\n&lt;li&gt;checkpoint：存储着&lt;code&gt;commitlog&lt;/code&gt;,&lt;code&gt;consumequeue&lt;/code&gt;,&lt;code&gt;index&lt;/code&gt;文件的最后刷盘时间&lt;/li&gt;\n&lt;li&gt;commitlog：存放&lt;code&gt;commitlog&lt;/code&gt;文件，消息就是存储在其中&lt;/li&gt;\n&lt;li&gt;consumerqueue：存放&lt;code&gt;consumequeue&lt;/code&gt;文件，队列就是存放在其中&lt;/li&gt;\n&lt;li&gt;index：存放消息索引文件，支持根据&lt;code&gt;key&lt;/code&gt;查询的依据&lt;/li&gt;\n&lt;li&gt;lock：运行期间使用到的全局资源锁&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;消息存储\&#34;&gt;消息存储&lt;/h1&gt;\n&lt;h2 id=\&#34;如何保证高性能读写\&#34;&gt;如何保证高性能读写&lt;/h2&gt;\n&lt;p&gt;传统的IO读写方式，存在多次上下文切换和多次数据的拷贝，在并发极高的MQ场景下，会严重影响读写效率。所以为了减少内核态&amp;lt;=&amp;gt;用户态切换，减少数据拷贝次数，引入了&lt;strong&gt;零拷贝&lt;/strong&gt;技术。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1699977065073.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;零拷贝\&#34;&gt;零拷贝&lt;/h2&gt;\n&lt;p&gt;零拷贝是一种思想，指的是CPU不需要先将数据从某处内存复制到另一个特定区域，实现零拷贝的方式有以下几种方式：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;mmap()&lt;/li&gt;\n&lt;li&gt;sendfile()&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;mmap\&#34;&gt;mmap()&lt;/h3&gt;\n&lt;p&gt;mmap(memory map) 是一种内存映射方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。&lt;br&gt;\n对应上图中&lt;code&gt;内核缓冲区-&amp;gt;用户缓冲区-&amp;gt;Socket缓冲区&lt;/code&gt;的过程直接变成了&lt;code&gt;内核缓冲区-(CPU拷贝)-&amp;gt;Socket缓冲区&lt;/code&gt;，减少了一次拷贝所需的时间。&lt;br&gt;\n但整个过程中，上下文切换依旧是&lt;strong&gt;4次&lt;/strong&gt;，相比于传统IO没有提升，切换过程：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;当用户发起mmap调用的时候会发生上下文切换1，进行内存映射；&lt;/li&gt;\n&lt;li&gt;然后数据被拷贝到内核缓冲区，mmap返回，发生上下文切换2；&lt;/li&gt;\n&lt;li&gt;随后用户调用write，发生上下文切换3；&lt;/li&gt;\n&lt;li&gt;将内核缓冲区的数据拷贝到Socket缓冲区，write返回，发生上下文切换4。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1700059059450.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;FileChannel fileChannel = \nnew RandomAccessFile(&amp;quot;mmap_test.txt&amp;quot;, &amp;quot;rw&amp;quot;).getChannel(); \nMappedByteBuffer mappedByteBuffer = \nfileChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileChannel.size());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;sendfile\&#34;&gt;sendfile()&lt;/h3&gt;\n&lt;p&gt;sendfile()和mmap()一样可以减少一次CPU拷贝，但它可以减少2次上下文切换，切换过程：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;用户发起sendfile()调用时会发生切换1，之后数据通过DMA拷贝到内核缓冲区&lt;/li&gt;\n&lt;li&gt;之后再将内核缓冲区的数据CPU拷贝到Socket缓冲区，最后拷贝到网卡，sendfile()返回，发生切换2。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1700059065166.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;//调用transferTo方法向目标数据传输 \nFileChannel channel = FileChannel.open(Paths.get(&amp;quot;./test.txt&amp;quot;),\n StandardOpenOption.WRITE, StandardOpenOption.CREATE); \n\nchannel.transferTo(position, len, target);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;commitlogmappedfile\&#34;&gt;commitlog（mappedFile）&lt;/h1&gt;\n&lt;h2 id=\&#34;目录与文件\&#34;&gt;目录与文件&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;真正存储消息，&lt;strong&gt;一个Broker只有一个&lt;code&gt;commitlog&lt;/code&gt;目录，所有Topic的消息都存放于此。&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;mappedFile大小1G，文件名由20位十进制数组成，&lt;strong&gt;表示当前文件的第一条消息的起始位置偏移量。&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;第一个文件名一定是20位0构成，第一条消息的偏移量commitlog offset为0.&lt;/li&gt;\n&lt;li&gt;当第一个文件放满时，会自动生成第二个文件继续存放消息，假设第一个&lt;code&gt;1073741820&lt;/code&gt;字节（1G=1073741824字节），最后只剩4字节不够存放下一条数据。则下一个文件名为&lt;code&gt;00000000001073741824&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;消息单元\&#34;&gt;消息单元&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1700059080546.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;consumequeue\&#34;&gt;consumequeue&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;存储topic消息在commitlog的位置索引。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;为了提高效率，会为每个topic在&lt;code&gt;~/store/consumequeue&lt;/code&gt;中创建一个目录&lt;code&gt;{TopicId}/{QueueId}&lt;/code&gt;，&lt;code&gt;consumequeue&lt;/code&gt;文件是&lt;code&gt;commitlog&lt;/code&gt;的索引文件，可以根据&lt;code&gt;consumequeue&lt;/code&gt;定位到具体的消息在&lt;code&gt;commitlog&lt;/code&gt;中的位置。&lt;/p&gt;\n&lt;p&gt;consumequeue文件名也是由20位数字组成，&lt;strong&gt;表示当前文件的第一个索引条目的起始位置偏移量&lt;/strong&gt;，与mappedFile文件不同的是，其后续的文件名也是固定的，因为consumequeue文件大小是固定不变的。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;每个consumequeue文件可以包含30w&lt;/code&gt;个索引条目，其中包含：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;消息在mappedFile文件中的偏移量&lt;code&gt;commitlog offset&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;消息长度&lt;/li&gt;\n&lt;li&gt;消息Tag的hashcode值&lt;br&gt;\n这三个属性占用20个字节，所以每个文件的大小是固定的30w * 20字节&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1700059143933.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1700059149125.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;对文件的读写\&#34;&gt;对文件的读写&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1700059156240.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;消息写入\&#34;&gt;消息写入&lt;/h2&gt;\n&lt;p&gt;一条消息进入到Broker后经历了以下几个过程才最终被持久化：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即QueueOffset&lt;/li&gt;\n&lt;li&gt;将queueId、queueOffset等数据，与消息一起封装为消息单元&lt;/li&gt;\n&lt;li&gt;将消息单元写入到commitlog&lt;/li&gt;\n&lt;li&gt;形成消息索引条目&lt;/li&gt;\n&lt;li&gt;将消息索引条目分发到相应的consumequeue&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;消息拉取\&#34;&gt;消息拉取&lt;/h2&gt;\n&lt;p&gt;当Consumer来拉取消息时会经历以下几个步骤：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Consumer获取到其要消费消息所在Queue的&lt;code&gt;消费偏移量offset&lt;/code&gt;，计算出其要消费消息的&lt;code&gt;消费offset&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;消费offset即消费进度，consumer对某个queue的消费offset，即消费到了该queue的第几条消息&lt;br&gt;\n消息offset = 消费offset + 1&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;Consumer向Broker发送拉取请求，其中会包含其要拉取消息的Queue、消息offset及消息Tag&lt;/li&gt;\n&lt;li&gt;Broker计算在该consumequeue中的queueOffset&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;queueOffset = 消息offset * 20字节&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;从该queueOffset处开始向后查找第一个指定Tag的索引条目&lt;/li&gt;\n&lt;li&gt;解析该索引条目的&lt;code&gt;前8个字节&lt;/code&gt;，即可定位到该消息在commitlog中的commitlog offset&lt;/li&gt;\n&lt;li&gt;从对应commitlog offset中读取消息单元，并发送给Consumer&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;刷盘机制\&#34;&gt;刷盘机制&lt;/h1&gt;\n&lt;p&gt;RocketMQ消息写入到Commitlog文件中时并不是直接写入到文件，而是先写到PageCache中，也就是前面IO图中的内核缓冲区，所以RocketMQ也和MySQL等类似的log刷盘机制&lt;/p&gt;\n&lt;h2 id=\&#34;异步刷盘\&#34;&gt;异步刷盘&lt;/h2&gt;\n&lt;p&gt;写入到PageCache后直接返回生产者消息存储成功，另外的后台线程在将消息刷到磁盘。其提供了2套刷盘机制：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;固定时间，默认每隔0.5s会刷一次【默认方式】&lt;/li&gt;\n&lt;li&gt;每存一次会通知刷盘，但不会等待结果，同时如果0.5s没有收到通知，也会主动刷盘。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;同步刷盘\&#34;&gt;同步刷盘&lt;/h2&gt;\n&lt;p&gt;同步刷盘机制很好理解，即每次一定等写入成功磁盘才会返回生产者写入成功，此方式可靠性更高，但会一定程度上影响系统吞吐量。&lt;/p&gt;\n&lt;h1 id=\&#34;后记\&#34;&gt;后记&lt;/h1&gt;\n&lt;p&gt;本文参考：&lt;br&gt;\n&lt;a href=\&#34;https://juejin.cn/post/7186880907582636069\&#34;&gt;https://juejin.cn/post/7186880907582636069&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;rocketmq-xiao-xi-cun-chu-guo-cheng&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;RocketMQ消息存储过程&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;RocketMQ&#34;,&#34;slug&#34;:&#34;YdtQW2aVg&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/YdtQW2aVg/&#34;}],&#34;date&#34;:&#34;2023-11-15 22:21:17&#34;,&#34;dateFormat&#34;:&#34;2023-11-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/rocketmq-xiao-xi-cun-chu-guo-cheng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:355000,&#34;words&#34;:1623,&#34;minutes&#34;:6},&#34;description&#34;:&#34;\n讲完了消息的生产过程，接下来记录一下消息发送到Broker后如何存储和分发。\n\n前言\n首先看下RocketMQ Broker的消息存储目录结构，RocketMQ的消息存储在本地文件系统中，默认在当前用户主目录下的store目录中：\n\n\na...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8\&#34;&gt;消息存储&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E6%80%A7%E8%83%BD%E8%AF%BB%E5%86%99\&#34;&gt;如何保证高性能读写&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9B%B6%E6%8B%B7%E8%B4%9D\&#34;&gt;零拷贝&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#mmap\&#34;&gt;mmap()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sendfile\&#34;&gt;sendfile()&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#commitlogmappedfile\&#34;&gt;commitlog（mappedFile）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6\&#34;&gt;目录与文件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E6%81%AF%E5%8D%95%E5%85%83\&#34;&gt;消息单元&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#consumequeue\&#34;&gt;consumequeue&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99\&#34;&gt;对文件的读写&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5\&#34;&gt;消息写入&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96\&#34;&gt;消息拉取&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6\&#34;&gt;刷盘机制&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98\&#34;&gt;异步刷盘&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98\&#34;&gt;同步刷盘&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E8%AE%B0\&#34;&gt;后记&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;时间轮的使用场景自不必多说，最近研究RocketMQ 5.0时，想简单写一个活跃下思路，遂写了下面的方案（没有参照任何代码，没有优化），主要做下记录。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;package top.imyzt.learning.algorithm.timer;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.SneakyThrows;\n\nimport java.time.LocalDateTime;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * 简易单机时间轮\n * @author imyzt\n * @date 2023-11-13 22:03\n */\npublic class SingleTimingWheel {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        TimingWheel timingWheel = new TimingWheel(60);\n        TimingWheel timingWheel2 = new TimingWheel(12);\n\n        while (true) {\n            System.out.print(&amp;quot;请输入延时周期: &amp;quot;);\n            Scanner scanner = new Scanner(System.in);\n            String next = scanner.next();\n            if (&amp;quot;exit&amp;quot;.equals(next)) {\n                timingWheel.shutdown();\n                timingWheel2.shutdown();\n                break;\n            }\n\n            String[] splits = next.split(&amp;quot;,&amp;quot;);\n\n            for (String split : splits) {\n                int delayTime = Integer.parseInt(split);\n                System.out.println(&amp;quot;新生产一个任务, 延迟&amp;quot; + delayTime + &amp;quot;秒后执行&amp;quot; + &amp;quot;, 当前时间: &amp;quot; +\n                        LocalDateTime.now() + &amp;quot;, 预计执行时间: &amp;quot; + LocalDateTime.now().plusSeconds(delayTime)\n                );\n                Task task = new Task(() -&amp;gt; Thread.currentThread().getName(), delayTime);\n                timingWheel.addTask(task);\n                timingWheel2.addTask(task);\n            }\n        }\n\n        TimeUnit.SECONDS.sleep(1);\n        System.exit(0);\n    }\n}\n\nclass TimingWheel {\n\n    private final ExecutorService EXECUTOR_TASK_POOL;\n    private final ScheduledExecutorService SCHEDULED_TASK_POOL;\n    /**\n     * 时间轮周期\n     */\n    private final int timer;\n\n    /**\n     * 记录每个刻度的任务\n     */\n    private final List&amp;lt;LinkedList&amp;lt;Task&amp;gt;&amp;gt; secondWheel;\n\n    /**\n     * 刻度计数器\n     */\n    private final AtomicInteger secondAtomic;\n\n    /**\n     * 任务队列\n     */\n    private final Queue&amp;lt;Task&amp;gt; taskQueue;\n\n    /**\n     * 运行标记\n     */\n    private boolean flag;\n\n    public TimingWheel(int timer) {\n        this.timer = timer;\n        this.secondWheel = IntStream.range(0, timer).mapToObj(d -&amp;gt; new LinkedList&amp;lt;Task&amp;gt;()).collect(Collectors.toList());\n        this.secondAtomic = new AtomicInteger(0);\n        this.taskQueue = new LinkedBlockingQueue&amp;lt;&amp;gt;();\n        this.EXECUTOR_TASK_POOL = Executors.newSingleThreadExecutor();\n        this.SCHEDULED_TASK_POOL = Executors.newSingleThreadScheduledExecutor();\n        this.flag = true;\n        this.init();\n    }\n\n    public void addTask(Task task) {\n\n        int delayTime = task.getDelayTime();\n        int targetRunSecond = delayTime + secondAtomic.get();\n        int cycle = delayTime / timer;\n        int index = targetRunSecond % timer;\n        task.setCycle(cycle);\n\n        System.out.printf(&amp;quot;任务id: %s, 当前刻度: %s, cycle: %s, 计划执行刻度: %s \\n&amp;quot;, task.getTaskId(), secondAtomic.get(), cycle, index);\n\n        LinkedList&amp;lt;Task&amp;gt; tasks = secondWheel.get(index);\n        if (tasks == null) {\n            tasks = new LinkedList&amp;lt;&amp;gt;();\n        }\n        tasks.add(task);\n    }\n\n    public void shutdown() {\n        EXECUTOR_TASK_POOL.shutdown();\n        SCHEDULED_TASK_POOL.shutdown();\n        this.flag = false;\n        System.out.println(&amp;quot;[&amp;quot; + timer + &amp;quot;]shutdown...&amp;quot;);\n    }\n\n    @SneakyThrows\n    private void init () {\n        SCHEDULED_TASK_POOL.scheduleAtFixedRate(() -&amp;gt; {\n            int second = secondAtomic.getAndAdd(1);\n            if (second + 1 == timer) {\n                secondAtomic.set(0);\n            }\n            LinkedList&amp;lt;Task&amp;gt; tasks = secondWheel.get(second);\n            if (tasks != null &amp;amp;&amp;amp; !tasks.isEmpty()) {\n                Iterator&amp;lt;Task&amp;gt; iterator = tasks.iterator();\n                while (iterator.hasNext()) {\n                    Task task = iterator.next();\n\n                    Integer taskCycle = task.getCycle();\n                    if (taskCycle != 0) {\n                        task.setCycle(taskCycle - 1);\n                        System.out.println(task.getTaskId() + &amp;quot;还未到时间, 当前周期&amp;quot; + taskCycle);\n                        continue;\n                    }\n\n                    taskQueue.add(task);\n                    // 从队列中剔除\n                    iterator.remove();\n                }\n            }\n        }, 0, 1, TimeUnit.SECONDS);\n\n        EXECUTOR_TASK_POOL.execute(() -&amp;gt; {\n            while (flag) {\n                Task task = taskQueue.poll();\n                if (task != null) {\n                    System.out.println(LocalDateTime.now() + &amp;quot;, [&amp;quot; + timer + &amp;quot;]时间轮调度任务====&amp;gt;&amp;quot; + task);\n                }\n            }\n        });\n    }\n\n}\n\n@Getter\nclass Task {\n\n    private final Integer taskId;\n\n    /**\n     * 执行任务\n     */\n    private final Supplier&amp;lt;String&amp;gt; runner;\n\n    /**\n     * 当前第几轮\n     */\n    @Setter\n    private  Integer cycle;\n\n    private final Integer delayTime;\n\n    /**\n     * 创建时间\n     */\n    private final LocalDateTime createdAt;\n\n    /**\n     * 理应执行时间\n     */\n    private final LocalDateTime runnerTime;\n\n    public Task(Supplier&amp;lt;String&amp;gt; runner,  Integer delayTime) {\n        this.taskId = new Random().nextInt() * 10000;\n        this.runner = runner;\n        this.delayTime = delayTime;\n        this.createdAt = LocalDateTime.now();\n        this.runnerTime = this.createdAt.plusSeconds(delayTime);\n    }\n\n    @Override\n    public String toString() {\n        return &amp;quot;Task{&amp;quot; +\n                &amp;quot;taskId=&amp;quot; + taskId +\n                &amp;quot;, runner=&amp;quot; + runner.get() +\n                &amp;quot;, cycle=&amp;quot; + cycle +\n                &amp;quot;, delayTime=&amp;quot; + delayTime +\n                &amp;quot;, createdAt=&amp;quot; + createdAt +\n                &amp;quot;, runnerTime=&amp;quot; + runnerTime +\n                &#39;}&#39;;\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-shi-xian-jian-dan-dan-ji-shi-jian-lun-fang-an&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 实现简单单机时间轮方案&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;TimeingWheel&#34;,&#34;slug&#34;:&#34;i73r1WX7G&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/i73r1WX7G/&#34;},{&#34;name&#34;:&#34;RocketMQ&#34;,&#34;slug&#34;:&#34;YdtQW2aVg&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/YdtQW2aVg/&#34;}],&#34;date&#34;:&#34;2023-11-13 22:20:41&#34;,&#34;dateFormat&#34;:&#34;2023-11-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-shi-xian-jian-dan-dan-ji-shi-jian-lun-fang-an/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:230000,&#34;words&#34;:696,&#34;minutes&#34;:4},&#34;description&#34;:&#34;时间轮的使用场景自不必多说，最近研究RocketMQ 5.0时，想简单写一个活跃下思路，遂写了下面的方案（没有参照任何代码，没有优化），主要做下记录。\npackage top.imyzt.learning.algorithm.timer;\n...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;RocketMQ 相较于 RabbitMQ、Kafka 能够集成两者的不少优点（原生的延迟消息、支持事务消息、能够支撑较大流量），加之Java技术架构，所以已作为目前队列选型调研时的第一选择，本文主要以图解形式讲明白RocketMQ一条消息的基本流程。&lt;/p&gt;\n&lt;h2 id=\&#34;核心概念\&#34;&gt;核心概念&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;NameServer：注册中心，用于保存Topic的路由信息、管理Broker的存活状态；NameServer一般是多节点部署的，多个NameServer之间互不通信。&lt;/li&gt;\n&lt;li&gt;Broker：用于存储消息，在启动时会向NameServer注册自己的地址信息，启动后每30s向NameServer心跳报告健康状态；Broker实例可以有多个，相同的BrokerName为一组Broker，每个Broker组只保存一部分信息。&lt;/li&gt;\n&lt;li&gt;Topic：消息的主题，一个Topic的消息可以分布在不同的Broker组下。&lt;/li&gt;\n&lt;li&gt;Queue：一个Topic可以有很多Queue，默认一个Topic在同一个Broker组下是4个，如果一个Topic在2个Broker组中，则有可能是8个Queue。&lt;strong&gt;一个Queue只能被一个Consumer消费，一个Consumer可以同时消费多个Queue。&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;Producer：消息的生产者、可以成组出现（Producer Group）。&lt;/li&gt;\n&lt;li&gt;Consumer：消息的消费者，可以成组出现（Consumer Group）。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;nameserver\&#34;&gt;NameServer&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;NameServer是Broker和Topic路由的注册中心，支持Broker的动态注册与发现。&lt;br&gt;\n主要包含2个功能：&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;Broker管理：接受Broker集群的注册信息并且保存下来作为消息路由信息的基本数据，提供心跳监测机制，检查Broker是否还存活。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1699778210047.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;路由信息管理：每个NameServer都保存着Broker集群的整个路由信息和用于客户端查询的队列信息，Producer和Consumer可以通过NameServer获得整个Broker集群的路由信息，从而进行消息的投递和消费。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;注册流程：&lt;/strong&gt;&lt;br&gt;\nNameServer每个节点之间是不通信的，每个Broker在启动时，会给所有NameServer注册自己的信息，&lt;code&gt;每30秒心跳&lt;/code&gt;上报自己的信息（BrokerId、Broker地址、名称、所属集群名称等信息），NameServer收到后会更新Broker的最新存活时间。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;优缺点：&lt;/strong&gt;&lt;br&gt;\n优点：NameServer集群搭建简单，随意启动即可（因为互不通信）&lt;br&gt;\n缺点：简单增加节点无效，Broker无法感知新NameServer不会向他注册信息和心跳。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;路由剔除：&lt;/strong&gt;&lt;br&gt;\nNameServer定时任务&lt;code&gt;每10秒&lt;/code&gt;扫描一次Broker列表，当Broker最新心跳时间戳距离当前时间&lt;code&gt;超过120秒&lt;/code&gt;，则将Broker从列表中剔除。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;运维方案：&lt;/strong&gt;&lt;br&gt;\n当需要升级RocketMQ集群时，可以依次将每个节点对外关闭读写权限。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Producer发送到Broker会收到无权读写而切换另一个Broker投递消息。&lt;/li&gt;\n&lt;li&gt;超过120秒不心跳，NameServer会自动将此Broker下线。&lt;/li&gt;\n&lt;li&gt;Producer每30秒会从NameServer拉取Broker信息，当NameServer记录为下线后此Broker也不会再有Producer进行消息投递。然后再关闭升级此Broker即可。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;路由发现：&lt;/strong&gt;&lt;br&gt;\n当Topic路由信息变化时，NameServer不会推送而是等客户端每30秒拉取一次最新的路由信息。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1699778321090.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;客户端（Producer）NameServer选择策略：&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;首先采用&lt;code&gt;随机策略&lt;/code&gt;, 然后采用&lt;code&gt;轮询策略&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;生成一个随机数，从配置的NameServer集群地址中根据数量取模然后连接，如果连接失败会切换为轮询逐个连接其他节点。&lt;/p&gt;\n&lt;p&gt;扩展：zk client如何选择zk server?&lt;br&gt;\n经过两次Shuffle，然后选择第一台ZK Server。&lt;br&gt;\n将配置文件中的zk server地址进行第一次shuffle，然后随机选择一个，这个选择出的一般都是hostname，然后获取到该hostname对应的所有IP，再对这些ip进行第二次shuffle。&lt;/p&gt;\n&lt;h2 id=\&#34;broker\&#34;&gt;Broker&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Broker充当着消息中转角色，负责存储消息、转发消息。&lt;br&gt;\nBroker在RocketMQ系统中负责接收并存储从生产者发送来的消息。同时为消费者的拉取请求做准备。&lt;br&gt;\nBroker同时存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;hr&gt;\n&lt;p&gt;一个Topic存储在不同的Broker中，按Queue轮询存放，一个Queue在Master/Slave中存储多份做主备集群。&lt;br&gt;\nBroker节点集群是主从集群，Broker集群是主备集群。&lt;/p&gt;\n&lt;hr&gt;\n&lt;ul&gt;\n&lt;li&gt;Remoting Module: 整个Broker的实体，负责处理来自clients的请求，由以下模块构成。&lt;/li&gt;\n&lt;li&gt;Client Manager：客户端管理器，负责接受、解析来自客户端（Producer、Consumer）请求，管理客户端，比如维护Consumer的Topic订阅关系。&lt;/li&gt;\n&lt;li&gt;Store Service：存储服务，处理&lt;code&gt;消息存储到物理硬盘&lt;/code&gt;和&lt;code&gt;消息查询&lt;/code&gt;功能。&lt;/li&gt;\n&lt;li&gt;HA Service： 高可用服务，提供&lt;code&gt;Master Broker&lt;/code&gt;和&lt;code&gt;Slave Broker&lt;/code&gt;之间的数据同步功能。&lt;/li&gt;\n&lt;li&gt;Index Service: 索引服务，根据特定的&lt;code&gt;Message Key&lt;/code&gt;，对投递到Broker的消息进行索引服务，同时提供根据 &lt;code&gt;Message Key&lt;/code&gt; 对消息进行快速查询的功能。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;消息的生产和发送\&#34;&gt;消息的生产和发送&lt;/h2&gt;\n&lt;p&gt;通过上面的流程，我们知道了NameServer和Broker的交互流程，Producer启动时，只指向了NameServer，并不知道Broker的信息。那么一条消息从Producer生产后，是如何投递到哪个Broker的哪个Queue上面的呢？&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1699778590005.png\&#34; alt=\&#34;queue select\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;针对这种情况，RocketMQ采用了2种Queue选择算法：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;轮询算法&lt;/li&gt;\n&lt;li&gt;最小投递延迟算法&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Producer可以将消息写入到某个Broker中的Queue中，过程如下：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Producer发送消息前，会向获取NameServer获取Topic的路由信息&lt;/li&gt;\n&lt;li&gt;NameServer返回该Topic的&lt;code&gt;路由表&lt;/code&gt;和&lt;code&gt;Broker列表&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Producer根据代码中指定的Queue选择策略，从Queue列表中选择一个队列&lt;/li&gt;\n&lt;li&gt;Producer对消息做处理，比如超过4M会进行压缩&lt;/li&gt;\n&lt;li&gt;Producer向选择出的Queue所在的broker发送RPC请求，将消息发送到选择出的Queue中&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;路由表：一个Map，Key为QueueData实例列表，QueueData并不是一个queue对应一个queueData，而是一个Broker中该Topic所有的QueueData对应一个QueueData。即只要涉及到该Topic的Broker，一个Broker对应一个QueueData。&lt;br&gt;\n路由表的key为Topic名称，value则为所有涉及该Topic的brokerName列表。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;路由表(一个Topic分散在哪些Broker上面，方便消费者和生产者连接Queue)：&lt;/strong&gt;&lt;br&gt;\n&lt;code&gt;Map&amp;lt;TopicName, List&amp;lt;BrokerName&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Broker列表：一个Map，Key为BrokerName，Value为BrokerData，一个Broker对应一个BrokerData实例，一套BrokerName名称相同的Master-Slave小集群对应一个BrokerData&lt;br&gt;\nBrokerData中包含一个Map，key为brokerId，value为该broker对应的地址，&lt;code&gt;brokerId=0表示master&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Broker列表(一个集群中Broker的分布，方便消费者和生产者连接Broker)：&lt;/strong&gt;&lt;br&gt;\n&lt;code&gt;Map&amp;lt;BrokerName, Map&amp;lt;brokerId, brokerAddress&amp;gt;&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;对于无序消息的Queue选择算法：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;轮询算法&lt;br&gt;\n默认选择方法，保证每个Queue都均匀获得消息&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;问题：当Broker出问题时，此Broker上的Queue投递延迟严重时，会造成producer消息堆积。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;最小投递延迟算法&lt;br&gt;\n统计每次消息投递的延迟，统计处投递延迟最小的Queue，如果延迟相同则选用轮询算法&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;问题：Queue上的消息分配不均，投递延迟小的Queue会存在大量消息，&lt;strong&gt;导致对应Queue的消费者要处理的消息很大。&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;rocketmq-xiao-xi-sheng-chan-ji-ben-liu-cheng&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;RocketMQ消息生产基本流程&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;RocketMQ&#34;,&#34;slug&#34;:&#34;YdtQW2aVg&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/YdtQW2aVg/&#34;}],&#34;date&#34;:&#34;2023-11-12 16:19:24&#34;,&#34;dateFormat&#34;:&#34;2023-11-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/rocketmq-xiao-xi-sheng-chan-ji-ben-liu-cheng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:382000,&#34;words&#34;:1757,&#34;minutes&#34;:7},&#34;description&#34;:&#34;RocketMQ 相较于 RabbitMQ、Kafka 能够集成两者的不少优点（原生的延迟消息、支持事务消息、能够支撑较大流量），加之Java技术架构，所以已作为目前队列选型调研时的第一选择，本文主要以图解形式讲明白RocketMQ一条消息...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\&#34;&gt;核心概念&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nameserver\&#34;&gt;NameServer&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#broker\&#34;&gt;Broker&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7%E5%92%8C%E5%8F%91%E9%80%81\&#34;&gt;消息的生产和发送&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在部分场景下，只需要简单将外部对象转换为标准JavaBean，而对接的外部是下划线命名时，如果需要一个个写&lt;code&gt;JSONField&lt;/code&gt;必然是比较麻烦的，可以通过FastJSON提供的序列化/反序列化配置类来快速实现。&lt;/p&gt;\n&lt;p&gt;JSON是下划线，Bean是驼峰时：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;ParserConfig parserConfig = new ParserConfig();\nparserConfig.propertyNamingStrategy = PropertyNamingStrategy.CamelCase;\nBytedanceClueLog bytedanceClueLog = clueJson.toJavaObject(BytedanceClueLog.class, parserConfig, 0);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Bean是驼峰，需要将JSON转为下划线时：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;SerializeConfig serializeConfig = new SerializeConfig();\nserializeConfig.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;\nreturn JSON.toJSONString(req, serializeConfig);\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;fastjson-xu-lie-hua-fan-xu-lie-hua-tuo-feng-he-xia-hua-xian-hu-zhuan&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;FastJSON 序列化反序列化驼峰和下划线互转&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;FastJSON&#34;,&#34;slug&#34;:&#34;0GA6N_K8_&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/0GA6N_K8_/&#34;}],&#34;date&#34;:&#34;2023-10-31 23:08:10&#34;,&#34;dateFormat&#34;:&#34;2023-10-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/fastjson-xu-lie-hua-fan-xu-lie-hua-tuo-feng-he-xia-hua-xian-hu-zhuan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:31000,&#34;words&#34;:128,&#34;minutes&#34;:1},&#34;description&#34;:&#34;在部分场景下，只需要简单将外部对象转换为标准JavaBean，而对接的外部是下划线命名时，如果需要一个个写JSONField必然是比较麻烦的，可以通过FastJSON提供的序列化/反序列化配置类来快速实现。\nJSON是下划线，Bean是驼峰...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在平时需要写抽象策略处理器时，希望传给处理器执行器的对象是泛型，避免每个子类都写强制类型转换的代码，通常需要获取子类的泛型，然后才能够避免写&lt;code&gt;@SuppressWarnings&lt;/code&gt;，可以通过如下工具类在&lt;code&gt;Abstract&lt;/code&gt;类上面获取到子类泛型。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;ResolvableType[] generics = ResolvableType.forClass(this.getClass()).getSuperType().getGenerics();\n// generics[0]是第一个泛型\nT o = (T) generalResult.toJavaObject(generics[0].resolve());\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;tong-guo-spring-gong-ju-lei-fu-lei-huo-qu-zi-lei-fan-xing-duo-tai-fan-xing-chuan-can&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;通过Spring工具类，父类获取子类泛型（多态泛型传参）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Spring&#34;,&#34;slug&#34;:&#34;r_PTn6Nd-&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/r_PTn6Nd-/&#34;}],&#34;date&#34;:&#34;2023-09-22 17:12:12&#34;,&#34;dateFormat&#34;:&#34;2023-09-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/tong-guo-spring-gong-ju-lei-fu-lei-huo-qu-zi-lei-fan-xing-duo-tai-fan-xing-chuan-can/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:25000,&#34;words&#34;:112,&#34;minutes&#34;:1},&#34;description&#34;:&#34;在平时需要写抽象策略处理器时，希望传给处理器执行器的对象是泛型，避免每个子类都写强制类型转换的代码，通常需要获取子类的泛型，然后才能够避免写@SuppressWarnings，可以通过如下工具类在Abstract类上面获取到子类泛型。\nRe...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;-- 转换编码不一致的情况\ncast(ldr.id as char character set utf8)\nCONVERT(CAST(bpr.id AS char) USING utf8)\n--转换排序规则也不一致的情况\nconvert(cl.app_id using utf8mb4) collate utf8mb4_unicode_ci\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-zi-fu-ji-bu-tong-zhuan-huan-zi-fu-ji-he-pai-xu-gui-ze&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL字符集不同转换字符集和排序规则&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySQL&#34;,&#34;slug&#34;:&#34;uTOj96mue&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/uTOj96mue/&#34;}],&#34;date&#34;:&#34;2023-09-04 12:16:06&#34;,&#34;dateFormat&#34;:&#34;2023-09-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-zi-fu-ji-bu-tong-zhuan-huan-zi-fu-ji-he-pai-xu-gui-ze/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:13000,&#34;words&#34;:46,&#34;minutes&#34;:1},&#34;description&#34;:&#34;-- 转换编码不一致的情况\ncast(ldr.id as char character set utf8)\nCONVERT(CAST(bpr.id AS char) USING utf8)\n--转换排序规则也不一致的情况\nconvert(c...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Golang在1.18时才支持了泛型，为此新增了两个操作符，&lt;code&gt;|&lt;/code&gt;和&lt;code&gt;~&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;~ T： 表示底层类型是T，比如 ~string表示所有基于string创建的自定义类型。&lt;br&gt;\nT1 | T2 |...： 代表&lt;code&gt;或&lt;/code&gt;，类型列表之一。&lt;/p&gt;\n&lt;p&gt;Go的泛型有别于其它语言的方案，在Go语言中泛型叫做Type Parameter(类型参数).&lt;/p&gt;\n&lt;p&gt;Golang的泛型：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;1.18才有&lt;/li&gt;\n&lt;li&gt;只能用在方法上,无法使用在结构体上&lt;/li&gt;\n&lt;li&gt;泛型下边界需要在类型上使用 &lt;code&gt;~&lt;/code&gt; 表达式&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;泛型的示例\&#34;&gt;泛型的示例&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;type myStr string\n\ntype customType interface {\n\tfloat32 | float64 | int | int8 | int32 | int16 | int64 | uint | uint8 | uint32 | uint16 | uint64 | ~string\n}\n\nfunc min[T customType](a, b T) T {\n\tif a &amp;gt; b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc main() {\n\n    // 泛型\n    fmt.Println(min(1, 2))\n    fmt.Println(min(1.1, 2.2))\n    fmt.Println(min(&amp;quot;3&amp;quot;, &amp;quot;2&amp;quot;))\n    \n    // 自定义类型泛型\n    num1 := myStr(&amp;quot;33&amp;quot;)\n    num2 := myStr(&amp;quot;344&amp;quot;)\n    fmt.Println(min(num1, num2))\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;go-xin-te-xing-qian-xi-fan-xing&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;go 新特性浅析（泛型）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Go&#34;,&#34;slug&#34;:&#34;OlQxAV0hi&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/OlQxAV0hi/&#34;}],&#34;date&#34;:&#34;2022-04-12 22:39:39&#34;,&#34;dateFormat&#34;:&#34;2022-04-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/go-xin-te-xing-qian-xi-fan-xing/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:57000,&#34;words&#34;:213,&#34;minutes&#34;:1},&#34;description&#34;:&#34;Golang在1.18时才支持了泛型，为此新增了两个操作符，|和~。\n~ T： 表示底层类型是T，比如 ~string表示所有基于string创建的自定义类型。\nT1 | T2 |...： 代表或，类型列表之一。\nGo的泛型有别于其它语言的...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%A4%BA%E4%BE%8B\&#34;&gt;泛型的示例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;解决方案\&#34;&gt;解决方案&lt;/h1&gt;\n&lt;p&gt;按住Fn+Del恢复出厂设置，option生效。IDEA跳单词问题解决！&lt;/p&gt;\n&lt;h1 id=\&#34;后记\&#34;&gt;后记&lt;/h1&gt;\n&lt;p&gt;配置option与command键盘互换。&lt;/p&gt;\n&lt;p&gt;系统偏好设置-键盘-修饰键-配置command与option互换（注意「选择键盘」为USB键盘）。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;lao-ban-ben-ikbc-c87-winoptionzai-mac-wu-fa-shi-yong-wen-ti-jie-jue-fang-an&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;老版本ikbc c87 win(option)在Mac无法使用问题解决方案&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-02-28 09:08:48&#34;,&#34;dateFormat&#34;:&#34;2022-02-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/lao-ban-ben-ikbc-c87-winoptionzai-mac-wu-fa-shi-yong-wen-ti-jie-jue-fang-an/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:13000,&#34;words&#34;:62,&#34;minutes&#34;:1},&#34;description&#34;:&#34;解决方案\n按住Fn+Del恢复出厂设置，option生效。IDEA跳单词问题解决！\n后记\n配置option与command键盘互换。\n系统偏好设置-键盘-修饰键-配置command与option互换（注意「选择键盘」为USB键盘）。\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\&#34;&gt;解决方案&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E8%AE%B0\&#34;&gt;后记&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;详细讲解每一列的作用，当做字典查看。&lt;/p&gt;\n&lt;h1 id=\&#34;前置知识\&#34;&gt;前置知识&lt;/h1&gt;\n&lt;h2 id=\&#34;半连接\&#34;&gt;半连接&lt;/h2&gt;\n&lt;h2 id=\&#34;子查询物化\&#34;&gt;子查询物化&lt;/h2&gt;\n&lt;h2 id=\&#34;索引合并\&#34;&gt;索引合并&lt;/h2&gt;\n&lt;h1 id=\&#34;table\&#34;&gt;table&lt;/h1&gt;\n&lt;p&gt;无论查询语句中包含多少张表，最终都会转换为对单表的访问，所以EXPLAIN语句输出的每条记录都对应着对单表的访问方法，&lt;strong&gt;也即table列代表着表名&lt;/strong&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;普通单表\&#34;&gt;普通单表&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1;\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n1 row in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;普通连接查询\&#34;&gt;普通连接查询&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2;\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL                                  |\n|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | Using join buffer (Block Nested Loop) |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+\n2 rows in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;id\&#34;&gt;id&lt;/h1&gt;\n&lt;p&gt;查询语句中，为每个select分配一个唯一id，当语句中包含多个select时（union、子查询），id的大小表示不同select的查询先后顺序。&lt;br&gt;\n当id相同table不同时（一般出现在连接语句），在前面的表示驱动表，在后面的是被驱动表。&lt;/p&gt;\n&lt;h2 id=\&#34;普通单id\&#34;&gt;普通单id&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 = &#39;a&#39;;\n+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+\n| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+\n|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+\n1 row in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;复杂连接语句\&#34;&gt;复杂连接语句&lt;/h2&gt;\n&lt;p&gt;语句中，id相同，s1是驱动表，s2是被驱动表。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2;\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL                                  |\n|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | Using join buffer (Block Nested Loop) |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+\n2 rows in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;语句中，id不同，表示MySQL先查询s1，后查询s2。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select id from s2) or key2 = &#39;b&#39;;\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key2      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where |\n|  2 | SUBQUERY    | s2    | NULL       | index | PRIMARY       | idx_key2 | 5       | NULL | 10143 |   100.00 | Using index |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n2 rows in set, 2 warnings (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;语句优化子查询转连接\&#34;&gt;语句优化（子查询转连接）&lt;/h2&gt;\n&lt;p&gt;虽然语句属于子查询，理应分配2个id，但是执行计划看出来只有id=1，因为在MySQL优化器将这种明显可以转换为连接查询优化速度的语句改写为连接查询了。&lt;br&gt;\n可以通过后面的&lt;code&gt;show warnings ;&lt;/code&gt;语句查看code=1003的优化过程。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select id from s2 where key1 = &#39;b&#39;);\n+----+-------------+-------+------------+------+------------------+----------+---------+-------+-------+----------+----------------------------------------------------+\n| id | select_type | table | partitions | type | possible_keys    | key      | key_len | ref   | rows  | filtered | Extra                                              |\n+----+-------------+-------+------------+------+------------------+----------+---------+-------+-------+----------+----------------------------------------------------+\n|  1 | SIMPLE      | s2    | NULL       | ref  | PRIMARY,idx_key1 | idx_key1 | 303     | const |     1 |   100.00 | Using index                                        |\n|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1         | NULL     | NULL    | NULL  | 10143 |    10.00 | Using where; Using join buffer (Block Nested Loop) |\n+----+-------------+-------+------------+------+------------------+----------+---------+-------+-------+----------+----------------------------------------------------+\n2 rows in set, 3 warnings (0.00 sec)\n\nmysql&amp;gt; show warnings ;\n| Level   | Code | Message\n| Note    | 1003 | select 此处省略一堆查询列节省篇幅 from `xiaohaizi`.`s2` join `xiaohaizi`.`s1` where ((`xiaohaizi`.`s2`.`key1` = &#39;b&#39;) and (`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`id`)) |\n3 rows in set (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;去重临时表\&#34;&gt;去重临时表&lt;/h2&gt;\n&lt;p&gt;当语句使用union对结果进行合并时，会使用临时表对结果进行去重。所以生成一个id=null的结果集。&lt;br&gt;\n当使用union all时，因为不需要对结果进行去重，故不会产生NULL记录。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 union select * from s2;\n+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+\n| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra           |\n+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+\n|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL            |\n|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL            |\n| NULL | UNION RESULT | &amp;lt;union1,2&amp;gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+\n3 rows in set, 1 warning (0.02 sec)\n\nmysql&amp;gt; mysql&amp;gt; explain select * from s1 union all select * from s2;\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |\n|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n2 rows in set, 1 warning (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;select_type\&#34;&gt;select_type&lt;/h1&gt;\n&lt;p&gt;MySQL为每个select关键字代表的小查询都定义了一个名为select_type的属性，只要知道了小查询的select_type属性，也就知道了这个小查询在大查询中的角色。&lt;/p&gt;\n&lt;h2 id=\&#34;simple\&#34;&gt;SIMPLE&lt;/h2&gt;\n&lt;p&gt;查询语句中不包含union或者子查询，就是简单的查询就是&lt;code&gt;SIMPLE&lt;/code&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1;\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql&amp;gt; explain select * from s1 join s2;\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                                 |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL                                  |\n|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | Using join buffer (Block Nested Loop) |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------------+\n2 rows in set, 1 warning (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;primary\&#34;&gt;PRIMARY&lt;/h2&gt;\n&lt;p&gt;对于union/union all/或者子查询等大查询来说，是有多个小查询组合而来的，最左边的那个查询就是&lt;code&gt;PRIMARY&lt;/code&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 union all select * from s2;\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |\n|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10143 |   100.00 | NULL  |\n+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+\n2 rows in set, 1 warning (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;union\&#34;&gt;UNION&lt;/h2&gt;\n&lt;p&gt;对于union/union all/或者子查询等大查询来说，是有多个小查询组合而来的，除最左边的那个查询是&lt;code&gt;PRIMARY&lt;/code&gt;外，其余所有小查询都是&lt;code&gt;UNION&lt;/code&gt;，执行计划同上。&lt;/p&gt;\n&lt;h2 id=\&#34;union-result\&#34;&gt;UNION RESULT&lt;/h2&gt;\n&lt;p&gt;MySQL选择使用临时表来完成UNION查询的去重工作，针对此临时表select_type就是&lt;code&gt;UNION RESULT&lt;/code&gt;，执行计划同「去重临时表」章节。&lt;/p&gt;\n&lt;h2 id=\&#34;subquery\&#34;&gt;SUBQUERY&lt;/h2&gt;\n&lt;p&gt;如果包含子查询的语句&lt;strong&gt;不能转换为对应的半连接形式&lt;/strong&gt;，&lt;strong&gt;并且该子查询是不相关子查询&lt;/strong&gt;，而且查询优化器决定采用&lt;strong&gt;子查询物化&lt;/strong&gt;的方案来执行该子查询时，select_type就是&lt;code&gt;SUBQUERY&lt;/code&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select key2 from s2) or key3 = &#39;b&#39;;\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where |\n|  2 | SUBQUERY    | s2    | NULL       | index | idx_key2      | idx_key2 | 5       | NULL | 10143 |   100.00 | Using index |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n2 rows in set, 1 warning (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;dependent-subquery\&#34;&gt;DEPENDENT SUBQUERY&lt;/h2&gt;\n&lt;p&gt;如果包含子查询的查询语句不能转换为对应的半连接形式，并且该子查询被查询优化器转换为相关子查询的形式，则该子查询的第一个select关键字代表的那个查询的select_type就是&lt;code&gt;DEPENDENT SUBQUERY&lt;/code&gt;。&lt;br&gt;\nselect_type=&lt;code&gt;DEPENDENT SUBQUERY&lt;/code&gt;的子查询可能会被执行多次。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select key2 from s2 where s1.key2 = s2.key2) or key3 = &#39;b&#39;;\n+----+--------------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+--------------------------+\n| id | select_type        | table | partitions | type   | possible_keys | key      | key_len | ref               | rows  | filtered | Extra                    |\n+----+--------------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+--------------------------+\n|  1 | PRIMARY            | s1    | NULL       | ALL    | idx_key3      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where              |\n|  2 | DEPENDENT SUBQUERY | s2    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | xiaohaizi.s1.key2 |     1 |   100.00 | Using where; Using index |\n+----+--------------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+--------------------------+\n2 rows in set, 2 warnings (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;dependent-union\&#34;&gt;DEPENDENT UNION&lt;/h2&gt;\n&lt;p&gt;在包含union或union all的大查询中，如果各个小查询都依赖外层查询，则除了最左边的小查询&lt;code&gt;select_type=DEPENDENT SUBQUERY&lt;/code&gt;外，其余小查询都是&lt;code&gt;DEPENDENT UNION&lt;/code&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select key2 from s2 union select key3 from s2 union select key1 from s2) or key3 = &#39;b&#39;;\n+----+--------------------+--------------+------------+------+---------------+----------+---------+------+-------+----------+--------------------------+\n| id | select_type        | table        | partitions | type | possible_keys | key      | key_len | ref  | rows  | filtered | Extra                    |\n+----+--------------------+--------------+------------+------+---------------+----------+---------+------+-------+----------+--------------------------+\n|  1 | PRIMARY            | s1           | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where              |\n|  2 | DEPENDENT SUBQUERY | s2           | NULL       | ref  | idx_key2      | idx_key2 | 5       | func |     1 |   100.00 | Using where; Using index |\n|  3 | DEPENDENT UNION    | s2           | NULL       | ref  | idx_key3      | idx_key3 | 303     | func |     1 |   100.00 | Using index              |\n|  4 | DEPENDENT UNION    | s2           | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |     1 |   100.00 | Using index              |\n| NULL | UNION RESULT       | &amp;lt;union2,3,4&amp;gt; | NULL       | ALL  | NULL          | NULL     | NULL    | NULL |  NULL |     NULL | Using temporary          |\n+----+--------------------+--------------+------------+------+---------------+----------+---------+------+-------+----------+--------------------------+\n5 rows in set, 1 warning (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;derived\&#34;&gt;DERIVED&lt;/h2&gt;\n&lt;p&gt;在包含派生表的查询中，如果是以物化派生表的方式执行查询，则派生表对应的子查询的&lt;code&gt;select_type=DERIVED&lt;/code&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from (select key1, count(*) as total from s2  group by key1) t where total &amp;gt; 1;\n+----+-------------+------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n| id | select_type | table      | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |\n+----+-------------+------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n|  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 10143 |    33.33 | Using where |\n|  2 | DERIVED     | s2         | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 10143 |   100.00 | Using index |\n+----+-------------+------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;materialized\&#34;&gt;MATERIALIZED&lt;/h2&gt;\n&lt;p&gt;当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询，该子查询对应的select_type=&lt;code&gt;MATERIALIZED&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;第三条记录的select_type=MATERIALIZED，说明优化器将子查询先转换为物化表，执行计划的前两条记录的id都=1，说明这两条记录对应的表进行的是连接查询。&lt;br&gt;\n&lt;strong&gt;第二条记录的table列的值是&lt;subquery2&gt;，说明该表其实就是执行计划中id为2对应的子查询执行之后产生的物化表，然后再将s1和该物化表进行连接查询。&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 in (select key1 from s2);\n+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+-------------------+-------+----------+-------------+\n| id | select_type  | table       | partitions | type   | possible_keys       | key                 | key_len | ref               | rows  | filtered | Extra       |\n+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+-------------------+-------+----------+-------------+\n|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1            | NULL                | NULL    | NULL              | 10143 |   100.00 | Using where |\n|  1 | SIMPLE       | &amp;lt;subquery2&amp;gt; | NULL       | eq_ref | &amp;lt;auto_distinct_key&amp;gt; | &amp;lt;auto_distinct_key&amp;gt; | 303     | xiaohaizi.s1.key1 |     1 |   100.00 | NULL        |\n|  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1            | idx_key1            | 303     | NULL              | 10143 |   100.00 | Using index |\n+----+--------------+-------------+------------+--------+---------------------+---------------------+---------+-------------------+-------+----------+-------------+\n3 rows in set, 1 warning (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;uncacheable-subquery-uncacheable-union\&#34;&gt;UNCACHEABLE SUBQUERY、UNCACHEABLE UNION&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;UNCACHEABLE SUBQUERY：对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）&lt;/li&gt;\n&lt;li&gt;UNCACHEABLE UNION：UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;partitions\&#34;&gt;partitions&lt;/h1&gt;\n&lt;p&gt;版本5.7以前，该项是explain partitions显示的选项，5.7以后成为了默认选项。该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。&lt;/p&gt;\n&lt;h1 id=\&#34;type\&#34;&gt;type&lt;/h1&gt;\n&lt;p&gt;表示单表的访问方法，最为核心的字段之一。&lt;/p&gt;\n&lt;h2 id=\&#34;system\&#34;&gt;system&lt;/h2&gt;\n&lt;p&gt;当表只有一条记录且该表的存储引擎为MyISAM、MEMORY时，为&lt;code&gt;SYSTEM&lt;/code&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;const\&#34;&gt;const&lt;/h2&gt;\n&lt;p&gt;根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法为&lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;eq_ref\&#34;&gt;eq_ref&lt;/h2&gt;\n&lt;p&gt;执行连接查询时，如果&lt;strong&gt;被驱动表&lt;/strong&gt;是通过主键或者不允许存储NULL值的唯一二级索引列等值匹配的方式进行访问的（如果该主键或者不允许存储NULL值的唯一二级索引是联合索引，则所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 where s1.id = s2.id; --通过主键索引访问s2\n+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+-------+----------+-------+\n| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows  | filtered | Extra |\n+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+-------+----------+-------+\n|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 10143 |   100.00 | NULL  |\n|  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |     1 |   100.00 | NULL  |\n+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+-------+----------+-------+\n2 rows in set, 1 warning (0.00 sec)\n\nmysql&amp;gt; explain select * from s1 join s2 on s1.key2 = s2.key2; --通过唯一二级索引访问s2\n+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-------------+\n| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |\n+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL    | idx_key2      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where |\n|  1 | SIMPLE      | s2    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | xiaohaizi.s1.key2 |     1 |   100.00 | NULL        |\n+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n\nmysql&amp;gt; explain select * from s1 join s2 on s1.key2 = s2.key3; --通过唯一二级索引访问s1，注意这里是s1做被驱动表！！\n+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-----------------------+\n| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref               | rows  | filtered | Extra                 |\n+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-----------------------+\n|  1 | SIMPLE      | s2    | NULL       | ALL    | idx_key3      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where           |\n|  1 | SIMPLE      | s1    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | xiaohaizi.s2.key3 |     1 |   100.00 | Using index condition |\n+----+-------------+-------+------------+--------+---------------+----------+---------+-------------------+-------+----------+-----------------------+\n2 rows in set, 2 warnings (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;ref\&#34;&gt;ref&lt;/h2&gt;\n&lt;p&gt;当通过普通二级索引列与常量进行等值匹配的方式来查询某个表时，对该表的访问方法就可能是ref。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 on s1.key3 = s2.key3;\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+\n|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 10143 |   100.00 | Using where |\n|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key3      | idx_key3 | 303     | xiaohaizi.s2.key3 |     1 |   100.00 | NULL        |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;fulltext\&#34;&gt;fulltext&lt;/h2&gt;\n&lt;p&gt;全文索引。&lt;/p&gt;\n&lt;h2 id=\&#34;ref_or_null\&#34;&gt;ref_or_null&lt;/h2&gt;\n&lt;p&gt;当对普通二级索引列进行等值匹配&lt;strong&gt;且该索引列的值也可以是NULL值&lt;/strong&gt;时，记为ref_or_null。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 = &#39;a&#39; or key1 is null;\n+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+\n| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                 |\n+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+\n|  1 | SIMPLE      | s1    | NULL       | ref_or_null | idx_key1      | idx_key1 | 303     | const |    2 |   100.00 | Using index condition |\n+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+\n1 row in set, 1 warning (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;index_merge\&#34;&gt;index_merge&lt;/h2&gt;\n&lt;p&gt;一般情况下只会为单个索引生成扫描区间，但当在某些场景下可以使用Intersection、union、sort-union进行索引合并。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 = &#39;a&#39; or key3 = &#39;b&#39;;\n+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+\n| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |\n+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+\n|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |\n+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+\n1 row in set, 1 warning (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;unique_subquery\&#34;&gt;unique_subquery&lt;/h2&gt;\n&lt;p&gt;类似于两表连接中被驱动表的eq_ref访问方法。针对一些包含in子查询的查询语句。如果查询优化器决定将in子查询转换为exists子查询，而且子查询&lt;strong&gt;在转换后可以使用主键或唯一二级索引进行等值匹配&lt;/strong&gt;，记为&lt;code&gt;unique_subquery&lt;/code&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where common_field in (select id「这里主键/唯一二级索引是核心」 from s2 where s1.common_field = s2.common_field ) or key3 = &#39;b&#39;;\n+----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+\n| id | select_type        | table | partitions | type            | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |\n+----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+\n|  1 | PRIMARY            | s1    | NULL       | ALL             | idx_key3      | NULL    | NULL    | NULL | 10143 |   100.00 | Using where |\n|  2 | DEPENDENT SUBQUERY | s2    | NULL       | unique_subquery | PRIMARY       | PRIMARY | 4       | func |     1 |    10.00 | Using where |\n+----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+\n2 rows in set, 2 warnings (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;index_subquery\&#34;&gt;index_subquery&lt;/h2&gt;\n&lt;p&gt;类似于unique_subquery，只不过在访问子查询中的表时使用的是普通的索引。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where common_field in (select key3「这里是普通索引」 from s2 where s1.common_field = s2.common_field ) or key3 = &#39;b&#39;;\n+----+--------------------+-------+------------+----------------+---------------+----------+---------+------+-------+----------+-------------+\n| id | select_type        | table | partitions | type           | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |\n+----+--------------------+-------+------------+----------------+---------------+----------+---------+------+-------+----------+-------------+\n|  1 | PRIMARY            | s1    | NULL       | ALL            | idx_key3      | NULL     | NULL    | NULL | 10143 |   100.00 | Using where |\n|  2 | DEPENDENT SUBQUERY | s2    | NULL       | index_subquery | idx_key3      | idx_key3 | 303     | func |     1 |    10.00 | Using where |\n+----+--------------------+-------+------------+----------------+---------------+----------+---------+------+-------+----------+-------------+\n2 rows in set, 2 warnings (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;range\&#34;&gt;range&lt;/h2&gt;\n&lt;p&gt;如果使用索引获取某些单点扫描区间的记录，那么就可能使用到range访问方法。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key3 in (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;abc&#39;);\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+\n| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+\n|  1 | SIMPLE      | s1    | NULL       | range | idx_key3      | idx_key3 | 303     | NULL |    4 |   100.00 | Using index condition |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+\n1 row in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;index\&#34;&gt;index&lt;/h2&gt;\n&lt;p&gt;当可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;InnoDB特殊的点：当我们需要执行全表扫描，并且需要对主键进行排序时，type列的值也是index。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select key_part2 from s1 where key_part2 = &#39;ab&#39;;\n+----+-------------+-------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows  | filtered | Extra                    |\n+----+-------------+-------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+\n|  1 | SIMPLE      | s1    | NULL       | index | idx_key_part  | idx_key_part | 909     | NULL | 10143 |    10.00 | Using where; Using index |\n+----+-------------+-------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+\n1 row in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;all\&#34;&gt;all&lt;/h2&gt;\n&lt;p&gt;全表扫描。&lt;/p&gt;\n&lt;h1 id=\&#34;possible_keys-key\&#34;&gt;possible_keys、key&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;possible_keys：可能使用的索引。&lt;/li&gt;\n&lt;li&gt;key：实际用到的索引。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;注意点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;possible_keys当type=index时显示为空，此时key展示的是实际使用的索引。&lt;/li&gt;\n&lt;li&gt;possible_keys不是越多越好，越多查询优化器在计算查询成本时花费的时间就越长，尽可能删除用不到的索引。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;key_len\&#34;&gt;key_len&lt;/h1&gt;\n&lt;p&gt;表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。&lt;strong&gt;在不损失精确性的情况下，长度越短越好&lt;/strong&gt;。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，&lt;strong&gt;即key_len是根据表定义计算而得&lt;/strong&gt;，不是通过表内检索出来的。&lt;/p&gt;\n&lt;h1 id=\&#34;ref-2\&#34;&gt;ref&lt;/h1&gt;\n&lt;p&gt;当访问方法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery中的其中一个时，&lt;strong&gt;ref列展示的就是与索引列进行等值匹配的东西是什么&lt;/strong&gt;。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;常量，即右侧的值&lt;code&gt;&#39;1&#39;&lt;/code&gt;为常量。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where id = &#39;1&#39;;\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n1 row in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;某个列，比如下面s2作为被驱动表时，s2的type=ref，ref=xiaohaizi.s1.key1&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 on s1.key1 = s2.key1;\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 12242 |   100.00 | Using where |\n|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |     1 |   100.00 | NULL        |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;某个函数，比如下面s2作为被驱动表时，s2的type=ref，ref=func表示进行了函数操作。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 on s1.key1 = upper(s2.key1);\n+----+-------------+-------+------------+------+---------------+----------+---------+------+-------+----------+-----------------------+\n| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows  | filtered | Extra                 |\n+----+-------------+-------+------------+------+---------------+----------+---------+------+-------+----------+-----------------------+\n|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 12558 |   100.00 | NULL                  |\n|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |     1 |   100.00 | Using index condition |\n+----+-------------+-------+------------+------+---------------+----------+---------+------+-------+----------+-----------------------+\n2 rows in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;rows\&#34;&gt;rows&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;在查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表该表的估算行数。&lt;/li&gt;\n&lt;li&gt;如果使用索引来执行查询，执行计划的rows列就代表预计扫描的索引记录行数。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 where key1 &amp;gt; &#39;z&#39;;\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+\n| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+\n|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |    1 |   100.00 | Using index condition |\n+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+\n1 row in set, 1 warning (0.00 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;filtered\&#34;&gt;filtered&lt;/h1&gt;\n&lt;p&gt;计算MySQL驱动表扇出的一种策略。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;如果使用全表扫描执行单表查询，那么计算驱动表扇出时需要估计出全部搜索条件的记录到底有多少条。&lt;/li&gt;\n&lt;li&gt;如果使用索引来执行单表查询，&lt;strong&gt;那么计算驱动表扇出时需要估计出满足形成索引扫描区间的搜索条件外，还满足其他搜索条件的记录有多少条。&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在单表查询时没太大意义，在连表查询时对估算执行次数有帮助。&lt;/p&gt;\n&lt;p&gt;下表中，s1做驱动表，s2做被驱动表，s1的filtered=10，rows=12242，12242* 10%=1224.2，s2的filtered=100，rows=1，表示还要对被驱动表执行答曰1224次查询。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;mysql&amp;gt; explain select * from s1 join s2 on s1.key1 = s2.key1 where s1.common_field = &#39;a&#39;;\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows  | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+\n|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 12242 |    10.00 | Using where |\n|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |     1 |   100.00 | NULL        |\n+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+-------+----------+-------------+\n2 rows in set, 1 warning (0.01 sec)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;extra\&#34;&gt;Extra&lt;/h1&gt;\n&lt;p&gt;展示额外信息时使用，比较多，此处按照书中描述，只记录常出现的内容。&lt;/p&gt;\n&lt;h2 id=\&#34;no-tables-used\&#34;&gt;No tables used&lt;/h2&gt;\n&lt;p&gt;当查询语句中没有FROM子句时，会提示。比如&lt;code&gt;SELECT 1&lt;/code&gt;之类。&lt;/p&gt;\n&lt;h2 id=\&#34;impossible-where\&#34;&gt;Impossible WHERE&lt;/h2&gt;\n&lt;p&gt;查询语句的WHERE子句永远为FALSE时，会提示。比如&lt;code&gt;SELECT * FROM s1 WHERE 1 &amp;lt;&amp;gt; 1&lt;/code&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;no-matching-minmax-row\&#34;&gt;No matching min/max row&lt;/h2&gt;\n&lt;p&gt;当查询列表处有MIN或MAX聚集函数，但是没有记录符合WHERE子句中的搜索条件时，会提示。比如&lt;code&gt;SELECT min(key1) FROM s1 WHERE key1 = &#39;一个不存在的值&#39;&lt;/code&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;using-index\&#34;&gt;Using index&lt;/h2&gt;\n&lt;p&gt;使用覆盖索引执行查询时，&lt;strong&gt;不用回表&lt;/strong&gt;，会提示。比如&lt;code&gt;SELECT key1 FROM s1 WHERE key1 = &#39;a&#39;&lt;/code&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;using-index-condition\&#34;&gt;Using index condition&lt;/h2&gt;\n&lt;p&gt;搜索条件中虽然出现了索引列，但却不能充当边界条件来形成扫描区间，&lt;strong&gt;也就是说不能用来减少需要扫描的记录数量&lt;/strong&gt;，会提示。&lt;br&gt;\n比如：&lt;code&gt;SELECT * FROM s1 WHERE key1 &amp;gt; &#39;z&#39; AND key1 LIKE &#39;%a&#39;&lt;/code&gt;，其中的&lt;code&gt;key1 &amp;gt; &#39;z&#39;&lt;/code&gt;可以用来形成扫描区间，但是&lt;code&gt;key1 LIKE &#39;%a&#39;&lt;/code&gt;却不能。&lt;br&gt;\n即索引覆盖（索引下推）达成条件。&lt;br&gt;\n只对于二级索引有效，对于二级索引等值判断不生效（这时Extra=NULL），对于主键索引不生效（直接查数据）。&lt;/p&gt;\n&lt;h2 id=\&#34;using-where\&#34;&gt;Using where&lt;/h2&gt;\n&lt;p&gt;当某个搜索条件需要在server层进行判断时，在Extra列会提示，比如索引覆盖没有达成的情况。&lt;br&gt;\n&lt;code&gt;SELECT * FROM s1 WHERE key1 = &#39;a&#39; AND common_field = &#39;a&#39;&lt;/code&gt;，由于comon_field无法在引擎层判断，只能通过key1形成扫描区间后，在server层判断。&lt;/p&gt;\n&lt;h2 id=\&#34;using-join-bufferblock-nested-loop\&#34;&gt;Using join buffer（Block Nested Loop）&lt;/h2&gt;\n&lt;p&gt;在连接过程中，当被驱动表不能有效的利用索引加快访问速度时，MySQL会分配一块JoinBuffer内存块来加快查询速度，基于块的嵌套循环算法执行连接查询。&lt;/p&gt;\n&lt;h2 id=\&#34;using-intersect-using-union和using-sort_union\&#34;&gt;Using intersect(...)、Using union(...)和Using sort_union(...)&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;intersect：准备使用Intersection索引合并的方式执行查询，括号中包含需要合并的索引名称。&lt;/li&gt;\n&lt;li&gt;union：准备使用union索引合并方式执行查询。&lt;/li&gt;\n&lt;li&gt;sort_union：准备使用Sort-Union索引合并的方式执行查询。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;zero_limit\&#34;&gt;zero_limit&lt;/h2&gt;\n&lt;p&gt;当Limit子句参数为0时，会提示。&lt;/p&gt;\n&lt;h2 id=\&#34;using-filesort\&#34;&gt;Using filesort&lt;/h2&gt;\n&lt;p&gt;对结果集中记录进行排序时，使用索引则不会出现，但很多情况无法使用索引进行排序，则会出现filesort。&lt;/p&gt;\n&lt;h2 id=\&#34;using-temporary\&#34;&gt;Using temporary&lt;/h2&gt;\n&lt;p&gt;MySQL利用临时表完成去重、排序时。&lt;br&gt;\n比如DISTINCT、GROUP BY、UNION等子句查询过程中如无法使用索引则会提示。&lt;/p&gt;\n&lt;h2 id=\&#34;start-temporaryend-temporary\&#34;&gt;Start temporary，End temporary&lt;/h2&gt;\n&lt;p&gt;子查询时，查询优化器会优先尝试将IN子查询转换为半连接。半连接有很多种策略，当选择Duplicate Weedout时，也就是通过建立临时表来为外城查询中的记录进行去重操作时，驱动表查询执行计划的Extra列将显示Start temporary，被驱动表则会显示End temporary。&lt;/p&gt;\n&lt;h2 id=\&#34;loosescan\&#34;&gt;LooseScan&lt;/h2&gt;\n&lt;p&gt;在将IN子查询转换为半连接时，如果采用的是LooseScan执行策略，则驱动表执行计划的Extra列就显示LooseScan提示。&lt;/p&gt;\n&lt;h2 id=\&#34;firstmatchtable_name\&#34;&gt;FirstMatch(table_name)&lt;/h2&gt;\n&lt;p&gt;在将IN子查询转换为半连接时，如果采用的是FirstMatch执行策略，则被驱动表执行计划的Extra列就显示FirstMatch提示。&lt;/p&gt;\n&lt;h1 id=\&#34;建表和1w条数据\&#34;&gt;建表和1w条数据&lt;/h1&gt;\n&lt;h2 id=\&#34;表\&#34;&gt;表&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;CREATE TABLE s1 (\n    id INT NOT NULL AUTO_INCREMENT,\n    key1 VARCHAR(100),\n    key2 INT,\n    key3 VARCHAR(100),\n    key_part1 VARCHAR(100),\n    key_part2 VARCHAR(100),\n    key_part3 VARCHAR(100),\n    common_field VARCHAR(100),\n    PRIMARY KEY (id),\n    KEY idx_key1 (key1),\n    UNIQUE KEY idx_key2 (key2),\n    KEY idx_key3 (key3),\n    KEY idx_key_part(key_part1, key_part2, key_part3)\n) Engine=InnoDB CHARSET=utf8;\n\nCREATE TABLE s2 (\n    id INT NOT NULL AUTO_INCREMENT,\n    key1 VARCHAR(100),\n    key2 INT,\n    key3 VARCHAR(100),\n    key_part1 VARCHAR(100),\n    key_part2 VARCHAR(100),\n    key_part3 VARCHAR(100),\n    common_field VARCHAR(100),\n    PRIMARY KEY (id),\n    KEY idx_key1 (key1),\n    UNIQUE KEY idx_key2 (key2),\n    KEY idx_key3 (key3),\n    KEY idx_key_part(key_part1, key_part2, key_part3)\n) Engine=InnoDB CHARSET=utf8;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;插入数据\&#34;&gt;插入数据&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;\ndelimiter $\ncreate procedure insertNData(n int)\nbegin\n    declare total int default 0;\n    declare num int default 1;\n    while total &amp;lt;= n\n        do\n            set total = total + 1;\n            set num = num + 1;\n            INSERT INTO xiaohaizi.s1 (id, key1, key2, key3, key_part1, key_part2, key_part3, common_field)\n            VALUES (null, substring(md5(rand()), 1, 10), floor(rand() * 100000000), substring(md5(rand()), 1, 10),\n                    substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10),\n                    substring(md5(rand()), 1, 10));\n            INSERT INTO xiaohaizi.s2 (id, key1, key2, key3, key_part1, key_part2, key_part3, common_field)\n            VALUES (null, substring(md5(rand()), 1, 10), floor(rand() * 100000000), substring(md5(rand()), 1, 10),\n                    substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10), substring(md5(rand()), 1, 10),\n                    substring(md5(rand()), 1, 10));\n        end while;\n    select count(*) from xiaohaizi.s1;\nend $\n\ncall insertNData(10000) $\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-explain-xiang-jie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL Explain 详解&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-02-27 15:50:25&#34;,&#34;dateFormat&#34;:&#34;2022-02-27&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-explain-xiang-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;25 min read&#34;,&#34;time&#34;:1497000,&#34;words&#34;:5279,&#34;minutes&#34;:25},&#34;description&#34;:&#34;详细讲解每一列的作用，当做字典查看。\n前置知识\n半连接\n子查询物化\n索引合并\ntable\n无论查询语句中包含多少张表，最终都会转换为对单表的访问，所以EXPLAIN语句输出的每条记录都对应着对单表的访问方法，也即table列代表着表名。\n普...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86\&#34;&gt;前置知识&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%8A%E8%BF%9E%E6%8E%A5\&#34;&gt;半连接&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%89%A9%E5%8C%96\&#34;&gt;子查询物化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6\&#34;&gt;索引合并&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#table\&#34;&gt;table&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%99%AE%E9%80%9A%E5%8D%95%E8%A1%A8\&#34;&gt;普通单表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%99%AE%E9%80%9A%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2\&#34;&gt;普通连接查询&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#id\&#34;&gt;id&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%99%AE%E9%80%9A%E5%8D%95id\&#34;&gt;普通单id&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%8D%E6%9D%82%E8%BF%9E%E6%8E%A5%E8%AF%AD%E5%8F%A5\&#34;&gt;复杂连接语句&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%BD%AC%E8%BF%9E%E6%8E%A5\&#34;&gt;语句优化（子查询转连接）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%BB%E9%87%8D%E4%B8%B4%E6%97%B6%E8%A1%A8\&#34;&gt;去重临时表&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#select_type\&#34;&gt;select_type&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#simple\&#34;&gt;SIMPLE&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#primary\&#34;&gt;PRIMARY&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#union\&#34;&gt;UNION&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#union-result\&#34;&gt;UNION RESULT&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#subquery\&#34;&gt;SUBQUERY&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dependent-subquery\&#34;&gt;DEPENDENT SUBQUERY&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dependent-union\&#34;&gt;DEPENDENT UNION&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#derived\&#34;&gt;DERIVED&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#materialized\&#34;&gt;MATERIALIZED&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#uncacheable-subquery-uncacheable-union\&#34;&gt;UNCACHEABLE SUBQUERY、UNCACHEABLE UNION&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#partitions\&#34;&gt;partitions&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#type\&#34;&gt;type&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#system\&#34;&gt;system&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#const\&#34;&gt;const&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#eq_ref\&#34;&gt;eq_ref&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ref\&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#fulltext\&#34;&gt;fulltext&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ref_or_null\&#34;&gt;ref_or_null&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#index_merge\&#34;&gt;index_merge&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#unique_subquery\&#34;&gt;unique_subquery&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#index_subquery\&#34;&gt;index_subquery&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#range\&#34;&gt;range&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#index\&#34;&gt;index&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#all\&#34;&gt;all&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#possible_keys-key\&#34;&gt;possible_keys、key&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#key_len\&#34;&gt;key_len&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ref-2\&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rows\&#34;&gt;rows&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#filtered\&#34;&gt;filtered&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#extra\&#34;&gt;Extra&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#no-tables-used\&#34;&gt;No tables used&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#impossible-where\&#34;&gt;Impossible WHERE&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#no-matching-minmax-row\&#34;&gt;No matching min/max row&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#using-index\&#34;&gt;Using index&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#using-index-condition\&#34;&gt;Using index condition&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#using-where\&#34;&gt;Using where&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#using-join-bufferblock-nested-loop\&#34;&gt;Using join buffer（Block Nested Loop）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#using-intersect-using-union%E5%92%8Cusing-sort_union\&#34;&gt;Using intersect(...)、Using union(...)和Using sort_union(...)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#zero_limit\&#34;&gt;zero_limit&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#using-filesort\&#34;&gt;Using filesort&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#using-temporary\&#34;&gt;Using temporary&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#start-temporaryend-temporary\&#34;&gt;Start temporary，End temporary&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#loosescan\&#34;&gt;LooseScan&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#firstmatchtable_name\&#34;&gt;FirstMatch(table_name)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%BA%E8%A1%A8%E5%92%8C1w%E6%9D%A1%E6%95%B0%E6%8D%AE\&#34;&gt;建表和1w条数据&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A1%A8\&#34;&gt;表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\&#34;&gt;插入数据&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;const\&#34;&gt;const&lt;/h1&gt;\n&lt;p&gt;通过主键或者唯一二级索引列来定位一条记录的访问方法定义为const（常数级别，代价忽略不计）。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT * FROM t WHERE id = xx;\nSELECT * FROM t WHERE 唯一索引column = xx;\n\n唯一索引A(列A，列B)\nSELECT * FROM t WHERE 列A = xx AND 列B = xx;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;例外：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;WHERE 唯一索引column IS NULL，因为唯一索引不限制NULL值数量，所以会扫描出多条记录，否则最多只是ref&lt;/li&gt;\n&lt;li&gt;多列唯一索引时，只有多列全匹配才会是const，否则最多只是ref&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;ref\&#34;&gt;ref&lt;/h1&gt;\n&lt;p&gt;采用二级索引来执行查询的方法称为ref。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT * FROM t WHERE 普通二级索引column = xx;\nSELECT * FROM t WHERE 普通二级索引column IS NULL;\n\n唯一索引A(列A，列B)\nSELECT * FROM t WHERE 列A = xx;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;ref_or_null\&#34;&gt;ref_or_null&lt;/h1&gt;\n&lt;p&gt;ref_or_null访问方法只是比ref方法多扫描了一些值为NULL的二级索引记录。&lt;br&gt;\n值为NULL的记录会被放在索引的最左边。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT * FROM t WHERE 普通二级索引column = xx OR 普通二级索引column IS NULL;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;range\&#34;&gt;range&lt;/h1&gt;\n&lt;p&gt;使用索引查询时，对应的扫描区间为若干个单点扫描区间或者范围扫描区间时，访问方法称为range。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT * FROM t WHERE key1 IN (111,222) OR (key2 &amp;gt; 22 AND key2 &amp;lt;33)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;只有单个扫描区间不能称为range。&lt;/li&gt;\n&lt;li&gt;扫描区间为(-∞, +∞)也不能称为range。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;index\&#34;&gt;index&lt;/h1&gt;\n&lt;p&gt;由于二级索引比聚簇索引小得多（聚簇索引要存储记录，二级索引只需要存储索引列和主键），而且这个过程不用执行回表操作，所以&lt;strong&gt;直接扫描全部的二级索引的访问方法称为index方法。&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;联合索引A(key1, key2, key3)\nSELECT key2,key3 FROM t WHERE k1 = xx;\n\n聚簇索引排序\nSELECT * FROM t ORDER BY id;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;all\&#34;&gt;all&lt;/h1&gt;\n&lt;p&gt;全表扫描，直接扫描全部的聚簇索引记录。称为all访问方法。&lt;/p&gt;\n&lt;h1 id=\&#34;eq_ref\&#34;&gt;eq_ref&lt;/h1&gt;\n&lt;p&gt;在单表中使用主键值或唯一二级索引列的值进行等值查询的方式称为const。&lt;br&gt;\n在连接查询中使用主键值或唯一二级索引列的值进行等值查询的方式称为eq_ref。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-dan-biao-lian-jie-fang-wen-fang-fa&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL单表/连接访问方法&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-02-26 22:56:08&#34;,&#34;dateFormat&#34;:&#34;2022-02-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-dan-biao-lian-jie-fang-wen-fang-fa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:128000,&#34;words&#34;:541,&#34;minutes&#34;:3},&#34;description&#34;:&#34;const\n通过主键或者唯一二级索引列来定位一条记录的访问方法定义为const（常数级别，代价忽略不计）。\nSELECT * FROM t WHERE id = xx;\nSELECT * FROM t WHERE 唯一索引column = ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#const\&#34;&gt;const&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ref\&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ref_or_null\&#34;&gt;ref_or_null&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#range\&#34;&gt;range&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#index\&#34;&gt;index&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#all\&#34;&gt;all&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#eq_ref\&#34;&gt;eq_ref&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;go 1.16版本开始，支持将静态资源文件打包至二进制文件啦~，在1.16版本之前，开源界提供了很多方案，终于在此版本官方提供了统一的解决方案。具体使用见官方文档：https://pkg.go.dev/embed&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;import _ &amp;quot;embed&amp;quot;\n\n//go:embed hello.txt\nvar s string\nprint(s)\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;go-xin-te-xing-embed&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Go 新特性 embed&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Go&#34;,&#34;slug&#34;:&#34;OlQxAV0hi&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/OlQxAV0hi/&#34;}],&#34;date&#34;:&#34;2021-12-02 19:38:44&#34;,&#34;dateFormat&#34;:&#34;2021-12-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/go-xin-te-xing-embed/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:21000,&#34;words&#34;:88,&#34;minutes&#34;:1},&#34;description&#34;:&#34;go 1.16版本开始，支持将静态资源文件打包至二进制文件啦~，在1.16版本之前，开源界提供了很多方案，终于在此版本官方提供了统一的解决方案。具体使用见官方文档：https://pkg.go.dev/embed\nimport _ &amp;quo...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;MySQL InnoDB通过多版本并发控制，对每一行记录都写入3个隐藏字段（TRX_ID、ROLL_POINT、ROW_ID），使&lt;code&gt;可重复读&lt;/code&gt;隔离级别下达到&lt;code&gt;事务开启且创建快照后其他任何其他事务的更新均对其不可见&lt;/code&gt;，至于其内部具体如何实现的，则通过下面的文章进行记录。&lt;/p&gt;\n&lt;h1 id=\&#34;四种事务隔离界别及解决的问题\&#34;&gt;四种事务隔离界别及解决的问题&lt;/h1&gt;\n&lt;p&gt;首先需要回顾下MySQL的四种事务隔离级别，以及其为了解决的问题。&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;级别&lt;/th&gt;\n&lt;th&gt;symbol&lt;/th&gt;\n&lt;th&gt;描述&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;读未提交&lt;/td&gt;\n&lt;td&gt;READ-UNCOMMITTED&lt;/td&gt;\n&lt;td&gt;存在脏读、不可重复读、幻读的问题&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;读已提交&lt;/td&gt;\n&lt;td&gt;READ-COMMITTED&lt;/td&gt;\n&lt;td&gt;解决脏读的问题，存在不可重复读、幻读的问题&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;可重复读&lt;/td&gt;\n&lt;td&gt;REPEATABLE-READ&lt;/td&gt;\n&lt;td&gt;mysql 默认级别，解决脏读、不可重复读的问题，存在幻读的问题。使用 MMVC机制 实现可重复读&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;序列化&lt;/td&gt;\n&lt;td&gt;SERIALIZABLE&lt;/td&gt;\n&lt;td&gt;解决脏读、不可重复读、幻读，可保证事务安全，但完全串行执行，性能最低&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;MySQL的可重复读解决了脏读、不可重复读问题，但通过MVCC并未解决幻读问题，幻读是结合next-key-lock（间隙锁）来实现的。关于此处内容文章&lt;a href=\&#34;https://segmentfault.com/a/1190000016566788\&#34;&gt;mysql 幻读的详解、实例及解决办法&lt;/a&gt;讲得不错。&lt;/p&gt;\n&lt;h1 id=\&#34;概念\&#34;&gt;概念&lt;/h1&gt;\n&lt;p&gt;TrxId = 当前记录（行数据）最后被修改的事务id&lt;br&gt;\nUpId = 当前活跃最小事务id&lt;br&gt;\nLowLimitId = 下一个即将分配的事务id（当前最大事务Id+1）&lt;br&gt;\n活跃事务列表 = 当前所有开启了事务但未提交的事务。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;如果当前记录最后被修改的事务id 小于 最小活跃事务id（当前所有活跃会话开启前事务提交的数据）  或者 当前记录最后被修改的事务id 和 当前事务id 相等（自己在当前事务下更新过该记录的数据）， 则可见&lt;/li&gt;\n&lt;li&gt;当前记录最后被修改的事务id 大于等于 下一个即将被分配的事务id（low-limit-id是开启快照读时生成，当low-limit-id小于TRX_ID则说明此数据在当前快照创建后已修改，此数据不可见需要继续通过RollId往上找），则不可见，通过回滚指针继续向上找。&lt;/li&gt;\n&lt;li&gt;当前记录最后被修改的事务id 在 活跃事务列表（活跃事务列表是开启快照读时生成，则说明是该事务创建时已经在活跃的事务） 中，则不可见，通过回滚指针继续向上找。&lt;/li&gt;\n&lt;li&gt;其他所有情况，都可见&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2021/11/v8l8t51cssjm3rfassbhrg223b.jpg\&#34; alt=\&#34;可重复读隔离级别下算法\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;前提条件\&#34;&gt;前提条件&lt;/h1&gt;\n&lt;p&gt;基于MySQL 的 &lt;code&gt;可重复读&lt;/code&gt; 隔离级别下。&lt;/p&gt;\n&lt;p&gt;快照读只有在当前事务第一次执行读取操作（SELECT）后才会生成。&lt;br&gt;\n此时已经固定下来包括：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;活跃事务id列表&lt;/li&gt;\n&lt;li&gt;最小活跃最小事务id&lt;/li&gt;\n&lt;li&gt;下一个即将分配的事务id&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;但没有固定 当前记录最后被修改的事务id，此字段根据每次查询时当前记录最后被更新的事务来更新（永远读最新的）。&lt;/p&gt;\n&lt;h1 id=\&#34;场景分析\&#34;&gt;场景分析&lt;/h1&gt;\n&lt;h2 id=\&#34;场景一创建快照前的更新\&#34;&gt;场景一：创建快照前的更新&lt;/h2&gt;\n&lt;p&gt;同时开启4个事务，但事务2第一次快照读在事务4提交之后，故事务4的数据修改对于事务2可见。&lt;/p&gt;\n&lt;p&gt;结合流程图分析：&lt;/p&gt;\n&lt;p&gt;当前记录最后被修改事务id（TRX_ID）=4， upid=1，low-limit-id=5，当前事务id=2，&lt;br&gt;\n活跃事务列表=（1、2、3），不包含4，因为4已提交&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;TRX_ID &amp;lt; upId = false，TRX_ID = 当前事务id = false&lt;/li&gt;\n&lt;li&gt;TRX_ID &amp;gt;= low-limit-id = false&lt;/li&gt;\n&lt;li&gt;TRX_ID in 活跃事务列表 = false&lt;/li&gt;\n&lt;li&gt;上述条件均不支持，数据可见。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2021/11/74mf4guj58jdlpkrke5flael6q.jpg\&#34; alt=\&#34;可重复读隔离级别-场景1\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;场景二创建快照后开启事务的更新\&#34;&gt;场景二：创建快照后开启事务的更新&lt;/h2&gt;\n&lt;p&gt;开始只开启事务1和2、当事务2执行select之后（生成了快照读），再开启了事务3、4，事务4执行了update语句且进行了提交，事务4的更新对于事务2第二次select来说处于高水位，是不可见的。&lt;/p&gt;\n&lt;p&gt;结合流程图分析：&lt;/p&gt;\n&lt;p&gt;当前记录最后被修改事务id（TRX_ID）=4， upid=1，low-limit-id=3，当前事务id=2，&lt;br&gt;\n活跃事务列表=（1、2），不包含3、4，因为2的快照读是在第一个select时创建的，那是3、4还未开启事务。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;TRX_ID &amp;lt; upId = false，TRX_ID = 当前事务id = false&lt;/li&gt;\n&lt;li&gt;TRX_ID &amp;gt;= low-limit-id = true，符合，即不可见（其实就是高水位，是在当前快照之后创建的事务，当然不可见）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2021/11/sne9d6nnj4gc4rq562ga6bdsrf.jpg\&#34; alt=\&#34;可重复读隔离级别-场景2\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;场景三创建快照同时开启事务的更新\&#34;&gt;场景三：创建快照同时开启事务的更新&lt;/h2&gt;\n&lt;p&gt;同时开启4个事务，事务2初次执行select时已创建快照读，在后续事务4执行了update操作进行了提交，事务4的更新对于事务2第二次select来说处于高水位，是不可见的。&lt;/p&gt;\n&lt;p&gt;结合流程图分析：&lt;/p&gt;\n&lt;p&gt;当前记录最后被修改事务id（TRX_ID）=4， upid=1，low-limit-id=5，当前事务id=2，&lt;br&gt;\n活跃事务列表=（1、2、3、4）。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;TRX_ID &amp;lt; upId = false, TRX_ID = 当前事务id = false&lt;/li&gt;\n&lt;li&gt;TRX_ID &amp;gt;= low-limit-id = false&lt;/li&gt;\n&lt;li&gt;TRX_ID in 活跃事务列表 = true，即不可见，保证了事务2在两次select时的查询均是一致的，事务4的更新对于事务2来说永远不可见。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2021/11/sju3secjpmi85phpfv3khgs6bo.jpg\&#34; alt=\&#34;可重复读隔离级别-场景3\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;记录\&#34;&gt;记录&lt;/h1&gt;\n&lt;p&gt;本文基于慕课网课程&lt;a href=\&#34;https://www.imooc.com/learn/1309\&#34;&gt;探秘 MySQL 多版本并发控制原理&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;duo-ban-ben-bing-fa-kong-zhi-yuan-li-fen-xi-zhi-shu-ju-ke-jian-xing-suan-fa&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;多版本并发控制原理分析之数据可见性算法&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-11-14 21:22:48&#34;,&#34;dateFormat&#34;:&#34;2021-11-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/duo-ban-ben-bing-fa-kong-zhi-yuan-li-fen-xi-zhi-shu-ju-ke-jian-xing-suan-fa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:296000,&#34;words&#34;:1344,&#34;minutes&#34;:5},&#34;description&#34;:&#34;MySQL InnoDB通过多版本并发控制，对每一行记录都写入3个隐藏字段（TRX_ID、ROLL_POINT、ROW_ID），使可重复读隔离级别下达到事务开启且创建快照后其他任何其他事务的更新均对其不可见，至于其内部具体如何实现的，则通过...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%95%8C%E5%88%AB%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;四种事务隔离界别及解决的问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E5%BF%B5\&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6\&#34;&gt;前提条件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90\&#34;&gt;场景分析&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%BA%E6%99%AF%E4%B8%80%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E5%89%8D%E7%9A%84%E6%9B%B4%E6%96%B0\&#34;&gt;场景一：创建快照前的更新&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%BA%E6%99%AF%E4%BA%8C%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E5%90%8E%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9B%B4%E6%96%B0\&#34;&gt;场景二：创建快照后开启事务的更新&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%BA%E6%99%AF%E4%B8%89%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E5%90%8C%E6%97%B6%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9B%B4%E6%96%B0\&#34;&gt;场景三：创建快照同时开启事务的更新&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%B0%E5%BD%95\&#34;&gt;记录&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;初始化数据库\&#34;&gt;初始化数据库&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;CREATE TABLE `xiaohaizi_second_table` (\n  `c1` int unsigned NOT NULL AUTO_INCREMENT,\n  `c2` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  `c3` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,\n  PRIMARY KEY (`c1`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&#39;学习小孩子-insert-into-select测试&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;查询结果插入数据\&#34;&gt;查询结果插入数据&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;INSERT INTO table_name(c1, c2, c3) SELECT c1, c2, c3 FROM table_name2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;查询结果插入数据-如果遇到-唯一约束-则跳过\&#34;&gt;查询结果，插入数据， 如果遇到 唯一约束， 则跳过&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;INSERT IGNORE INTO table_name(c1, c2, c3) SELECT c1, c2, c3 FROM table_name2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;查询结果插入数据如果遇到-唯一约束-则更新\&#34;&gt;查询结果，插入数据，如果遇到 唯一约束， 则更新&lt;/h1&gt;\n&lt;h2 id=\&#34;冲突更新单列\&#34;&gt;冲突更新单列：&lt;/h2&gt;\n&lt;p&gt;假设c1列具有唯一索引，插入数据(1, ‘xx’, ‘yy’)，如果c1列已存在c1=1的数据，则将此列的c2字段更新为’hhh’&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;INSERT INTO table_name(c1, c2, c3) VALUES(1, ‘xx’, ‘yy’) ON DUPLICATE KEY UPDATE c2 = ‘hhh&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;冲突更新多列\&#34;&gt;冲突更新多列：&lt;/h2&gt;\n&lt;p&gt;假设c1列具有唯一索引，插入数据(1, ‘xx’, ‘yy’)，如果c1列已存在c1=1的数据，则将此列的c2字段更新为待插入行中对应列的数据。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;INSERT INTO table_name ( c1, c2, c3 )\nVALUES\n\t( 1, &amp;quot;xx1&amp;quot;, &amp;quot;yy1&amp;quot; ),\n\t( 2, &amp;quot;xxx2&amp;quot;, &amp;quot;yyy2&amp;quot; ) \n\tON DUPLICATE KEY UPDATE c2 =\nVALUES\n\t( c2 ),\n\tc3 =\nVALUES\n\t( c3 );\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-insert-into-select&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL INSERT INTO SELECT&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-08-11 21:41:38&#34;,&#34;dateFormat&#34;:&#34;2021-08-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-insert-into-select/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:79000,&#34;words&#34;:280,&#34;minutes&#34;:2},&#34;description&#34;:&#34;初始化数据库\nCREATE TABLE `xiaohaizi_second_table` (\n  `c1` int unsigned NOT NULL AUTO_INCREMENT,\n  `c2` varchar(255) CHARACTE...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93\&#34;&gt;初始化数据库&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\&#34;&gt;查询结果插入数据&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-%E5%A6%82%E6%9E%9C%E9%81%87%E5%88%B0-%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F-%E5%88%99%E8%B7%B3%E8%BF%87\&#34;&gt;查询结果，插入数据， 如果遇到 唯一约束， 则跳过&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%A6%82%E6%9E%9C%E9%81%87%E5%88%B0-%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F-%E5%88%99%E6%9B%B4%E6%96%B0\&#34;&gt;查询结果，插入数据，如果遇到 唯一约束， 则更新&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%B2%E7%AA%81%E6%9B%B4%E6%96%B0%E5%8D%95%E5%88%97\&#34;&gt;冲突更新单列：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%B2%E7%AA%81%E6%9B%B4%E6%96%B0%E5%A4%9A%E5%88%97\&#34;&gt;冲突更新多列：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;介绍\&#34;&gt;介绍&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1722136355320.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。&lt;br&gt;\nArthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。&lt;/p&gt;\n&lt;h2 id=\&#34;arthas能为我们解决哪些问题\&#34;&gt;Arthas能为我们解决哪些问题&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？&lt;/li&gt;\n&lt;li&gt;我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？&lt;/li&gt;\n&lt;li&gt;遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？&lt;/li&gt;\n&lt;li&gt;线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！&lt;/li&gt;\n&lt;li&gt;是否有一个全局视角来查看系统的运行状况？&lt;/li&gt;\n&lt;li&gt;有什么办法可以监控到JVM的实时运行状态？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;与skywalking的区别\&#34;&gt;与SkyWalking的区别&lt;/h2&gt;\n&lt;p&gt;Skywalking是一个可观测性分析平台（Observability Analysis Platform，OAP）和一个应用性能管理（Application Performance Management，APM）系统。&lt;/p&gt;\n&lt;h1 id=\&#34;quick-start\&#34;&gt;Quick Start&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;启动本地Java进程 （实例工程，空SpringBoot项目）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;下载arthas-boot curl -O https://arthas.aliyun.com/arthas-boot.jar，此步骤仅完成基础包下载，大小为139K上下&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;执行命令 java -jar arthas-boot.jar，选择需要attch的Java进程，进入arthas的命令界面&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136365937.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;基本操作（官网入门示例）&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;dashboard\&#34;&gt;dashboard&lt;/h3&gt;\n&lt;p&gt;执行dashboard，将展示当前进程的信息。如图：&lt;br&gt;\n通过此命令可以查看JVM的堆内存情况，以及活跃线程、JVM基本信息等内容。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136372698.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;jad反编译代码\&#34;&gt;jad反编译代码&lt;/h3&gt;\n&lt;p&gt;通过jad指令，反编译class&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136380342.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;watch方法执行数据观测查看函数入参和返回值\&#34;&gt;watch方法执行数据观测（查看函数入参和返回值）&lt;/h3&gt;\n&lt;p&gt;通过模拟对入参 *2 的程序，反应watch的强大。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1722136387106.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;通过watch命令，监听方法的一切行为。watch的参数比较多，以下摘抄自官网：&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;class-pattern&lt;/th&gt;\n&lt;th&gt;类名表达式匹配&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;method-pattern&lt;/td&gt;\n&lt;td&gt;方法名表达式匹配&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;express&lt;/td&gt;\n&lt;td&gt;观察表达式&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;condition-express&lt;/td&gt;\n&lt;td&gt;条件表达式&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[b]&lt;/td&gt;\n&lt;td&gt;在方法调用之前观察&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[e]&lt;/td&gt;\n&lt;td&gt;在方法异常之后观察&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[s]&lt;/td&gt;\n&lt;td&gt;在方法返回之后观察&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[f]&lt;/td&gt;\n&lt;td&gt;在方法结束之后(正常返回和异常返回)观察&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[E]&lt;/td&gt;\n&lt;td&gt;开启正则表达式匹配，默认为通配符匹配&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[x:]&lt;/td&gt;\n&lt;td&gt;指定输出结果的属性遍历深度，默认为 1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1722136394130.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;monitor方法执行监控什么时候执行了\&#34;&gt;monitor方法执行监控（什么时候执行了）&lt;/h3&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;参数名称&lt;/th&gt;\n&lt;th&gt;参数说明&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;class-pattern&lt;/td&gt;\n&lt;td&gt;类名表达式匹配&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;method-pattern&lt;/td&gt;\n&lt;td&gt;方法名表达式匹配&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;condition-express&lt;/td&gt;\n&lt;td&gt;条件表达式&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[E]&lt;/td&gt;\n&lt;td&gt;开启正则表达式匹配，默认为通配符匹配&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[c:]&lt;/td&gt;\n&lt;td&gt;统计周期，默认值为120秒&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;[b]&lt;/td&gt;\n&lt;td&gt;在方法调用之前计算condition-express&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;&lt;code&gt;monitor -c 5 top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController index&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;每5秒监听一次，统计耗时、失败率、总次数、成功次数、失败次数等信息&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136401218.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;通过表达式过滤不需要的请求方法调用。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136409477.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;trace方法内部调用路径输出方法路径上的节点耗时我调用了谁\&#34;&gt;trace方法内部调用路径，输出方法路径上的节点耗时（我调用了谁）&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;trace top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController index&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;因为代价比较高（这属于skywarking的工作范围），trace默认只支持一层的耗时分析。但官网提供了多层trace的方法，具体见：https://arthas.aliyun.com/doc/trace.html&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1722136417885.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136422365.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;stack方法输出当前方法被调用的调用路径谁调用了我\&#34;&gt;stack方法输出当前方法被调用的调用路径（谁调用了我）&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;stack top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController getResult -n 3&lt;/code&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1722136451605.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;tt 记录方法请求的信息，方便重做请求和查看结果&lt;br&gt;\n方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测&lt;br&gt;\nwatch指令复杂，通过tt记录请求的信息后面可以针对性分析&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1722136456891.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;2-进阶操作\&#34;&gt;2. 进阶操作&lt;/h2&gt;\n&lt;h3 id=\&#34;热加载代码\&#34;&gt;热加载代码&lt;/h3&gt;\n&lt;p&gt;首先声明：在生产环境热更新代码是不很不好的行为。&lt;br&gt;\n但是肯定有它使用的场景。&lt;/p&gt;\n&lt;p&gt;涉及到几个命令：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;jad（反编译指定已加载类的源码）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;sc（查看JVM已加载的类信息）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;mc（内存编译器，内存编译.java文件为.class文件）、&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;redefine（加载外部的.class文件，redefine到JVM里）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;jad反编译代码，vim调整代码逻辑&lt;br&gt;\n&lt;code&gt;jad --source-only top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController &amp;gt; /tmp/IndexController.java&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136462341.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过 sc 命令，找到类加载器&lt;br&gt;\n&lt;code&gt;sc -d *IndexController&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136467677.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过 mc 内存编译java -&amp;gt; class&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;code&gt;mc -c 31221be2 /tmp/IndexController.java -d /tmp&lt;/code&gt;&lt;/p&gt;\n&lt;ol start=\&#34;4\&#34;&gt;\n&lt;li&gt;通过 redefine 热加载&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;code&gt;redefine /tmp/top/imyzt/learning/arthas/arthaswebdemo/web/controller/IndexController.class&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;全流程&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136472731.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;profiler图\&#34;&gt;profiler🔥图&lt;/h2&gt;\n&lt;p&gt;通过 profiler start/stop 获得一份程序的火焰图&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136500580.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136504657.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;火焰图查看工具\&#34;&gt;火焰图查看工具&lt;/h3&gt;\n&lt;p&gt;JDK JMC：https://github.com/openjdk/jmc&lt;br&gt;\nJProfiler(付费)： https://www.ej-technologies.com/download/jprofiler/files&lt;/p&gt;\n&lt;h3 id=\&#34;如何读懂火焰图\&#34;&gt;如何读懂火焰图？&lt;/h3&gt;\n&lt;p&gt;如何读懂火焰图? - 阮一峰的网络日志&lt;br&gt;\n使用arthas+jprofiler做复杂链路分析 · Issue #1416 · alibaba/arthas&lt;/p&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;进阶使用&amp;amp;命令列表&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;a href=\&#34;https://arthas.aliyun.com/doc/advanced-use.html\&#34;&gt;https://arthas.aliyun.com/doc/advanced-use.html&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;https://arthas.aliyun.com/doc/commands.html\&#34;&gt;https://arthas.aliyun.com/doc/commands.html&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;常用使用场景分析和讨论\&#34;&gt;常用使用场景分析和讨论&lt;/h1&gt;\n&lt;p&gt;同传统方式进行对比，最大的目的是为了解决目前低效的生产环境问题排查方式。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;通过watch观察方法入参，是否可以客户反馈使用出了问题，但是又不知道小程序发过来的请求具体是啥？&lt;/li&gt;\n&lt;li&gt;通过stack观察，某个方法什么时候被调用了，被谁调用了？&lt;/li&gt;\n&lt;li&gt;通过tt记录请求信息，便于重做请求，模拟用户操作？&lt;/li&gt;\n&lt;li&gt;通过后台异步任务，观察定时周期出现问题的代码，阿里描述：当线上出现偶发的问题，比如需要watch某个条件，而这个条件一天可能才会出现一次时，异步后台任务就派上用场了，详情请参考这里&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;以上描述的操作虽然能解决很多问题，但是是否面临着一个更大的问题？&lt;/p&gt;\n&lt;h1 id=\&#34;适合生产环境的实践\&#34;&gt;适合生产环境的实践&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;Web_Console&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;在attrch成功之后，直接访问本地3658端口，可以通过web界面操作。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136520274.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n默认情况下，arthas只listen 127.0.0.1，所以如果想从远程连接，则可以使用 --target-ip参数指定listen的IP。&lt;/p&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;Tunnel Server&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;下载arthas-tunnel-server，本地java -jar启动，Web界面监听8080端口，WebSocket通信监听7777端口。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136525447.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;java -jar arthas-boot.jar --tunnel-server &#39;ws://127.0.0.1:7777/ws&#39;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136531162.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;可以通过http://127.0.0.1:8080/actuator/arthas访问本地，获得已连接到tunnel-server的arthas-client。密码在启动控制台。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136536317.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136540359.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;通过上面的操作，虽然免去了去生产环境机器直接操作arthas这种不现实的问题，但是在Web界面操作还有一个问题，就是谁给我们绑定执行 java -jar arthas-boot.jar --tunnel-server &#39;ws://127.0.0.1:7777/ws&#39; 这个命令呢.......&lt;/p&gt;\n&lt;h1 id=\&#34;与springboot集成更适合生产环境的实践\&#34;&gt;与SpringBoot集成，更适合生产环境的实践&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;增加Maven依赖&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;com.taobao.arthas&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;arthas-spring-boot-starter&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt;\n&amp;lt;/dependency&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;调整配置文件&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;server.port=8892\n\nspring.application.name=arthas-demo\n\n# 建议不指定, 会根据 spring.application.name 生成\n#arthas.agent-id=arthas-demo\narthas.tunnel-server=ws://localhost:7777/ws\n# -1会随机分配端口\narthas.http-port=-1\narthas.telnet-port=-1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;\n&lt;p&gt;查看agentId&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136547923.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;tunnel-server连接后操作&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1722136552794.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;对性能的影响\&#34;&gt;对性能的影响&lt;/h2&gt;\n&lt;p&gt;通过spring-boot-starter的方式，在应用启动时，就对进程自动完成了attach，对于性能方面的影响是不大的，下面有两个官方的回复，从原理是解释了这个问题。&lt;/p&gt;\n&lt;h2 id=\&#34;开发团队回复\&#34;&gt;开发团队回复：&lt;/h2&gt;\n&lt;p&gt;目前arthas-spring-boot-starter方式是长期启动状态，对程序的性能有什么影响吗？ · Issue #1843 · alibaba/arthas&lt;br&gt;\n是否进行过性能评估，attach之后对原进程性能有多大的影响呢 · Issue #44 · alibaba/arthas&lt;/p&gt;\n&lt;h1 id=\&#34;如何记住各种命令\&#34;&gt;如何记住各种命令&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://arthas.aliyun.com/doc/idea-plugin.html\&#34;&gt;https://arthas.aliyun.com/doc/idea-plugin.html&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;遇到的一些坑\&#34;&gt;遇到的一些坑&lt;/h1&gt;\n&lt;h2 id=\&#34;pid1无法attach\&#34;&gt;Pid=1无法Attach&lt;/h2&gt;\n&lt;p&gt;linux保护机制，jstack无法attach住pid&amp;lt;=5的进程，arthas也无法使用，通用解决方案是使用tini挂载java进程。&lt;br&gt;\n&lt;a href=\&#34;https://github.com/alibaba/arthas/issues/362\&#34;&gt;https://github.com/alibaba/arthas/issues/362&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;arthas端口问题\&#34;&gt;Arthas端口问题&lt;/h2&gt;\n&lt;p&gt;应用被Arthas-Boot attch之后，包括应用本身的端口，同时还会监听另外两个端口：&lt;br&gt;\n默认情况下，Arthas的Telnet端口是3658，HTTP端口是8563，这个常常让用户迷惑。在新版本里，在3658端口同时支持Telnet/HTTP协议。&lt;br&gt;\n在浏览器里访问 http://localhost:3658/ 也可以访问到Web Console了。&lt;br&gt;\n在后续的版本里，考虑默认只侦听 3658端口，减少用户的配置项。&lt;/p&gt;\n&lt;p&gt;当启动tunnel-server后，8080与7777端口也被监听。&lt;/p&gt;\n&lt;h2 id=\&#34;与skywalking的兼容性问题\&#34;&gt;与Skywalking的兼容性问题&lt;/h2&gt;\n&lt;p&gt;java.lang.ClassFormatError: null、skywalking arthas 兼容使用&lt;br&gt;\n当出现这个错误日志java.lang.ClassFormatError: null,通常情况下都是被其他字节码工具修改过与arthas修改字节码不兼容。&lt;br&gt;\n比如: 使用 skywalking V8.1.0 以下版本 无法trace、watch 被skywalking agent 增强过的类, V8.1.0 以上版本可以兼容使用,更多参考skywalking配置 skywalking compatible with other javaagent bytecode processing。&lt;/p&gt;\n&lt;h2 id=\&#34;jvm版本问题\&#34;&gt;JVM版本问题&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/alibaba/arthas/issues/1519\&#34;&gt;启动Arthas的Java版本和启动应用的Java版本要保持一致&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;推荐文章\&#34;&gt;推荐文章&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;Arthas源码学习-1_慢一拍的coder-CSDN博客&lt;/li&gt;\n&lt;li&gt;Arthas Tutorials&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s/NZ5k9htzaak-yMR0UdCoZQ\&#34;&gt;工商银行打造在线诊断平台的探索与实践&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;arthas使用到的技术\&#34;&gt;Arthas使用到的技术&lt;/h1&gt;\n&lt;h2 id=\&#34;arthas运行原理\&#34;&gt;Arthas运行原理&lt;/h2&gt;\n&lt;p&gt;tt命令探究&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;执行 tt -t top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController index&lt;/li&gt;\n&lt;li&gt;下载正在运行的字节码文件 dump top.imyzt.learning.arthas.arthaswebdemo.web.controller.IndexController&lt;/li&gt;\n&lt;li&gt;查看字节码 javap -c -s -v -l xxx.class&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1722136338422.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;相关文章：&lt;a href=\&#34;https://juejin.cn/post/6904280021632974856\&#34;&gt;Arthas原理系列(四):字节码插装让一切变得有可能&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;arthas-zai-xiang-mu-kai-fa-zhong-de-ying-yong-xian-shang-gu-zhang-ding-wei&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Arthas在项目开发中的应用 - 线上故障定位&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Arthas&#34;,&#34;slug&#34;:&#34;8NNFU0jVs&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/8NNFU0jVs/&#34;}],&#34;date&#34;:&#34;2021-07-10 16:09:12&#34;,&#34;dateFormat&#34;:&#34;2021-07-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/arthas-zai-xiang-mu-kai-fa-zhong-de-ying-yong-xian-shang-gu-zhang-ding-wei/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:568000,&#34;words&#34;:2405,&#34;minutes&#34;:10},&#34;description&#34;:&#34;介绍\n\nArthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。\nArthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8B%E7%BB%8D\&#34;&gt;介绍&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#arthas%E8%83%BD%E4%B8%BA%E6%88%91%E4%BB%AC%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98\&#34;&gt;Arthas能为我们解决哪些问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8Eskywalking%E7%9A%84%E5%8C%BA%E5%88%AB\&#34;&gt;与SkyWalking的区别&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#quick-start\&#34;&gt;Quick Start&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#dashboard\&#34;&gt;dashboard&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jad%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81\&#34;&gt;jad反编译代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#watch%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%A7%82%E6%B5%8B%E6%9F%A5%E7%9C%8B%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC\&#34;&gt;watch方法执行数据观测（查看函数入参和返回值）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#monitor%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%9B%91%E6%8E%A7%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E4%BA%86\&#34;&gt;monitor方法执行监控（什么时候执行了）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#trace%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E8%B7%AF%E5%BE%84%E8%BE%93%E5%87%BA%E6%96%B9%E6%B3%95%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%80%97%E6%97%B6%E6%88%91%E8%B0%83%E7%94%A8%E4%BA%86%E8%B0%81\&#34;&gt;trace方法内部调用路径，输出方法路径上的节点耗时（我调用了谁）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#stack%E6%96%B9%E6%B3%95%E8%BE%93%E5%87%BA%E5%BD%93%E5%89%8D%E6%96%B9%E6%B3%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E8%B0%83%E7%94%A8%E8%B7%AF%E5%BE%84%E8%B0%81%E8%B0%83%E7%94%A8%E4%BA%86%E6%88%91\&#34;&gt;stack方法输出当前方法被调用的调用路径（谁调用了我）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C\&#34;&gt;2. 进阶操作&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%83%AD%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%A0%81\&#34;&gt;热加载代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#profiler%E5%9B%BE\&#34;&gt;profiler:fire:图&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%81%AB%E7%84%B0%E5%9B%BE%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7\&#34;&gt;火焰图查看工具&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E8%AF%BB%E6%87%82%E7%81%AB%E7%84%B0%E5%9B%BE\&#34;&gt;如何读懂火焰图？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%A8%E8%AE%BA\&#34;&gt;常用使用场景分析和讨论&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%82%E5%90%88%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%9E%E8%B7%B5\&#34;&gt;适合生产环境的实践&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8Espringboot%E9%9B%86%E6%88%90%E6%9B%B4%E9%80%82%E5%90%88%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%9E%E8%B7%B5\&#34;&gt;与SpringBoot集成，更适合生产环境的实践&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D\&#34;&gt;对性能的影响&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E5%9B%9E%E5%A4%8D\&#34;&gt;开发团队回复：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E8%AE%B0%E4%BD%8F%E5%90%84%E7%A7%8D%E5%91%BD%E4%BB%A4\&#34;&gt;如何记住各种命令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91\&#34;&gt;遇到的一些坑&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#pid1%E6%97%A0%E6%B3%95attach\&#34;&gt;Pid=1无法Attach&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#arthas%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98\&#34;&gt;Arthas端口问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8Eskywalking%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98\&#34;&gt;与Skywalking的兼容性问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jvm%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98\&#34;&gt;JVM版本问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0\&#34;&gt;推荐文章&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#arthas%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF\&#34;&gt;Arthas使用到的技术&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#arthas%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86\&#34;&gt;Arthas运行原理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在网络上找到的，在此代码备忘下&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;package util\n\nimport (\n\t&amp;quot;fmt&amp;quot;\n\t&amp;quot;io&amp;quot;\n\t&amp;quot;log&amp;quot;\n\t&amp;quot;os/exec&amp;quot;\n\t&amp;quot;strings&amp;quot;\n)\n\nfunc asyncLog(reader io.ReadCloser) error {\n\tbucket := make([]byte, 1024)\n\tbuffer := make([]byte, 100)\n\tfor {\n\t\tnum, err := reader.Read(buffer)\n\t\tif err != nil {\n\t\t\tif err == io.EOF || strings.Contains(err.Error(), &amp;quot;closed&amp;quot;) {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif num &amp;gt; 0 {\n\t\t\tline := &amp;quot;&amp;quot;\n\t\t\tbucket = append(bucket, buffer[:num]...)\n\t\t\ttmp := string(bucket)\n\t\t\tif strings.Contains(tmp, &amp;quot;\\n&amp;quot;) {\n\t\t\t\tts := strings.Split(tmp, &amp;quot;\\n&amp;quot;)\n\t\t\t\tif len(ts) &amp;gt; 1 {\n\t\t\t\t\tline = strings.Join(ts[:len(ts)-1], &amp;quot;\\n&amp;quot;)\n\t\t\t\t\tbucket = []byte(ts[len(ts)-1]) //不够整行的以后再处理\n\t\t\t\t} else {\n\t\t\t\t\tline = ts[0]\n\t\t\t\t\tbucket = bucket[:0]\n\t\t\t\t}\n\t\t\t\tfmt.Printf(&amp;quot;%s\\n&amp;quot;, line)\n\t\t\t}\n\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc Execute(shellPath string) error {\n\n\tcmd := exec.Command(&amp;quot;/bin/bash&amp;quot;, &amp;quot;-c&amp;quot;, shellPath)\n\n\tstdout, _ := cmd.StdoutPipe()\n\tstderr, _ := cmd.StderrPipe()\n\n\tif err := cmd.Start(); err != nil {\n\t\tlog.Printf(&amp;quot;Error starting command: %s......&amp;quot;, err.Error())\n\t\treturn err\n\t}\n\n\tgo asyncLog(stdout)\n\tgo asyncLog(stderr)\n\n\tif err := cmd.Wait(); err != nil {\n\t\tlog.Printf(&amp;quot;Error waiting for command execution: %s......&amp;quot;, err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;golang-zhi-xing-shell-bing-shi-shi-da-yin-shell-ri-zhi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Golang执行shell并实时打印shell日志&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-06-27 18:31:56&#34;,&#34;dateFormat&#34;:&#34;2021-06-27&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/golang-zhi-xing-shell-bing-shi-shi-da-yin-shell-ri-zhi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:77000,&#34;words&#34;:217,&#34;minutes&#34;:2},&#34;description&#34;:&#34;在网络上找到的，在此代码备忘下\npackage util\n\nimport (\n\t&amp;quot;fmt&amp;quot;\n\t&amp;quot;io&amp;quot;\n\t&amp;quot;log&amp;quot;\n\t&amp;quot;os/exec&amp;quot;\n\t&amp;quot;str...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Spring容器的的refresh()【创建刷新】&lt;/p&gt;\n&lt;h1 id=\&#34;refresh源码\&#34;&gt;refresh()源码&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;public void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        StartupStep contextRefresh = this.applicationStartup.start(&amp;quot;spring.context.refresh&amp;quot;);\n\n        // 刷新前的预处理\n        prepareRefresh();\n\n        // 获取BeanFactory\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n        // BeanFactory的预处理工作，对BeanFactory进行一些赋值设置\n        prepareBeanFactory(beanFactory);\n\n        try {\n            // BeanFactory准备工作完成后进行的后置处理工作\n            postProcessBeanFactory(beanFactory);\n            \n            StartupStep beanPostProcess = this.applicationStartup.start(&amp;quot;spring.context.beans.post-process&amp;quot;);\n            // 注册BeanFactory的后置处理器，执行BeanFactoryPostProcessor方法\n            invokeBeanFactoryPostProcessors(beanFactory);\n\n            // 注册Bean的后置处理器，用于拦截Bean的整个创建过程\n            registerBeanPostProcessors(beanFactory);\n            beanPostProcess.end();\n\n            // 初始化MessageSource组件（做国际化功能，消息绑定，消息解析）\n            initMessageSource();\n\n            // 初始化事件派发器\n            initApplicationEventMulticaster();\n\n            // 留给子容器（子类）重写，在刷新上下文时自定义逻辑\n            onRefresh();\n\n            // 将项目中所有的ApplicationListener注册到容器中\n            registerListeners();\n\n            // 初始化所有剩下的单实例bean\n            finishBeanFactoryInitialization(beanFactory);\n\n            // 完成BeanFactory的初始化创建工作，IOC容器就创建完成\n            finishRefresh();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;beanfactory的创建及预准备工作\&#34;&gt;BeanFactory的创建及预准备工作&lt;/h1&gt;\n&lt;h2 id=\&#34;1-preparerefresh-刷新前的预处理\&#34;&gt;1. prepareRefresh(); 刷新前的预处理&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;initPropertySources(); 初始化一些属性设置（空），子类可实现后自定义个性化的属性设置方法&lt;/li&gt;\n&lt;li&gt;getEnvironment().validateRequiredProperties(); 校验属性的合法等&lt;/li&gt;\n&lt;li&gt;this.earlyApplicationEvents = new LinkedHashSet&amp;lt;&amp;gt;(); 保存容器中的一些早期的事件&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;2-obtainfreshbeanfactory-获取beanfactory\&#34;&gt;2. obtainFreshBeanFactory(); 获取BeanFactory&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;refreshBeanFactory(); 刷新【创建】BeanFactory对象\n&lt;ol&gt;\n&lt;li&gt;创建一个bean工厂&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;    public GenericApplicationContext() {\n        this.beanFactory = new DefaultListableBeanFactory();\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;2. 设置id\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;getBeanFactory(); 返回刚才GenericApplicationContext创建的BeanFactory对象&lt;/li&gt;\n&lt;li&gt;将创建的BeanFactory【DefaultListableBeanFactory】返回&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;3-preparebeanfactorybeanfactory-beanfactory的预处理工作对beanfactory进行一些赋值设置\&#34;&gt;3. prepareBeanFactory(beanFactory); BeanFactory的预处理工作，对BeanFactory进行一些赋值设置&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;设置BeanFactory的类加载器、支持表达式解析器...&lt;/li&gt;\n&lt;li&gt;添加部分BeanPostProcessor【ApplicationContextAwareProcessor】&lt;/li&gt;\n&lt;li&gt;设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、ApplicationStartupAware&lt;/li&gt;\n&lt;li&gt;注册可以解析的自动装配，使我们能够在任何组件中自动注入(@Autowired)。BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext&lt;/li&gt;\n&lt;li&gt;添加部分BeanPostProcessor【ApplicationListenerDetector】&lt;/li&gt;\n&lt;li&gt;添加编译时的AspectJ&lt;/li&gt;\n&lt;li&gt;给BeanFactory注册一些能用的组件\n&lt;ol&gt;\n&lt;li&gt;environment ConfigurableEnvironment&lt;/li&gt;\n&lt;li&gt;systemProperties Map&amp;lt;String, Object&amp;gt;&lt;/li&gt;\n&lt;li&gt;systemEnvironment Map&amp;lt;String, Object&amp;gt;&lt;/li&gt;\n&lt;li&gt;applicationStartup ApplicationStartup&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;4-postprocessbeanfactorybeanfactory-beanfactory准备工作完成后进行的后置处理工作\&#34;&gt;4. postProcessBeanFactory(beanFactory); BeanFactory准备工作完成后进行的后置处理工作&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;子类可以重写此方法在BeanFactory创建并预准备完成以后做进一步的设置。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;beanfactory后面的流程\&#34;&gt;BeanFactory后面的流程&lt;/h1&gt;\n&lt;h2 id=\&#34;5-invokebeanfactorypostprocessorsbeanfactory-注册beanfactory的后置处理器执行beanfactorypostprocessor方法\&#34;&gt;5. invokeBeanFactoryPostProcessors(beanFactory); 注册BeanFactory的后置处理器，执行BeanFactoryPostProcessor方法&lt;/h2&gt;\n&lt;p&gt;源代码位于：PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors()&lt;/p&gt;\n&lt;p&gt;BeanFactoryPostProcessor:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;BeanFactory的后置处理器&lt;/li&gt;\n&lt;li&gt;在BeanFactory标准初始化之后执行&lt;/li&gt;\n&lt;li&gt;拥有两个接口\n&lt;ol&gt;\n&lt;li&gt;BeanFactoryPostProcessor&lt;/li&gt;\n&lt;li&gt;BeanDefinitionRegistryPostProcessor&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;执行beanfactorypostprocessor方法\&#34;&gt;执行BeanFactoryPostProcessor方法&lt;/h3&gt;\n&lt;p&gt;子接口[BeanDefinitionRegistryPostProcessor]具有最高优先级，其次再执行BeanFactoryPostProcessor的方法&lt;/p&gt;\n&lt;h4 id=\&#34;先执行beandefinitionregistrypostprocessor的方法\&#34;&gt;先执行BeanDefinitionRegistryPostProcessor的方法&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;获取所有的BeanDefinitionRegistryPostProcessor&lt;/li&gt;\n&lt;li&gt;先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor\n&lt;ol&gt;\n&lt;li&gt;postProcessor.postProcessBeanDefinitionRegistry(registry);&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor\n&lt;ol&gt;\n&lt;li&gt;postProcessor.postProcessBeanDefinitionRegistry(registry);&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;最后执行没有实现任何优先级或顺序接口的BeanDefinitionRegistryPostProcessor\n&lt;ol&gt;\n&lt;li&gt;postProcessor.postProcessBeanDefinitionRegistry(registry);&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;再执行beanfactorypostprocessor的方法\&#34;&gt;再执行BeanFactoryPostProcessor的方法&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;获取所有的BeanFactoryPostProcessor&lt;/li&gt;\n&lt;li&gt;先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor\n&lt;ol&gt;\n&lt;li&gt;postProcessor.postProcessBeanFactory(beanFactory);&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;再执行实现了Ordered顺序接口的BeanFactoryPostProcessor\n&lt;ol&gt;\n&lt;li&gt;postProcessor.postProcessBeanFactory(beanFactory);&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;最后执行没有实现任何优先级或顺序接口的BeanFactoryPostProcessor\n&lt;ol&gt;\n&lt;li&gt;postProcessor.postProcessBeanFactory(beanFactory);&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;6-registerbeanpostprocessorsbeanfactory-注册bean的后置处理器用于拦截bean的整个创建过程\&#34;&gt;6. registerBeanPostProcessors(beanFactory); 注册Bean的后置处理器，用于拦截Bean的整个创建过程&lt;/h2&gt;\n&lt;p&gt;源代码位于：PostProcessorRegistrationDelegate#registerBeanPostProcessors()&lt;/p&gt;\n&lt;p&gt;不同接口类型的BeanPostProcessor，在Bean创建前后的执行时机是不一样的&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;BeanPostProcessor&lt;/li&gt;\n&lt;li&gt;DestructionAwareBeanPostProcessor&lt;/li&gt;\n&lt;li&gt;InstantiationAwareBeanPostProcessor&lt;/li&gt;\n&lt;li&gt;SmartInstantiationAwareBeanPostProcessor&lt;/li&gt;\n&lt;li&gt;MergedBeanDefinitionPostProcessor【internalPostProcessors】&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;执行过程&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;获取所有的BeanPostProcessor；后置处理器都默认可以通过PriorityOrdered、Ordered接口来实现优先级排序&lt;/li&gt;\n&lt;li&gt;先注册PriorityOrdered优先级排序接口的BeanPostProcessor&lt;br&gt;\n把每一个BeanPostProcessor都添加到BeanFactory中&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;private static void registerBeanPostProcessors(\n        ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanPostProcessor&amp;gt; postProcessors) {\n\n    if (beanFactory instanceof AbstractBeanFactory) {\n        // Bulk addition is more efficient against our CopyOnWriteArrayList there\n        ((AbstractBeanFactory) beanFactory).addBeanPostProcessors(postProcessors);\n    }\n    else {\n        for (BeanPostProcessor postProcessor : postProcessors) {\n            beanFactory.addBeanPostProcessor(postProcessor);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;再注册Ordered接口的&lt;/li&gt;\n&lt;li&gt;再注册没有实现任何优先级接口的&lt;/li&gt;\n&lt;li&gt;最后注册MergedBeanDefinitionPostProcessor【internalPostProcessors】&lt;/li&gt;\n&lt;li&gt;最终注册一个ApplicationListenerDetector；再Bean创建完后检查是否是ApplicationListener，如果是则将其注册到上下文中&lt;br&gt;\napplicationContext.addApplicationListener((ApplicationListener&amp;lt;?&amp;gt;) bean);&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;7-initmessagesource初始化messagesource组件做国际化功能消息绑定消息解析\&#34;&gt;7. initMessageSource();初始化MessageSource组件（做国际化功能，消息绑定，消息解析）&lt;/h2&gt;\n&lt;p&gt;MessageSource按照区域，取出国际化配置文件中的某个key的值&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;getBeanFactory();获取BeanFactory&lt;/li&gt;\n&lt;li&gt;判断容器中是否有id=messageSource的组件，类型=MessageSource\n&lt;ol&gt;\n&lt;li&gt;如果有，赋值给变量messageSource&lt;/li&gt;\n&lt;li&gt;如果没有，自己创建一个DelegatingMessageSource&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;把创建好的MessageSource注册到容器中，后续可依赖注入&lt;br&gt;\n&lt;code&gt;beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;8-initapplicationeventmulticaster初始化事件派发器\&#34;&gt;8. initApplicationEventMulticaster();初始化事件派发器&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;获取BeanFactory&lt;/li&gt;\n&lt;li&gt;从BeanFactory中获取ApplicationEventMulticaster的ApplicationEventMulticaster&lt;/li&gt;\n&lt;li&gt;将创建的ApplicationEventMulticaster添加到BeanFactory中，后续可依赖注入&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;9-onrefresh-留给子容器子类\&#34;&gt;9. onRefresh(); 留给子容器（子类）&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;子类重写这个方法，在容器刷新的时候可以自定义逻辑；&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;10-registerlisteners将项目中所有的applicationlistener注册到容器中\&#34;&gt;10. registerListeners();将项目中所有的ApplicationListener注册到容器中&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;从applicationListeners属性中拿到之前步骤中所有的ApplicationListener，注册到事件派发器中&lt;/li&gt;\n&lt;li&gt;从容器中拿到所有的ApplicationListener，注册到事件派发器中&lt;br&gt;\n&lt;code&gt;getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;派发（调用）之前步骤产生的事件&lt;br&gt;\n&lt;code&gt;getApplicationEventMulticaster().multicastEvent(earlyEvent);&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;11-finishbeanfactoryinitializationbeanfactory-初始化所有剩下的单实例bean\&#34;&gt;11. finishBeanFactoryInitialization(beanFactory); 初始化所有剩下的单实例bean&lt;/h2&gt;\n&lt;h3 id=\&#34;111-beanfactorypreinstantiatesingletons-初始化剩下的单实例bean\&#34;&gt;11.1 beanFactory.preInstantiateSingletons(); - 初始化剩下的单实例bean&lt;/h3&gt;\n&lt;h4 id=\&#34;1111-获取容器中的所有bean依次进行初始化和创建对象\&#34;&gt;11.1.1 获取容器中的所有bean，依次进行初始化和创建对象&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; beanNames = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames);\n// Trigger initialization of all non-lazy singleton beans...\nfor (String beanName : beanNames) {\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;1112-获取bean的定义信息rootbeandefinition\&#34;&gt;11.1.2 获取bean的定义信息RootBeanDefinition&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;1113-bean不是抽象的是单实例的不是懒加载的\&#34;&gt;11.1.3 Bean不是抽象的，是单实例的，不是懒加载的&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !bd.isLazyInit()&lt;/code&gt;&lt;/p&gt;\n&lt;h5 id=\&#34;11131-判断是否是factorybean是否是实现factorybean接口的bean\&#34;&gt;11.1.3.1 判断是否是FactoryBean，是否是实现FactoryBean接口的bean&lt;/h5&gt;\n&lt;ol&gt;\n&lt;li&gt;如果是，则利用FactoryBean接口的&lt;code&gt;FactoryBean#getObject&lt;/code&gt;获取对象&lt;/li&gt;\n&lt;li&gt;如果不是，利用&lt;code&gt;getBean(beanName)&lt;/code&gt;创建对象&lt;br&gt;\n0. getBean(beanName) -&amp;gt; 与ApplicationContext#getBean一致\n&lt;ol&gt;\n&lt;li&gt;doGetBean(name, null, null, false);&lt;/li&gt;\n&lt;li&gt;先获取缓存中保存的单实例bean，如果能获取到，说明之前被创建过。（所有创建过的单实例Bean都会被缓存起来）&lt;/li&gt;\n&lt;li&gt;getSingleton(beanName, true);&lt;br&gt;\n&lt;code&gt;private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap&amp;lt;&amp;gt;(256);&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;缓存中获取不到，开始创建对象流程&lt;/li&gt;\n&lt;li&gt;标记当前bean已被创建 &lt;code&gt;markBeanAsCreated(beanName);&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;获取Bean的定义信息&lt;br&gt;\n&lt;code&gt;RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;【&lt;strong&gt;获取当前Bean依赖的其他bean，如果有按照getBean()把依赖的Bean先创建出来&lt;/strong&gt;】&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;String[] dependsOn = mbd.getDependsOn();\n    if (dependsOn != null) {\n        for (String dep : dependsOn) {\n            ...\n            registerDependentBean(dep, beanName);\n            getBean(dep);\n            ...\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;8\&#34;&gt;\n&lt;li&gt;启动单实例Bean的创建流程 &lt;code&gt;mbd.isSingleton()&lt;/code&gt;\n&lt;ol&gt;\n&lt;li&gt;getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory)&lt;/li&gt;\n&lt;li&gt;createBean(beanName, mbd, args);&lt;/li&gt;\n&lt;li&gt;resolveBeforeInstantiation(beanName, mbdToUse); 让BeanPostProcessor先提前拦截返回Bean代理对象&lt;br&gt;\n【&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;】: 提前执行&lt;br&gt;\n先触发：Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);&lt;br&gt;\n如果有返回值，再触发：processor.postProcessAfterInitialization(result, beanName);&lt;/li&gt;\n&lt;li&gt;Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n&lt;ol&gt;\n&lt;li&gt;【创建Bean实例】：createBeanInstance(beanName, mbd, args);&lt;br&gt;\n利用工厂方法或者对象的构造器创建出Bean实例&lt;/li&gt;\n&lt;li&gt;applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);&lt;br&gt;\n调用【MergedBeanDefinitionPostProcessor】的&lt;code&gt;processor.postProcessMergedBeanDefinition(mbd, beanType, beanName);&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;【bean属性赋值】populateBean(beanName, mbd, instanceWrapper);&lt;br&gt;\n赋值之前：\n&lt;ol&gt;\n&lt;li&gt;拿到InstantiationAwareBeanPostProcessor后置处理器&lt;br&gt;\n执行&lt;code&gt;postProcessAfterInstantiation&lt;/code&gt;方法&lt;/li&gt;\n&lt;li&gt;拿到InstantiationAwareBeanPostProcessor后置处理器&lt;br&gt;\n执行&lt;code&gt;postProcessPropertyValues&lt;/code&gt;方法&lt;br&gt;\n=&lt;mark&gt;赋值之前&lt;/mark&gt;=&lt;/li&gt;\n&lt;li&gt;应用bean属性的值，利用setter为属性赋值&lt;br&gt;\n&lt;code&gt;applyPropertyValues(beanName, mbd, bw, pvs);&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;【Bean初始化】initializeBean(beanName, exposedObject, mbd);\n&lt;ol&gt;\n&lt;li&gt;【执行Aware接口方法】invokeAwareMethods(beanName, wrappedBean, mbd);执行XXX_Aware接口为Aware属性赋值&lt;br&gt;\n&lt;code&gt;BeanNameAware/BeanClassLoaderAware/BeanFactoryAware&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);&lt;br&gt;\n&lt;code&gt;processor.postProcessBeforeInitialization(result, beanName);&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);\n&lt;ol&gt;\n&lt;li&gt;是否是InitializingBean接口的实现，执行接口规定的初始化方法&lt;/li&gt;\n&lt;li&gt;是否有自定义初始化方法 &lt;code&gt;String initMethodName = mbd.getInitMethodName();&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;【执行后置处理器初始化之后的方法】applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);&lt;br&gt;\n&lt;code&gt;processor.postProcessAfterInitialization(result, beanName); &lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;5. 【注册bean的销毁方法】registerDisposableBeanIfNecessary(beanName, bean, mbd); 实现`DisposableBean`接口\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;将创建的bean添加到缓存&lt;code&gt;DefaultSingletonBeanRegistry#addSingleton&lt;/code&gt;中&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;12-finishrefresh完成beanfactory的初始化创建工作ioc容器就创建完成\&#34;&gt;12. finishRefresh();完成BeanFactory的初始化创建工作，IOC容器就创建完成&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;clearResourceCaches(); 清除上下文级别的资源缓存&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;initLifecycleProcessor();初始化和生命周期有关的后置处理器：LifecycleProcessor&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;默认从容器中找是否存在名为lifecycleProcessor的组件[LifecycleProcessor]，如果没有就创建&lt;code&gt;new DefaultLifecycleProcessor();&lt;/code&gt;，然后加入到容器中&lt;/li&gt;\n&lt;li&gt;自定义实现LifecycleProcessor接口，可以接收到两个回调\n&lt;ol&gt;\n&lt;li&gt;void onRefresh(); - 上下文刷新的通知&lt;/li&gt;\n&lt;li&gt;void onClose(); - 上下文关闭的通知&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;getLifecycleProcessor().onRefresh(); 拿到刚才获取的生命周期处理器，回调&lt;code&gt;onRefresh()&lt;/code&gt;事件&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;publishEvent(new ContextRefreshedEvent(this)); - 发布容器刷新完成事件&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;在Spring启动时，先会保存所有注册进来的Bean定义信息\n&lt;ol&gt;\n&lt;li&gt;xml注册&lt;/li&gt;\n&lt;li&gt;@Bean、@Component...&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;Spring会在适当的时候创建对应的Bean\n&lt;ol&gt;\n&lt;li&gt;用到这个bean的时候，利用getBean创建&lt;/li&gt;\n&lt;li&gt;启动时统一创建剩下的所有Bean，&lt;code&gt;finishBeanFactoryInitialization(beanFactory)&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;后置处理器 BeanPostProcessor\n&lt;ol&gt;\n&lt;li&gt;每一个Bean创建完成后，都会使用各种后置处理器增强Bean的功能\n&lt;ol&gt;\n&lt;li&gt;AutowiredAnnotationBeanPostProcessor: 处理自动注入&lt;/li&gt;\n&lt;li&gt;AsyncAnnotationBeanPostProcessor: 处理异步&lt;/li&gt;\n&lt;li&gt;AnnotationAwareAspectJAutoProxyCreator: 处理AOP&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;事件驱动模型\n&lt;ol&gt;\n&lt;li&gt;ApplicationListener：事件监听&lt;/li&gt;\n&lt;li&gt;AnnotationAwareAspectJAutoProxyCreator：事件派发器&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-rong-qi-de-de-refresh&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring容器的的refresh()&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-04-10 16:11:13&#34;,&#34;dateFormat&#34;:&#34;2021-04-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-rong-qi-de-de-refresh/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:534000,&#34;words&#34;:2173,&#34;minutes&#34;:9},&#34;description&#34;:&#34;Spring容器的的refresh()【创建刷新】\nrefresh()源码\npublic void refresh() throws BeansException, IllegalStateException {\n    synchroni...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#refresh%E6%BA%90%E7%A0%81\&#34;&gt;refresh()源码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#beanfactory%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E9%A2%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\&#34;&gt;BeanFactory的创建及预准备工作&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-preparerefresh-%E5%88%B7%E6%96%B0%E5%89%8D%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86\&#34;&gt;1. prepareRefresh(); 刷新前的预处理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-obtainfreshbeanfactory-%E8%8E%B7%E5%8F%96beanfactory\&#34;&gt;2. obtainFreshBeanFactory(); 获取BeanFactory&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-preparebeanfactorybeanfactory-beanfactory%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C%E5%AF%B9beanfactory%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E8%B5%8B%E5%80%BC%E8%AE%BE%E7%BD%AE\&#34;&gt;3. prepareBeanFactory(beanFactory); BeanFactory的预处理工作，对BeanFactory进行一些赋值设置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-postprocessbeanfactorybeanfactory-beanfactory%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%E5%AE%8C%E6%88%90%E5%90%8E%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C\&#34;&gt;4. postProcessBeanFactory(beanFactory); BeanFactory准备工作完成后进行的后置处理工作&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#beanfactory%E5%90%8E%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B\&#34;&gt;BeanFactory后面的流程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-invokebeanfactorypostprocessorsbeanfactory-%E6%B3%A8%E5%86%8Cbeanfactory%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E6%89%A7%E8%A1%8Cbeanfactorypostprocessor%E6%96%B9%E6%B3%95\&#34;&gt;5. invokeBeanFactoryPostProcessors(beanFactory); 注册BeanFactory的后置处理器，执行BeanFactoryPostProcessor方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%A7%E8%A1%8Cbeanfactorypostprocessor%E6%96%B9%E6%B3%95\&#34;&gt;执行BeanFactoryPostProcessor方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%88%E6%89%A7%E8%A1%8Cbeandefinitionregistrypostprocessor%E7%9A%84%E6%96%B9%E6%B3%95\&#34;&gt;先执行BeanDefinitionRegistryPostProcessor的方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%8D%E6%89%A7%E8%A1%8Cbeanfactorypostprocessor%E7%9A%84%E6%96%B9%E6%B3%95\&#34;&gt;再执行BeanFactoryPostProcessor的方法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-registerbeanpostprocessorsbeanfactory-%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%94%A8%E4%BA%8E%E6%8B%A6%E6%88%AAbean%E7%9A%84%E6%95%B4%E4%B8%AA%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B\&#34;&gt;6. registerBeanPostProcessors(beanFactory); 注册Bean的后置处理器，用于拦截Bean的整个创建过程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-initmessagesource%E5%88%9D%E5%A7%8B%E5%8C%96messagesource%E7%BB%84%E4%BB%B6%E5%81%9A%E5%9B%BD%E9%99%85%E5%8C%96%E5%8A%9F%E8%83%BD%E6%B6%88%E6%81%AF%E7%BB%91%E5%AE%9A%E6%B6%88%E6%81%AF%E8%A7%A3%E6%9E%90\&#34;&gt;7. initMessageSource();初始化MessageSource组件（做国际化功能，消息绑定，消息解析）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-initapplicationeventmulticaster%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8B%E4%BB%B6%E6%B4%BE%E5%8F%91%E5%99%A8\&#34;&gt;8. initApplicationEventMulticaster();初始化事件派发器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9-onrefresh-%E7%95%99%E7%BB%99%E5%AD%90%E5%AE%B9%E5%99%A8%E5%AD%90%E7%B1%BB\&#34;&gt;9. onRefresh(); 留给子容器（子类）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#10-registerlisteners%E5%B0%86%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84applicationlistener%E6%B3%A8%E5%86%8C%E5%88%B0%E5%AE%B9%E5%99%A8%E4%B8%AD\&#34;&gt;10. registerListeners();将项目中所有的ApplicationListener注册到容器中&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#11-finishbeanfactoryinitializationbeanfactory-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E5%89%A9%E4%B8%8B%E7%9A%84%E5%8D%95%E5%AE%9E%E4%BE%8Bbean\&#34;&gt;11. finishBeanFactoryInitialization(beanFactory); 初始化所有剩下的单实例bean&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#111-beanfactorypreinstantiatesingletons-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%A9%E4%B8%8B%E7%9A%84%E5%8D%95%E5%AE%9E%E4%BE%8Bbean\&#34;&gt;11.1 beanFactory.preInstantiateSingletons(); - 初始化剩下的单实例bean&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1111-%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89bean%E4%BE%9D%E6%AC%A1%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\&#34;&gt;11.1.1 获取容器中的所有bean，依次进行初始化和创建对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#1112-%E8%8E%B7%E5%8F%96bean%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BF%A1%E6%81%AFrootbeandefinition\&#34;&gt;11.1.2 获取bean的定义信息RootBeanDefinition&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#1113-bean%E4%B8%8D%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%98%AF%E5%8D%95%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%8D%E6%98%AF%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84\&#34;&gt;11.1.3 Bean不是抽象的，是单实例的，不是懒加载的&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#11131-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AFfactorybean%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%9E%E7%8E%B0factorybean%E6%8E%A5%E5%8F%A3%E7%9A%84bean\&#34;&gt;11.1.3.1 判断是否是FactoryBean，是否是实现FactoryBean接口的bean&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#12-finishrefresh%E5%AE%8C%E6%88%90beanfactory%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9Cioc%E5%AE%B9%E5%99%A8%E5%B0%B1%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90\&#34;&gt;12. finishRefresh();完成BeanFactory的初始化创建工作，IOC容器就创建完成&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;普通验证\&#34;&gt;普通验证&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;/**\n更多验证规则\nhttps://pkg.go.dev/gopkg.in/bluesuncorp/validator.v8#section-documentation\n*/\ntype Student struct {\n\tName string `form:&amp;quot;name&amp;quot; json:&amp;quot;name&amp;quot; binding:&amp;quot;required&amp;quot;`\n\t// binding 逗号分割表示并且, | 分割表示或者(满足一项)\n\tAge      int       `form:&amp;quot;age&amp;quot; json:&amp;quot;age&amp;quot; binding:&amp;quot;required,gt=10&amp;quot;`\n\tBirthday time.Time `form:&amp;quot;birthday&amp;quot; time_format:&amp;quot;2006-01-02 15:04:05&amp;quot; json:&amp;quot;birthday&amp;quot;`\n}\n\nfunc main() {\n\n\tr := gin.Default()\n\tr.POST(&amp;quot;test&amp;quot;, func(context *gin.Context) {\n\n\t\tvar student Student\n\t\t// 根据不同的context-type,做不同的映射\n\t\tif err := context.ShouldBind(&amp;amp;student); err != nil {\n\t\t\tcontext.String(http.StatusBadRequest, &amp;quot;student bind error %v&amp;quot;, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tcontext.JSON(http.StatusOK, student)\n\t})\n\n\tr.Run()\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;自定义验证\&#34;&gt;自定义验证&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;/**\n更多验证规则\nhttps://pkg.go.dev/gopkg.in/bluesuncorp/validator.v8#section-documentation\n*/\ntype Booking struct {\n\t// 时间必须符合bookabledate检查\n\tChinkIn time.Time `form:&amp;quot;checkIn&amp;quot; json:&amp;quot;chink_in&amp;quot; binding:&amp;quot;required,bookabledate&amp;quot; time_format:&amp;quot;2006-01-02&amp;quot;`\n\t// 时间必须大于ChinkIn\n\tChinkOut time.Time `form:&amp;quot;checkOut&amp;quot; json:&amp;quot;chink_out&amp;quot; binding:&amp;quot;required,gtfield=ChinkIn&amp;quot; time_format:&amp;quot;2006-01-02&amp;quot;`\n}\n\nfunc bookableDate(fl validator.FieldLevel) bool {\n\n\tif date, ok := fl.Field().Interface().(time.Time); ok {\n\t\t// 大于今天\n\t\treturn date.Unix() &amp;gt; time.Now().Unix()\n\t}\n\treturn false\n}\n\nfunc main() {\n\n\tr := gin.Default()\n\n\t// 注册验证规则\n\tif v, ok := binding.Validator.Engine().(*validator.Validate); ok {\n\t\terr := v.RegisterValidation(&amp;quot;bookabledate&amp;quot;, bookableDate)\n\t\tif err != nil {\n\t\t\tfor _, e := range err.(validator.ValidationErrors) {\n\t\t\t\tfmt.Println(e)\n\t\t\t}\n\t\t}\n\t}\n\n\tr.POST(&amp;quot;test&amp;quot;, func(context *gin.Context) {\n\n\t\tvar booking Booking\n\t\t// 根据不同的context-type,做不同的映射\n\t\tif err := context.ShouldBind(&amp;amp;booking); err != nil {\n\t\t\tcontext.String(http.StatusBadRequest, &amp;quot;booking bind error %v&amp;quot;, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tcontext.JSON(http.StatusOK, booking)\n\t})\n\n\tr.Run()\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;i18n验证\&#34;&gt;i18n验证&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;package main\n\nimport (\n\t&amp;quot;github.com/gin-gonic/gin&amp;quot;\n\ten2 &amp;quot;github.com/go-playground/locales/en&amp;quot;\n\tzh2 &amp;quot;github.com/go-playground/locales/zh&amp;quot;\n\tut &amp;quot;github.com/go-playground/universal-translator&amp;quot;\n\t&amp;quot;gopkg.in/go-playground/validator.v9&amp;quot;\n\ten_translations &amp;quot;gopkg.in/go-playground/validator.v9/translations/en&amp;quot;\n\tzh_translations &amp;quot;gopkg.in/go-playground/validator.v9/translations/zh&amp;quot;\n\t&amp;quot;net/http&amp;quot;\n\t&amp;quot;time&amp;quot;\n)\n\n/**\n更多验证规则\nhttps://pkg.go.dev/gopkg.in/bluesuncorp/validator.v8#section-documentation\n*/\ntype Student struct {\n\tName string `form:&amp;quot;name&amp;quot; json:&amp;quot;name&amp;quot; validate:&amp;quot;required&amp;quot;`\n\tAge      int       `form:&amp;quot;age&amp;quot; json:&amp;quot;age&amp;quot; validate:&amp;quot;required,gt=10&amp;quot;`\n\tBirthday time.Time `form:&amp;quot;birthday&amp;quot; time_format:&amp;quot;2006-01-02 15:04:05&amp;quot; json:&amp;quot;birthday&amp;quot;`\n}\n\nvar (\n\tUni *ut.UniversalTranslator\n\tValidate *validator.Validate\n)\n\nfunc main() {\n\n\t// 初始化验证器\n\tinitValidator()\n\n\tr := gin.Default()\n\n\tr.GET(&amp;quot;test&amp;quot;, func(context *gin.Context) {\n\n\t\t// 根据不同语言,加载不同的验证器\n\t\tlocale := context.DefaultQuery(&amp;quot;locale&amp;quot;, &amp;quot;zh&amp;quot;)\n\t\ttranslator, _ := Uni.GetTranslator(locale)\n\t\tswitch locale {\n\t\tcase &amp;quot;zh&amp;quot;:\n\t\t\t_ = zh_translations.RegisterDefaultTranslations(Validate, translator)\n\t\tcase &amp;quot;en&amp;quot;:\n\t\t\t_ = en_translations.RegisterDefaultTranslations(Validate, translator)\n\t\tdefault:\n\t\t\t_ = zh_translations.RegisterDefaultTranslations(Validate, translator)\n\t\t}\n\n\t\t// 根据不同的context-type,做不同的映射\n\t\tvar student Student\n\t\tif err := context.ShouldBind(&amp;amp;student); err != nil {\n\t\t\tcontext.String(http.StatusBadRequest, &amp;quot;student bind error %v&amp;quot;, err.Error())\n\t\t\tcontext.Abort()\n\t\t\treturn\n\t\t}\n\n\t\t// 验证\n\t\tif valid(context, student, translator) {\n\t\t\treturn\n\t\t}\n\n\t\tcontext.JSON(http.StatusOK, student)\n\t})\n\n\tr.Run()\n\n\t//➜  github.com curl -X GET &amp;quot;localhost:8080/test?name=xxx&amp;amp;bbb=ddd&amp;amp;locale=zh&amp;amp;age=2&amp;quot;\n\t//student validate error [Age必须大于10]%                                                                                                                                                                     ➜  github.com curl -X GET &amp;quot;localhost:8080/test?name=xxx&amp;amp;bbb=ddd&amp;amp;locale=en&amp;amp;age=2&amp;quot;\n\t//➜  github.com curl -X GET &amp;quot;localhost:8080/test?name=xxx&amp;amp;bbb=ddd&amp;amp;locale=en&amp;amp;age=2&amp;quot;\n\t//student validate error [Age must be greater than 10]%\n\n}\n\nfunc valid(context *gin.Context, student Student, translator ut.Translator) bool {\n\tif err := Validate.Struct(student); err != nil {\n\t\terrors := err.(validator.ValidationErrors)\n\t\tsliceErrors := []string{}\n\t\tfor _, e := range errors {\n\t\t\tsliceErrors = append(sliceErrors, e.Translate(translator))\n\t\t}\n\t\tcontext.String(http.StatusBadRequest, &amp;quot;student validate error %v&amp;quot;, sliceErrors)\n\t\tcontext.Abort()\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc initValidator() {\n\tValidate = validator.New()\n\tzh := zh2.New()\n\ten := en2.New()\n\tUni = ut.New(zh, en)\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;gin-can-shu-yan-zheng&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Gin 参数验证&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-03-08 21:28:48&#34;,&#34;dateFormat&#34;:&#34;2021-03-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/gin-can-shu-yan-zheng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:273000,&#34;words&#34;:789,&#34;minutes&#34;:5},&#34;description&#34;:&#34;普通验证\n/**\n更多验证规则\nhttps://pkg.go.dev/gopkg.in/bluesuncorp/validator.v8#section-documentation\n*/\ntype Student struct {\n\tNam...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%99%AE%E9%80%9A%E9%AA%8C%E8%AF%81\&#34;&gt;普通验证&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81\&#34;&gt;自定义验证&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#i18n%E9%AA%8C%E8%AF%81\&#34;&gt;i18n验证&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;相关代码位置：&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/golang/imooc-gin-study\&#34;&gt;https://github.com/imyzt/learning-technology-code/tree/master/golang/imooc-gin-study&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;httpmethod-start\&#34;&gt;httpMethod start&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;package main\n\nimport &amp;quot;github.com/gin-gonic/gin&amp;quot;\n\nfunc main() {\n\n\t// 简单gin使用\n\tr := gin.Default()\n\tr.GET(&amp;quot;/get&amp;quot;, func(context *gin.Context) {\n\t\tcontext.JSON(200, gin.H{\n\t\t\t&amp;quot;message&amp;quot;: &amp;quot;get&amp;quot;,\n\t\t})\n\t})\n\tr.POST(&amp;quot;/post&amp;quot;, func(context *gin.Context) {\n\t\tcontext.JSON(200, gin.H{\n\t\t\t&amp;quot;message&amp;quot;: &amp;quot;post&amp;quot;,\n\t\t})\n\t})\n\tr.DELETE(&amp;quot;/delete&amp;quot;, func(context *gin.Context) {\n\t\tcontext.JSON(200, gin.H{\n\t\t\t&amp;quot;message&amp;quot;: &amp;quot;delete&amp;quot;,\n\t\t})\n\t})\n\tr.PUT(&amp;quot;/put&amp;quot;, func(context *gin.Context) {\n\t\tcontext.JSON(200, gin.H{\n\t\t\t&amp;quot;message&amp;quot;: &amp;quot;put&amp;quot;,\n\t\t})\n\t})\n\t// 支持任意请求\n\tr.Any(&amp;quot;/any&amp;quot;, func(context *gin.Context) {\n\t\tcontext.String(200, &amp;quot;any&amp;quot;)\n\t})\n\n\tr.Run()\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;rest参数\&#34;&gt;rest参数&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;r.GET(&amp;quot;:name/:id&amp;quot;, func(context *gin.Context) {\n    context.JSON(200, gin.H{\n        &amp;quot;name&amp;quot;: context.Param(&amp;quot;name&amp;quot;),\n        &amp;quot;id&amp;quot;: context.Param(&amp;quot;id&amp;quot;),\n    })\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;开放静态资源\&#34;&gt;开放静态资源&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;// 静态文件夹\nr.Static(&amp;quot;/asserts&amp;quot;, &amp;quot;./asserts&amp;quot;)\n// 静态文件目录\nr.StaticFS(&amp;quot;/static&amp;quot;, http.Dir(&amp;quot;/Users/imyzt/Downloads/&amp;quot;))\n// 静态文件\nr.StaticFile(&amp;quot;/test.html&amp;quot;, &amp;quot;./test.html&amp;quot;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;泛匹配\&#34;&gt;泛匹配&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;r.GET(&amp;quot;/name/*action&amp;quot;, func(context *gin.Context) {\n    context.String(200, &amp;quot;helloWorld&amp;quot;)\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;获取get请求参数\&#34;&gt;获取GET请求参数&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;r.GET(&amp;quot;/test&amp;quot;, func(context *gin.Context) {\n    firstName := context.Query(&amp;quot;firstName&amp;quot;)\n    // 默认值\n    lastName := context.DefaultQuery(&amp;quot;lastName&amp;quot;, &amp;quot;defaultLastName&amp;quot;)\n    context.JSON(http.StatusOK, gin.H{\n        &amp;quot;firstName&amp;quot;: firstName,\n        &amp;quot;lastName&amp;quot;:  lastName,\n    })\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;获取post-form-data请求参数\&#34;&gt;获取POST form-data请求参数&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;r.POST(&amp;quot;/test&amp;quot;, func(context *gin.Context) {\n    firstName := context.PostForm(&amp;quot;firstName&amp;quot;)\n    // 默认值\n    lastName := context.DefaultPostForm(&amp;quot;lastName&amp;quot;, &amp;quot;defaultLastName&amp;quot;)\n    context.JSON(http.StatusOK, gin.H{\n        &amp;quot;firstName&amp;quot;: firstName,\n        &amp;quot;lastName&amp;quot;:  lastName,\n    })\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;获取post-body请求参数\&#34;&gt;获取POST body请求参数&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;r.POST(&amp;quot;/test&amp;quot;, func(context *gin.Context) {\n\n    bodyBytes, err := ioutil.ReadAll(context.Request.Body)\n    if err != nil {\n        context.String(http.StatusBadRequest, err.Error())\n        context.Abort()\n    }\n\n    // 回传, 方便获取参数\n    context.Request.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))\n\n    // 默认值\n    name := context.DefaultPostForm(&amp;quot;name&amp;quot;, &amp;quot;defaultName&amp;quot;)\n    context.String(http.StatusOK, &amp;quot;%s - %s&amp;quot;, name, string(bodyBytes))\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;CURL输出&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;//curl -X POST &amp;quot;localhost:8080/test&amp;quot; -d &#39;name=xxx&amp;amp;bbb=ddd&#39;\n//xxx - name=xxx&amp;amp;bbb=ddd%\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;getpost请求参数映射到struct\&#34;&gt;GET/POST请求参数映射到struct&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;type Student struct {\n\tName string `form:&amp;quot;name&amp;quot; json:&amp;quot;name&amp;quot;`\n\tAddr string `form:&amp;quot;addr&amp;quot; json:&amp;quot;addr&amp;quot;`\n\tBirthday time.Time `form:&amp;quot;birthday&amp;quot; time_format:&amp;quot;2006-01-02 15:04:05&amp;quot; json:&amp;quot;birthday&amp;quot;`\n}\nfunc main() {\n\n\tr := gin.Default()\n\n\tr.POST(&amp;quot;test&amp;quot;, test)\n\tr.GET(&amp;quot;test&amp;quot;, test)\n\n\tr.Run()\n}\n\nfunc test(context *gin.Context) {\n\n\tvar student Student\n\t// 根据不同的context-type,做不同的映射\n\tif err := context.ShouldBind(&amp;amp;student); err != nil {\n\t\tcontext.String(http.StatusBadRequest, &amp;quot;student bind error %v&amp;quot;, err.Error())\n\t\treturn\n\t}\n\n\tcontext.JSON(http.StatusOK, student)\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;gin-ji-ben-zhi-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Gin基本知识&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-03-07 17:56:11&#34;,&#34;dateFormat&#34;:&#34;2021-03-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/gin-ji-ben-zhi-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:193000,&#34;words&#34;:561,&#34;minutes&#34;:4},&#34;description&#34;:&#34;相关代码位置：https://github.com/imyzt/learning-technology-code/tree/master/golang/imooc-gin-study\nhttpMethod start\npackage mai...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#httpmethod-start\&#34;&gt;httpMethod start&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rest%E5%8F%82%E6%95%B0\&#34;&gt;rest参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%80%E6%94%BE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\&#34;&gt;开放静态资源&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%9B%E5%8C%B9%E9%85%8D\&#34;&gt;泛匹配&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96get%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0\&#34;&gt;获取GET请求参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96post-form-data%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0\&#34;&gt;获取POST form-data请求参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96post-body%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0\&#34;&gt;获取POST body请求参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#getpost%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%E5%88%B0struct\&#34;&gt;GET/POST请求参数映射到struct&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在Spring环境中，查找Bean是非常方便的，但是如果是需要查询方法上的注解进行反射调用或其它，则极其不方便。&lt;/p&gt;\n&lt;p&gt;可以使用&lt;code&gt;MethodIntrospector.selectMethods&lt;/code&gt;工具方法，通过遍历所有@Component Bean的方式，挨个查找。&lt;/p&gt;\n&lt;p&gt;示例代码如下，既能拿到Method对象，又可以拿到注解信息：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; beans = applicationContext.getBeansWithAnnotation(Component.class);\nbeans.forEach((beanName, handler) -&amp;gt; {\n\n    Map&amp;lt;Method, AnalysisListener&amp;gt; methodAnalysisListenerMap = MethodIntrospector.selectMethods(handler.getClass(),\n            (MethodIntrospector.MetadataLookup&amp;lt;AnalysisListener&amp;gt;) method -&amp;gt; AnnotatedElementUtils.findMergedAnnotation(method, AnalysisListener.class));\n\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;AnalysisListener.class&lt;/code&gt;为自定义注解&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-find-methods-by-annotation&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring Find Methods By Annotation &#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-02-03 19:23:47&#34;,&#34;dateFormat&#34;:&#34;2021-02-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-find-methods-by-annotation/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:35000,&#34;words&#34;:136,&#34;minutes&#34;:1},&#34;description&#34;:&#34;在Spring环境中，查找Bean是非常方便的，但是如果是需要查询方法上的注解进行反射调用或其它，则极其不方便。\n可以使用MethodIntrospector.selectMethods工具方法，通过遍历所有@Component Bean的...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;参考文章：&lt;a href=\&#34;https://mp.weixin.qq.com/s/ewjGZCgc_TUhiZIINCLfbg\&#34;&gt;基于Redis的限流系统的设计&lt;/a&gt;&lt;br&gt;\n本文作为总结和回顾&lt;/p&gt;\n&lt;h1 id=\&#34;限流脚本\&#34;&gt;限流脚本&lt;/h1&gt;\n&lt;p&gt;首先需要引入的是redis的LUA脚本.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\n--- 判断source_str 中是否contains pattern_str\n--- @param source_str\n--- @param patter_str\nlocal function contains(source_str, sub_str)\n    local start_pos, end_pos = string.find(source_str, sub_str);\n    if start_pos == nil then\n        return false;\n    end\n    local source_str_len = string.len(source_str);\n\n    if source_str_len == end_pos then\n        return true\n    elseif string.sub(source_str, end_pos + 1, end_pos + 1) == &amp;quot;,&amp;quot; then\n        return true\n    end\n    return false;\nend\n\n\n--- 获取令牌\n--- 返回码\n--- 0 没有令牌桶配置\n--- -1 表示取令牌失败，也就是桶里没有令牌\n--- 1 表示取令牌成功\n--- @param key 令牌的唯一标识\n--- @param permits  请求令牌数量\n--- @param curr_mill_second 当前毫秒数\n--- @param context 使用令牌的应用标识\nlocal function acquire(key, permits, curr_mill_second, context)\n    local rate_limit_info = redis.pcall(&amp;quot;HMGET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, &amp;quot;curr_permits&amp;quot;, &amp;quot;max_permits&amp;quot;, &amp;quot;rate&amp;quot;, &amp;quot;apps&amp;quot;)\n    local last_mill_second = rate_limit_info[1]\n    local curr_permits = tonumber(rate_limit_info[2])\n    local max_permits = tonumber(rate_limit_info[3])\n    local rate = rate_limit_info[4]\n    local apps = rate_limit_info[5]\n\n    --- 标识没有配置令牌桶\n    if type(apps) == &#39;boolean&#39; or apps == nil or not contains(apps, context) then\n        return 0\n    end\n\n\n    local local_curr_permits = max_permits;\n\n    --- 第一次, 没有last_mill_second, 所以local_curr_permits = max_permits, \n    --- 首先设置 redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second) 将上次更新时间修改为现在\n    --- 然后直接进入到最下面 redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits - permits) 用最大速率-自己用的这一次\n    \n    --- 第二次, 有last_mill_second, 走进去if的逻辑\n    --- reverse_permits -&amp;gt; 时间差转换成秒, 然后乘以每秒的速率rage -&amp;gt; 得到每秒需要添加多少个令牌\n    \n    --- 第二次\n\n    --- 令牌桶刚刚创建，上一次获取令牌的毫秒数为空\n    --- 根据和上一次向桶里添加令牌的时间和当前时间差，触发式往桶里添加令牌，并且更新上一次向桶里添加令牌的时间\n    --- 如果向桶里添加的令牌数不足一个，则不更新上一次向桶里添加令牌的时间\n    if (type(last_mill_second) ~= &#39;boolean&#39;  and last_mill_second ~= nil) then\n        --- 当前消耗时间内 -&amp;gt; 需要添加多少个令牌\n        --- 假设curr_mill_second - last_mill_second = 100ms,rate=10, 100ms/1000=0.1s * 10 = 1个\n        --- 假设curr_mill_second - last_mill_second = 1000000ms,rate=10, 1000000ms/1000=1000s * 10 = 1w个 -》 说明很久没有访问了，下面math.min就会丢弃掉多的\n        --- 即刚过去的这一段时间, 需要往桶里面添加1个令牌  \n        local reverse_permits = math.floor(((curr_mill_second - last_mill_second) / 1000) * rate)\n        --- 需要+的 + 当前还剩余的令牌 = 期望当前的令牌数量\n        local expect_curr_permits = reverse_permits + curr_permits;\n        --- 将期望的和最大速率比对, 取小的, 防止超载\n        --- 多于最大速率后的漏（丢弃策略）\n        local_curr_permits = math.min(expect_curr_permits, max_permits);\n\n        --- 大于0表示不是第一次获取令牌，也没有向桶里添加令牌\n        --- 如果当前消耗时间内需要添加令牌, 设置最新的添加时间为当前时间 \n        if (reverse_permits &amp;gt; 0) then\n            redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second)\n        end\n    else\n        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second)\n    end\n\n\n    local result = -1\n    if (local_curr_permits - permits &amp;gt;= 0) then\n        result = 1\n        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits - permits)\n    else\n        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits)\n    end\n\n    return result\nend\n\n\n--- 初始化令牌桶配置\n--- @param key 令牌的唯一标识\n--- @param max_permits 桶大小\n--- @param rate  向桶里添加令牌的速率\n--- @param apps  可以使用令牌桶的应用列表，应用之前用逗号分隔\nlocal function init(key, max_permits, rate, apps)\n    local rate_limit_info = redis.pcall(&amp;quot;HMGET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, &amp;quot;curr_permits&amp;quot;, &amp;quot;max_permits&amp;quot;, &amp;quot;rate&amp;quot;, &amp;quot;apps&amp;quot;)\n    local org_max_permits = tonumber(rate_limit_info[3])\n    local org_rate = rate_limit_info[4]\n    local org_apps = rate_limit_info[5]\n\n    if (org_max_permits == nil) or (apps ~= org_apps or rate ~= org_rate or max_permits ~= org_max_permits) then\n        redis.pcall(&amp;quot;HMSET&amp;quot;, key, &amp;quot;max_permits&amp;quot;, max_permits, &amp;quot;rate&amp;quot;, rate, &amp;quot;curr_permits&amp;quot;, max_permits, &amp;quot;apps&amp;quot;, apps)\n    end\n    return 1;\nend\n\n\n--- 删除令牌桶\nlocal function delete(key)\n    redis.pcall(&amp;quot;DEL&amp;quot;, key)\n    return 1;\nend\n\n\nlocal key = KEYS[1]\nlocal method = ARGV[1]\n\nif method == &#39;acquire&#39; then\n    return acquire(key, ARGV[2], ARGV[3], ARGV[4])\nelseif method == &#39;init&#39; then\n    return init(key, ARGV[2], ARGV[3], ARGV[4])\nelseif method == &#39;delete&#39; then\n    return delete(key)\nelse\n    --ignore\nend\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;概览\&#34;&gt;概览&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;LUA的下标是从1开始的&lt;/li&gt;\n&lt;li&gt;LUA的KEYS是调用方逗号分割前一部分，ARGV是后一部分。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;整个脚本包含了4个方法，入口处使用ARGV[1]判断，决定调用哪一个方法&lt;/p&gt;\n&lt;p&gt;其核心使用了一个 &lt;code&gt;HASH&lt;/code&gt; 来存放策略信息。其中包括：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;max_permits -&amp;gt; 每秒最大速率&lt;/li&gt;\n&lt;li&gt;rate -&amp;gt; 每秒放入速率&lt;/li&gt;\n&lt;li&gt;curr_permits -&amp;gt; 当前速率&lt;/li&gt;\n&lt;li&gt;apps -&amp;gt; 应用列表&lt;/li&gt;\n&lt;li&gt;last_mill_second -&amp;gt; 上次添加令牌时间&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;delete\&#34;&gt;delete&lt;/h2&gt;\n&lt;p&gt;delete方法最为简单，就是调用DEL删除key即可，相当于删除了访问控制的策略。&lt;/p&gt;\n&lt;h2 id=\&#34;init\&#34;&gt;init&lt;/h2&gt;\n&lt;p&gt;初始化方法即将数据库或其他三方的元数据，加载到redis中，以redis的数据格式 &lt;code&gt;Hash&lt;/code&gt; 存储。&lt;br&gt;\n此方法是幂等的，在加入之前会进行判断，如果没有才会添加。&lt;/p&gt;\n&lt;h2 id=\&#34;acquire\&#34;&gt;acquire&lt;/h2&gt;\n&lt;p&gt;此方法最为核心，是从桶中获取令牌的动作，并且模拟RateLimiter实现了触发式添加，从而提升QPS。&lt;/p&gt;\n&lt;p&gt;方法前面内容均为赋值操作和基本判空操作，没什么好说的。&lt;br&gt;\n从&lt;code&gt;local local_curr_permits = max_permits;&lt;/code&gt;便开始了触发式添加动作。&lt;br&gt;\n从&lt;code&gt;if (local_curr_permits - permits &amp;gt;= 0) then&lt;/code&gt;开始消耗动作。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;--- 获取令牌\n--- 返回码\n--- 0 没有令牌桶配置\n--- -1 表示取令牌失败，也就是桶里没有令牌\n--- 1 表示取令牌成功\n--- @param key 令牌的唯一标识\n--- @param permits  请求令牌数量\n--- @param curr_mill_second 当前毫秒数\n--- @param context 使用令牌的应用标识\nlocal function acquire(key, permits, curr_mill_second, context)\n    local rate_limit_info = redis.pcall(&amp;quot;HMGET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, &amp;quot;curr_permits&amp;quot;, &amp;quot;max_permits&amp;quot;, &amp;quot;rate&amp;quot;, &amp;quot;apps&amp;quot;)\n    local last_mill_second = rate_limit_info[1]\n    local curr_permits = tonumber(rate_limit_info[2])\n    local max_permits = tonumber(rate_limit_info[3])\n    local rate = rate_limit_info[4]\n    local apps = rate_limit_info[5]\n\n    if type(apps) == &#39;boolean&#39; or apps == nil or not contains(apps, context) then\n        return 0\n    end\n\n    --- 将当前令牌调整为配置的最大速率\n    local local_curr_permits = max_permits;\n\n    --- 此处为触发式添加令牌动作\n    --- 判断是否有上次添加令牌时间, 此处有三种情况:\n    --- 1. 第一次进来, last_mill_second = nil, 直接走进else, 然后消耗令牌\n    --- 2. 第二次进来, 分为两种情况\n    --- 2.1 在第一次后的1秒内访问, 即下方情况1\n    --- 2.2 在第一次后的1秒后访问, 即下方情况2\n    if (type(last_mill_second) ~= &#39;boolean&#39;  and last_mill_second ~= nil) then\n        --- 向下取整(距离上次添加过去多少秒 * rate) = 需要向令牌桶添加的令牌数量\n        --- 假设rate=10, max_permits=10\n        --- 情况1: 距离上次添加过去多少秒 &amp;lt; 1秒 假设=0.2秒 * 10 = 2个令牌\n        --- 情况2: 距离上次添加过去多少秒 &amp;gt; 1秒 假设=10秒 * 10 = 100个令牌\n        local reverse_permits = math.floor(((curr_mill_second - last_mill_second) / 1000) * rate)\n        --- 本次需要添加的令牌 + 剩余的令牌 = 期望令牌数量\n        --- 情况1: 可能出现两种情况\n        --- 情况1.1 reverse_permits = 2, curr_permits &amp;gt;= 9 , 即桶中还只消耗1个或没有消耗, 但是本次需要添加2个, 多了, 下方min函数会将其漏掉\n        --- 情况1.2 reverse_permits = 2, curr_permits &amp;lt; 9 , 即桶中消耗了超过2个, 本次添加2个, 符合\n        --- 情况2: 绝对多了, 下方min函数会将其漏掉\n        local expect_curr_permits = reverse_permits + curr_permits;\n        --- 此处解决上面两种情况, 防止过载(即将多的令牌丢弃的动作)\n        --- 情况1: 期望令牌 &amp;lt; max_permits(10), 设置期望令牌到当前令牌\n        --- 情况2: 期望令牌 &amp;gt; max_permits(10), 设置最大令牌到当前令牌 -&amp;gt; 即很久没有访问后的一次访问动作\n        local_curr_permits = math.min(expect_curr_permits, max_permits);\n\n        --- 如果需要向令牌桶添加的令牌数量 &amp;gt; 0, 就更新上次添加令牌时间\n        if (reverse_permits &amp;gt; 0) then\n            redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second)\n        end\n    else\n        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;last_mill_second&amp;quot;, curr_mill_second)\n    end\n\n\n    local result = -1\n    --- 当前令牌 够本次 申请的令牌数量\n    if (local_curr_permits - permits &amp;gt;= 0) then\n        result = 1\n        --- 消耗令牌\n        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits - permits)\n    else\n        --- 上面的if不满足, 即令牌没有了\n        redis.pcall(&amp;quot;HSET&amp;quot;, key, &amp;quot;curr_permits&amp;quot;, local_curr_permits)\n    end\n\n    return result\nend\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;java客户端编写\&#34;&gt;Java客户端编写&lt;/h1&gt;\n&lt;h2 id=\&#34;载入脚本\&#34;&gt;载入脚本&lt;/h2&gt;\n&lt;p&gt;整个脚本较大，可以事先载入到redis服务器，采用SHA1串访问。&lt;br&gt;\n多个实例创建多份rateLimiterLua也无妨，因为是同一个脚本文件内容，创建出来的sha1串也是一致的。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Bean\npublic DefaultRedisScript&amp;lt;Long&amp;gt; rateLimiterLua() {\n    DefaultRedisScript&amp;lt;Long&amp;gt; redisScript = new DefaultRedisScript&amp;lt;&amp;gt;();\n    redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(&amp;quot;scripts/rate_limiter.lua&amp;quot;)));\n    redisScript.setResultType(Long.class);\n    return redisScript;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;编写java访问客户端\&#34;&gt;编写Java访问客户端&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;init() - 初始化访问策略&lt;/li&gt;\n&lt;li&gt;acquire() - 获取令牌&lt;/li&gt;\n&lt;li&gt;delete() - 删除访问策略&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;public class RateLimiterClient {\n\n    @Autowired\n    @Qualifier(&amp;quot;longRedisTemplate&amp;quot;)\n    private RedisTemplate&amp;lt;String, Long&amp;gt; longRedisTemplate;\n    @Autowired\n    private RedisTemplate&amp;lt;String, String&amp;gt; redisTemplate;\n\n    @Resource\n    private RedisScript&amp;lt;Long&amp;gt; rateLimiterLua;\n\n    /**\n     * 获取访问令牌\n     * @param context 应用名称\n     * @param key 限制速率key\n     * @param permits 获取令牌数量\n     * @return token\n     */\n    public Token acquireToken(String context, String key, Integer permits) {\n\n        Token token;\n        try {\n            // redis当前时间\n            Long currMillSecond = longRedisTemplate.execute(RedisServerCommands::time);\n            // 获取令牌\n            Long acquire = longRedisTemplate.execute(rateLimiterLua, ImmutableList.of(getKey(key)), RATE_LIMITER_ACQUIRE_METHOD, permits.toString(), currMillSecond, context);\n\n            if (acquire == null) {\n                log.error(&amp;quot;no rate limit config for context = {}&amp;quot;, context);\n                return Token.NO_CONFIG;\n            }\n\n            if (acquire == 1) {\n                token = Token.PASS;\n            } else if (acquire == -1) {\n                token = Token.FUSING;\n            } else {\n                log.error(&amp;quot;no rate limit config for context = {}&amp;quot;, context);\n                token = Token.NO_CONFIG;\n            }\n        } catch (Exception e) {\n            log.error(&amp;quot;get rage limit token for redis error, key = &amp;quot; + key, e);\n            token = Token.ACCESS_REDIS_FAIL;\n        }\n        return token;\n    }\n\n    public void deleteRateLimiter(String key) {\n        redisTemplate.execute(rateLimiterLua, ImmutableList.of(getKey(key)), RATE_LIMITER_DELETE_METHOD);\n    }\n\n    public void initRateLimiter(String code, Integer maxPermits, Integer rate, String apps) {\n        redisTemplate.execute(rateLimiterLua,\n                ImmutableList.of(getKey(code)),\n                RATE_LIMITER_INIT_METHOD,\n                maxPermits.toString(),\n                rate.toString(),\n                apps);\n    }\n    \n    private String getKey(String key) {\n        return RateLimiterConstants.RATE_LIMITER_KEY_PREFIX + key;\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;redis-lua-ratelimiter&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Redis LUA RateLimiter&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-01-13 15:29:12&#34;,&#34;dateFormat&#34;:&#34;2021-01-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/redis-lua-ratelimiter/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;11 min read&#34;,&#34;time&#34;:622000,&#34;words&#34;:2296,&#34;minutes&#34;:11},&#34;description&#34;:&#34;参考文章：基于Redis的限流系统的设计\n本文作为总结和回顾\n限流脚本\n首先需要引入的是redis的LUA脚本.\n\n--- 判断source_str 中是否contains pattern_str\n--- @param source_str...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%90%E6%B5%81%E8%84%9A%E6%9C%AC\&#34;&gt;限流脚本&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E8%A7%88\&#34;&gt;概览&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#delete\&#34;&gt;delete&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#init\&#34;&gt;init&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#acquire\&#34;&gt;acquire&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E5%86%99\&#34;&gt;Java客户端编写&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BD%BD%E5%85%A5%E8%84%9A%E6%9C%AC\&#34;&gt;载入脚本&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99java%E8%AE%BF%E9%97%AE%E5%AE%A2%E6%88%B7%E7%AB%AF\&#34;&gt;编写Java访问客户端&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;springboot自带的conditional\&#34;&gt;SpringBoot自带的Conditional&lt;/h1&gt;\n&lt;p&gt;打开任意*AutoConfiguration文件，一般都有下面的条件注解，在spring-boot-autoconfigure-1.5.3.RELEASE.jar的org.springframework.boot.autoconfigure.condition包下条件注解如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;@ConditionalOnBean：当前容器有指定Bean的条件下。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnClass：当前类路径下有指定的类的条件下。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnExpression：基于SpEL表达式作为判断条件。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnJava：基于JVM版本作为判断条件。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnJndi：在JNDI存在的条件下查找指定的位置。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnMissingBean：当容器里没有指定Bean的情况下。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnMissingClass：当类路径下没有指定的类的条件下。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnNotWebApplication：当前项目不是WEB项目的条件下。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnProperty：指定属性是否有指定的值。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnResource：类路径是否有指定的值。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnSingleCandidate：当指定Bean在容器中只有一个，或者虽然有多个但 是指定首选的Bean。&lt;/li&gt;\n&lt;li&gt;@ConditionalOnWebApplication：当前项目是WEB项目的条件下。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;这些注解都组合了@Conditional元注解，只是使用了不同的条件（Conditional），Spring 条件注解（@Conditional）我们介绍过根据不同条件创建不同Bean。&lt;br&gt;\n虽然平时使用的多，但是没怎么了解过是怎么实现的，其实就是实现&lt;code&gt;org.springframework.context.annotation.Condition&lt;/code&gt;的不同子类做不同的扩展即可。&lt;/p&gt;\n&lt;h1 id=\&#34;手写一个\&#34;&gt;手写一个&lt;/h1&gt;\n&lt;h2 id=\&#34;注解\&#34;&gt;注解&lt;/h2&gt;\n&lt;p&gt;首先写一个ConditionOnOS注解&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2021/01/02\n * @description 是否是对应OS\n */\n@Target({ ElementType.TYPE, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional(OnOSCondition.class)\npublic @interface ConditionOnOS {\n\n\n    /**\n     * 系统类型\n     */\n    OSType osType();\n\n\n    public enum OSType {\n        MAC,\n        LINUX,\n        WINDOWS,\n        ;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;处理程序\&#34;&gt;处理程序&lt;/h2&gt;\n&lt;p&gt;然后写一个处理程序&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Order\npublic class OnOSCondition implements ConfigurationCondition {\n\n\n    @Override\n    public ConfigurationPhase getConfigurationPhase() {\n        return ConfigurationPhase.REGISTER_BEAN;\n    }\n\n\n    @Override\n    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\n\n        Map&amp;lt;String, Object&amp;gt; attributes = metadata.getAnnotationAttributes(ConditionOnOS.class.getName());\n        ConditionOnOS.OSType osType = (ConditionOnOS.OSType) attributes.get(&amp;quot;osType&amp;quot;);\n\n\n        boolean contains = System.getProperty(&amp;quot;os.name&amp;quot;).toUpperCase().contains(osType.name());\n\n\n        return contains;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;测试程序\&#34;&gt;测试程序&lt;/h2&gt;\n&lt;p&gt;最后写一个启动程序&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;package top.imyzt.learning.condition;\n\n\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n\n/**\n * @author imyzt\n * @date 2021/01/02\n * @description 手写一个ConditionOn*\n */\n@ComponentScan(&amp;quot;top.imyzt.learning.condition&amp;quot;)\n@Configuration\npublic class ConditionOnTest {\n\n\n    public static void main(String[] args) {\n\n\n        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext();\n\n\n        annotationConfigApplicationContext.register(ConditionOnTest.class);\n\n\n        annotationConfigApplicationContext.refresh();\n\n\n        HelloWorld helloWorld;\n        try {\n            helloWorld = (HelloWorld) annotationConfigApplicationContext.getBean(&amp;quot;helloWorld&amp;quot;);\n        } catch (NoSuchBeanDefinitionException e) {\n            System.out.println(&amp;quot;helloWorld bean is not exists!&amp;quot;);\n            return;\n        }\n\n\n        helloWorld.say();\n\n\n    }\n\n\n    @Bean\n    @ConditionOnOS(osType = ConditionOnOS.OSType.MAC)\n    public HelloWorld helloWorld() {\n        return new HelloWorld(ConditionOnOS.OSType.MAC.name());\n    }\n\n\n    public class HelloWorld{\n        private String name;\n\n\n        public HelloWorld(String name) {\n            this.name = name;\n        }\n\n\n        public void say() {\n            System.out.println(this.name + &amp;quot; --- say hello!&amp;quot;);\n        }\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;测试\&#34;&gt;测试&lt;/h1&gt;\n&lt;h2 id=\&#34;正向\&#34;&gt;正向&lt;/h2&gt;\n&lt;p&gt;我的电脑是Mac，所以我执行后的结果是&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;…省略\n15:42:08.868 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;conditionOnTest&#39;\n15:42:08.873 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;helloWorld&#39;\nMAC --- say hello!\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;反向\&#34;&gt;反向&lt;/h2&gt;\n&lt;p&gt;当将注解的参数修改为 ConditionOnOS.OSType.LINUX 后，结果如下&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;15:42:59.405 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;conditionOnTest&#39;\nhelloWorld bean is not exists!\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;讲解\&#34;&gt;讲解&lt;/h1&gt;\n&lt;p&gt;其中自主要的是在注解ConditionOnOS上面的@Conditional(OnOSCondition.class)元注解，它指定了判断的处理程序是OnOSCondition.class。&lt;br&gt;\n其次是OnOSCondition通过实现ConfigurationCondition来重写判断逻辑。&lt;/p&gt;\n&lt;h2 id=\&#34;getconfigurationphase\&#34;&gt;getConfigurationPhase()&lt;/h2&gt;\n&lt;p&gt;getConfigurationPhase()用于提供给Spring告知其构建阶段，有两个：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;PARSE_CONFIGURATION： 一个是Condition应评估@Configuration类，如果此时条件不匹配，@Configuration 则不会添加该类。&lt;/li&gt;\n&lt;li&gt;REGISTER_BEAN： 该条件不会阻止@Configuration添加类，在评估条件时，所有@Configurations都将被解析。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;ConfigurationPhase的作用并不是根据条件来判断是否加载这个配置类，&lt;strong&gt;实际ConfigurationPhase控制的是过滤的时&lt;/strong&gt;机，是在创建Configuration类的时候过滤还是在创建bean的时候过滤（也可用条件注解的生效阶段来描述）。&lt;br&gt;\n此处@https://blog.csdn.net/xcy1193068639/article/details/81589489&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;enum ConfigurationPhase {\n\n\n   /**\n    * The {@link Condition} should be evaluated as a {@code @Configuration}\n    * class is being parsed.\n    * &amp;lt;p&amp;gt;If the condition does not match at this point, the {@code @Configuration}\n    * class will not be added.\n    */\n   PARSE_CONFIGURATION,\n\n\n   /**\n    * The {@link Condition} should be evaluated when adding a regular\n    * (non {@code @Configuration}) bean. The condition will not prevent\n    * {@code @Configuration} classes from being added.\n    * &amp;lt;p&amp;gt;At the time that the condition is evaluated, all {@code @Configuration}\n    * classes will have been parsed.\n    */\n   REGISTER_BEAN\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;matches\&#34;&gt;matches()&lt;/h2&gt;\n&lt;p&gt;matches()方法用于重写匹配逻辑，此方法根据自己的业务逻辑重写即可。&lt;/p&gt;\n&lt;h1 id=\&#34;后文\&#34;&gt;后文&lt;/h1&gt;\n&lt;p&gt;本篇文章的源代码位置：&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/source-code/xiaomage-springboot-teach/spring-boot-condition\&#34;&gt;https://github.com/imyzt/learning-technology-code/tree/master/source-code/xiaomage-springboot-teach/spring-boot-condition&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;shou-xie-yi-ge-springboot-conditionon&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;手写一个SpringBoot ConditionOn*&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-01-02 15:56:32&#34;,&#34;dateFormat&#34;:&#34;2021-01-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/shou-xie-yi-ge-springboot-conditionon/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:289000,&#34;words&#34;:1039,&#34;minutes&#34;:5},&#34;description&#34;:&#34;SpringBoot自带的Conditional\n打开任意*AutoConfiguration文件，一般都有下面的条件注解，在spring-boot-autoconfigure-1.5.3.RELEASE.jar的org.springfra...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#springboot%E8%87%AA%E5%B8%A6%E7%9A%84conditional\&#34;&gt;SpringBoot自带的Conditional&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA\&#34;&gt;手写一个&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E8%A7%A3\&#34;&gt;注解&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F\&#34;&gt;处理程序&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F\&#34;&gt;测试程序&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%8B%E8%AF%95\&#34;&gt;测试&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%A3%E5%90%91\&#34;&gt;正向&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%8D%E5%90%91\&#34;&gt;反向&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%B2%E8%A7%A3\&#34;&gt;讲解&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#getconfigurationphase\&#34;&gt;getConfigurationPhase()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#matches\&#34;&gt;matches()&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E6%96%87\&#34;&gt;后文&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在项目中，大家通常都喜欢使用 &lt;code&gt;throw new BusinessException()&lt;/code&gt; 来阻断错误的参数或者业务逻辑异常等已知异常，反馈给用户。比如用户未绑定手机号、用户的参数异常等情况。在大部分情况下，使用异常终止流程都不是很好的方式，但是奈何在SpringBoot 环境下，&lt;code&gt;@RestControllerAdvice&lt;/code&gt; 实在是香，不需要定义很多返回状态码。所以被大多数人使用在项目中。&lt;/p&gt;\n&lt;p&gt;但是使用此方式是具有一定的性能损耗的，因为在基类Throwable 的fillInStackTrace()方法会不断收集各层的调用链路，而SpringMVC又是在外层的Tomcat到DispatcherServlet到应用自定义的各种intercepter层层调用，调用堆栈通常较长。所以多多少少具有一定的性能消耗，下面进行了一个基本测试。&lt;/p&gt;\n&lt;p&gt;第一个for循环是为了给JVM预热。&lt;br&gt;\n第二个模拟普通的异常。&lt;br&gt;\n第三个模拟重写了fillInStackTrace()方法的异常。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2021/01/02\n * @description 异常收集测试\n */\npublic class TestMain {\n\n\n    public static void main(String[] args) {\n\n\n        int idx = 1000022;\n\n\n        long t1Start = System.currentTimeMillis();\n        for (int i = 0; i &amp;lt; idx; i++) {\n            Test test = new Test(&amp;quot;aa&amp;quot; + i);\n        }\n        long t1end = System.currentTimeMillis();\n        System.out.println(t1end - t1Start);\n\n\n\n\n        long t2Start = System.currentTimeMillis();\n        for (int i = 0; i &amp;lt; idx; i++) {\n            try {\n                throw new ThrowableTest(&amp;quot;aa&amp;quot; + i);\n            } catch (ThrowableTest throwableTest) {\n            }\n        }\n        long t2end = System.currentTimeMillis();\n        System.out.println(t2end - t2Start);\n\n\n\n\n\n\n        long t3Start = System.currentTimeMillis();\n        for (int i = 0; i &amp;lt; idx; i++) {\n            try {\n                throw new ThrowableTest2(&amp;quot;aa&amp;quot; + i);\n            } catch (ThrowableTest2 throwableTest) {\n\n\n            }\n        }\n        long t3end = System.currentTimeMillis();\n        System.out.println(t3end - t3Start);\n    }\n\n\n\n\n    public static class Test {\n\n\n        private String name;\n\n\n        public Test(String name) {\n            this.name = name;\n        }\n    }\n\n\n    public static class ThrowableTest extends RuntimeException {\n\n\n        private String msg;\n\n\n        public ThrowableTest(String msg) {\n            super(msg);\n            this.msg = msg;\n        }\n    }\n\n\n    public static class ThrowableTest2 extends RuntimeException {\n\n\n        private String msg;\n\n\n        public ThrowableTest2(String msg) {\n            super(msg);\n            this.msg = msg;\n        }\n\n\n        @Override\n        public synchronized Throwable fillInStackTrace() {\n            return this;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;耗时对比：&lt;/p&gt;\n&lt;p&gt;88&lt;br&gt;\n1631&lt;br&gt;\n74&lt;/p&gt;\n&lt;p&gt;通过结果可以看出，即使在非Web环境下都有如此巨大的性能差距，web环境下冗长的调用链路差距只会更大，大家可使用web环境下进行测试。&lt;/p&gt;\n&lt;p&gt;但是不是说有性能损耗就不用， 也需要结合业务进行权衡，比如可以将类似于参数错误等无需通过调用堆栈判断的、但是出现频率有很高的的异常进行重写基类的&lt;code&gt;fillInStackTrace()&lt;/code&gt;方法，使其不收集堆栈，但是此举会使出现异常后无法排查，所以只能使用在无需通过堆栈判断问题的场景下用于提升性能。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;java-throwable-yi-chang-dui-zhan-shou-ji-de-xing-neng-wen-ti&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java Throwable异常堆栈收集的性能问题&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-01-02 14:25:53&#34;,&#34;dateFormat&#34;:&#34;2021-01-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-throwable-yi-chang-dui-zhan-shou-ji-de-xing-neng-wen-ti/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:155000,&#34;words&#34;:615,&#34;minutes&#34;:3},&#34;description&#34;:&#34;在项目中，大家通常都喜欢使用 throw new BusinessException() 来阻断错误的参数或者业务逻辑异常等已知异常，反馈给用户。比如用户未绑定手机号、用户的参数异常等情况。在大部分情况下，使用异常终止流程都不是很好的方式，...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;从版本8.0开始，MySQL简单地引入了公用表表达式功能或CTE。&lt;br&gt;\n用于单词定义多次引用使用。&lt;/p&gt;\n&lt;p&gt;语法如下所示，其中需要注意的是&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;定义后，必须下方接着使用，不然语法错误。&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;同一个语句可以定义多个CTE&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;with 别名 as (SQL语句),\nwith 别名2 as (SQL语句)\nSELECT/DELETE/UPDATE/INSERT子句\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;例子：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;with cte as (select *\n             from t_window_func)\nselect dept, count(*)\nfrom cte\nwhere salary not in (select salary from cte where salary &amp;lt; 13000)\ngroup by dept;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;以上语句的外层&lt;code&gt;from cte&lt;/code&gt;和内层&lt;code&gt;not in&lt;/code&gt;中多次引用了&lt;code&gt;cte&lt;/code&gt;这个”公用表“&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-80-gong-yong-biao-biao-da-shi-cte&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL 8.0 公用表表达式（CTE）&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-11-30 21:54:22&#34;,&#34;dateFormat&#34;:&#34;2020-11-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-80-gong-yong-biao-biao-da-shi-cte/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:37000,&#34;words&#34;:151,&#34;minutes&#34;:1},&#34;description&#34;:&#34;从版本8.0开始，MySQL简单地引入了公用表表达式功能或CTE。\n用于单词定义多次引用使用。\n语法如下所示，其中需要注意的是\n\n定义后，必须下方接着使用，不然语法错误。\n同一个语句可以定义多个CTE\n\nwith 别名 as (SQL语句)...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;接&lt;a href=\&#34;http://blog.imyzt.top/article/118\&#34;&gt;上一篇&lt;/a&gt;的内容，继续讲一下窗口函数和分析函数结合的使用。&lt;/p&gt;\n&lt;p&gt;lag与lead函数是跟偏移量相关的两个分析函数，通过这两个函数可以在一次查询中取出同一字段的前N行的数据(lag)和后N行的数据(lead)作为独立的列,从而更方便地进行进行数据过滤。&lt;strong&gt;这种操作可以代替表的自联接，并且LAG和LEAD有更高的效率。&lt;/strong&gt;&lt;br&gt;\n&lt;a href=\&#34;https://my.oschina.net/u/2338224/blog/3112042\&#34;&gt;https://my.oschina.net/u/2338224/blog/3112042&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;lagexpression-offset-default_value\&#34;&gt;lag(expression, offset, default_value)&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;取出同一字段的前N行的数据。&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;语法\&#34;&gt;语法&lt;/h2&gt;\n&lt;p&gt;lag(expression, offset, default_value)&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;expression: 表达式，需要处理的结果列。&lt;/li&gt;\n&lt;li&gt;offset: 偏移量，必须&amp;gt;=0，=0时返回当前行自己。&amp;gt;0返回当前行的前几行&lt;/li&gt;\n&lt;li&gt;default_value: 默认值，第一行没有值时显示。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;示例\&#34;&gt;示例&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;select\nname, dept,\n       salary,\n       lag(salary, 1) over (partition by dept order by salary ) as &#39;上一个人的工资&#39;\nfrom t_window_func\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;lag(salary, 1) over (partition by dept order by salary )&lt;/code&gt; 通过对部门分区，对薪资取上一条数据，最后根据薪资正序排序，展示了不同部门每个人自己和上一个人的薪资情况。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/ssu8u0eo5uiu0qk3i41fmrkv4g.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;从结果集中，我们看到了的是，&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;首先数据根据&lt;code&gt;partition by dept&lt;/code&gt;, 根据部门进行了分区，不同分区不同处理。&lt;/li&gt;\n&lt;li&gt;defaultValue展示了默认值&lt;/li&gt;\n&lt;li&gt;员工2的上一个人工资=员工1的10000，员工3的上一个人工资=员工2的10000，以此类推&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;leadexpression-offset-default_value\&#34;&gt;lead(expression, offset, default_value)&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;取出同一字段的后N行的数据&lt;/strong&gt;，语法与lag的相同。&lt;/p&gt;\n&lt;h2 id=\&#34;示例-2\&#34;&gt;示例&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;select\nname, dept,\n       salary,\n       lead(salary, 1, &#39;defaultValue&#39;) over (partition by dept order by salary ) as &#39;下一个人的工资&#39;\nfrom t_window_func\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/09pl5ltr1uh7bq2eu8qrtj7bob.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-80-window-functionser&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL 8.0 window functions（二）&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-11-30 21:48:22&#34;,&#34;dateFormat&#34;:&#34;2020-11-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-80-window-functionser/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:99000,&#34;words&#34;:420,&#34;minutes&#34;:2},&#34;description&#34;:&#34;接上一篇的内容，继续讲一下窗口函数和分析函数结合的使用。\nlag与lead函数是跟偏移量相关的两个分析函数，通过这两个函数可以在一次查询中取出同一字段的前N行的数据(lag)和后N行的数据(lead)作为独立的列,从而更方便地进行进行数据过...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#lagexpression-offset-default_value\&#34;&gt;lag(expression, offset, default_value)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%AD%E6%B3%95\&#34;&gt;语法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E4%BE%8B\&#34;&gt;示例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#leadexpression-offset-default_value\&#34;&gt;lead(expression, offset, default_value)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E4%BE%8B-2\&#34;&gt;示例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;什么是window-functions\&#34;&gt;什么是window functions&lt;/h1&gt;\n&lt;p&gt;window functions（开窗函数），主要是用来解决聚合函数执行后丢失原有结果的问题。&lt;br&gt;\n通过使用window functions可以同时携带原有结果并且具有聚合后的结果。&lt;/p&gt;\n&lt;p&gt;目前，MySQL8.0已经支持开窗函数了。喜大普奔&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://dev.mysql.com/doc/refman/8.0/en/window-functions.html\&#34;&gt;MySQL8.0 - Window Functions&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;知识点复习\&#34;&gt;知识点复习&lt;/h1&gt;\n&lt;h2 id=\&#34;group-by是分组函数\&#34;&gt;group by是分组函数&lt;/h2&gt;\n&lt;p&gt;group by则只保留参与分组的字段和聚合函数的结果&lt;/p&gt;\n&lt;h2 id=\&#34;sum等聚合函数\&#34;&gt;sum()等聚合函数&lt;/h2&gt;\n&lt;p&gt;avg()、sum()、min()、max()&lt;/p&gt;\n&lt;p&gt;求平均、求和、求最大最小等&lt;/p&gt;\n&lt;h2 id=\&#34;partition-by是分析函数\&#34;&gt;partition by是分析函数&lt;/h2&gt;\n&lt;p&gt;partition by相比较于group by，能够在保留全部数据的基础上，只对其中某些字段做分组排序&lt;/p&gt;\n&lt;h1 id=\&#34;样例数据准备\&#34;&gt;样例数据准备&lt;/h1&gt;\n&lt;p&gt;通过创建一个测试数据表，里面包含员工编号、员工姓名、部门和薪资数据。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\nCREATE TABLE `t_window_func` (\n  `id` int NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) DEFAULT NULL,\n  `dept` varchar(32) DEFAULT NULL,\n  `salary` int DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\nINSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (1, &#39;员工1&#39;, &#39;部门1&#39;, 10000);\nINSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (2, &#39;员工2&#39;, &#39;部门1&#39;, 11000);\nINSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (3, &#39;员工3&#39;, &#39;部门1&#39;, 12000);\nINSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (4, &#39;员工4&#39;, &#39;部门2&#39;, 13000);\nINSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (5, &#39;员工5&#39;, &#39;部门2&#39;, 14000);\nINSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (6, &#39;员工6&#39;, &#39;部门2&#39;, 15000);\nINSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (7, &#39;员工7&#39;, &#39;部门3&#39;, 16000);\nINSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (8, &#39;员工8&#39;, &#39;部门3&#39;, 17000);\nINSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (9, &#39;员工9&#39;, &#39;部门3&#39;, 18000);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/q6mkoi9kbogdkqo18m8148qoc8.png\&#34; alt=\&#34;表数据\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;开窗函数与排名函数结合\&#34;&gt;开窗函数与排名函数结合&lt;/h1&gt;\n&lt;p&gt;窗口函数只要有以下几个：&lt;br&gt;\nrow_number()，rank()，dense_rank()，NTILE()，PERCENT_RANK()&lt;/p&gt;\n&lt;p&gt;下面将每种介绍一个场景进行测试&lt;/p&gt;\n&lt;h2 id=\&#34;row_number\&#34;&gt;row_number()&lt;/h2&gt;\n&lt;p&gt;显示结果集的行号，&lt;strong&gt;当遇到相同数据时，会直接顺序编号&lt;/strong&gt;。&lt;/p&gt;\n&lt;h3 id=\&#34;分别统计每个部门薪资排名\&#34;&gt;分别统计每个部门薪资排名&lt;/h3&gt;\n&lt;p&gt;通过对每个部门分区，对结果集进行汇总，展示在&lt;code&gt;salaryRank&lt;/code&gt;这一列，在没有开窗函数之前，实现此功能可是不简单。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;select\nname, dept, salary, \n       row_number() over (partition by dept order by salary desc ) salaryRank\nfrom t_window_func\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/7f8tgcu962hgrp53fjkec0aoa8.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;统计每个部门薪资排名最高的前两个人\&#34;&gt;统计每个部门薪资排名最高的前两个人&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select *\nfrom (select name,\n             dept,\n             salary,\n             row_number() over (partition by dept order by salary desc ) salaryRank\n      from t_window_func\n     ) tmp\nwhere salaryRank &amp;lt;= 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/0hoie1p7isj9uophfhtsrhjrtb.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;rank-dense_rank\&#34;&gt;rank()、dense_rank()&lt;/h2&gt;\n&lt;h3 id=\&#34;区别\&#34;&gt;区别&lt;/h3&gt;\n&lt;p&gt;rank()用于对结果记录生成序号，dense_rank()和rank()功能相同，当遇到排序字段数据相同时，两者的处理方式不同。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;rank(): 跳跃排序，当第1、2行结果相同时，第1、2行排序为1，&lt;strong&gt;第3行排序为3&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;dense_rank(): 不跳跃排序，当第1、2行结果相同时，第1、2行排序为1，&lt;strong&gt;第3行排序为2&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;数据准备\&#34;&gt;数据准备&lt;/h3&gt;\n&lt;p&gt;首先往表中插入一条数据，使&lt;code&gt;部门3&lt;/code&gt;有两个薪资一样的员工。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;INSERT INTO test_db.t_window_func (id, name, dept, salary) VALUES (10, &#39;员工10&#39;, &#39;部门3&#39;, 17000);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;统计每个部门的排名\&#34;&gt;统计每个部门的排名&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select name,\n       dept,\n       rank() over (partition by dept order by salary desc )       salaryRank,\n       dense_rank() over (partition by dept order by salary desc ) salaryDenseRank\nfrom t_window_func;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/o0fr73l0esjoho8q6jpev0qosf.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;ntile\&#34;&gt;ntile()&lt;/h2&gt;\n&lt;p&gt;函数ntile(group_num)主要用于数据分组，将所有记录分成group_num个组，每组序号一样。&lt;br&gt;\n当数据不足以整除时，会把不够除的余数分给第一组。&lt;/p&gt;\n&lt;h3 id=\&#34;普通ntile分组\&#34;&gt;普通ntile()分组&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select\nname, dept, ntile(3) over (order by salary desc)\nfrom t_window_func;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/tu8da9840ej8qoqf6m8gm3i0go.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;结合partition-by分区分组\&#34;&gt;结合partition by分区分组&lt;/h3&gt;\n&lt;p&gt;针对部门，进行分区分2组。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;select\nname, dept, ntile(2) over (partition by dept order by salary desc)\nfrom t_window_func;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/46engtn98cjgdpdrh4ftoflain.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;cume_dist\&#34;&gt;cume_dist()&lt;/h2&gt;\n&lt;p&gt;计算某个值在一组有序的数据中累计的分布&lt;br&gt;\n计算方法为：&lt;strong&gt;相对位置/总行数,返回值为(0,1]&lt;/strong&gt;&lt;br&gt;\n&lt;strong&gt;注意：对于重复值，计算的时候，取重复值的最后一行的位置&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;select name,\n       dept,\n       salary,\n       round(cume_dist() over (order by salary ), 2) randSalary\nfrom t_window_func;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/6tsgjemm7che8pfdhufa10h85r.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;percent_rank\&#34;&gt;percent_rank()&lt;/h2&gt;\n&lt;p&gt;和cume_dist() 的不同点在于计算分布结果的方法&lt;br&gt;\n计算方法为：&lt;strong&gt;（相对位置-1）/（总行数-1）&lt;/strong&gt;&lt;br&gt;\n&lt;strong&gt;注意：对于重复值，计算的时候，取重复值的第一行的位&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;select name,\n       dept,\n       salary,\n       round(percent_rank() over (order by salary ), 2) randSalary\nfrom t_window_func;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/4781raij6qhssrncu929g346aq.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;同一个window被多次使用\&#34;&gt;同一个window被多次使用&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;select name,\n             dept,\n             salary,\n            row_number() over w salaryRowNumber,\n            rank() over w salaryRank,\n            dense_rank() over w salaryDenseRank\n      from t_window_func\nwindow w as (partition by dept order by salary desc )\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/3pqcnolh46hfoo7qo83g6gsvnd.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;窗口函数和sum等聚合函数结合\&#34;&gt;窗口函数和sum()等聚合函数结合&lt;/h1&gt;\n&lt;p&gt;下面通过sum()函数演示具体的效果，对于avg()等聚合函数效果均相同。&lt;/p&gt;\n&lt;h2 id=\&#34;sum\&#34;&gt;sum()&lt;/h2&gt;\n&lt;h3 id=\&#34;分部门求和\&#34;&gt;分部门求和&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select id,\n       name,\n       dept,\n       sum(salary) over (partition by dept )\nfrom t_window_func;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/3o6mfujs1uge5qnngt84n16pdb.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;和group by结果类似，只是展示形式不同。group by 结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;select id,\n       name,\n       dept,\n       sum(salary)\nfrom t_window_func\ngroup by dept;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/sucgkgtr1sj82qdc5e2om28vfj.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;分部门阶段性累计求和\&#34;&gt;分部门阶段性累计求和&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;上述窗口函数当over中加入了order by之后，结果集大不相同。(order by DESC|ASC)也影响结果&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;over(order by # desc)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;select id,\n       name,\n       dept,\n       sum(salary) over (partition by dept order by salary desc )\nfrom t_window_func;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;12\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/qve5un7bfagjmpqjl1khue6clj.png\&#34; alt=\&#34;order by desc\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;over(order by # asc)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;select id,\n       name,\n       dept,\n       sum(salary) over (partition by dept order by salary asc )\nfrom t_window_func;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;13\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/pbr47c6f50gn8q1ougnrmfnsvm.png\&#34; alt=\&#34;order by desc\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;求总和\&#34;&gt;求总和&lt;/h3&gt;\n&lt;p&gt;over() 中不包含 partition by 和 order by 时，对所有结果集进行求和。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;select id,\n       name,\n       dept,\n       sum(salary) over ()\nfrom t_window_func;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;14\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/11/2qplonccncg7lq1tfsk8fcjc81.png\&#34; alt=\&#34;结果集\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-80-window-functionsyi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL 8.0 window functions（一）&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-11-29 16:53:55&#34;,&#34;dateFormat&#34;:&#34;2020-11-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-80-window-functionsyi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:330000,&#34;words&#34;:1241,&#34;minutes&#34;:6},&#34;description&#34;:&#34;什么是window functions\nwindow functions（开窗函数），主要是用来解决聚合函数执行后丢失原有结果的问题。\n通过使用window functions可以同时携带原有结果并且具有聚合后的结果。\n目前，MySQL8....&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFwindow-functions\&#34;&gt;什么是window functions&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0\&#34;&gt;知识点复习&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#group-by%E6%98%AF%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0\&#34;&gt;group by是分组函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sum%E7%AD%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0\&#34;&gt;sum()等聚合函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#partition-by%E6%98%AF%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0\&#34;&gt;partition by是分析函数&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B7%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87\&#34;&gt;样例数据准备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8E%92%E5%90%8D%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88\&#34;&gt;开窗函数与排名函数结合&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#row_number\&#34;&gt;row_number()&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%88%AB%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%AA%E9%83%A8%E9%97%A8%E8%96%AA%E8%B5%84%E6%8E%92%E5%90%8D\&#34;&gt;分别统计每个部门薪资排名&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%AA%E9%83%A8%E9%97%A8%E8%96%AA%E8%B5%84%E6%8E%92%E5%90%8D%E6%9C%80%E9%AB%98%E7%9A%84%E5%89%8D%E4%B8%A4%E4%B8%AA%E4%BA%BA\&#34;&gt;统计每个部门薪资排名最高的前两个人&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rank-dense_rank\&#34;&gt;rank()、dense_rank()&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%BA%E5%88%AB\&#34;&gt;区别&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87\&#34;&gt;数据准备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%AA%E9%83%A8%E9%97%A8%E7%9A%84%E6%8E%92%E5%90%8D\&#34;&gt;统计每个部门的排名&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ntile\&#34;&gt;ntile()&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%99%AE%E9%80%9Antile%E5%88%86%E7%BB%84\&#34;&gt;普通ntile()分组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E5%90%88partition-by%E5%88%86%E5%8C%BA%E5%88%86%E7%BB%84\&#34;&gt;结合partition by分区分组&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cume_dist\&#34;&gt;cume_dist()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#percent_rank\&#34;&gt;percent_rank()&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8C%E4%B8%80%E4%B8%AAwindow%E8%A2%AB%E5%A4%9A%E6%AC%A1%E4%BD%BF%E7%94%A8\&#34;&gt;同一个window被多次使用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E5%92%8Csum%E7%AD%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88\&#34;&gt;窗口函数和sum()等聚合函数结合&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#sum\&#34;&gt;sum()&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E9%83%A8%E9%97%A8%E6%B1%82%E5%92%8C\&#34;&gt;分部门求和&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E9%83%A8%E9%97%A8%E9%98%B6%E6%AE%B5%E6%80%A7%E7%B4%AF%E8%AE%A1%E6%B1%82%E5%92%8C\&#34;&gt;分部门阶段性累计求和&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B1%82%E6%80%BB%E5%92%8C\&#34;&gt;求总和&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;dtp和xa\&#34;&gt;DTP和XA&lt;/h3&gt;\n&lt;p&gt;分布式事务的解决方案之一就是两阶段提交协议（2PC：Two-Phase Commit）&lt;/p&gt;\n&lt;p&gt;1994年X/Open组织（现在的Open Group）定义了分布式事务处理的&lt;strong&gt;DTP模型&lt;/strong&gt;，该模型包括这样几个角色：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;应用程序（AP）：业务微服务&lt;/li&gt;\n&lt;li&gt;事务管理器（TM）：全局事务管理者&lt;/li&gt;\n&lt;li&gt;资源管理者（RM）：一般是数据库&lt;/li&gt;\n&lt;li&gt;通信资源管理器（CRM）：是TM和RM间的通信中间件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在该模型中，一个分布式事务（全局事务）可以被拆分成多个本地事务，运行在不同的AP和RM上，每个本地事务的ACID很好实现，但是全局事务必须保证其中包含的每个本地事务都能成功，若有一个失败，则所有其他事务都必须回滚。&lt;br&gt;\n问题是本地事务处理过程中，并不知道其他事务的运行状态，因此就&lt;strong&gt;需要通过CRM来通知各个本地事务，同步事务执行状态&lt;/strong&gt;。&lt;br&gt;\n因此各个本地事务的通信必须有一个统一的标准，否则不同数据库之间就无法通信，XA就是X/Open DTP中通信中间件和TM间联系的&lt;strong&gt;接口规范&lt;/strong&gt;，定义了用于通知事务开始、提交、终止、回滚等接口，各个数据库厂商都必须实现这些接口。&lt;/p&gt;\n&lt;h3 id=\&#34;2pc两阶段提交\&#34;&gt;2PC（两阶段提交）&lt;/h3&gt;\n&lt;p&gt;参考：&lt;a href=\&#34;https://zhuanlan.zhihu.com/p/35298019\&#34;&gt;漫话分布式系统共识协议: 2PC/3PC篇&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;两阶提交协议&lt;/strong&gt;就是根据这一思想衍生出来的，将全局事务拆分为两个阶段来执行。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;阶段一：准备阶段，各个本地事务完成本地事务的准备工作。&lt;/li&gt;\n&lt;li&gt;阶段二：执行阶段，各个本地事务根据上一阶段执行结果，进行提交或回滚。&lt;br&gt;\n这个过程中需要一个协调者（coordinator），还有事务的参与者（voter）。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;正常情况\&#34;&gt;正常情况&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://pic4.zhimg.com/80/v2-e2f7149a81d9ad3aa46589e25503d688_1440w.jpg\&#34; alt=\&#34;2pc\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;strong&gt;投票阶段&lt;/strong&gt;：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入undo和redo log，然后反馈事务执行成功。（agree）&lt;br&gt;\n&lt;strong&gt;提交阶段&lt;/strong&gt;：协调组发现每个参与者都可以执行事务（agree），于是向各个事务参与者发出commit指令，各个事务参与者提交事务。&lt;/p&gt;\n&lt;h4 id=\&#34;异常情况\&#34;&gt;异常情况&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://pic2.zhimg.com/80/v2-d40abfa365ed84e84e264ba13900f64b_1440w.jpg\&#34; alt=\&#34;2pc\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;strong&gt;投票阶段&lt;/strong&gt;：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入undo和redo log，然后反馈事务执行结果，但只要有一个参与者返回的是&lt;code&gt;Disagree&lt;/code&gt;，就说明执行失败。&lt;br&gt;\n&lt;strong&gt;提交阶段&lt;/strong&gt;：协调组发现每个有一个或多个参与者返回Disagree，认为执行失败，于是向各个事务参与者发出&lt;code&gt;abort&lt;/code&gt;指令，各个事务参与者回滚事务。&lt;/p&gt;\n&lt;h4 id=\&#34;缺陷\&#34;&gt;缺陷&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;存在CRM单点故障问题&lt;br&gt;\n协调者挂了之后就不知道别人什么情况。&lt;br&gt;\n&lt;img src=\&#34;https://pic3.zhimg.com/80/v2-a9e4ef8b9082ffdf76bc426e61ba3ed2_1440w.jpg\&#34; alt=\&#34;2pc\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;阻塞问题&lt;br&gt;\n在准备阶段，提交阶段，每个事务参与者都会锁定本地资源，并等待其他事务的执行结果，阻塞时间较长。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;总结\&#34;&gt;总结&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;面对二阶段提交的缺点，后来又演变出来了三阶段提交，但是依旧没有解决阻塞和资源锁定的问题，而且引入了新的微，因此实际场景使用较少。&lt;/li&gt;\n&lt;li&gt;2PC拥有稳定成熟的框架支持，可以保证强一致，并且对代码侵入度不高，&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h4 id=\&#34;使用场景\&#34;&gt;使用场景&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;适用于对效率要求不高，一致性要求高的场景&lt;/li&gt;\n&lt;li&gt;代码侵入度小，不影响原有代码&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;3pc三阶段提交\&#34;&gt;3PC（三阶段提交）&lt;/h3&gt;\n&lt;h2 id=\&#34;tcc\&#34;&gt;TCC&lt;/h2&gt;\n&lt;p&gt;TCC模式可以解决2PC中资源锁定和阻塞的问题，减少资源锁定时间。&lt;/p&gt;\n&lt;h3 id=\&#34;基本原理\&#34;&gt;基本原理&lt;/h3&gt;\n&lt;p&gt;本质是一种&lt;strong&gt;补偿&lt;/strong&gt;的机制，事务运行包括三个方法，&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;try：资源的检测和预留&lt;/li&gt;\n&lt;li&gt;confirm：执行业务操作提交；要求try成功confirm一定能成功&lt;/li&gt;\n&lt;li&gt;cancel：预留资源释放&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;执行分两个阶段：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;准备阶段（try）：资源的检测和预留&lt;/li&gt;\n&lt;li&gt;执行阶段（confirm/cancel）：根据上一步的结果，判断下面的执行方法。如果上一步所有事务参与者都成功，这里执行confirm，否则执行cancel&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/u3n1k3gdrmio1rn77kkmq75mk7.png\&#34; alt=\&#34;tcc\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;看似与两阶段提交没有什么区别，其实差距很大。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;try，confirm，cancel都是独立的事务&lt;/strong&gt;，不受其他参与者的影响，不会阻塞等待他人。&lt;/li&gt;\n&lt;li&gt;try，confirm，cancel由程序员在业务层编写，锁粒度由代码控制。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;实例\&#34;&gt;实例&lt;/h3&gt;\n&lt;p&gt;假如账户A原来有100元，需要从余额扣除30元。如图：&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/tmr3m1trf2gphpmjn63s4apc1j.png\&#34; alt=\&#34;tcc\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;一阶段（Try）：余额检查，并冻结用户部分金额，此阶段执行完毕，事务已提交。\n&lt;ul&gt;\n&lt;li&gt;检查用户余额是否足够，如果足够，冻结部分余额&lt;/li&gt;\n&lt;li&gt;在账户表中添加冻结金额字段，值为30，余额不变&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;二阶段\n&lt;ul&gt;\n&lt;li&gt;提交（Confirm）：真正的扣款，把冻结金额从余额中扣除，冻结金额清空。\n&lt;ul&gt;\n&lt;li&gt;修改冻结金额=0，修改余额为100-30=79&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;补偿（Cancel）：释放之前冻结的金额，不是回滚\n&lt;ul&gt;\n&lt;li&gt;余额不变，修改账户冻结金额=0&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;优势缺点\&#34;&gt;优势&amp;amp;缺点&lt;/h3&gt;\n&lt;h4 id=\&#34;优势\&#34;&gt;优势&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;避免资源长期锁定和阻塞等待操作。执行效率高。&lt;br&gt;\nTCC执行的每个阶段都是独立的事务，不需要等待其他事务的结果。如果执行失败，不是执行的回滚而是执行的&lt;strong&gt;补偿&lt;/strong&gt;。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;缺点\&#34;&gt;缺点&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;代码侵入&lt;/strong&gt;：需要人为编写try，confirm，cancel操作，对开发人员要求高&lt;/li&gt;\n&lt;li&gt;开发成本高：一个业务需要拆分三个阶段，开发成本高&lt;/li&gt;\n&lt;li&gt;安全性考虑：cancel动作如果执行失败，资源就无法释放。需要引入重试，但是引入重试又有可能造成重复执行问题，还需要考虑重试时的幂等问题。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;使用场景-2\&#34;&gt;使用场景&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;对事务有一定的一致性要求（最终一致性）&lt;/li&gt;\n&lt;li&gt;对性能要求较高&lt;/li&gt;\n&lt;li&gt;开发人员具备较高的编码能力和幂等处理经验&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;可靠消息服务\&#34;&gt;可靠消息服务&lt;/h2&gt;\n&lt;p&gt;源于eBay，设计思想是将远程分布式事务拆分成一系列的本地事务。&lt;/p&gt;\n&lt;h3 id=\&#34;基本原理-2\&#34;&gt;基本原理&lt;/h3&gt;\n&lt;p&gt;事务分为&lt;code&gt;发起者A&lt;/code&gt;和&lt;code&gt;参与者BCD&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;事务&lt;code&gt;发起者A&lt;/code&gt;执行本地事务&lt;/li&gt;\n&lt;li&gt;事务&lt;code&gt;发起者A&lt;/code&gt;通过MQ将需要执行的事务信息发送给&lt;code&gt;事务参与者BCD&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;事务&lt;code&gt;参与者BCD&lt;/code&gt;接收到消息后执行本地事务&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/qh87gftgnuiovqhu1aj3thcj8d.png\&#34; alt=\&#34;mq\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;现实场景（老师给的场景，好像不恰当）：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;你点了一杯奶茶，付完钱。（发起者A完成）&lt;/li&gt;\n&lt;li&gt;服务员给了你一个号码牌。（参与者B）&lt;/li&gt;\n&lt;li&gt;你凭这张小票，一定能够领到一杯奶茶。（不断问服务员，重试）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;本地消息表\&#34;&gt;本地消息表&lt;/h3&gt;\n&lt;p&gt;为了避免消息发送失败或丢失，消息需要持久化到数据库。实现有简化版本和解耦合版本两种。&lt;/p&gt;\n&lt;h4 id=\&#34;简化版本\&#34;&gt;简化版本&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/p0a94m11pgjahpd5btcceofk5m.png\&#34; alt=\&#34;mq\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;事务发起者\n&lt;ol&gt;\n&lt;li&gt;开启本地事务&lt;/li&gt;\n&lt;li&gt;执行业务操作&lt;/li&gt;\n&lt;li&gt;发送消息到MQ&lt;/li&gt;\n&lt;li&gt;保存消息记录到数据库，&lt;strong&gt;记录为已发送&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;提交本地事务&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;事务参与者\n&lt;ol&gt;\n&lt;li&gt;接收消息&lt;/li&gt;\n&lt;li&gt;开启本地事务&lt;/li&gt;\n&lt;li&gt;执行业务操作&lt;/li&gt;\n&lt;li&gt;修改数据库&lt;strong&gt;记录状态为已消费&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;提交本地事务&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;额外的定时任务\n&lt;ul&gt;\n&lt;li&gt;定时扫描数据库中超时未消费的，重新发送&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;优点缺点\&#34;&gt;优点&amp;amp;缺点&lt;/h3&gt;\n&lt;h4 id=\&#34;优点\&#34;&gt;优点&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;与TCC相比，不用写那么多代码。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;缺点-2\&#34;&gt;缺点&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;数据一致性完全依赖MQ，因此消息服务一定需要可靠。&lt;/li&gt;\n&lt;li&gt;需要处理被动业务方的幂等问题。&lt;/li&gt;\n&lt;li&gt;被动业务失败不会主动业务回滚，而是重试被动的业务。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;事务业务与消息业务耦合，发起者业务完成后需要写消息表&lt;/strong&gt;。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;独立消息服务\&#34;&gt;独立消息服务&lt;/h3&gt;\n&lt;p&gt;通过引入独立的消息服务，完成对消息的持久化、发送、确认、失败重试等行为。&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/rg722262raj42ous0564ei5dae.png\&#34; alt=\&#34;mq\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;rocketmq事务消息\&#34;&gt;RocketMQ事务消息&lt;/h4&gt;\n&lt;p&gt;自带事务消息，可以保证消息的可靠性，原理就是自带了一个本地消息表。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/apache/rocketmq/blob/master/docs/cn/features.md#7-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF\&#34;&gt;RocketMQ-事务消息&lt;/a&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;rabbitmq的消息确认\&#34;&gt;RabbitMQ的消息确认&lt;/h4&gt;\n&lt;p&gt;RabbitMQ确保消息不丢失使用的是ACK确认机制。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;生产者确认机制：确保从生产者 -&amp;gt; MQ不丢失\n&lt;ul&gt;\n&lt;li&gt;生产者发送消息到mq，设置异步监听MQ的ACK&lt;/li&gt;\n&lt;li&gt;MQ接收到消息，返回ACK到生产者\n&lt;ol&gt;\n&lt;li&gt;消息到exchange但是route失败，返回失败ACK&lt;/li&gt;\n&lt;li&gt;消息route成功，持久化失败，返回失败ACK&lt;/li&gt;\n&lt;li&gt;消息route成功，持久化成功，返回成功ACK&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;生产者提前编写好不同回调的处理方式\n&lt;ol&gt;\n&lt;li&gt;成功，记录日志&lt;/li&gt;\n&lt;li&gt;失败，一段时间后重新发送&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;消费者确认机制：确保从MQ -&amp;gt; 消费者正确消费\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;消费者开启监听时开启手动ACK模式&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;mq将消息发送到消费者后，会等待消费者ACK\n&lt;ol&gt;\n&lt;li&gt;收到消费者ACK才会删除消息&lt;/li&gt;\n&lt;li&gt;一直没有收到ACK则一直保存&lt;/li&gt;\n&lt;li&gt;消费者断开或异常后，发送给其它消费者（此处需要做好幂等）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;消费者处理完消息，提交事务，手动ACK。如果异常，则不会ACK，业务处理失败。等待处理下一条消息。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;事务消息优点缺点\&#34;&gt;事务消息优点&amp;amp;缺点&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;优点\n&lt;ul&gt;\n&lt;li&gt;业务简单，不需要写三个阶段的代码&lt;/li&gt;\n&lt;li&gt;多个本地事务，缩短资源锁定时间，性能高&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;缺点\n&lt;ul&gt;\n&lt;li&gt;代码侵入度高&lt;/li&gt;\n&lt;li&gt;一致性依赖MQ的可靠性&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;消息发起者可以回滚，参与者无法引起全局事务回滚&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;时效性差，完全取决于MQ的消息发送是否及时，消费是否及时。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;针对缺点3，无法回滚问题。有人提出可以让事务参与者失败后，利用MQ通知消息服务，由消息服务通知其他参与者回滚，可是这是在利用MQ重新实现了2PC，又是一个轮子。没必要&lt;/p&gt;\n&lt;h2 id=\&#34;seata\&#34;&gt;Seata&lt;/h2&gt;\n&lt;p&gt;官网：&lt;a href=\&#34;http://seata.io/\&#34;&gt;http://seata.io/&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Seata是阿里开源的框架，支持XA，AT，TCC，SAGA四种模式。&lt;/p&gt;\n&lt;h3 id=\&#34;at模式\&#34;&gt;AT模式&lt;/h3&gt;\n&lt;p&gt;2019年1月份，Seata开源了AT模式。AT模式是一种无侵入的分布式事务解决方案。是对TCC或两阶段提交模型的优化，解决了TCC模式代码侵入，编码复杂等问题。&lt;/p&gt;\n&lt;p&gt;在AT模式下，用户只需要关注自己业务的&amp;quot;sql&amp;quot;，用户的业务SQL作为“一阶段”，Seata框架会解析SQL自动生成事务的“二阶段”提交或回滚操作。&lt;/p&gt;\n&lt;p&gt;Seata官方文档：&lt;a href=\&#34;seata.io\&#34;&gt;seata.io&lt;/a&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/qlv6afj24ohdopkuksaoi920l2.png\&#34; alt=\&#34;at-1\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;乍一看和TCC协议很像，都是分两阶段提交。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;一阶段：执行本地事务，并返回执行结果&lt;/li&gt;\n&lt;li&gt;二阶段：根据一阶段的结果，决定执行提交或回滚&lt;br&gt;\n但是AT模式底层完全不同，二阶段完全不需要我们编码，框架帮我们实现了。我们写的代码和本地事务代码完全一致，无需手动处理分布式事务。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;一阶段\&#34;&gt;一阶段&lt;/h4&gt;\n&lt;p&gt;一阶段，Seata会拦截&lt;code&gt;业务SQL&lt;/code&gt;，首先解析SQL语义，找到&lt;code&gt;业务SQL&lt;/code&gt;要更新的业务数据，在业务数据被更新前，将其保存为&lt;code&gt;before image&lt;/code&gt;，然后执行&lt;code&gt;业务SQL&lt;/code&gt;，更新业务数据，在业务数据执行之后，再将其保存为&lt;code&gt;after image&lt;/code&gt;，最后获取全局行锁，&lt;strong&gt;提交事务&lt;/strong&gt;。以上所有操作都是在一个本地事务中完成，保证了一阶段的原子性。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;before image&lt;/code&gt;和&lt;code&gt;after image&lt;/code&gt;类似于数据库的undo log和redo log。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/15j04em37giudou1njfedr92rv.png\&#34; alt=\&#34;at-2\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;二阶段提交\&#34;&gt;二阶段提交&lt;/h4&gt;\n&lt;p&gt;二阶段如果是提交的话，因为&lt;code&gt;业务SQL&lt;/code&gt;在一阶段已经提交到数据库，所以Seata框架只需要将一阶段保存的快照数据和行锁删掉，完成数据清理即可。&lt;/p&gt;\n&lt;h4 id=\&#34;二阶段回滚\&#34;&gt;二阶段回滚&lt;/h4&gt;\n&lt;p&gt;回滚可直接使用&lt;code&gt;before image&lt;/code&gt;还原业务数据，但在还原前首先要检查脏写，对比&lt;code&gt;数据库当前业务数据&lt;/code&gt;与&lt;code&gt;after image&lt;/code&gt;，如果两份完全一致则没有脏写，可以还原；如果数据不一致，说明出现了脏写，需要人工处理。&lt;/p&gt;\n&lt;h4 id=\&#34;详细架构和流程\&#34;&gt;详细架构和流程&lt;/h4&gt;\n&lt;p&gt;基本概念&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;TC（Transaction Coordinator）：事务协调者，维护全局和分支事务的状态，驱动全局事务提交或回滚（TM之间的协调者）&lt;/li&gt;\n&lt;li&gt;TM（Transaction Manager）：事务管理器，定义全局事务的范围：开启全局事务，提交或回滚全局事务&lt;/li&gt;\n&lt;li&gt;RM（Resource Manager）：资源管理器，管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/qh04k2e1h2ge6qmqknagdselpf.png\&#34; alt=\&#34;at-3\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;TM：业务模块中全局事务的开启者\n&lt;ul&gt;\n&lt;li&gt;向TC开启一个全局事务&lt;/li&gt;\n&lt;li&gt;调用其它微服务&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;RM：业务模块执行者中，包含RM部分，负责向TC汇报事务执行状态\n&lt;ul&gt;\n&lt;li&gt;执行本地事务&lt;/li&gt;\n&lt;li&gt;向TC注册分支事务，并提交本地事务执行结果&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;TM：结束对微服务的调用，通知TC，全局事务执行完毕，一阶段结束&lt;/li&gt;\n&lt;li&gt;TC：汇总各个分支事务执行结果，决定分布式事务是提交还是回滚&lt;/li&gt;\n&lt;li&gt;TC：通知所有RM提交/回滚资源，二阶段结束&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;详细流程\&#34;&gt;详细流程&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;一阶段\n&lt;ul&gt;\n&lt;li&gt;TM开启全局事务，并向TC声明全局事务，包括全局事务XID信息&lt;/li&gt;\n&lt;li&gt;TM所在服务调用其他微服务&lt;/li&gt;\n&lt;li&gt;微服务，主要由RM执行\n&lt;ul&gt;\n&lt;li&gt;查询&lt;code&gt;before image&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;执行本地事务&lt;/li&gt;\n&lt;li&gt;查询&lt;code&gt;after image&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;生成&lt;code&gt;undo log&lt;/code&gt;写入数据库&lt;/li&gt;\n&lt;li&gt;向TC注册分支事务，并告知事务执行结果&lt;/li&gt;\n&lt;li&gt;获取全局锁（防止其他全局事务并发修改当前数据）&lt;/li&gt;\n&lt;li&gt;释放本地锁（不影响其他业务对数据的操作）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;二阶段\n&lt;ul&gt;\n&lt;li&gt;TC 统计各个分支事务的执行情况，根据情况做对应的操作\n&lt;ul&gt;\n&lt;li&gt;都成功：通知分支事务，提交事务&lt;/li&gt;\n&lt;li&gt;有分支失败：通知执行成功的事务，回滚数据（做补偿）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;分支事务RM\n&lt;ul&gt;\n&lt;li&gt;提交事务：直接清空&lt;code&gt;before image&lt;/code&gt;和&lt;code&gt;after image&lt;/code&gt;信息，释放全局锁&lt;/li&gt;\n&lt;li&gt;回滚事务\n&lt;ul&gt;\n&lt;li&gt;校验&lt;code&gt;after image&lt;/code&gt;，判断是否有脏写&lt;/li&gt;\n&lt;li&gt;如果没有脏写，回滚到&lt;code&gt;before image&lt;/code&gt;，清空&lt;code&gt;before image&lt;/code&gt;和&lt;code&gt;after image&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;如果有脏写，需要人工干预&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;优点缺点-2\&#34;&gt;优点&amp;amp;缺点&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;优点\n&lt;ol&gt;\n&lt;li&gt;一阶段无锁，高性能&lt;/li&gt;\n&lt;li&gt;补偿服务易于实现&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;缺点\n&lt;ol&gt;\n&lt;li&gt;解析，查询和保存undo log的blob字段徒增性能损耗，根据二八定理，80%的业务是不会出现问题，而需要接受这部分写入log的损耗&lt;/li&gt;\n&lt;li&gt;不保证隔离性，一阶段完成后仅维护着全局事务锁XID提交了本地事务。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;适用场景\&#34;&gt;适用场景&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;业务流程长，业务逻辑多的地方。&lt;/li&gt;\n&lt;li&gt;历史遗留代码无法修改的情况&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;fen-bu-shi-shi-wu-san-fen-bu-shi-shi-wu-jie-jue-fang-an&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;分布式事务(三) 分布式事务解决方案&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-09-07 22:42:38&#34;,&#34;dateFormat&#34;:&#34;2020-09-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/fen-bu-shi-shi-wu-san-fen-bu-shi-shi-wu-jie-jue-fang-an/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;14 min read&#34;,&#34;time&#34;:783000,&#34;words&#34;:3730,&#34;minutes&#34;:14},&#34;description&#34;:&#34;DTP和XA\n分布式事务的解决方案之一就是两阶段提交协议（2PC：Two-Phase Commit）\n1994年X/Open组织（现在的Open Group）定义了分布式事务处理的DTP模型，该模型包括这样几个角色：\n\n应用程序（AP）：业...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#dtp%E5%92%8Cxa\&#34;&gt;DTP和XA&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2pc%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4\&#34;&gt;2PC（两阶段提交）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5\&#34;&gt;正常情况&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5\&#34;&gt;异常情况&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E9%99%B7\&#34;&gt;缺陷&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\&#34;&gt;使用场景&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3pc%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4\&#34;&gt;3PC（三阶段提交）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcc\&#34;&gt;TCC&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\&#34;&gt;基本原理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E4%BE%8B\&#34;&gt;实例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E5%8A%BF%E7%BC%BA%E7%82%B9\&#34;&gt;优势&amp;amp;缺点&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E5%8A%BF\&#34;&gt;优势&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E7%82%B9\&#34;&gt;缺点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2\&#34;&gt;使用场景&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1\&#34;&gt;可靠消息服务&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-2\&#34;&gt;基本原理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8\&#34;&gt;本地消息表&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC\&#34;&gt;简化版本&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E7%82%B9%E7%BC%BA%E7%82%B9\&#34;&gt;优点&amp;amp;缺点&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E7%82%B9\&#34;&gt;优点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E7%82%B9-2\&#34;&gt;缺点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%8B%AC%E7%AB%8B%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1\&#34;&gt;独立消息服务&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#rocketmq%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF\&#34;&gt;RocketMQ事务消息&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rabbitmq%E7%9A%84%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4\&#34;&gt;RabbitMQ的消息确认&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E4%BC%98%E7%82%B9%E7%BC%BA%E7%82%B9\&#34;&gt;事务消息优点&amp;amp;缺点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#seata\&#34;&gt;Seata&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#at%E6%A8%A1%E5%BC%8F\&#34;&gt;AT模式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80%E9%98%B6%E6%AE%B5\&#34;&gt;一阶段&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4\&#34;&gt;二阶段提交&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%9B%9E%E6%BB%9A\&#34;&gt;二阶段回滚&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%A6%E7%BB%86%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B5%81%E7%A8%8B\&#34;&gt;详细架构和流程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B\&#34;&gt;详细流程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E7%82%B9%E7%BC%BA%E7%82%B9-2\&#34;&gt;优点&amp;amp;缺点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\&#34;&gt;适用场景&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;cap理论\&#34;&gt;CAP理论&lt;/h2&gt;\n&lt;p&gt;什么是CAP理论？&lt;a href=\&#34;http://www.ruanyifeng.com/blog/2018/07/cap.html\&#34;&gt;阮一峰-CAP 定理的含义&lt;/a&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg\&#34; alt=\&#34;CAP\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;1998年，加州大学的计算机科学家Eric Brewer 提出，分布式系统有三个指标。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Consistency（一致性） - C&lt;/li&gt;\n&lt;li&gt;Availability（可用性）  - A&lt;/li&gt;\n&lt;li&gt;Partition tolerance（分区容错性）  - P&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;partition-tolerance\&#34;&gt;Partition tolerance&lt;/h3&gt;\n&lt;p&gt;大部分分布式系统都分布在多个子网络，每个子网络叫做一个&lt;strong&gt;区（Partition）&lt;/strong&gt;，分区容错的意思是区间通信可能会失败。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/3ar3v3qm3cjmeqe6080nbcl54o.png\&#34; alt=\&#34;cap-p\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;上图中，G1和G2是两台跨区的服务器，G1向G2发送一条消息，G2可能无法收到，系统设计的时候，需要考虑到这种情况。&lt;br&gt;\n一般来说，&lt;strong&gt;分布式系统中分区容错性无法避免，因此可以认为CAP中的P总是成立，根据CAP定理，剩下的C和A无法同时满足&lt;/strong&gt;。&lt;/p&gt;\n&lt;h3 id=\&#34;consistency\&#34;&gt;Consistency&lt;/h3&gt;\n&lt;p&gt;一致性的意思是，写操作之后的读操作，必须返回该值，举例来说，某条记录是V0，用户向G1发起一个写操作，将其改为V1。&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/0rbg59pergi1uos6ht6hqgderm.png\&#34; alt=\&#34;cap-c-1\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n接下来，用户的读操作就会得到V1，这叫做&lt;strong&gt;数据的一致性&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/pn2ki67jo6g27p0krmdk11n7qf.png\&#34; alt=\&#34;cap-c-2\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n问题是，用户有可能向G2发起读操作，由于G2的值没有变化，因此返回的是V0，G1和G2读操作的结果不一致，这就不满足一致性了。&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/4b49j404vajttoqq733cm6st3b.png\&#34; alt=\&#34;cap-c-3\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n为了让G2也能变成V1，就要在G1写操作的时候，让G1向G2发送一条消息，要求G2也改成V1.&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/0a81st7q7eho5rfdd6vr5gq0s7.png\&#34; alt=\&#34;cap-c-4\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n这样的话，用户向G2发起读操作，也能得到V1.&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/prldhirihah0kq59fng5jj3q25.png\&#34; alt=\&#34;cap-c-5\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;availability\&#34;&gt;Availability&lt;/h3&gt;\n&lt;p&gt;只要收到了用户的请求，服务器就必须给出回应。（不论对错）&lt;br&gt;\n用户可以向G1或G2发起读操作，不管是那台服务器，只要收到请求就必须返回用户到底是V1还是V0，否则就不满足&lt;strong&gt;可用性&lt;/strong&gt;。&lt;/p&gt;\n&lt;h3 id=\&#34;consistency和availability的矛盾\&#34;&gt;Consistency和Availability的矛盾&lt;/h3&gt;\n&lt;p&gt;Q：一致性和可用性为什么不能同时满足？&lt;br&gt;\nA：因为通信可能会失败（出现分区容错）&lt;/p&gt;\n&lt;p&gt;如果&lt;u&gt;保证G2的一致性&lt;/u&gt;，那么G1必须在写操作时，锁定G2的读写操作。只有数据库同步后，才能重新开放读写操作。锁定期间，G2没有&lt;strong&gt;可用性&lt;/strong&gt;&lt;br&gt;\n如果&lt;u&gt;保证G2的可用性&lt;/u&gt;，那么不能锁定G2，G2没有&lt;strong&gt;一致性&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;几点疑问\&#34;&gt;几点疑问&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;怎样同时满足CAP？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;除非是单体架构&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;何时要满足CP？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;对一致性要求高的场景&lt;/strong&gt;，Zookeeper就是这样，在服务节点数据同步时，服务对外不可用。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;何时要满足AP？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;对可用性要求高的场景&lt;/strong&gt;，Eureka就是这样，必须保证注册中心随时可用，不然拉取不到服务就可能出问题，所以可能会出现eureka节点间数据不一致的问题。&lt;/p&gt;\n&lt;h2 id=\&#34;base理论\&#34;&gt;Base理论&lt;/h2&gt;\n&lt;p&gt;base是三个单词的缩写&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Basically Available（基本可用）&lt;br&gt;\n不能满足完全可用，等一小段同步时间，就满足基本可用，只要时间足够短。&lt;/li&gt;\n&lt;li&gt;Soft state（软状态）&lt;br&gt;\n保留一个中间状态&lt;/li&gt;\n&lt;li&gt;Eventually consistent（最终一致性）&lt;br&gt;\n不能实时的一致性，等待数据同步完成后，满足一致性。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;解决分布式事务，就是根据Base理论来实现的。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;fen-bu-shi-shi-wu-er-jie-jue-fen-bu-shi-shi-wu-de-si-lu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;分布式事务(二) 解决分布式事务的思路&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-09-06 11:48:00&#34;,&#34;dateFormat&#34;:&#34;2020-09-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/fen-bu-shi-shi-wu-er-jie-jue-fen-bu-shi-shi-wu-de-si-lu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:170000,&#34;words&#34;:795,&#34;minutes&#34;:3},&#34;description&#34;:&#34;CAP理论\n什么是CAP理论？阮一峰-CAP 定理的含义\n\n1998年，加州大学的计算机科学家Eric Brewer 提出，分布式系统有三个指标。\n\nConsistency（一致性） - C\nAvailability（可用性）  - A\nP...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#cap%E7%90%86%E8%AE%BA\&#34;&gt;CAP理论&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#partition-tolerance\&#34;&gt;Partition tolerance&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#consistency\&#34;&gt;Consistency&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#availability\&#34;&gt;Availability&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#consistency%E5%92%8Cavailability%E7%9A%84%E7%9F%9B%E7%9B%BE\&#34;&gt;Consistency和Availability的矛盾&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%A0%E7%82%B9%E7%96%91%E9%97%AE\&#34;&gt;几点疑问&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#base%E7%90%86%E8%AE%BA\&#34;&gt;Base理论&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;什么是分布式事务\&#34;&gt;什么是分布式事务&lt;/h1&gt;\n&lt;p&gt;要了解分布式事务，首先需要了解什么是本地事务。&lt;/p&gt;\n&lt;h2 id=\&#34;本地事务\&#34;&gt;本地事务&lt;/h2&gt;\n&lt;p&gt;本地事务，是指传统的单机数据库事务，必须满足ACID原则。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;原子性（atomicity）&lt;br&gt;\n整个事务中所有操作，要么一块完成，要么都不完成。&lt;br&gt;\n对于事务发生错误，所有操作必须完成回滚。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;一致性（consistency）&lt;br&gt;\n事务的执行必须保证系统的一致性，事务在开始之前和结束之后，数据库的&lt;strong&gt;完整性&lt;/strong&gt;不能被破坏。&lt;br&gt;\n比如在一个事务中，A（余额100）给B（余额100）转账10元，那么不管发生什么，最终A和B的账户总额必须是200元。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;隔离性（isolation）&lt;br&gt;\n隔离性就是事务与事务之间不会互相影响，一个事务的中间状态不能被其他事务感知。数据库的隔离级别包括四种：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Read UmCommitted 读取未提交内容&lt;/li&gt;\n&lt;li&gt;Read Committed 读取提交内容&lt;/li&gt;\n&lt;li&gt;Repeatable Read 可重复读&lt;/li&gt;\n&lt;li&gt;Seriallzable 可串行化&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;持久性（durability）&lt;br&gt;\n事物一旦执行完毕，那么事务对数据进行的变更就完全保存在数据库硬盘中，即使断电、宕机也不会改变。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;传统项目中，项目部署基本都是单点式，这种情况下，数据库本身的事务机制就能保证ACID的原则，这样的事务叫做本地事务。&lt;br&gt;\n其中原子性和持久性需要依靠undo和redo日志来实现。&lt;/p&gt;\n&lt;h2 id=\&#34;undo和redo日志\&#34;&gt;undo和redo日志&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;数据库中数据从来不是最重要的，日志才是。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在缓存中也有log buffer，也有磁盘log file。&lt;br&gt;\n&lt;strong&gt;MySQL的日志文件，有两种与事务有关，undo log和redo log&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;undo日志\&#34;&gt;undo日志&lt;/h3&gt;\n&lt;h4 id=\&#34;介绍\&#34;&gt;介绍&lt;/h4&gt;\n&lt;p&gt;数据库事务具备原子性（Atomicity），如果事务执行失败，需要把数据回滚。&lt;br&gt;\n事务同时还具备持久性（durability），事务对数据做的更改完全保存在数据库，不能因为故障而丢失。&lt;br&gt;\n原子性可以使用undo log来实现。&lt;/p&gt;\n&lt;h4 id=\&#34;原理\&#34;&gt;原理&lt;/h4&gt;\n&lt;p&gt;undo log的原理很简单，为了满足事务的原子性，&lt;strong&gt;在操作任何数据之前都会将数据备份到undo log中然后再对数据进行更改&lt;/strong&gt;。如果执行出错或者手动回滚后，系统可以利用undo log中备份的数据恢复到事务开始之前的状态。&lt;br&gt;\n&lt;strong&gt;数据库写入数据到磁盘之前，会把数据先缓存在内存中。事务提交才写入到磁盘。&lt;/strong&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;实例\&#34;&gt;实例&lt;/h4&gt;\n&lt;p&gt;用undo log实现原子性和持久性的简化过程：&lt;br&gt;\n假设有A=1, B=2两条数据。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/u01mna67dej84qtokjc1o342ca.png\&#34; alt=\&#34;实例.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;如何保证持久性？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;事务提交前，会把修改数据记录到磁盘中，只要事务提交了，数据肯定持久化了。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;如何保证原子性？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;每次对数据库修改，都会把修改前记录保存在undo log中，需要回滚时可以直接读取undo log恢复数据。&lt;/p&gt;\n&lt;h4 id=\&#34;缺陷\&#34;&gt;缺陷&lt;/h4&gt;\n&lt;p&gt;每个事务提交前都需要将数据和undo log写入到磁盘，导致大量磁盘IO，性能差。&lt;/p&gt;\n&lt;h3 id=\&#34;redo日志\&#34;&gt;redo日志&lt;/h3&gt;\n&lt;p&gt;和undo log相反，redo log是对新数据的备份，在事务提交之前，只要将redo log持久化即可，不需要将数据持久化，减少IO操作。&lt;/p&gt;\n&lt;h4 id=\&#34;实例-2\&#34;&gt;实例&lt;/h4&gt;\n&lt;p&gt;用undo log + redo log 实现原子性和持久性的简化过程：&lt;br&gt;\n假设有A=1, B=2两条数据。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;事务开始&lt;/li&gt;\n&lt;li&gt;记录A=1到undo log buffer&lt;/li&gt;\n&lt;li&gt;修改A=3&lt;/li&gt;\n&lt;li&gt;记录A=3到redo log buffer&lt;/li&gt;\n&lt;li&gt;记录B=2到undo log buffer&lt;/li&gt;\n&lt;li&gt;修改B=4&lt;/li&gt;\n&lt;li&gt;记录B=4到redo log buffer&lt;/li&gt;\n&lt;li&gt;将undo log写入&lt;strong&gt;redo log&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;将redo log写入磁盘&lt;/li&gt;\n&lt;li&gt;事务提交&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;如何保证持久性&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;整个过程数据并未持久化，因为数据已经写入到redo log中，而redo log已经写入到磁盘中，因此只要进行到（9）后，事务是可以提交的。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;如何保证原子性&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;如果在事务提交前故障，通过undo log恢复数据，如果undo log还未写入（8），那么数据尚未持久化，无需回滚。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;内存中数据何时持久化到硬盘&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;因为redo log已经持久化，因此是否写入硬盘已经不重要了。但是一般为了避免内存数据与数据库数据不一致，在事务提交后或者会固定频率刷新到数据库中。&lt;/p&gt;\n&lt;h4 id=\&#34;问题\&#34;&gt;问题&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;之前是将数据库数据和undo log写入磁盘，现在是将undo log和redo log写入磁盘，IO次数并没有减少吗？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;数据库数据写入是随机的，性能差&lt;/li&gt;\n&lt;li&gt;redo log在初始化时会开辟一段连续空间，写入是顺序IO，性能高&lt;/li&gt;\n&lt;li&gt;实际上undo log并不是直接写入磁盘，而是写入到redo log buffer中，当redo log持久化时，undo log也顺便持久化了。&lt;br&gt;\n因此事务在提交前只需要将redo log持久化即可。&lt;br&gt;\n另外redo log并不是写入一次就持久化一次，redo log在内存中有redo log buffer缓冲池，在最终数据库事务提交时一次性持久化，减少IO次数。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;redo log buffer已满（第8步）但事务未提交时会写入buffer数据到硬盘，而此时如果数据库宕机事务未提交已保存的部分redo log怎么处理。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;恢复时，只重做已经提交了的事务。&lt;/li&gt;\n&lt;li&gt;恢复时，重做所有事务包括未提交的和回滚的事务，然后通过undo log回滚哪些未提交的事务。&lt;br&gt;\ninnodb采用了方案2，因此undo log要在redo log前持久化。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;总结\&#34;&gt;总结&lt;/h3&gt;\n&lt;p&gt;undo log记录旧数据，redo log记录最新数据。&lt;/p&gt;\n&lt;h2 id=\&#34;分布式事务\&#34;&gt;分布式事务&lt;/h2&gt;\n&lt;h3 id=\&#34;跨数据源\&#34;&gt;跨数据源&lt;/h3&gt;\n&lt;p&gt;对数据库进行水平或垂直拆分，将原表数据拆分成数据库分片。于是就产生了跨数据库事务问题。&lt;br&gt;\n因为ACID是数据库内部的，不能解决多个数据库实例之间的问题。&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/4dq7t4f6sejrdq9edf4b85g9hq.png\&#34; alt=\&#34;multiDS\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;跨服务\&#34;&gt;跨服务&lt;/h3&gt;\n&lt;p&gt;对单体项目进行微服务拆分后，将原有的Spring Transaction Manager拆分到每个微服务之间都有自己的Spring事务管理器。导致出现分布式事务问题。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/vh310l61i6j1qqvph3lhkmaunq.png\&#34; alt=\&#34;microService\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;分布式系统的数据一致性问题\&#34;&gt;分布式系统的数据一致性问题&lt;/h3&gt;\n&lt;p&gt;当出现部分事务成功，部分事务失败时，业务数据就会不一致。&lt;br&gt;\n例如电商下单场景，包括以下几个行为：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;创建订单&lt;/li&gt;\n&lt;li&gt;扣减库存&lt;/li&gt;\n&lt;li&gt;扣减余额&lt;br&gt;\n完成上面三个动作需要三个微服务和三个不同的数据库，一旦其中任何一个失败，其它的服务之间都无法感知，就会造成数据的不一致问题。&lt;br&gt;\n这正是分布式事务要解决的问题。&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/09/oku3t2m7huglnrvm2mmd5fltdp.png\&#34; alt=\&#34;microServiceSimple\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;fen-bu-shi-shi-wu-yi-ben-di-shi-wu-hui-gu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;分布式事务(一) 本地事务回顾&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-08-30 10:11:14&#34;,&#34;dateFormat&#34;:&#34;2020-08-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/fen-bu-shi-shi-wu-yi-ben-di-shi-wu-hui-gu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:371000,&#34;words&#34;:1722,&#34;minutes&#34;:7},&#34;description&#34;:&#34;什么是分布式事务\n要了解分布式事务，首先需要了解什么是本地事务。\n本地事务\n本地事务，是指传统的单机数据库事务，必须满足ACID原则。\n\n\n原子性（atomicity）\n整个事务中所有操作，要么一块完成，要么都不完成。\n对于事务发生错误，所...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1\&#34;&gt;什么是分布式事务&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1\&#34;&gt;本地事务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#undo%E5%92%8Credo%E6%97%A5%E5%BF%97\&#34;&gt;undo和redo日志&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#undo%E6%97%A5%E5%BF%97\&#34;&gt;undo日志&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8B%E7%BB%8D\&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E7%90%86\&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E4%BE%8B\&#34;&gt;实例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E9%99%B7\&#34;&gt;缺陷&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#redo%E6%97%A5%E5%BF%97\&#34;&gt;redo日志&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E4%BE%8B-2\&#34;&gt;实例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98\&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1\&#34;&gt;分布式事务&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%A8%E6%95%B0%E6%8D%AE%E6%BA%90\&#34;&gt;跨数据源&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%A8%E6%9C%8D%E5%8A%A1\&#34;&gt;跨服务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98\&#34;&gt;分布式系统的数据一致性问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;参考文章\&#34;&gt;参考文章&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;https://www.cnblogs.com/mfrank/p/11260355.html&lt;/li&gt;\n&lt;li&gt;https://blog.csdn.net/u014308482/article/details/53036770&lt;/li&gt;\n&lt;li&gt;https://blog.csdn.net/u012988901/article/details/88958654&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;本文大纲\&#34;&gt;本文大纲&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/380dc612ncjaoojm2ta7l64ih8.png\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/380dc612ncjaoojm2ta7l64ih8.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;什么是延迟队列\&#34;&gt;什么是延迟队列&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;延迟队列也是队列，队列就意味着元素是有序的。元素出队和入队是有方向的，从一端进，从另一端出。&lt;/strong&gt;&lt;br&gt;\n延迟队列体现在延迟上面，普通的队列是希望元素能够被更快的消费，而延迟队列是希望元素在指定的时间被消费。所以&lt;strong&gt;延迟队列里面的元素是带有时间属性&lt;/strong&gt;的。&lt;/p&gt;\n&lt;h1 id=\&#34;延迟队列的使用场景\&#34;&gt;延迟队列的使用场景&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;用户订单10分钟内未支付自动取消&lt;/li&gt;\n&lt;li&gt;预定会议后，开会前10分钟提醒&lt;/li&gt;\n&lt;li&gt;优惠券到期前提醒&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;基础知识补充\&#34;&gt;基础知识补充&lt;/h1&gt;\n&lt;h2 id=\&#34;ttltime-to-live\&#34;&gt;TTL（Time To Live）&lt;/h2&gt;\n&lt;h3 id=\&#34;什么是ttl\&#34;&gt;什么是TTL&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;TTL是RabbitMQ中一个消息或者队列的属性，表明一条消息或者该队列中所有消息的最大存活时间，单位是毫秒&lt;/strong&gt;。如果一条设置了TTL属性的消息或者一条消息进入设置了TTL属性的队列后，那么这条消息在设置的时间内没有被消费，则会成为“死信”，如果消息配置了TTL后被投递到设置了TTL属性的队列中，则按照较小的那个值设置。&lt;/p&gt;\n&lt;h3 id=\&#34;如何设置ttl\&#34;&gt;如何设置TTL&lt;/h3&gt;\n&lt;p&gt;如果不设置TTL，则消息永远不会过期。&lt;br&gt;\n如果TTL=0，则表示除非此时可以直接投递到该消息的消费者，否则这条消息就会被丢弃。&lt;/p&gt;\n&lt;h3 id=\&#34;创建队列时设置队列的ttl\&#34;&gt;创建队列时，设置队列的TTL&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;String, Object&amp;gt;();\nargs.put(&amp;quot;x-message-ttl&amp;quot;, 6000);\nchannel.queueDeclare(queueName, durable, exclusive, autoDelete, args);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;设置每条消息的ttl\&#34;&gt;设置每条消息的TTL&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder();\nbuilder.expiration(&amp;quot;6000&amp;quot;);\nAMQP.BasicProperties properties = builder.build();\nchannel.basicPublish(exchangeName, routingKey, mandatory, properties, &amp;quot;msg body&amp;quot;.getBytes());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;两种ttl的特性\&#34;&gt;两种TTL的特性&lt;/h3&gt;\n&lt;p&gt;两种设置方式有很大的区别&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;如果设置了队列的TTL，那么一旦消息过期，就会被队列丢弃。&lt;/li&gt;\n&lt;li&gt;针对每条消息设置TTL，即使消息过期，也不会马上丢弃，因为消息是否过期是在即将投递到消费者之前确定的，如果当前队列有严重的消息积压，则已经过期的消息也许还能存活很长时间。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;上述第2点，RabbitMQ只会检查第一个消息是否过期，消息过期还存活的原因是因为队列是有序消费的，而如果需要判断每条消息是否过期则需要遍历整个队列，性能损耗太大，选择在有序消费到该消息时准备投递前进行消息的判断，空间换时间的方案。&lt;/p&gt;\n&lt;h2 id=\&#34;dlxdead-letter-exchanges\&#34;&gt;DLX（Dead Letter Exchanges）&lt;/h2&gt;\n&lt;h3 id=\&#34;什么是dlx\&#34;&gt;什么是DLX&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;DLX的作用就是用来接收死信消息，当一个消息在队列中变成了死信消息后，可以发送到另一个exchange（交换机），这个交换机就是DLX，绑定DLX的队列成为死信队列，当这个队列存在死信消息时，RabbitMQ就会立即将这个消息发布到设置的DLX上去，进而被路由到绑定该DLX的死信队列上。&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;什么是死信\&#34;&gt;什么是死信&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;消息被拒绝 （Basic.Reject/Basic.Nack），并且设置requeue=false&lt;/li&gt;\n&lt;li&gt;消息过期（TTL）&lt;/li&gt;\n&lt;li&gt;队列达到最大长度&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;如何设置dlx\&#34;&gt;如何设置DLX&lt;/h3&gt;\n&lt;p&gt;RabbitMQ的Queue可以配置&lt;code&gt;x-dead-letter-exchange&lt;/code&gt; 和 &lt;code&gt;x-dead-letter-routing-key&lt;/code&gt;（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由转发到指定的队列。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange&lt;/li&gt;\n&lt;li&gt;x-dead-letter-routing-key：出现dead letter之后将dead letter重新按照指定的routing-key发送&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;基础知识总结\&#34;&gt;基础知识总结&lt;/h2&gt;\n&lt;p&gt;结合TTL和DLX两个特性，将消息设置了TTL规则之后当消息在队列中变为dead letter时，利用DLX特性将它转发到另一个Exchange或者Routing Key，这个时候绑定这个死信队列的消费者开始消费消息即可实现延时消费的效果。&lt;/p&gt;\n&lt;p&gt;生产者生产一条延时消息，根据需要延时时间的不同，&lt;strong&gt;利用不同的routingKey将消息路由到不同的延时队列①&lt;/strong&gt;，每个队列都设置了不同的TTL属性，并绑定在同一个死信交换机中，消息过期后，根据routingKey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列进行处理即可。&lt;/p&gt;\n&lt;p&gt;①：不同消息绑定在不同的队列中很重要，此处使用的是TTL的第一种，为队列设置时长。可以确保队列中消息的过期时间是有序的。因为如果队列中有不同过期时间的消息，会出现消息错乱的情况。比如第一条是10分钟过期，第二条是20秒过期，则必须要等第一条消息有序被消费后（结合TTL过期特性，空间换时间），才能在10分钟20秒后消费到第二条消息。&lt;/p&gt;\n&lt;h1 id=\&#34;实现延迟消息队列\&#34;&gt;实现延迟消息队列&lt;/h1&gt;\n&lt;h2 id=\&#34;源码\&#34;&gt;源码&lt;/h2&gt;\n&lt;h3 id=\&#34;配置部分\&#34;&gt;配置部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * 代码: https://www.cnblogs.com/mfrank/p/11260355.html\n * @author imyzt\n * @date 2020/08/29\n * @description 配置文件\n */\n@Configuration\npublic class RabbitMQConfig {\n\n    /**\n     * 延迟交换机\n     */\n    public static final String DELAY_EXCHANGE_NAME = &amp;quot;delay.queue.demo.business.exchange&amp;quot;;\n    /**\n     * 延迟队列名称\n     */\n    private static final String DELAY_QUEUEA_NAME = &amp;quot;delay.queue.demo.business.queuea&amp;quot;;\n    private static final String DELAY_QUEUEB_NAME = &amp;quot;delay.queue.demo.business.queueb&amp;quot;;\n    /**\n     * 延迟队列Routing Key\n     */\n    public static final String DELAY_QUEUEA_ROUTING_KEY = &amp;quot;delay.queue.demo.business.queuea.routingkey&amp;quot;;\n    public static final String DELAY_QUEUEB_ROUTING_KEY = &amp;quot;delay.queue.demo.business.queueb.routingkey&amp;quot;;\n    /**\n     * 死信交换机\n     */\n    private static final String DEAD_LETTER_EXCHANGE = &amp;quot;delay.queue.demo.deadletter.exchange&amp;quot;;\n    /**\n     * 死信队列Routing Key\n     */\n    private static final String DEAD_LETTER_QUEUEA_ROUTING_KEY = &amp;quot;delay.queue.demo.deadletter.delay_10s.routingkey&amp;quot;;\n    private static final String DEAD_LETTER_QUEUEB_ROUTING_KEY = &amp;quot;delay.queue.demo.deadletter.delay_60s.routingkey&amp;quot;;\n    /**\n     * 死信队列名称\n     */\n    public static final String DEAD_LETTER_QUEUEA_NAME = &amp;quot;delay.queue.demo.deadletter.queuea&amp;quot;;\n    public static final String DEAD_LETTER_QUEUEB_NAME = &amp;quot;delay.queue.demo.deadletter.queueb&amp;quot;;\n\n    /**\n     * 首先声明延迟队列, 生产者通过交换机和Routing Key将消息发送到延迟队列上\n     * 然后消息变为死信时, 死信交换机将消息转发到死信队列上, 消费者对死信队列进行监听\n     */\n\n    /**\n     * 声明延迟队列交换机\n     */\n    @Bean\n    public DirectExchange delayExchange() {\n        return new DirectExchange(DELAY_EXCHANGE_NAME);\n    }\n    /**\n     * 声明死信队列交换机\n     */\n    @Bean\n    public DirectExchange deadLetterExchange() {\n        return new DirectExchange(DEAD_LETTER_EXCHANGE);\n    }\n\n    /**\n     * 声明延迟队列A\n     * 延迟10秒\n     * 并绑定到对应的死信交换机\n     */\n    @Bean\n    public Queue delayQueueA() {\n        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(3);\n        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机\n        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;, DEAD_LETTER_EXCHANGE);\n        // x-dead-letter-routing-key  这里声明当前队列的死信路由key\n        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;, DEAD_LETTER_QUEUEA_ROUTING_KEY);\n        // x-message-ttl  声明队列的TTL\n        args.put(&amp;quot;x-message-ttl&amp;quot;, 10000);\n        return QueueBuilder.durable(DELAY_QUEUEA_NAME).withArguments(args).build();\n    }\n    /**\n     * 声明延迟队列B\n     * 延迟60秒\n     * 并绑定到对应的死信交换机\n     */\n    @Bean\n    public Queue delayQueueB() {\n        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(3);\n        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机\n        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;, DEAD_LETTER_EXCHANGE);\n        // x-dead-letter-routing-key  这里声明当前队列的死信路由key\n        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;, DEAD_LETTER_QUEUEB_ROUTING_KEY);\n        // x-message-ttl  声明队列的TTL\n        args.put(&amp;quot;x-message-ttl&amp;quot;, 60000);\n        return QueueBuilder.durable(DELAY_QUEUEB_NAME).withArguments(args).build();\n    }\n\n    /**\n     * 声明死信队列A, 用于接收延迟10s的消息\n     */\n    @Bean\n    public Queue deadLetterQueueA() {\n        return new Queue(DEAD_LETTER_QUEUEA_NAME);\n    }\n    /**\n     * 声明死信队列B, 用于接收延迟60s的消息\n     */\n    @Bean\n    public Queue deadLetterQueueB() {\n        return new Queue(DEAD_LETTER_QUEUEB_NAME);\n    }\n\n    /**\n     * 声明延迟队列A与延迟队列交换机绑定关系\n     * Routing Key\n     */\n    @Bean\n    public Binding delayBindingA(@Qualifier(&amp;quot;delayQueueA&amp;quot;) Queue queue,\n                                                                   @Qualifier(&amp;quot;delayExchange&amp;quot;) Exchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEA_ROUTING_KEY).noargs();\n    }\n    /**\n     * 声明延迟队列B与延迟队列交换机绑定关系\n     * Routing Key\n     */\n    @Bean\n    public Binding delayBindingB(@Qualifier(&amp;quot;delayQueueB&amp;quot;) Queue queue,\n                                                                   @Qualifier(&amp;quot;delayExchange&amp;quot;) Exchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEB_ROUTING_KEY).noargs();\n    }\n\n    /**\n     * 声明死信队列A与死信队列交换机绑定关系\n     * Routing Key\n     */\n    @Bean\n    public Binding deadBindingA(@Qualifier(&amp;quot;deadLetterQueueA&amp;quot;) Queue queue,\n                                                                   @Qualifier(&amp;quot;deadLetterExchange&amp;quot;) Exchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY).noargs();\n    }\n    /**\n     * 声明死信队列B与死信队列交换机绑定关系\n     * Routing Key\n     */\n    @Bean\n    public Binding deadBindingB(@Qualifier(&amp;quot;deadLetterQueueB&amp;quot;) Queue queue,\n                                                                  @Qualifier(&amp;quot;deadLetterExchange&amp;quot;) Exchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY).noargs();\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;生产者部分\&#34;&gt;生产者部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 消息生产者\n */\n@Slf4j\n@RestController\n@RequestMapping(&amp;quot;sender&amp;quot;)\npublic class MessageSenderController {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @PostMapping\n    public void sender(String msg, String type) {\n\n        log.info(&amp;quot;当前时间：{},收到请求，msg:{},delayType:{}&amp;quot;, LocalDateTime.now().toString(), msg, type);\n\n        switch (type) {\n            case &amp;quot;DELAY_10S&amp;quot;:\n                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEA_ROUTING_KEY, msg);\n                break;\n            case &amp;quot;DELAY_60S&amp;quot;:\n                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEB_ROUTING_KEY, msg);\n                break;\n            default:\n                break;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;消费者部分\&#34;&gt;消费者部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 死信队列消费者\n */\n@Component\n@Slf4j\npublic class DeadLetterQueueConsumer {\n\n    @RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)\n    public void receiveA(Message message, Channel channel) throws IOException {\n        String msg = new String(message.getBody());\n        log.info(&amp;quot;当前时间：{},死信队列A收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n\n    @RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)\n    public void receiveB(Message message, Channel channel) throws IOException {\n        String msg = new String(message.getBody());\n        log.info(&amp;quot;当前时间：{},死信队列B收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;两个交换机\&#34;&gt;两个交换机&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/pu6dgrcf7kjtuqqahres3bp48v.jpg\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/pu6dgrcf7kjtuqqahres3bp48v.jpg\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;四个队列\&#34;&gt;四个队列&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/3vtkq5kvviivlrlfvtd7mdtja3.jpg\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/3vtkq5kvviivlrlfvtd7mdtja3.jpg\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;延迟效果\&#34;&gt;延迟效果&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/0hr7c5k8ochhhrfq0t2lldo29b.jpg\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/0hr7c5k8ochhhrfq0t2lldo29b.jpg\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;缺陷\&#34;&gt;缺陷&lt;/h2&gt;\n&lt;p&gt;从上面的效果来看，第一条消息在10秒后变成了死信消息，然后被消费掉。第二条消息在60秒后变成了死信队列，然后被消费掉。目前来看基本功能的延迟队列就算完成了。&lt;br&gt;\n但是有一个问题就是，队列的消息都是有序的失效，如果增加一个新的时间需求，那么有需要增加一个队列处理上面的逻辑，实在是不够优雅。&lt;/p&gt;\n&lt;h1 id=\&#34;延迟队列优化\&#34;&gt;延迟队列优化&lt;/h1&gt;\n&lt;p&gt;通过上面实现的内容，使用RabbitMQ自带的DLX和TTL，实现的结果是无法对灵活过期时间的支持。&lt;br&gt;\n针对这个问题的最终解决方案是使用rabbit提供的一个延迟插件实现。&lt;a href=\&#34;https://www.rabbitmq.com/community-plugins.html\&#34;&gt;https://www.rabbitmq.com/community-plugins.html&lt;/a&gt;，下载rabbitmq_delayed_message_exchange插件。&lt;/p&gt;\n&lt;h2 id=\&#34;插件的安装\&#34;&gt;插件的安装&lt;/h2&gt;\n&lt;p&gt;进入到RabbitMQ安装目录的bin目录下，执行指令安装插件即可&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;rabbitmq-plugins enable rabbitmq_delayed_message_exchange\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;重新实现延迟功能\&#34;&gt;重新实现延迟功能&lt;/h2&gt;\n&lt;h3 id=\&#34;配置部分-2\&#34;&gt;配置部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 延迟插件实现消息延迟\n */\n@Configuration\npublic class DelayedRabbitMQConfig {\n\n    /**\n     * 延迟队列\n     */\n    public static final String DELAYED_QUEUE_NAME = &amp;quot;delay.queue.demo.delay.queue&amp;quot;;\n    /**\n     * 延迟交换机\n     */\n    public static final String DELAYED_EXCHANGE_NAME = &amp;quot;delay.queue.demo.delay.exchange&amp;quot;;\n    /**\n     * 延迟队列 Routing Key\n     */\n    public static final String DELAYED_ROUTING_KEY = &amp;quot;delay.queue.demo.delay.routingkey&amp;quot;;\n\n\n    /**\n     * 创建延迟队列\n     */\n    @Bean\n    public Queue immediateQueue() {\n        return new Queue(DELAYED_QUEUE_NAME);\n    }\n\n    /**\n     * 创建一个自定义的交换机(插件实现)\n     */\n    @Bean\n    public CustomExchange customExchange() {\n        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(1);\n        args.put(&amp;quot;x-delayed-type&amp;quot;, &amp;quot;direct&amp;quot;);\n        return new CustomExchange(DELAYED_EXCHANGE_NAME, &amp;quot;x-delayed-message&amp;quot;, true, false, args);\n    }\n\n    /**\n     * 绑定交换机和队列\n     */\n    @Bean\n    public Binding bindingNotify(@Qualifier(&amp;quot;immediateQueue&amp;quot;) Queue queue,\n                                 @Qualifier(&amp;quot;customExchange&amp;quot;) CustomExchange customExchange) {\n        return BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;生产者部分-2\&#34;&gt;生产者部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 消息生产者\n */\n@Slf4j\n@RestController\n@RequestMapping(&amp;quot;sender&amp;quot;)\npublic class MessageSenderController {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * 通过插件实现的延迟消息\n     * @param msg 消息内容\n     * @param delayTime 延迟时间, 毫秒\n     */\n    @PostMapping(&amp;quot;v2&amp;quot;)\n    public void sender(String msg, Integer delayTime) {\n\n        log.info(&amp;quot;当前时间：{},收到请求，msg:{},delayTime:{}&amp;quot;, LocalDateTime.now().toString(), msg, delayTime);\n\n        rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, messagePostProcessor -&amp;gt;{\n            messagePostProcessor.getMessageProperties().setDelay(delayTime);\n            return messagePostProcessor;\n        });\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;消费者部分-2\&#34;&gt;消费者部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 死信队列消费者\n */\n@Component\n@Slf4j\npublic class DeadLetterQueueConsumer {\n\n    /**\n     * 插件延迟队列\n     * 消费者\n     */\n    @RabbitListener(queues = DELAYED_QUEUE_NAME)\n    public void receiveD(Message message, Channel channel) throws IOException {\n        String msg = new String(message.getBody());\n        log.info(&amp;quot;当前时间：{},延时队列收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;交换机\&#34;&gt;交换机&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/7p9h2n83oojuqpn5rt3dmkfc3r.png\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/7p9h2n83oojuqpn5rt3dmkfc3r.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;队列\&#34;&gt;队列&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/05esbd0g36giqrfcltkp3jg0bg.png\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/05esbd0g36giqrfcltkp3jg0bg.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;效果图\&#34;&gt;效果图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/1m6okllergjoqp3i0imaadojao.png\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/1m6okllergjoqp3i0imaadojao.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;TTL对消息设置过期时间，过期时间是无序的。所以不能用于延迟队列不同过期时间的处理。只能针对队列设置时间，一个队列处理一个时间的需求。&lt;/li&gt;\n&lt;li&gt;如果需要可靠性延迟队列，推荐使用插件。&lt;/li&gt;\n&lt;li&gt;rabbitmq_delayed_message_exchange插件在RAM节点会有一些问题，这个博主描述了这部分&lt;a href=\&#34;https://blog.csdn.net/wangming520liwei/article/details/103352440\&#34;&gt;https://blog.csdn.net/wangming520liwei/article/details/103352440&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;本文大量参考了“参考文章”中的内容，只是对自己学习延迟队列的内容记载。感谢原作者们。&lt;/li&gt;\n&lt;li&gt;本文出现的源代码均在&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/mq-series/RabbitMQ/delay-queue-simple\&#34;&gt;github&lt;/a&gt;中&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;rabbitmq-shi-xian-yan-chi-dui-lie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;RabbitMQ 实现延迟队列&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-08-29 23:08:05&#34;,&#34;dateFormat&#34;:&#34;2020-08-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/rabbitmq-shi-xian-yan-chi-dui-lie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;13 min read&#34;,&#34;time&#34;:775000,&#34;words&#34;:3021,&#34;minutes&#34;:13},&#34;description&#34;:&#34;参考文章\n\nhttps://www.cnblogs.com/mfrank/p/11260355.html\nhttps://blog.csdn.net/u014308482/article/details/53036770\nhttps://b...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\&#34;&gt;参考文章&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E6%96%87%E5%A4%A7%E7%BA%B2\&#34;&gt;本文大纲&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97\&#34;&gt;什么是延迟队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\&#34;&gt;延迟队列的使用场景&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85\&#34;&gt;基础知识补充&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ttltime-to-live\&#34;&gt;TTL（Time To Live）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFttl\&#34;&gt;什么是TTL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEttl\&#34;&gt;如何设置TTL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97%E6%97%B6%E8%AE%BE%E7%BD%AE%E9%98%9F%E5%88%97%E7%9A%84ttl\&#34;&gt;创建队列时，设置队列的TTL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E7%BD%AE%E6%AF%8F%E6%9D%A1%E6%B6%88%E6%81%AF%E7%9A%84ttl\&#34;&gt;设置每条消息的TTL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%A4%E7%A7%8Dttl%E7%9A%84%E7%89%B9%E6%80%A7\&#34;&gt;两种TTL的特性&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dlxdead-letter-exchanges\&#34;&gt;DLX（Dead Letter Exchanges）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFdlx\&#34;&gt;什么是DLX&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1\&#34;&gt;什么是死信&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEdlx\&#34;&gt;如何设置DLX&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93\&#34;&gt;基础知识总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\&#34;&gt;实现延迟消息队列&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%BA%90%E7%A0%81\&#34;&gt;源码&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E9%83%A8%E5%88%86\&#34;&gt;配置部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%9F%E4%BA%A7%E8%80%85%E9%83%A8%E5%88%86\&#34;&gt;生产者部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E8%B4%B9%E8%80%85%E9%83%A8%E5%88%86\&#34;&gt;消费者部分&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%A4%E4%B8%AA%E4%BA%A4%E6%8D%A2%E6%9C%BA\&#34;&gt;两个交换机&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B%E4%B8%AA%E9%98%9F%E5%88%97\&#34;&gt;四个队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%B6%E8%BF%9F%E6%95%88%E6%9E%9C\&#34;&gt;延迟效果&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E9%99%B7\&#34;&gt;缺陷&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96\&#34;&gt;延迟队列优化&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85\&#34;&gt;插件的安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E5%8A%9F%E8%83%BD\&#34;&gt;重新实现延迟功能&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E9%83%A8%E5%88%86-2\&#34;&gt;配置部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%9F%E4%BA%A7%E8%80%85%E9%83%A8%E5%88%86-2\&#34;&gt;生产者部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E8%B4%B9%E8%80%85%E9%83%A8%E5%88%86-2\&#34;&gt;消费者部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%A4%E6%8D%A2%E6%9C%BA\&#34;&gt;交换机&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%98%9F%E5%88%97\&#34;&gt;队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%88%E6%9E%9C%E5%9B%BE\&#34;&gt;效果图&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;参考文章\&#34;&gt;参考文章&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;https://www.cnblogs.com/mfrank/p/11260355.html&lt;/li&gt;\n&lt;li&gt;https://blog.csdn.net/u014308482/article/details/53036770&lt;/li&gt;\n&lt;li&gt;https://blog.csdn.net/u012988901/article/details/88958654&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;本文大纲\&#34;&gt;本文大纲&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/380dc612ncjaoojm2ta7l64ih8.png\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/380dc612ncjaoojm2ta7l64ih8.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;什么是延迟队列\&#34;&gt;什么是延迟队列&lt;/h1&gt;\n&lt;p&gt;&lt;strong&gt;延迟队列也是队列，队列就意味着元素是有序的。元素出队和入队是有方向的，从一端进，从另一端出。&lt;/strong&gt;&lt;br&gt;\n延迟队列体现在延迟上面，普通的队列是希望元素能够被更快的消费，而延迟队列是希望元素在指定的时间被消费。所以&lt;strong&gt;延迟队列里面的元素是带有时间属性&lt;/strong&gt;的。&lt;/p&gt;\n&lt;h1 id=\&#34;延迟队列的使用场景\&#34;&gt;延迟队列的使用场景&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;用户订单10分钟内未支付自动取消&lt;/li&gt;\n&lt;li&gt;预定会议后，开会前10分钟提醒&lt;/li&gt;\n&lt;li&gt;优惠券到期前提醒&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;基础知识补充\&#34;&gt;基础知识补充&lt;/h1&gt;\n&lt;h2 id=\&#34;ttltime-to-live\&#34;&gt;TTL（Time To Live）&lt;/h2&gt;\n&lt;h3 id=\&#34;什么是ttl\&#34;&gt;什么是TTL&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;TTL是RabbitMQ中一个消息或者队列的属性，表明一条消息或者该队列中所有消息的最大存活时间，单位是毫秒&lt;/strong&gt;。如果一条设置了TTL属性的消息或者一条消息进入设置了TTL属性的队列后，那么这条消息在设置的时间内没有被消费，则会成为“死信”，如果消息配置了TTL后被投递到设置了TTL属性的队列中，则按照较小的那个值设置。&lt;/p&gt;\n&lt;h3 id=\&#34;如何设置ttl\&#34;&gt;如何设置TTL&lt;/h3&gt;\n&lt;p&gt;如果不设置TTL，则消息永远不会过期。&lt;br&gt;\n如果TTL=0，则表示除非此时可以直接投递到该消息的消费者，否则这条消息就会被丢弃。&lt;/p&gt;\n&lt;h3 id=\&#34;创建队列时设置队列的ttl\&#34;&gt;创建队列时，设置队列的TTL&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;String, Object&amp;gt;();\nargs.put(&amp;quot;x-message-ttl&amp;quot;, 6000);\nchannel.queueDeclare(queueName, durable, exclusive, autoDelete, args);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;设置每条消息的ttl\&#34;&gt;设置每条消息的TTL&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder();\nbuilder.expiration(&amp;quot;6000&amp;quot;);\nAMQP.BasicProperties properties = builder.build();\nchannel.basicPublish(exchangeName, routingKey, mandatory, properties, &amp;quot;msg body&amp;quot;.getBytes());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;两种ttl的特性\&#34;&gt;两种TTL的特性&lt;/h3&gt;\n&lt;p&gt;两种设置方式有很大的区别&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;如果设置了队列的TTL，那么一旦消息过期，就会被队列丢弃。&lt;/li&gt;\n&lt;li&gt;针对每条消息设置TTL，即使消息过期，也不会马上丢弃，因为消息是否过期是在即将投递到消费者之前确定的，如果当前队列有严重的消息积压，则已经过期的消息也许还能存活很长时间。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;上述第2点，RabbitMQ只会检查第一个消息是否过期，消息过期还存活的原因是因为队列是有序消费的，而如果需要判断每条消息是否过期则需要遍历整个队列，性能损耗太大，选择在有序消费到该消息时准备投递前进行消息的判断，空间换时间的方案。&lt;/p&gt;\n&lt;h2 id=\&#34;dlxdead-letter-exchanges\&#34;&gt;DLX（Dead Letter Exchanges）&lt;/h2&gt;\n&lt;h3 id=\&#34;什么是dlx\&#34;&gt;什么是DLX&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;DLX的作用就是用来接收死信消息，当一个消息在队列中变成了死信消息后，可以发送到另一个exchange（交换机），这个交换机就是DLX，绑定DLX的队列成为死信队列，当这个队列存在死信消息时，RabbitMQ就会立即将这个消息发布到设置的DLX上去，进而被路由到绑定该DLX的死信队列上。&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;什么是死信\&#34;&gt;什么是死信&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;消息被拒绝 （Basic.Reject/Basic.Nack），并且设置requeue=false&lt;/li&gt;\n&lt;li&gt;消息过期（TTL）&lt;/li&gt;\n&lt;li&gt;队列达到最大长度&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;如何设置dlx\&#34;&gt;如何设置DLX&lt;/h3&gt;\n&lt;p&gt;RabbitMQ的Queue可以配置&lt;code&gt;x-dead-letter-exchange&lt;/code&gt; 和 &lt;code&gt;x-dead-letter-routing-key&lt;/code&gt;（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由转发到指定的队列。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange&lt;/li&gt;\n&lt;li&gt;x-dead-letter-routing-key：出现dead letter之后将dead letter重新按照指定的routing-key发送&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;基础知识总结\&#34;&gt;基础知识总结&lt;/h2&gt;\n&lt;p&gt;结合TTL和DLX两个特性，将消息设置了TTL规则之后当消息在队列中变为dead letter时，利用DLX特性将它转发到另一个Exchange或者Routing Key，这个时候绑定这个死信队列的消费者开始消费消息即可实现延时消费的效果。&lt;/p&gt;\n&lt;p&gt;生产者生产一条延时消息，根据需要延时时间的不同，&lt;strong&gt;利用不同的routingKey将消息路由到不同的延时队列①&lt;/strong&gt;，每个队列都设置了不同的TTL属性，并绑定在同一个死信交换机中，消息过期后，根据routingKey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列进行处理即可。&lt;/p&gt;\n&lt;p&gt;①：不同消息绑定在不同的队列中很重要，此处使用的是TTL的第一种，为队列设置时长。可以确保队列中消息的过期时间是有序的。因为如果队列中有不同过期时间的消息，会出现消息错乱的情况。比如第一条是10分钟过期，第二条是20秒过期，则必须要等第一条消息有序被消费后（结合TTL过期特性，空间换时间），才能在10分钟20秒后消费到第二条消息。&lt;/p&gt;\n&lt;h1 id=\&#34;实现延迟消息队列\&#34;&gt;实现延迟消息队列&lt;/h1&gt;\n&lt;h2 id=\&#34;源码\&#34;&gt;源码&lt;/h2&gt;\n&lt;h3 id=\&#34;配置部分\&#34;&gt;配置部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * 代码: https://www.cnblogs.com/mfrank/p/11260355.html\n * @author imyzt\n * @date 2020/08/29\n * @description 配置文件\n */\n@Configuration\npublic class RabbitMQConfig {\n\n    /**\n     * 延迟交换机\n     */\n    public static final String DELAY_EXCHANGE_NAME = &amp;quot;delay.queue.demo.business.exchange&amp;quot;;\n    /**\n     * 延迟队列名称\n     */\n    private static final String DELAY_QUEUEA_NAME = &amp;quot;delay.queue.demo.business.queuea&amp;quot;;\n    private static final String DELAY_QUEUEB_NAME = &amp;quot;delay.queue.demo.business.queueb&amp;quot;;\n    /**\n     * 延迟队列Routing Key\n     */\n    public static final String DELAY_QUEUEA_ROUTING_KEY = &amp;quot;delay.queue.demo.business.queuea.routingkey&amp;quot;;\n    public static final String DELAY_QUEUEB_ROUTING_KEY = &amp;quot;delay.queue.demo.business.queueb.routingkey&amp;quot;;\n    /**\n     * 死信交换机\n     */\n    private static final String DEAD_LETTER_EXCHANGE = &amp;quot;delay.queue.demo.deadletter.exchange&amp;quot;;\n    /**\n     * 死信队列Routing Key\n     */\n    private static final String DEAD_LETTER_QUEUEA_ROUTING_KEY = &amp;quot;delay.queue.demo.deadletter.delay_10s.routingkey&amp;quot;;\n    private static final String DEAD_LETTER_QUEUEB_ROUTING_KEY = &amp;quot;delay.queue.demo.deadletter.delay_60s.routingkey&amp;quot;;\n    /**\n     * 死信队列名称\n     */\n    public static final String DEAD_LETTER_QUEUEA_NAME = &amp;quot;delay.queue.demo.deadletter.queuea&amp;quot;;\n    public static final String DEAD_LETTER_QUEUEB_NAME = &amp;quot;delay.queue.demo.deadletter.queueb&amp;quot;;\n\n    /**\n     * 首先声明延迟队列, 生产者通过交换机和Routing Key将消息发送到延迟队列上\n     * 然后消息变为死信时, 死信交换机将消息转发到死信队列上, 消费者对死信队列进行监听\n     */\n\n    /**\n     * 声明延迟队列交换机\n     */\n    @Bean\n    public DirectExchange delayExchange() {\n        return new DirectExchange(DELAY_EXCHANGE_NAME);\n    }\n    /**\n     * 声明死信队列交换机\n     */\n    @Bean\n    public DirectExchange deadLetterExchange() {\n        return new DirectExchange(DEAD_LETTER_EXCHANGE);\n    }\n\n    /**\n     * 声明延迟队列A\n     * 延迟10秒\n     * 并绑定到对应的死信交换机\n     */\n    @Bean\n    public Queue delayQueueA() {\n        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(3);\n        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机\n        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;, DEAD_LETTER_EXCHANGE);\n        // x-dead-letter-routing-key  这里声明当前队列的死信路由key\n        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;, DEAD_LETTER_QUEUEA_ROUTING_KEY);\n        // x-message-ttl  声明队列的TTL\n        args.put(&amp;quot;x-message-ttl&amp;quot;, 10000);\n        return QueueBuilder.durable(DELAY_QUEUEA_NAME).withArguments(args).build();\n    }\n    /**\n     * 声明延迟队列B\n     * 延迟60秒\n     * 并绑定到对应的死信交换机\n     */\n    @Bean\n    public Queue delayQueueB() {\n        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(3);\n        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机\n        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;, DEAD_LETTER_EXCHANGE);\n        // x-dead-letter-routing-key  这里声明当前队列的死信路由key\n        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;, DEAD_LETTER_QUEUEB_ROUTING_KEY);\n        // x-message-ttl  声明队列的TTL\n        args.put(&amp;quot;x-message-ttl&amp;quot;, 60000);\n        return QueueBuilder.durable(DELAY_QUEUEB_NAME).withArguments(args).build();\n    }\n\n    /**\n     * 声明死信队列A, 用于接收延迟10s的消息\n     */\n    @Bean\n    public Queue deadLetterQueueA() {\n        return new Queue(DEAD_LETTER_QUEUEA_NAME);\n    }\n    /**\n     * 声明死信队列B, 用于接收延迟60s的消息\n     */\n    @Bean\n    public Queue deadLetterQueueB() {\n        return new Queue(DEAD_LETTER_QUEUEB_NAME);\n    }\n\n    /**\n     * 声明延迟队列A与延迟队列交换机绑定关系\n     * Routing Key\n     */\n    @Bean\n    public Binding delayBindingA(@Qualifier(&amp;quot;delayQueueA&amp;quot;) Queue queue,\n                                                                   @Qualifier(&amp;quot;delayExchange&amp;quot;) Exchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEA_ROUTING_KEY).noargs();\n    }\n    /**\n     * 声明延迟队列B与延迟队列交换机绑定关系\n     * Routing Key\n     */\n    @Bean\n    public Binding delayBindingB(@Qualifier(&amp;quot;delayQueueB&amp;quot;) Queue queue,\n                                                                   @Qualifier(&amp;quot;delayExchange&amp;quot;) Exchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEB_ROUTING_KEY).noargs();\n    }\n\n    /**\n     * 声明死信队列A与死信队列交换机绑定关系\n     * Routing Key\n     */\n    @Bean\n    public Binding deadBindingA(@Qualifier(&amp;quot;deadLetterQueueA&amp;quot;) Queue queue,\n                                                                   @Qualifier(&amp;quot;deadLetterExchange&amp;quot;) Exchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY).noargs();\n    }\n    /**\n     * 声明死信队列B与死信队列交换机绑定关系\n     * Routing Key\n     */\n    @Bean\n    public Binding deadBindingB(@Qualifier(&amp;quot;deadLetterQueueB&amp;quot;) Queue queue,\n                                                                  @Qualifier(&amp;quot;deadLetterExchange&amp;quot;) Exchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY).noargs();\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;生产者部分\&#34;&gt;生产者部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 消息生产者\n */\n@Slf4j\n@RestController\n@RequestMapping(&amp;quot;sender&amp;quot;)\npublic class MessageSenderController {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @PostMapping\n    public void sender(String msg, String type) {\n\n        log.info(&amp;quot;当前时间：{},收到请求，msg:{},delayType:{}&amp;quot;, LocalDateTime.now().toString(), msg, type);\n\n        switch (type) {\n            case &amp;quot;DELAY_10S&amp;quot;:\n                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEA_ROUTING_KEY, msg);\n                break;\n            case &amp;quot;DELAY_60S&amp;quot;:\n                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEB_ROUTING_KEY, msg);\n                break;\n            default:\n                break;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;消费者部分\&#34;&gt;消费者部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 死信队列消费者\n */\n@Component\n@Slf4j\npublic class DeadLetterQueueConsumer {\n\n    @RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)\n    public void receiveA(Message message, Channel channel) throws IOException {\n        String msg = new String(message.getBody());\n        log.info(&amp;quot;当前时间：{},死信队列A收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n\n    @RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)\n    public void receiveB(Message message, Channel channel) throws IOException {\n        String msg = new String(message.getBody());\n        log.info(&amp;quot;当前时间：{},死信队列B收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;两个交换机\&#34;&gt;两个交换机&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/pu6dgrcf7kjtuqqahres3bp48v.jpg\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/pu6dgrcf7kjtuqqahres3bp48v.jpg\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;四个队列\&#34;&gt;四个队列&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/3vtkq5kvviivlrlfvtd7mdtja3.jpg\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/3vtkq5kvviivlrlfvtd7mdtja3.jpg\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;延迟效果\&#34;&gt;延迟效果&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/0hr7c5k8ochhhrfq0t2lldo29b.jpg\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/0hr7c5k8ochhhrfq0t2lldo29b.jpg\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;缺陷\&#34;&gt;缺陷&lt;/h2&gt;\n&lt;p&gt;从上面的效果来看，第一条消息在10秒后变成了死信消息，然后被消费掉。第二条消息在60秒后变成了死信队列，然后被消费掉。目前来看基本功能的延迟队列就算完成了。&lt;br&gt;\n但是有一个问题就是，队列的消息都是有序的失效，如果增加一个新的时间需求，那么有需要增加一个队列处理上面的逻辑，实在是不够优雅。&lt;/p&gt;\n&lt;h1 id=\&#34;延迟队列优化\&#34;&gt;延迟队列优化&lt;/h1&gt;\n&lt;p&gt;通过上面实现的内容，使用RabbitMQ自带的DLX和TTL，实现的结果是无法对灵活过期时间的支持。&lt;br&gt;\n针对这个问题的最终解决方案是使用rabbit提供的一个延迟插件实现。&lt;a href=\&#34;https://www.rabbitmq.com/community-plugins.html\&#34;&gt;https://www.rabbitmq.com/community-plugins.html&lt;/a&gt;，下载rabbitmq_delayed_message_exchange插件。&lt;/p&gt;\n&lt;h2 id=\&#34;插件的安装\&#34;&gt;插件的安装&lt;/h2&gt;\n&lt;p&gt;进入到RabbitMQ安装目录的bin目录下，执行指令安装插件即可&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;rabbitmq-plugins enable rabbitmq_delayed_message_exchange\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;重新实现延迟功能\&#34;&gt;重新实现延迟功能&lt;/h2&gt;\n&lt;h3 id=\&#34;配置部分-2\&#34;&gt;配置部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 延迟插件实现消息延迟\n */\n@Configuration\npublic class DelayedRabbitMQConfig {\n\n    /**\n     * 延迟队列\n     */\n    public static final String DELAYED_QUEUE_NAME = &amp;quot;delay.queue.demo.delay.queue&amp;quot;;\n    /**\n     * 延迟交换机\n     */\n    public static final String DELAYED_EXCHANGE_NAME = &amp;quot;delay.queue.demo.delay.exchange&amp;quot;;\n    /**\n     * 延迟队列 Routing Key\n     */\n    public static final String DELAYED_ROUTING_KEY = &amp;quot;delay.queue.demo.delay.routingkey&amp;quot;;\n\n\n    /**\n     * 创建延迟队列\n     */\n    @Bean\n    public Queue immediateQueue() {\n        return new Queue(DELAYED_QUEUE_NAME);\n    }\n\n    /**\n     * 创建一个自定义的交换机(插件实现)\n     */\n    @Bean\n    public CustomExchange customExchange() {\n        Map&amp;lt;String, Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;(1);\n        args.put(&amp;quot;x-delayed-type&amp;quot;, &amp;quot;direct&amp;quot;);\n        return new CustomExchange(DELAYED_EXCHANGE_NAME, &amp;quot;x-delayed-message&amp;quot;, true, false, args);\n    }\n\n    /**\n     * 绑定交换机和队列\n     */\n    @Bean\n    public Binding bindingNotify(@Qualifier(&amp;quot;immediateQueue&amp;quot;) Queue queue,\n                                 @Qualifier(&amp;quot;customExchange&amp;quot;) CustomExchange customExchange) {\n        return BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;生产者部分-2\&#34;&gt;生产者部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 消息生产者\n */\n@Slf4j\n@RestController\n@RequestMapping(&amp;quot;sender&amp;quot;)\npublic class MessageSenderController {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * 通过插件实现的延迟消息\n     * @param msg 消息内容\n     * @param delayTime 延迟时间, 毫秒\n     */\n    @PostMapping(&amp;quot;v2&amp;quot;)\n    public void sender(String msg, Integer delayTime) {\n\n        log.info(&amp;quot;当前时间：{},收到请求，msg:{},delayTime:{}&amp;quot;, LocalDateTime.now().toString(), msg, delayTime);\n\n        rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, messagePostProcessor -&amp;gt;{\n            messagePostProcessor.getMessageProperties().setDelay(delayTime);\n            return messagePostProcessor;\n        });\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;消费者部分-2\&#34;&gt;消费者部分&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2020/08/29\n * @description 死信队列消费者\n */\n@Component\n@Slf4j\npublic class DeadLetterQueueConsumer {\n\n    /**\n     * 插件延迟队列\n     * 消费者\n     */\n    @RabbitListener(queues = DELAYED_QUEUE_NAME)\n    public void receiveD(Message message, Channel channel) throws IOException {\n        String msg = new String(message.getBody());\n        log.info(&amp;quot;当前时间：{},延时队列收到消息：{}&amp;quot;, LocalDateTime.now().toString(), msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;交换机\&#34;&gt;交换机&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/7p9h2n83oojuqpn5rt3dmkfc3r.png\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/7p9h2n83oojuqpn5rt3dmkfc3r.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;队列\&#34;&gt;队列&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/05esbd0g36giqrfcltkp3jg0bg.png\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/05esbd0g36giqrfcltkp3jg0bg.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;效果图\&#34;&gt;效果图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/08/1m6okllergjoqp3i0imaadojao.png\&#34; alt=\&#34;http://blog.imyzt.top/upload/2020/08/1m6okllergjoqp3i0imaadojao.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;TTL对消息设置过期时间，过期时间是无序的。所以不能用于延迟队列不同过期时间的处理。只能针对队列设置时间，一个队列处理一个时间的需求。&lt;/li&gt;\n&lt;li&gt;如果需要可靠性延迟队列，推荐使用插件。&lt;/li&gt;\n&lt;li&gt;rabbitmq_delayed_message_exchange插件在RAM节点会有一些问题，这个博主描述了这部分&lt;a href=\&#34;https://blog.csdn.net/wangming520liwei/article/details/103352440\&#34;&gt;https://blog.csdn.net/wangming520liwei/article/details/103352440&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;本文大量参考了“参考文章”中的内容，只是对自己学习延迟队列的内容记载。感谢原作者们。&lt;/li&gt;\n&lt;li&gt;本文出现的源代码均在&lt;a href=\&#34;https://github.com/imyzt/learning-technology-code/tree/master/mq-series/RabbitMQ/delay-queue-simple\&#34;&gt;github&lt;/a&gt;中&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;rabbitmq-yan-chi-gong-neng&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;RabbitMQ实现延迟队列&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-08-29 22:37:42&#34;,&#34;dateFormat&#34;:&#34;2020-08-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/rabbitmq-yan-chi-gong-neng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;13 min read&#34;,&#34;time&#34;:775000,&#34;words&#34;:3021,&#34;minutes&#34;:13},&#34;description&#34;:&#34;参考文章\n\nhttps://www.cnblogs.com/mfrank/p/11260355.html\nhttps://blog.csdn.net/u014308482/article/details/53036770\nhttps://b...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\&#34;&gt;参考文章&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E6%96%87%E5%A4%A7%E7%BA%B2\&#34;&gt;本文大纲&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97\&#34;&gt;什么是延迟队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\&#34;&gt;延迟队列的使用场景&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85\&#34;&gt;基础知识补充&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ttltime-to-live\&#34;&gt;TTL（Time To Live）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFttl\&#34;&gt;什么是TTL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEttl\&#34;&gt;如何设置TTL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97%E6%97%B6%E8%AE%BE%E7%BD%AE%E9%98%9F%E5%88%97%E7%9A%84ttl\&#34;&gt;创建队列时，设置队列的TTL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E7%BD%AE%E6%AF%8F%E6%9D%A1%E6%B6%88%E6%81%AF%E7%9A%84ttl\&#34;&gt;设置每条消息的TTL&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%A4%E7%A7%8Dttl%E7%9A%84%E7%89%B9%E6%80%A7\&#34;&gt;两种TTL的特性&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dlxdead-letter-exchanges\&#34;&gt;DLX（Dead Letter Exchanges）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFdlx\&#34;&gt;什么是DLX&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1\&#34;&gt;什么是死信&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEdlx\&#34;&gt;如何设置DLX&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93\&#34;&gt;基础知识总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\&#34;&gt;实现延迟消息队列&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%BA%90%E7%A0%81\&#34;&gt;源码&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E9%83%A8%E5%88%86\&#34;&gt;配置部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%9F%E4%BA%A7%E8%80%85%E9%83%A8%E5%88%86\&#34;&gt;生产者部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E8%B4%B9%E8%80%85%E9%83%A8%E5%88%86\&#34;&gt;消费者部分&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%A4%E4%B8%AA%E4%BA%A4%E6%8D%A2%E6%9C%BA\&#34;&gt;两个交换机&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B%E4%B8%AA%E9%98%9F%E5%88%97\&#34;&gt;四个队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%B6%E8%BF%9F%E6%95%88%E6%9E%9C\&#34;&gt;延迟效果&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E9%99%B7\&#34;&gt;缺陷&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96\&#34;&gt;延迟队列优化&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85\&#34;&gt;插件的安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E5%8A%9F%E8%83%BD\&#34;&gt;重新实现延迟功能&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E9%83%A8%E5%88%86-2\&#34;&gt;配置部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%9F%E4%BA%A7%E8%80%85%E9%83%A8%E5%88%86-2\&#34;&gt;生产者部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E8%B4%B9%E8%80%85%E9%83%A8%E5%88%86-2\&#34;&gt;消费者部分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%A4%E6%8D%A2%E6%9C%BA\&#34;&gt;交换机&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%98%9F%E5%88%97\&#34;&gt;队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%88%E6%9E%9C%E5%9B%BE\&#34;&gt;效果图&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;数组\&#34;&gt;数组&lt;/h1&gt;\n&lt;p&gt;数组只能存储同一种数据类型的数据&lt;br&gt;\n数组长度一经初始化，不能够修改&lt;/p&gt;\n&lt;h2 id=\&#34;数组的声明\&#34;&gt;数组的声明&lt;/h2&gt;\n&lt;p&gt;var 数组名称 [长度]数据类型&lt;/p&gt;\n&lt;p&gt;获取数组的长度使用内置函数len(arr)&lt;br&gt;\n获取数组的容量使用内置函数cap(arr)&lt;/p&gt;\n&lt;p&gt;func main() {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// var 数组名词 [长度]数据类型\nvar arr [5]int\narr[0] = 1\narr[1] = 2\n\n// 没有赋值的内容, 默认为数组数据类型的零值\nfmt.Println(arr[2])\t// 0\n\nfmt.Println(&amp;quot;数组的长度为:&amp;quot;, len(arr))\t// 5\nfmt.Println(&amp;quot;数组的容量为:&amp;quot;, cap(arr))\t// 3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;h2 id=\&#34;数组的创建\&#34;&gt;数组的创建&lt;/h2&gt;\n&lt;p&gt;数组创建有四种方式&lt;/p&gt;\n&lt;p&gt;func main() {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 0. 创建时制定长度, 不赋值\nvar arr0 [5]int\narr0[0] = 1\nfmt.Println(arr0[0])\t// 1\n\n// 1. 创建时, 直接将值赋值到数组里面\narr := [3]int{1,2,3}\nfmt.Println(arr[2])\t\t// 3\n\n// 2. 指定对应位置的值\narr1 := [3]int{0:3, 1:2, 2:1}\nfmt.Println(arr1[0])\t// 3\n\n// 3. 创建时, 不指定数组长度, 由初始化赋值长度自动推断\narr2 := [...]int{1, 2, 3, 4, 5}\nfmt.Println(&amp;quot;arr2 len: &amp;quot;, len(arr2))\t// 5\nfmt.Println(&amp;quot;arr2 cap: &amp;quot;, cap(arr2))\t// 5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;h2 id=\&#34;数组的遍历\&#34;&gt;数组的遍历&lt;/h2&gt;\n&lt;p&gt;func main() {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;arr := [...]int{1,2,3,4,5}\n\n// range方式遍历\nfor a := range arr {\n\tfmt.Println(a)\n}\n\nfmt.Println(&amp;quot;---&amp;quot;)\n\n// for循环方式\nfor idx, a := range arr {\n\tfmt.Println(&amp;quot;idx=&amp;quot;, idx, &amp;quot;arr=&amp;quot;, a)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;h2 id=\&#34;二维数组\&#34;&gt;二维数组&lt;/h2&gt;\n&lt;p&gt;func main() {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 定义, 后赋值\n// arr1 := [2][3]int\n\n// 定义时初始化\narr := [2][3]int{{1,2,3},{11,22,33}}\n\nprintArr(arr)\n\n//[0][0]=1\n//[0][1]=2\n//[0][2]=3\n//[1][0]=11\n//[1][1]=22\n//[1][2]=33\n\nfmt.Println(&amp;quot;---&amp;quot;)\n\n// 通过下标修改数组元素\narr[1][0] = 111\n\nprintArr(arr)\n\n//[0][0]=1\n//[0][1]=2\n//[0][2]=3\n//[1][0]=111\n//[1][1]=22\n//[1][2]=33\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;p&gt;func printArr(arr [2][3]int) {&lt;br&gt;\nfor one, ints := range arr {&lt;br&gt;\nfor two, i2 := range ints {&lt;br&gt;\nfmt.Println(fmt.Sprintf(&amp;quot;[%v][%v]=%v&amp;quot;, one, two, i2))&lt;br&gt;\n}&lt;br&gt;\n}&lt;br&gt;\n}&lt;/p&gt;\n&lt;h1 id=\&#34;切片slice\&#34;&gt;切片Slice&lt;/h1&gt;\n&lt;h2 id=\&#34;切片的声明\&#34;&gt;切片的声明&lt;/h2&gt;\n&lt;p&gt;它与数组的唯一区别，就是[]中不指定长度&lt;/p&gt;\n&lt;p&gt;var 切片名称 []数据类型&lt;br&gt;\n切片名称 := make([]数据类型, 初始数据, 初始容量)&lt;/p&gt;\n&lt;p&gt;// 声明一个切片slice&lt;br&gt;\nvar slice []int&lt;br&gt;\n// 初始化一个长度为2, 容量为5的切片&lt;br&gt;\nslice := make([]int, 2, 5)&lt;/p&gt;\n&lt;h2 id=\&#34;切片的创建与扩容\&#34;&gt;切片的创建与扩容&lt;/h2&gt;\n&lt;p&gt;通过make函数创建切片&lt;br&gt;\n通过append添加元素&lt;br&gt;\n切片的扩容是成倍的,扩容后内存地址改变&lt;/p&gt;\n&lt;p&gt;func main() {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 初始化一个长度为2, 容量为5的切片\nslice := make([]int, 2, 5)\n\nfmt.Println(slice)\nfmt.Println(&amp;quot;len=&amp;quot;, len(slice), &amp;quot;cap=&amp;quot;, cap(slice))\n\n// 切片通过append添加元素\nslice = append(slice, 2, 3, 4, 5, 6)\nfmt.Println(slice)\n// 当切片容量不够时, 成倍扩容\nfmt.Println(&amp;quot;len=&amp;quot;, len(slice), &amp;quot;cap=&amp;quot;, cap(slice))\n//[0 0]\n//len= 2 cap= 5\n//[0 0 2 3 4 5 6]\n//len= 7 cap= 10\n\n\n// 添加一组切片到另一切片中\nslice1 := append(slice)\n// 修改源切片会影响到新切片, 因为是浅拷贝\nslice[1] = 1\nfmt.Println(slice)\nfmt.Println(slice1)\n//[0 1 2 3 4 5 6]\n//[0 1 2 3 4 5 6]\n\ns1 := make([]int, 0, 3)\nfmt.Printf(&amp;quot;地址%p,长度%d,容量%d\\n&amp;quot;, s1, len(s1), cap(s1))\ns1 = append(s1, 1, 2)\nfmt.Printf(&amp;quot;地址%p,长度%d,容量%d\\n&amp;quot;, s1, len(s1), cap(s1))\ns1 = append(s1, 3, 4, 5)\nfmt.Printf(&amp;quot;地址%p,长度%d,容量%d\\n&amp;quot;, s1, len(s1), cap(s1))\n\n//地址0xc000016160,长度0,容量3\n//地址0xc000016160,长度2,容量3\n//地址0xc00001c180,长度5,容量6\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;h2 id=\&#34;make与new-的区别\&#34;&gt;make()与new() 的区别&lt;/h2&gt;\n&lt;p&gt;make()是Go语言中的内置函数，主要用于创建并初始化slice切片类型，或者map字典类型，或者channel通道类型数据。他与new方法的区别是。new用于各种数据类型的内存分配，在Go语言中认为他返回的是一个指针。指向的是一个某种类型的零值。make 返回的是一个有着初始值的非零值。&lt;/p&gt;\n&lt;p&gt;func main() {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;slice1 := new([]int)\nfmt.Println(slice1) // &amp;amp;[]\n\nslice2 := make([]int, 3)\nfmt.Println(slice2)\t// [0 0 0]\n\n//结果出错 slice1是一个空指针 invalid operation: slice1[0] (type *[]int does not support indexing)\nfmt.Println(slice1[0])\n//结果为 0 因为已经初始化了\nfmt.Println(slice2[0])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;go-qie-pian-shu-zu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Go 切片数组&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-08-23 17:20:44&#34;,&#34;dateFormat&#34;:&#34;2020-08-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/go-qie-pian-shu-zu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:281000,&#34;words&#34;:1009,&#34;minutes&#34;:5},&#34;description&#34;:&#34;数组\n数组只能存储同一种数据类型的数据\n数组长度一经初始化，不能够修改\n数组的声明\nvar 数组名称 [长度]数据类型\n获取数组的长度使用内置函数len(arr)\n获取数组的容量使用内置函数cap(arr)\nfunc main() {\n//...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84\&#34;&gt;数组&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E\&#34;&gt;数组的声明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA\&#34;&gt;数组的创建&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86\&#34;&gt;数组的遍历&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84\&#34;&gt;二维数组&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%87%E7%89%87slice\&#34;&gt;切片Slice&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%87%E7%89%87%E7%9A%84%E5%A3%B0%E6%98%8E\&#34;&gt;切片的声明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%87%E7%89%87%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%89%A9%E5%AE%B9\&#34;&gt;切片的创建与扩容&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#make%E4%B8%8Enew-%E7%9A%84%E5%8C%BA%E5%88%AB\&#34;&gt;make()与new() 的区别&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;go的变量定义了必须使用，不然无法通过编译&lt;br&gt;\n全局变量定义后可以不使用，如果全局与局部同名，采用就近原则&lt;br&gt;\n如果是简洁模式定义，左边至少应该包括一个新变量&lt;/p&gt;\n&lt;h1 id=\&#34;变量的定义\&#34;&gt;变量的定义&lt;/h1&gt;\n&lt;p&gt;变量从繁到简，总共三种方式&lt;br&gt;\nvar globalVar = &amp;quot;全局变量无法使用简洁模式定义, 但可以定义了不使用&amp;quot;&lt;/p&gt;\n&lt;p&gt;func main() {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 先定义再赋值\nvar i int;\ni = 1\n// 定义变量, 定义数据类型, 赋值\nvar i2 int = 2\n// 定义变量, 赋值, 数据类型自动推断\nvar i3= 3\n// 省略变量, 数据类型定义, 数据类型自动推断\ni4 := 4\n// 定义多个变量\ni5, i6, i7 := 5, 6, &amp;quot;i7&amp;quot;\n// 会报错, 因为没有定义新的变量\n//i5, i6 := 5, 6\n//i6, i7 := 6, &amp;quot;i7&amp;quot;\n// 表达式中定义了新的i8, 所以不会报错, 并且还给i7赋值了新值(i77)\ni7, i8 := &amp;quot;i77&amp;quot;, &amp;quot;i8&amp;quot;\n\nfmt.Println(i, i2, i3, i4, i5, i6, i7, i8)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;h1 id=\&#34;变量的零值\&#34;&gt;变量的零值&lt;/h1&gt;\n&lt;p&gt;int  -&amp;gt; 0&lt;br&gt;\nstring -&amp;gt; &amp;quot;&amp;quot;&lt;br&gt;\nbool  -&amp;gt; false&lt;br&gt;\nfloat  -&amp;gt; 0.0&lt;/p&gt;\n&lt;h1 id=\&#34;匿名变量\&#34;&gt;匿名变量&lt;/h1&gt;\n&lt;p&gt;不想使用的变量可以丢给匿名变量&lt;br&gt;\nfunc main() {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 赋值给匿名变量, 字符串在go中可以用双引号(&amp;quot;&amp;quot;)也可以用(``)\ni1, _ := 1, `赋值给匿名变量的值`\n\nfmt.Println(i1)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;h1 id=\&#34;go变量交换\&#34;&gt;go变量交换&lt;/h1&gt;\n&lt;p&gt;其他语言交换需要中间变量，golang不需要&lt;br&gt;\nfunc main() {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a, b := &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;\n// 变量直接交换\na, b = b, a\n\nfmt.Println(fmt.Sprintf(&amp;quot;a=%s, b=%s&amp;quot;, a, b))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;p&gt;console：&lt;br&gt;\na=b, b=a&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;go-yu-yan-de-bian-liang-yu-chang-liang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;go语言的变量与常量&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-08-23 17:19:31&#34;,&#34;dateFormat&#34;:&#34;2020-08-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/go-yu-yan-de-bian-liang-yu-chang-liang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:100000,&#34;words&#34;:398,&#34;minutes&#34;:2},&#34;description&#34;:&#34;go的变量定义了必须使用，不然无法通过编译\n全局变量定义后可以不使用，如果全局与局部同名，采用就近原则\n如果是简洁模式定义，左边至少应该包括一个新变量\n变量的定义\n变量从繁到简，总共三种方式\nvar globalVar = &amp;quot;全局...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89\&#34;&gt;变量的定义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%98%E9%87%8F%E7%9A%84%E9%9B%B6%E5%80%BC\&#34;&gt;变量的零值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F\&#34;&gt;匿名变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#go%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2\&#34;&gt;go变量交换&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;if分支语句\&#34;&gt;if分支语句&lt;/h2&gt;\n&lt;h3 id=\&#34;普通if\&#34;&gt;普通if&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;resp, err := http.Get(url)\nif err != nil {\n  log.Fatal(fmt.Sprintf(&amp;quot;请求异常, url: %s&amp;quot;, url))\n} else if {\n} else {\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;赋值if\&#34;&gt;赋值if&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;var nameList []string\nif err := json.Unmarshal([]byte(jsonData), &amp;amp;nameList); err != nil {\n  log.Fatal(err)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;switch分支语句\&#34;&gt;switch分支语句&lt;/h2&gt;\n&lt;h3 id=\&#34;普通switch\&#34;&gt;普通switch&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;func main()  {\n\n\t// 普通switch\n\tswitch 2 {\n\tcase 1:\n\t\tfmt.Println(1)\n\tcase 2:\n\t\tfmt.Println(2)\n\tcase 3, 4, 5:\n\t\tfmt.Println(&amp;quot;3, 4, 5&amp;quot;)\n\tdefault:\n\t\tfmt.Println(&amp;quot;default&amp;quot;)\n\t}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;判断switch\&#34;&gt;判断switch&lt;/h3&gt;\n&lt;p&gt;很神奇，可以代替多个if条件判断&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 省略变量, 相当于作用于bool类型\nfunc main() {\n\n\tage := 18\n\tswitch {\n    // 条件为true是 执行内容\n\tcase age &amp;gt; 10:\n\t\tfmt.Println(&amp;quot;age &amp;gt; 10&amp;quot;)\n\tcase age &amp;gt; 8:\n\t\tfmt.Println(&amp;quot;age &amp;gt; 8&amp;quot;)\n\tdefault:\n\t\tfmt.Println(&amp;quot;default&amp;quot;)\n\t}\n    }\n}\n\nconsole\n\nage &amp;gt; 10\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;赋值switch\&#34;&gt;赋值switch&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;func main()  {\n\n\tswitch name := &amp;quot;shenzhen&amp;quot;; name {\n\tcase &amp;quot;shenzhen&amp;quot;:\n\t\tfmt.Println(&amp;quot;shenzhen&amp;quot;)\n\tcase &amp;quot;foshan&amp;quot;:\n\t\tfmt.Println(&amp;quot;foshan&amp;quot;)\n\tdefault:\n\t\tfmt.Println(&amp;quot;default&amp;quot;)\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;带跳出的switch\&#34;&gt;带跳出的switch&lt;/h3&gt;\n&lt;p&gt;golang的switch case自带一个break&lt;br&gt;\n如果需要向下执行可以使用fallthrough&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;func main()  {\n\n\t// break 强制跳出, 不执行 &amp;quot;gd3&amp;quot;\n\tswitch name := &amp;quot;gd&amp;quot;; name {\n\tcase &amp;quot;gd&amp;quot;:\n\t\tfmt.Println(&amp;quot;gd1&amp;quot;)\n\t\tfmt.Println(&amp;quot;gd2&amp;quot;)\n\t\tbreak\n\t\tfmt.Println(&amp;quot;gd3&amp;quot;)\n\t}\n\n\tfmt.Println(&amp;quot;-0----&amp;quot;)\n\n\tswitch name := &amp;quot;sz&amp;quot;; name {\n\tcase &amp;quot;sz&amp;quot;:\n\t\tfmt.Println(&amp;quot;深圳1&amp;quot;)\n\t\tfmt.Println(&amp;quot;深圳2&amp;quot;)\n\t\tfmt.Println(&amp;quot;深圳3&amp;quot;)\n\t\t// 执行完 case = &amp;quot;sz&amp;quot;后, 不跳出, 继续执行 case = &amp;quot;gz&amp;quot;\n\t\tfallthrough\n\tcase &amp;quot;gz&amp;quot;:\n\t\tfmt.Println(&amp;quot;广州&amp;quot;)\n\t}\n}\n\nconsole: \n\ngd1\ngd2\n-0----\n深圳1\n深圳2\n深圳3\n广州\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;for循环语句\&#34;&gt;for循环语句&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;for (init; condition; post) {}\n\nInit: 初始化，只执行一次\ncondition: bool类型，\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;普通for\&#34;&gt;普通for&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;func main()  {\n\n\tfor i := 0; i &amp;lt; 5; i ++ {\n\t\tfmt.Println(i)\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;外部初始化for\&#34;&gt;外部初始化for&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;func main() {\n\ti := 0\n\tfor i &amp;lt;= 5 {\n\t\tfmt.Println(i)\n\t\ti ++\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;死循环\&#34;&gt;死循环&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;func main() {\n\tfor {\n\t\tfmt.Println()\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;for循环中的跳转\&#34;&gt;for循环中的跳转&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;func main() {\n\n\tfor i := 1; i &amp;lt;= 5; i++ {\n\t\t// 跳出整个循环\n\t\tif i == 4 {\n\t\t\tbreak\n\t\t}\n\n\t\t// 跳出当前循环进行下一次循环\n\t\tif i &amp;lt; 3 {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(fmt.Sprintf(&amp;quot;i = %v&amp;quot;, i))\n\t}\n\n\t// 多层循环可通过定义标签跳转, 在for循环中break和goto都可以完成\n\tlable:\n\tfor i := 1; i &amp;lt;= 5; i++ {\n\t\tfor j := i; j &amp;lt;= 5; j++ {\n\t\t\tif i == j {\n\t\t\t\tbreak lable\n\t\t\t}\n\t\t\tif j &amp;gt; 3 {\n\t\t\t\tgoto lable\n\t\t\t}\n\t\t}\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;for循环实现冒泡\&#34;&gt;for循环实现冒泡&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;升序冒泡\nfunc main() {\n\n\tarr := []int{1, 2, 5, 2, 22, 1}\n\t\n\t// len(arr) - 1, 对比时, 最后一位必须要对比\n\tfor i := 0; i &amp;lt; len(arr) - 1; i++ {\n\t\t// j := i + 1, 对比时, 内层for循环无需从第一个开始比对, 即第一个(外层for)和第二个(内层for)比对\n\t\t// len(arr) 对比时, 最后一位参与上一层for循环的对比\n\t\tfor j := i + 1; j &amp;lt; len(arr); j++ {\n\t\t\tif arr[i] &amp;gt; arr[j] {\n\t\t\t\t// 如果当前的数字, 大于后面的数字, 就把当前数字往后移\n\t\t\t\tarr[i], arr[j] = arr[j], arr[i]\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, num := range arr {\n\t\tfmt.Println(num)\n\t}\n}\n\n\nconsole:\n\n1\n1\n2\n2\n5\n22\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;return跳出语句\&#34;&gt;return跳出语句&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;func main() {\n\n\treturnTest(1)\n}\n\nfunc returnTest(i uint) {\n\n\tif i &amp;gt; 0 {\n\t\treturn\n\t}\n\tfmt.Println(&amp;quot;i &amp;lt;= 0&amp;quot;)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;golang-fen-zhi-yu-xun-huan&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;golang分支与循环&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-08-13 22:07:59&#34;,&#34;dateFormat&#34;:&#34;2020-08-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/golang-fen-zhi-yu-xun-huan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:214000,&#34;words&#34;:703,&#34;minutes&#34;:4},&#34;description&#34;:&#34;if分支语句\n普通if\nresp, err := http.Get(url)\nif err != nil {\n  log.Fatal(fmt.Sprintf(&amp;quot;请求异常, url: %s&amp;quot;, url))\n} else i...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#if%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5\&#34;&gt;if分支语句&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%99%AE%E9%80%9Aif\&#34;&gt;普通if&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B5%8B%E5%80%BCif\&#34;&gt;赋值if&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#switch%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5\&#34;&gt;switch分支语句&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%99%AE%E9%80%9Aswitch\&#34;&gt;普通switch&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A4%E6%96%ADswitch\&#34;&gt;判断switch&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B5%8B%E5%80%BCswitch\&#34;&gt;赋值switch&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%A6%E8%B7%B3%E5%87%BA%E7%9A%84switch\&#34;&gt;带跳出的switch&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#for%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\&#34;&gt;for循环语句&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%99%AE%E9%80%9Afor\&#34;&gt;普通for&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%96%E9%83%A8%E5%88%9D%E5%A7%8B%E5%8C%96for\&#34;&gt;外部初始化for&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%BB%E5%BE%AA%E7%8E%AF\&#34;&gt;死循环&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%BD%AC\&#34;&gt;for循环中的跳转&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#for%E5%BE%AA%E7%8E%AF%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1\&#34;&gt;for循环实现冒泡&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#return%E8%B7%B3%E5%87%BA%E8%AF%AD%E5%8F%A5\&#34;&gt;return跳出语句&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Spring时间处理&lt;/p&gt;\n&lt;h1 id=\&#34;入参处理\&#34;&gt;入参处理&lt;/h1&gt;\n&lt;p&gt;入参在POST请求时，Spring会默认序列化字符串时间到LocalDateTime系列。&lt;br&gt;\n入参在GET请求时，Spring默认不处理，需要在参数上写&lt;code&gt;@DateTimeFormat&lt;/code&gt;注解。&lt;br&gt;\n可以通过统一处理&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/***\n     * Date日期类型转换器\n     */\n    @Bean\n    public Formatter&amp;lt;Date&amp;gt; dateFormatter() {\n        return new Formatter&amp;lt;Date&amp;gt;() {\n\n            @Override\n            public Date parse(String text, Locale locale) {\n                SimpleDateFormat sdf = new SimpleDateFormat(Dateutils.DATE_FORMAT_FULL);\n                Date date = null;\n                try {\n                    date = sdf.parse(text);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                return date;\n            }\n\n            @Override\n            public String print(Date object, Locale locale) {\n                SimpleDateFormat sdf = new SimpleDateFormat(Dateutils.DATE_FORMAT_FULL);\n                return sdf.format(object);\n            }\n        };\n    }\n    @Bean\n    public Formatter&amp;lt;LocalDate&amp;gt; localDateFormatter() {\n        return new Formatter&amp;lt;LocalDate&amp;gt;() {\n            @Override\n            public LocalDate parse(String text, Locale locale) {\n                return LocalDate.parse(text, DateTimeFormatter.ISO_LOCAL_DATE);\n            }\n\n            @Override\n            public String print(LocalDate object, Locale locale) {\n                return DateTimeFormatter.ISO_LOCAL_DATE.format(object);\n            }\n        };\n    }\n\n    @Bean\n    public Formatter&amp;lt;LocalDateTime&amp;gt; localDateTimeFormatter() {\n        return new Formatter&amp;lt;LocalDateTime&amp;gt;() {\n            @Override\n            public String print(LocalDateTime localDateTime, Locale locale) {\n                return DateTimeFormatter.ofPattern(Dateutils.DATE_FORMAT_FULL).format(localDateTime);\n            }\n\n            @Override\n            public LocalDateTime parse(String text, Locale locale) {\n                return LocalDateTime.parse(text, DateTimeFormatter.ofPattern(Dateutils.DATE_FORMAT_FULL));\n            }\n        };\n    }\n\n    @Bean\n    public Formatter&amp;lt;LocalTime&amp;gt; localTimeFormatter() {\n        return new Formatter&amp;lt;LocalTime&amp;gt;() {\n            @Override\n            public String print(LocalTime localTime, Locale locale) {\n                return DateTimeFormatter.ofPattern(Dateutils.DATE_FORMAT_HMS).format(localTime);\n            }\n\n            @Override\n            public LocalTime parse(String text, Locale locale) {\n                return LocalTime.parse(text, DateTimeFormatter.ofPattern(Dateutils.DATE_FORMAT_HMS));\n            }\n        };\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;出参处理\&#34;&gt;出参处理&lt;/h1&gt;\n&lt;p&gt;出参LocalDateTime时间需要写&lt;code&gt;@JsonFormat(pattern = Dateutils.DATE_FORMAT_FULL)&lt;/code&gt;处理，可以通过增加统一配置处理&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;    @Bean\n    public Jackson2ObjectMapperBuilderCustomizer customizer() {\n        return builder -&amp;gt; {\n            builder.locale(Locale.CHINA);\n            builder.timeZone(TimeZone.getTimeZone(ZoneId.systemDefault()));\n            builder.simpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);\n\n            JavaTimeModule javaTimeModule = new JavaTimeModule();\n            javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;)));\n            javaTimeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(&amp;quot;yyyy-MM-dd&amp;quot;)));\n            javaTimeModule.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(&amp;quot;HH:mm:ss&amp;quot;)));\n            javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;)));\n            javaTimeModule.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(&amp;quot;yyyy-MM-dd&amp;quot;)));\n            javaTimeModule.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(&amp;quot;HH:mm:ss&amp;quot;)));\n\n            builder.modules(javaTimeModule);\n        };\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-huan-jing-xia-shi-jian-zi-fu-chuan-zhuan-huan&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring环境下时间字符串转换&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-07-21 09:25:03&#34;,&#34;dateFormat&#34;:&#34;2020-07-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-huan-jing-xia-shi-jian-zi-fu-chuan-zhuan-huan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:136000,&#34;words&#34;:406,&#34;minutes&#34;:3},&#34;description&#34;:&#34;Spring时间处理\n入参处理\n入参在POST请求时，Spring会默认序列化字符串时间到LocalDateTime系列。\n入参在GET请求时，Spring默认不处理，需要在参数上写@DateTimeFormat注解。\n可以通过统一处理\n/...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%A5%E5%8F%82%E5%A4%84%E7%90%86\&#34;&gt;入参处理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BA%E5%8F%82%E5%A4%84%E7%90%86\&#34;&gt;出参处理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;组合注解\&#34;&gt;组合注解&lt;/h1&gt;\n&lt;h2 id=\&#34;使用\&#34;&gt;使用&lt;/h2&gt;\n&lt;p&gt;组合注解就是将多个注解组合到一个注解上。&lt;br&gt;\n比如我们在编写控制器（Controller）时，一般需要写&lt;code&gt;@Controller&lt;/code&gt;和&lt;code&gt;@ResponseBody&lt;/code&gt;，通过组合注解，我们可以写一个&lt;code&gt;@RestController&lt;/code&gt;就可以实现两个注解的功能了。&lt;/p&gt;\n&lt;p&gt;在使用SpringBoot时，经常能够看到这些注解的使用。&lt;br&gt;\n比如我们在使用&lt;code&gt;@RestController&lt;/code&gt;, &lt;code&gt;@GetMapping&lt;/code&gt;, &lt;code&gt;@Service&lt;/code&gt;时，通过查看它们的源码，都能够发现元注解中有一些常见的注解。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Controller // 组合@Controller元注解\n@ResponseBody // 组合@ResponseBody元注解\npublic @interface RestController {}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;@RequestMapping(method = RequestMethod.GET) // 组合@RequestMapping元注解\npublic @interface GetMapping {}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;值的获取\&#34;&gt;值的获取&lt;/h2&gt;\n&lt;p&gt;通过组合注解，我们可以很方便的自定义组合功能注解，但是我们没有办法在获取父注解时，像Java继承多态那样方便的获取到子注解的值。&lt;/p&gt;\n&lt;p&gt;比如我们的&lt;code&gt;@Controller&lt;/code&gt;注解是有很多参数的，通过定义了&lt;code&gt;@RestController&lt;/code&gt;后，是没有办法传递值到&lt;code&gt;@Controller&lt;/code&gt;的。&lt;/p&gt;\n&lt;p&gt;所以Spring给我们提供了一个工具类，具体操作如下：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;在子注解定义参数，通过&lt;code&gt;@AliasFor(annotation = Controller.class)&lt;/code&gt; 指定参数绑定的父注解参数（参数名相同无需指定）。主要用于约束（类似于重写）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;@Controller\n@ResponseBody\npublic @interface RestController {\n\n\t/**\n\t * The value may indicate a suggestion for a logical component name,\n\t * to be turned into a Spring bean in case of an autodetected component.\n\t * @return the suggested component name, if any (or empty String otherwise)\n\t * @since 4.0.1\n\t */\n\t@AliasFor(annotation = Controller.class)\n\tString value() default &amp;quot;&amp;quot;;\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;通过&lt;code&gt;AnnotatedElementUtils&lt;/code&gt;工具类，即可获取父注解（携带子注解值）。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;父注解 变量名称 = AnnotatedElementUtils.findMergedAnnotation(子注解.class, 父注解.class);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其实原理非常简单，就是将两个注解的值合并，具体可以查看spring官方文档 &lt;a href=\&#34;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/AnnotatedElementUtils.html#findMergedAnnotation-java.lang.reflect.AnnotatedElement-java.lang.Class-\&#34;&gt;findMergedAnnotation&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;注解继承\&#34;&gt;注解继承&lt;/h1&gt;\n&lt;p&gt;注解继承的意思就是标记该注解的类，子类也同等能够继承到父类的注解。&lt;/p&gt;\n&lt;p&gt;可以通过 &lt;code&gt;@Inherited&lt;/code&gt; 元注解实现，底层是用jdk帮我们实现的。基本会使用就行&lt;/p&gt;\n&lt;p&gt;可以看一下这篇博客： &lt;a href=\&#34;https://www.jianshu.com/p/a848655d478e\&#34;&gt;简书-JAVA注解的继承性&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;zhu-jie-ji-cheng-zu-he-zhu-jie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;注解继承、组合注解&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-07-12 17:26:31&#34;,&#34;dateFormat&#34;:&#34;2020-07-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/zhu-jie-ji-cheng-zu-he-zhu-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:120000,&#34;words&#34;:518,&#34;minutes&#34;:3},&#34;description&#34;:&#34;组合注解\n使用\n组合注解就是将多个注解组合到一个注解上。\n比如我们在编写控制器（Controller）时，一般需要写@Controller和@ResponseBody，通过组合注解，我们可以写一个@RestController就可以实现两个...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3\&#34;&gt;组合注解&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8\&#34;&gt;使用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%80%BC%E7%9A%84%E8%8E%B7%E5%8F%96\&#34;&gt;值的获取&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E8%A7%A3%E7%BB%A7%E6%89%BF\&#34;&gt;注解继承&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;什么是yapiupload\&#34;&gt;什么是YapiUpload&lt;/h1&gt;\n&lt;p&gt;yapiUpload是为IDEA提供的快速编写 &lt;a href=\&#34;https://github.com/YMFE/yapi\&#34;&gt;yapi&lt;/a&gt; 接口文档的工具，在编写好Spring Controller后，通过一系列配置，可以直接生成接口文档到YAPI上。&lt;/p&gt;\n&lt;p&gt;yapiUpload是开源的&lt;br&gt;\n代码仓库在：&lt;a href=\&#34;https://github.com/diwand/YapiIdeaUploadPlugin\&#34;&gt;https://github.com/diwand/YapiIdeaUploadPlugin&lt;/a&gt;&lt;br&gt;\n文档在：&lt;a href=\&#34;https://github.com/diwand/YapiIdeaUploadPlugin/wiki/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8\&#34;&gt;https://github.com/diwand/YapiIdeaUploadPlugin/wiki&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;如何安装及配置\&#34;&gt;如何安装及配置&lt;/h1&gt;\n&lt;h2 id=\&#34;idea安装插件\&#34;&gt;IDEA安装插件&lt;/h2&gt;\n&lt;p&gt;插件地址：&lt;br&gt;\n&lt;a href=\&#34;https://plugins.jetbrains.com/plugin/12276-yapiupload\&#34;&gt;https://plugins.jetbrains.com/plugin/12276-yapiupload&lt;/a&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/05/q2nkc4848kg8gqgirhvv5pp2bc.png\&#34; alt=\&#34;安装图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;配置yapiupload\&#34;&gt;配置yapiUpload&lt;/h2&gt;\n&lt;p&gt;找到项目文件 &lt;code&gt;.idea/misc.xml&lt;/code&gt;，在&lt;code&gt;&amp;lt;project&amp;gt;&lt;/code&gt;节点粘贴以下内容。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  &amp;lt;!--yapi配置--&amp;gt;\n  &amp;lt;component name=&amp;quot;yapi&amp;quot;&amp;gt;\n    &amp;lt;option name=&amp;quot;projectToken&amp;quot;&amp;gt;你的token&amp;lt;/option&amp;gt;\n    &amp;lt;option name=&amp;quot;projectId&amp;quot;&amp;gt;14&amp;lt;/option&amp;gt;\n    &amp;lt;option name=&amp;quot;yapiUrl&amp;quot;&amp;gt;你的yapi地址&amp;lt;/option&amp;gt;\n    &amp;lt;option name=&amp;quot;projectType&amp;quot;&amp;gt;api&amp;lt;/option&amp;gt;\n  &amp;lt;/component&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/05/qgo4ug4vd8jguqpci92n9lhj3v.png\&#34; alt=\&#34;请输入图片描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;如何使用\&#34;&gt;如何使用&lt;/h1&gt;\n&lt;h2 id=\&#34;编写一个标准的接口\&#34;&gt;编写一个标准的接口&lt;/h2&gt;\n&lt;p&gt;yapiUpload支持很多Javadoc注解，可以在官方文档查看。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/05/shtq7dpcbkgmrom8ttjaprbgr5.png\&#34; alt=\&#34;标准接口\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;上传到文档地址\&#34;&gt;上传到文档地址&lt;/h2&gt;\n&lt;h3 id=\&#34;上传成功\&#34;&gt;上传成功&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/05/rn8ue7flgejktrmv2tt8qk168e.png\&#34; alt=\&#34;上传成功\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;接口列表\&#34;&gt;接口列表&lt;/h3&gt;\n&lt;p&gt;登录yapi上查看即可&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/05/r8bpv8cg54iu1rjsk3vnik94t9.png\&#34; alt=\&#34;接口列表\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;接口详情\&#34;&gt;接口详情&lt;/h3&gt;\n&lt;p&gt;修改时，一般是直接覆盖，高版本yapi的api支持修改。不过好像这个工具还不支持。&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/05/tll83ishceintqja43s3utkfk9.png\&#34; alt=\&#34;接口详情\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;二次开发\&#34;&gt;二次开发&lt;/h1&gt;\n&lt;p&gt;yapiUpload本身是一个IDEA的插件，可以按照IDEA编码进行二次开发。&lt;br&gt;\nyapi也提供了二次开发api，可以对该插件做升级。&lt;a href=\&#34;https://hellosean1025.github.io/yapi/openapi.html\&#34;&gt;https://hellosean1025.github.io/yapi/openapi.html&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;yapiupload-pei-zhi-ji-shi-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;YapiUpload配置及使用\t&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-06-14 12:19:25&#34;,&#34;dateFormat&#34;:&#34;2020-06-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/yapiupload-pei-zhi-ji-shi-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:82000,&#34;words&#34;:323,&#34;minutes&#34;:2},&#34;description&#34;:&#34;什么是YapiUpload\nyapiUpload是为IDEA提供的快速编写 yapi 接口文档的工具，在编写好Spring Controller后，通过一系列配置，可以直接生成接口文档到YAPI上。\nyapiUpload是开源的\n代码仓库在...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFyapiupload\&#34;&gt;什么是YapiUpload&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE\&#34;&gt;如何安装及配置&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#idea%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6\&#34;&gt;IDEA安装插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AEyapiupload\&#34;&gt;配置yapiUpload&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\&#34;&gt;如何使用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84%E6%8E%A5%E5%8F%A3\&#34;&gt;编写一个标准的接口&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%96%87%E6%A1%A3%E5%9C%B0%E5%9D%80\&#34;&gt;上传到文档地址&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F\&#34;&gt;上传成功&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E5%88%97%E8%A1%A8\&#34;&gt;接口列表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E8%AF%A6%E6%83%85\&#34;&gt;接口详情&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91\&#34;&gt;二次开发&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/06/umhrmcs17eho2qdnnfs44e7vjp.png\&#34; alt=\&#34;执行图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;调试命令\&#34;&gt;调试命令&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;redis-cli --ldb --eval loop.lua keysargs1 keysargs2, argv1,argv2&lt;/code&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;命令解析&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;--ldb 即开启调试模式&lt;br&gt;\n--eval 指定调试脚本&lt;br&gt;\nkeysargs1 keysargs2, argv1,argv2 逗号前是KEYS的参数， 之后是ARGV的参数。&lt;br&gt;\ns 如果，通过 &lt;code&gt;s&lt;/code&gt; 执行下一步&lt;/p&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;loop.lua&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;local i=0\nwhile true\ndo\n\ti=i+1\n\tredis.debug(i)\nend\nreturn &amp;quot;OK&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;redis-lua-调试工具\&#34;&gt;redis lua 调试工具&lt;/h2&gt;\n&lt;h4 id=\&#34;ide-地址及安装\&#34;&gt;IDE 地址及安装&lt;/h4&gt;\n&lt;p&gt;&lt;a href=\&#34;https://redislabs.com/blog/zerobrane-studio-plugin-for-redis-lua-scripts/\&#34;&gt;&lt;br&gt;\nZeroBrane Studio Plugin for Redis Lua Scripts&lt;/a&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;lua调试插件地址\&#34;&gt;LUA调试插件地址&lt;/h4&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/pkulchenko/ZeroBranePackage/blob/master/redis.lua\&#34;&gt;https://github.com/pkulchenko/ZeroBranePackage/blob/master/redis.lua&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;redis-lua-debug&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Redis LUA debug&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-06-14 12:15:42&#34;,&#34;dateFormat&#34;:&#34;2020-06-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/redis-lua-debug/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:33000,&#34;words&#34;:117,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n调试命令\nredis-cli --ldb --eval loop.lua keysargs1 keysargs2, argv1,argv2\n\n命令解析\n\n--ldb 即开启调试模式\n--eval 指定调试脚本\nkeysargs1 keys...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4\&#34;&gt;调试命令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#redis-lua-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7\&#34;&gt;redis lua 调试工具&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ide-%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%AE%89%E8%A3%85\&#34;&gt;IDE 地址及安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#lua%E8%B0%83%E8%AF%95%E6%8F%92%E4%BB%B6%E5%9C%B0%E5%9D%80\&#34;&gt;LUA调试插件地址&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;eval-lua\&#34;&gt;EVAL LUA&lt;/h1&gt;\n&lt;h2 id=\&#34;rediscall\&#34;&gt;redis.call&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;通过EVAL指令，使用 redis.call 执行LUA脚本，3指定的是，前三个参数是KEYS的，然后后面的是ARGV的。&lt;/li&gt;\n&lt;li&gt;LUA索引从1开始。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; EVAL &amp;quot;return redis.call(’SET&#39;, KEYS[2], ARGV[3])&amp;quot; 3 1 2 3 4 5 6\n127.0.0.1:6379&amp;gt; get 2\n&amp;quot;6&amp;quot;\n\n[1 2 3]是KEYS的\n[4 5 6]是ARGV的\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;redispcall\&#34;&gt;redis.pcall&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;redis.call 在遇到异常之后，不会继续往后执行。&lt;/li&gt;\n&lt;li&gt;redis.pcall 可以捕获异常，如果没处理的话，将继续往后执行。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;此处第一条语句报错，第二条语句将不会执行。\n127.0.0.1:6379&amp;gt; EVAL &amp;quot;redis.call(&#39;SETRRRR&#39;, KEYS[1], ARGV[1]); redis.call(&#39;SET&#39;, KEYS[2], ARGV[2])&amp;quot; 2 a b c d e f g\n(error) ERR Error running script (call to f_8a873e7e4125dc92ef97aa5e8b07e22f7d185183): @user_script:1: @user_script: 1: Unknown Redis command called from Lua script\n127.0.0.1:6379&amp;gt; get b\n(nil)\n\n通过redis.pcall命令，对错误进行捕获后，会继续执行第二条语句。\n127.0.0.1:6379&amp;gt; EVAL &amp;quot;redis.pcall(&#39;SETRRRR&#39;, KEYS[1], ARGV[1]); redis.call(&#39;SET&#39;, KEYS[2], ARGV[2])&amp;quot; 2 a b c d e f g\n(nil)\n127.0.0.1:6379&amp;gt; get b\n&amp;quot;d&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;script\&#34;&gt;SCRIPT&lt;/h1&gt;\n&lt;h2 id=\&#34;script作用\&#34;&gt;SCRIPT作用&lt;/h2&gt;\n&lt;p&gt;在开发过程中，如果LUA脚本比较长，是会有一定的网络开销的。可以事先将LUA脚本缓存到redis服务器上，还可以防止脚本暴露在程序中被篡改。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;可以通过 &lt;code&gt;SCRIPT LOAD &lt;/code&gt;指令将LUA脚本缓存到服务端，服务端返回一个RSA加密后的串。&lt;/li&gt;\n&lt;li&gt;执行时，通过 &lt;code&gt;EVALSHA&lt;/code&gt; 执行 &lt;code&gt;RSA串&lt;/code&gt; 即可。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SCRIPT LOAD &amp;quot;redis.call(&#39;SET&#39;, KEYS[1], ARGV[1])&amp;quot;\n&amp;quot;fcd2612e1ca113b83fdfbc2a88493d3b231a32ad&amp;quot;\n127.0.0.1:6379&amp;gt; EVALSHA fcd2612e1ca113b83fdfbc2a88493d3b231a32ad 2 a b c d e f g\n(nil)\n127.0.0.1:6379&amp;gt; get a\n&amp;quot;c&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;script基础指令\&#34;&gt;SCRIPT基础指令&lt;/h2&gt;\n&lt;h3 id=\&#34;script-exists-检查是否存在脚本\&#34;&gt;SCRIPT EXISTS 检查是否存在脚本&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SCRIPT EXISTS fcd2612e1ca113b83fdfbc2a88493d3b231a32ad\n1) (integer) 1\n127.0.0.1:6379&amp;gt; SCRIPT EXISTS fcd2612e1ca113b83fdfbc2a88493d3b231a32adaaa\n1) (integer) 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;script-flush-清空所有脚本\&#34;&gt;SCRIPT FLUSH 清空所有脚本&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SCRIPT FLUSH\nOK\n127.0.0.1:6379&amp;gt; SCRIPT EXISTS fcd2612e1ca113b83fdfbc2a88493d3b231a32ad\n1) (integer) 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;script-kill-杀死当前正在运行的脚本\&#34;&gt;SCRIPT KILL 杀死当前正在运行的脚本&lt;/h3&gt;\n&lt;p&gt;loop.lua&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;local i=0\nwhile true\ndo\n\ti=i+1\n\tredis.debug(i)\nend\nreturn &amp;quot;OK&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;redis-cli --eval loop.lua\n进入锁死状态，开一个新窗口。所有指令都返回Redis服务器处于繁忙状态\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/06/rqj21n5tuajciqe98qdlp3tek3.png\&#34; alt=\&#34;锁死\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;通过KILL指令干掉当前正在执行的指令。\n127.0.0.1:6379&amp;gt; SCRIPT KILL\nOK\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/06/41h4b4jrrghg0pjagomun2fpbv.png\&#34; alt=\&#34;释放\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;redis-lua-ji-ben-shi-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Redis LUA基本使用&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-06-14 12:02:04&#34;,&#34;dateFormat&#34;:&#34;2020-06-14&#34;,&#34;feature&#34;:&#34;https://redis.io/images/redis-white.png&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/redis-lua-ji-ben-shi-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:171000,&#34;words&#34;:588,&#34;minutes&#34;:3},&#34;description&#34;:&#34;EVAL LUA\nredis.call\n\n通过EVAL指令，使用 redis.call 执行LUA脚本，3指定的是，前三个参数是KEYS的，然后后面的是ARGV的。\nLUA索引从1开始。\n\n127.0.0.1:6379&amp;gt; EVAL &amp;...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#eval-lua\&#34;&gt;EVAL LUA&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#rediscall\&#34;&gt;redis.call&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#redispcall\&#34;&gt;redis.pcall&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#script\&#34;&gt;SCRIPT&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#script%E4%BD%9C%E7%94%A8\&#34;&gt;SCRIPT作用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#script%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4\&#34;&gt;SCRIPT基础指令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#script-exists-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%84%9A%E6%9C%AC\&#34;&gt;SCRIPT EXISTS 检查是否存在脚本&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#script-flush-%E6%B8%85%E7%A9%BA%E6%89%80%E6%9C%89%E8%84%9A%E6%9C%AC\&#34;&gt;SCRIPT FLUSH 清空所有脚本&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#script-kill-%E6%9D%80%E6%AD%BB%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC\&#34;&gt;SCRIPT KILL 杀死当前正在运行的脚本&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;介绍\&#34;&gt;介绍&lt;/h1&gt;\n&lt;p&gt;​\t看了美团  &lt;a href=\&#34;https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww\&#34;&gt;Java线程池实现原理及其在美团业务中的实践&lt;/a&gt; 这篇文章之后，对线程池有了一些新的认识，后面看到了 &lt;a href=\&#34;https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A\&#34;&gt;如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答&lt;/a&gt; 四川好男人的一顿骚操作，瞬间又认识的更清晰了一些。就想着能不能做一套这样的线程池管理系统，然后就有了后文。&lt;/p&gt;\n&lt;p&gt;​\tWeb应用系统中，ThreadPoolExecutor一般是由代码硬编码的，core/max/queueSize都是定数，而系统的流量不是一个定数。在峰值期间，线程池无法动态扩容，导致大量请求处理失败进行拒绝策略。本系统主要是做了一个可以动态调参的线程池，依赖ThreadPoolExecutor本身提供的set方法，对运行中的各项基本参数进行动态调控。并且包括监控报警、Web界面、自动扩容策略等。&lt;/p&gt;\n&lt;h1 id=\&#34;设计\&#34;&gt;设计&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/06/rshg8a6buigc7rdvcdk9q193rj.png\&#34; alt=\&#34;架构图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;实现\&#34;&gt;实现&lt;/h1&gt;\n&lt;h2 id=\&#34;客户端\&#34;&gt;客户端&lt;/h2&gt;\n&lt;p&gt;配置文件需配置服务端地址&lt;/p&gt;\n&lt;p&gt;线程池配置需配置线程池（三种接入方式）&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;接入方式， 提供三种[##feature]&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;启动时，携带应用名上报对应的线程池配置(多实例同时启动， 此接口需要幂等)&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过Java定时器，定时上报线程池数据。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;与服务端维持长连接，60秒一次，服务端线程池配置（web操作）变化时，返回对应发生改变的[线程池名称]。然后客户端请求服务端获取对应线程池新的配置。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;服务端\&#34;&gt;服务端&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;上报接口&lt;/p&gt;\n&lt;p&gt;1.1 配置上报接口(配置带版本号)&lt;/p&gt;\n&lt;p&gt;1.1.1 初次上报(数据库无法查询, 即视为初次上报)， 存储初始化参数&lt;/p&gt;\n&lt;p&gt;1.1.2 服务端Web发起调参, 自行记录， 无需客户端上报(可优化为客户端上报)&lt;/p&gt;\n&lt;p&gt;1.2 工作状态上报接口&lt;/p&gt;\n&lt;p&gt;​\t1.2.1 定时上报应用每个线程池各项指标&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;发起调参后，接受客户端请求最新线程池参数请求&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;存储上报数据， 负责提供数据展示接口，读取数据&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;feature\&#34;&gt;feature&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;接入方式新增, 除了Dynamic，让默认的Spring的task和jdk的executor都支持，只有dynamic支持修改队列大小。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;todo-list\&#34;&gt;todo-list&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/imyzt/dynamic-thread-pool/projects/1\&#34;&gt;https://github.com/imyzt/dynamic-thread-pool/projects/1&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;xian-cheng-chi-dong-tai-guan-li&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;线程池动态管理&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-06-13 19:03:11&#34;,&#34;dateFormat&#34;:&#34;2020-06-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/xian-cheng-chi-dong-tai-guan-li/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:127000,&#34;words&#34;:601,&#34;minutes&#34;:3},&#34;description&#34;:&#34;介绍\n​\t看了美团  Java线程池实现原理及其在美团业务中的实践 这篇文章之后，对线程池有了一些新的认识，后面看到了 如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答 四川好男人的一顿骚操作，瞬间又认识的更清晰了一些。就想着能不能...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8B%E7%BB%8D\&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E8%AE%A1\&#34;&gt;设计&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0\&#34;&gt;实现&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%A2%E6%88%B7%E7%AB%AF\&#34;&gt;客户端&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%8D%E5%8A%A1%E7%AB%AF\&#34;&gt;服务端&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#feature\&#34;&gt;feature&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#todo-list\&#34;&gt;todo-list&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;场景及问题\&#34;&gt;场景及问题&lt;/h2&gt;\n&lt;p&gt;做工具封装时，通常会定义一个顶级父类data struct，子类继承之后补充自己独有的属性。该模式在常规使用情况下都是可用的，但是在涉及到序列化后反序列化对象时，就不是那么管用了。&lt;/p&gt;\n&lt;p&gt;我们假设有两个对象，&lt;code&gt;class BaseClass&lt;/code&gt; 和 &lt;code&gt;class ChildClass&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;import lombok.Data;\n\n/**\n * @author imyzt\n * @date 2020/04/25\n * @description 超类\n */\n@Data\npublic class BaseClass {\n    private Integer bashInfo;\n}\n\nimport lombok.*;\n\n/**\n * @author imyzt\n * @date 2020/04/25\n * @description 子类\n */\n@EqualsAndHashCode(callSuper = true)\n@Data\n@ToString(callSuper = true)\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ChildClass extends BaseClass {\n\n    private String childInfo;\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们假设生产端生产消息，通过FastJSON序列化为字符串，然后通过kafka或者其他途径传递到消费端，消费端通过超类&lt;code&gt;BaseClass&lt;/code&gt;转换消息，根据不同的子类通过不同的策略去处理。但是在这种情况下，通过&lt;strong&gt;超类解析字符串对象回JavaBean对象时&lt;/strong&gt;，一般只能将&lt;strong&gt;超类&lt;/strong&gt;中拥有的参数转换回来，不能获得子类的属性。示例代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\nimport com.alibaba.fastjson.JSON;\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * @author imyzt\n * @date 2020/04/25\n * @description test\n */\n\n@Slf4j\npublic class Test {\n\n    public static void main(String[] args) {\n\n        ChildClass one = new ChildClass();\n        one.setBashInfo(122);\n        one.setChildInfo(&amp;quot;childInfo&amp;quot;);\n\n        // 转换为字符串, 便于传输\n        String str = parseStr(one);\n\n        log.info(&amp;quot;str={}&amp;quot;, str);\n\n        // 转换回java bean\n        BaseClass childClass = JSON.parseObject(str, BaseClass.class);\n        log.info(&amp;quot;childClass={}&amp;quot;, childClass);\n    }\n\n    private static String parseStr(BaseClass obj) {\n        return JSON.toJSONString(obj);\n    }\n}\n\n日志打印：\n14:18:09.208 [main] INFO xxx.json.Test - str={&amp;quot;bashInfo&amp;quot;:122,&amp;quot;childInfo&amp;quot;:&amp;quot;childInfo&amp;quot;}\n14:18:09.227 [main] INFO xxx.json.Test - childClass=BaseClass(bashInfo=122)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;实现方式\&#34;&gt;实现方式&lt;/h2&gt;\n&lt;p&gt;遇到这种情况，我们可以通过JSON的&lt;strong&gt;自省&lt;/strong&gt;功能，实现在反序列化为JavaBean时，得到完整的子类属性，并且将JavaBean通过多态得到对应的子类对象。具体思路就是在序列化为JSON时，在json字符串中写入对应的类型，在反序列化时，通过JSON字符串中特殊标记的类型属性，按照该类型进行反序列化即可。&lt;/p&gt;\n&lt;p&gt;FastJSON具体的实现是在调用 &lt;code&gt;JSON.toJSONString()&lt;/code&gt;时，第二个数组参数传入Feature功能&lt;code&gt;SerializerFeature.WriteClassName&lt;/code&gt;，完整调用如&lt;code&gt;JSON.toJSONString(obj, SerializerFeature.WriteClassName);&lt;/code&gt; 在写入为JSON字符串时，会带有一个特殊的标记&lt;code&gt;@type&lt;/code&gt;存储序列化时对应的类型，如下图。&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/04/upm13a7uk2hooofjkrdbe8kdhf.png\&#34; alt=\&#34;请输入图片描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n在反序列化时，只需要按照对应的类型进行解析即可。上述代码重新运行后日志如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;14:22:24.528 [main] INFO xxx.json.Test - str={&amp;quot;@type&amp;quot;:&amp;quot;xxx.json.ChildClass&amp;quot;,&amp;quot;bashInfo&amp;quot;:122,&amp;quot;childInfo&amp;quot;:&amp;quot;childInfo&amp;quot;}\n14:25:03.631 [main] INFO xxx.json.Test - childClass=ChildClass(super=BaseClass(bashInfo=122), childInfo=childInfo)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;注意点\&#34;&gt;注意点&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;子类必须实现全参构造，或者有用lombok的&lt;code&gt;@ToString(callSuper = true)&lt;/code&gt;也行，不然会出现映射父类属性的情况。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;OK, 整篇文章就讲了一个Feature，水了一整页。。可以多关注下JSON的其他Feature功能，说不定就是需要的。/狗头&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;fastjson-ji-cheng-lei-fan-xu-lie-hua-can-shu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;FastJSON继承类反序列化参数&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-05-05 13:45:01&#34;,&#34;dateFormat&#34;:&#34;2020-05-05&#34;,&#34;feature&#34;:&#34;https://imyzt.top/post-images/fastjson-ji-cheng-lei-fan-xu-lie-hua-can-shu.png&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/fastjson-ji-cheng-lei-fan-xu-lie-hua-can-shu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:187000,&#34;words&#34;:734,&#34;minutes&#34;:4},&#34;description&#34;:&#34;场景及问题\n做工具封装时，通常会定义一个顶级父类data struct，子类继承之后补充自己独有的属性。该模式在常规使用情况下都是可用的，但是在涉及到序列化后反序列化对象时，就不是那么管用了。\n我们假设有两个对象，class BaseCla...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%BA%E6%99%AF%E5%8F%8A%E9%97%AE%E9%A2%98\&#34;&gt;场景及问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\&#34;&gt;实现方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F%E7%82%B9\&#34;&gt;注意点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;yapi-api\&#34;&gt;yapi api&lt;/h1&gt;\n&lt;p&gt;https://hellosean1025.github.io/yapi/openapi.html&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;yapi-upload-cha-jian-shi-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;yapi upload插件使用&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-04-30 16:29:25&#34;,&#34;dateFormat&#34;:&#34;2020-04-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/yapi-upload-cha-jian-shi-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:3000,&#34;words&#34;:9,&#34;minutes&#34;:1},&#34;description&#34;:&#34;yapi api\nhttps://hellosean1025.github.io/yapi/openapi.html\n&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#yapi-api\&#34;&gt;yapi api&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;平时对象参数拷贝时，顺手使用的都是&lt;code&gt;Spring&lt;/code&gt; 提供的 &lt;code&gt;BeanUtils&lt;/code&gt;。究其原因，更多都是因为它方便，好使。&lt;/p&gt;\n&lt;p&gt;但是大家都知道cglib的 &lt;code&gt;BeanCopier&lt;/code&gt; 通过字节码技术，在大多数没有Converter的情况下，拷贝效率更高。只是因为每次使用都得&lt;code&gt;BeanCopier.create&lt;/code&gt;，创建一个BeanCopier对象，麻烦，代码还不好看。&lt;/p&gt;\n&lt;p&gt;因此，就有了这个工具类。使用和Spring工具包一样的代码（重载方法甚至比Spring的更丰富），获得更好的效率。实现中通过对&lt;code&gt;BeanCopier&lt;/code&gt;对象的一个Map缓存，会使得其效率更高一丢丢。&lt;/p&gt;\n&lt;p&gt;至于具体的速度对比，网上有很多的实例，我也不做对比测试了。代码如下，如有欠缺的地方，希望留言指正，不胜感激。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\nimport com.google.common.collect.Maps;\nimport lombok.experimental.UtilityClass;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.cglib.beans.BeanCopier;\nimport org.springframework.cglib.core.Converter;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * @author imyzt\n * @date 2020/01/15\n * @description bean拷贝缓存工具类\n * 合理使用, 注意Map大小\n */\n@UtilityClass\n@Slf4j\npublic class BeanCopierUtils {\n\n    private static final Map&amp;lt;String, BeanCopier&amp;gt; BEAN_COPIER_MAP = Maps.newConcurrentMap();\n\n    /**\n     * 使用BeanCopier拷贝对象属性\n     * 1. target不能使用链式调用 {@link lombok.experimental.Accessors#chain}\n     * 2. 只会拷贝source,target属性类型和名称完全一致的字段\n     * @param source 源\n     * @param target 目标\n     * @param useCache 是否使用缓存\n     * @param converter converter对象\n     * @param &amp;lt;S&amp;gt; 源对象泛型\n     * @param &amp;lt;T&amp;gt; 目标对象泛型\n     * @return 返回target对象\n     */\n    public &amp;lt;S, T&amp;gt; T copy(S source, T target, boolean useCache, Converter converter) {\n\n        requireNonNull(source, target);\n        boolean useConverter = Objects.nonNull(converter);\n\n        Class&amp;lt;?&amp;gt; targetClass = target.getClass();\n\n        String key = getKey(source, targetClass);\n\n        BeanCopier beanCopier = getBeanCopier(useCache, key, createBeanCopier(source, targetClass, useConverter));\n        beanCopier.copy(source, target, converter);\n        return target;\n    }\n\n    /**\n     * 使用BeanCopier拷贝对象属性\n     * 1. target不能使用链式调用 {@link lombok.experimental.Accessors#chain}\n     * 2. 只会拷贝source,target属性类型和名称完全一致的字段\n     * @param source 源\n     * @param targetClass 目标类对象\n     * @param useCache 是否使用缓存\n     * @param converter converter对象\n     * @param &amp;lt;S&amp;gt; 源对象泛型\n     * @param &amp;lt;T&amp;gt; 目标对象泛型\n     * @return 返回target对象\n     */\n    public &amp;lt;S, T&amp;gt; T copy(S source, Class&amp;lt;T&amp;gt; targetClass, boolean useCache, Converter converter) {\n\n        requireNonNull(source, targetClass);\n        boolean useConverter = Objects.nonNull(converter);\n\n        String key = getKey(source, targetClass);\n\n        BeanCopier beanCopier = getBeanCopier(useCache, key, createBeanCopier(source, targetClass, useConverter));\n\n        T instance;\n        try {\n            instance = targetClass.getDeclaredConstructor().newInstance();\n        } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {\n            throw new IllegalArgumentException();\n        }\n        beanCopier.copy(source, instance, converter);\n        return instance;\n    }\n\n    private static BeanCopier getBeanCopier(boolean useCache, String key, BeanCopier beanCopier2) {\n        BeanCopier beanCopier;\n        if (useCache) {\n            beanCopier = BEAN_COPIER_MAP.computeIfAbsent(key, k -&amp;gt; beanCopier2);\n        } else {\n            beanCopier = beanCopier2;\n        }\n        return beanCopier;\n    }\n\n    private static &amp;lt;S&amp;gt; void requireNonNull(S source, Object targetClass) {\n        Objects.requireNonNull(source, &amp;quot;源对象不能为空&amp;quot;);\n        Objects.requireNonNull(targetClass, &amp;quot;目标对象不能为空&amp;quot;);\n    }\n\n    public &amp;lt;S, T&amp;gt; T copy(S source, T target) {\n        return copy(source, target, true, null);\n    }\n\n    public &amp;lt;S, T&amp;gt; T copy(S source, Class&amp;lt;T&amp;gt; targetClass) {\n        return copy(source, targetClass, true, null);\n    }\n\n    public &amp;lt;S, T&amp;gt; T copy(S source, Class&amp;lt;T&amp;gt; targetClass, boolean useCache) {\n        return copy(source, targetClass, useCache, null);\n    }\n\n    public &amp;lt;S, T&amp;gt; T copy(S source, Class&amp;lt;T&amp;gt; targetClass, Converter converter) {\n        return copy(source, targetClass, true, converter);\n    }\n\n    public &amp;lt;S, T&amp;gt; T copy(S source, T target, boolean useCache) {\n        return copy(source, target, useCache, null);\n    }\n\n    public &amp;lt;S, T&amp;gt; T copy(S source, T target, Converter converter) {\n        return copy(source, target, true, converter);\n    }\n\n    private static &amp;lt;S, T&amp;gt; BeanCopier createBeanCopier(S source, Class&amp;lt;T&amp;gt; target, boolean useConverter) {\n        return BeanCopier.create(source.getClass(), target, useConverter);\n    }\n\n    private static &amp;lt;S, T&amp;gt; String getKey(S source, Class&amp;lt;T&amp;gt; targetClass) {\n        return source.getClass().getName() + &amp;quot;:&amp;quot; + targetClass.getName();\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在使用时，有两点需要注意的地方：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;target不能使用lombok等工具的链式调用，只有符合标准的set方法，cglib才会调用赋值。&lt;/li&gt;\n&lt;li&gt;只会拷贝source，target类型和名称完全一致的属性。&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;beancopier-de-gong-ju-lei&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;BeanCopier的工具类&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-04-15 22:01:29&#34;,&#34;dateFormat&#34;:&#34;2020-04-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/beancopier-de-gong-ju-lei/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:256000,&#34;words&#34;:876,&#34;minutes&#34;:5},&#34;description&#34;:&#34;平时对象参数拷贝时，顺手使用的都是Spring 提供的 BeanUtils。究其原因，更多都是因为它方便，好使。\n但是大家都知道cglib的 BeanCopier 通过字节码技术，在大多数没有Converter的情况下，拷贝效率更高。只是因...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;mybatis 在type表达式中，如果是内部类，不能通过 Class.InnerClass 指定，需要通过 Class$InnerClass 指定，不然会报ClassNotFound。&lt;/p&gt;\n&lt;p&gt;错误堆栈&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Caused by: java.lang.ClassNotFoundException: Cannot find class: Class.InnerClass\n\tat org.apache.ibatis.io.ClassLoaderWrapper.classForName(ClassLoaderWrapper.java:200)\n\tat org.apache.ibatis.io.ClassLoaderWrapper.classForName(ClassLoaderWrapper.java:89)\n\tat org.apache.ibatis.io.Resources.classForName(Resources.java:261)\n\tat org.apache.ibatis.type.TypeAliasRegistry.resolveAlias(TypeAliasRegistry.java:116)\n\t... 104 common frames omitted\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;具体的产生原因通过报错信息，发现是&lt;code&gt;org.apache.ibatis.type.TypeAliasRegistry#resolveAlias&lt;/code&gt;方法抛出的异常&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/04/5bdfpl20vcj4tp687qmbh2m8sm.png\&#34; alt=\&#34;resolveAlias\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;通过继续往里面走，发现是&lt;code&gt;org.apache.ibatis.io.ClassLoaderWrapper#classForName(java.lang.String, java.lang.ClassLoader[])&lt;/code&gt;方法内部使用&lt;code&gt;java.lang.Class#forName&lt;/code&gt;加载的类，&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/04/r6o46ekjhah0tpgif4a3mj9f0u.png\&#34; alt=\&#34;classForName\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;而Java的内部类在编译之后，都会以&lt;code&gt;Class$InnerClass&lt;/code&gt;的形式进行保存字节码文件，所以说为什么使用 &lt;code&gt;.&lt;/code&gt; 会抛出ClassNotFound，因为mybatis最终底层还是使用的Java提供的类加载工具进行累的加载的。&lt;/p&gt;\n&lt;p&gt;通过对内部类进行&lt;code&gt;javac&lt;/code&gt; 我们可以看到一个类编译之后的状态。&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/04/vdtmipks0ig1kq01bjagt6i1ra.png\&#34; alt=\&#34;javac\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mybatis-yu-fa-jiu-cuo&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Mybatis 语法纠错&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-04-15 20:47:44&#34;,&#34;dateFormat&#34;:&#34;2020-04-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mybatis-yu-fa-jiu-cuo/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:65000,&#34;words&#34;:250,&#34;minutes&#34;:2},&#34;description&#34;:&#34;mybatis 在type表达式中，如果是内部类，不能通过 Class.InnerClass 指定，需要通过 Class$InnerClass 指定，不然会报ClassNotFound。\n错误堆栈\nCaused by: java.lang....&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;知识点\&#34;&gt;知识点&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;innodb不支持全文检索&lt;/li&gt;\n&lt;li&gt;between包含左右边界&lt;br&gt;\n3.UPDATE IGNORE 用于在更新多行时，某一行报错不影响其他行&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-zhi-shi-dian&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL知识点&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-03-16 22:38:27&#34;,&#34;dateFormat&#34;:&#34;2020-03-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-zhi-shi-dian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:8000,&#34;words&#34;:40,&#34;minutes&#34;:1},&#34;description&#34;:&#34;知识点\n\ninnodb不支持全文检索\nbetween包含左右边界\n3.UPDATE IGNORE 用于在更新多行时，某一行报错不影响其他行\n\n&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9F%A5%E8%AF%86%E7%82%B9\&#34;&gt;知识点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;MySQL的regexp与LIKE语句非常类似，大部分功能都可以相互替补。之前一直没有使用过，最近在阅读《MySQL必知必会》第九章时，看到了这个内容，在此做下笔记记录一下。&lt;/p&gt;\n&lt;p&gt;在此之前，首先建立对应的数据表，ddl与dml如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;create table if not exists test_db.products\n(\n\tid int auto_increment\n\t\tprimary key,\n\tprod_name varchar(20) not null\n);\n\nINSERT INTO test_db.products (id, prod_name) VALUES (1, &#39;JetPack 1000&#39;);\nINSERT INTO test_db.products (id, prod_name) VALUES (2, &#39;JetPack 2000&#39;);\nINSERT INTO test_db.products (id, prod_name) VALUES (3, &#39;1 ton anvil&#39;);\nINSERT INTO test_db.products (id, prod_name) VALUES (4, &#39;2 ton anvil&#39;);\nINSERT INTO test_db.products (id, prod_name) VALUES (5, &#39;TNT (1 stick)&#39;);\nINSERT INTO test_db.products (id, prod_name) VALUES (6, &#39;.5 ton anvil&#39;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2020/03/tcfrq33pfoi12o2lsjkr76m906.png\&#34; alt=\&#34;请输入图片描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;常用指令\&#34;&gt;常用指令&lt;/h1&gt;\n&lt;p&gt;由于regexp与LIKE的高度相似性，所以学习时以常用的LIKE的指令作为对比学习，有助于记忆。&lt;/p&gt;\n&lt;h2 id=\&#34;基本字符匹配\&#34;&gt;基本字符匹配&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;全文字匹配&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;select *\nfrom products\nwhere prod_name regexp &#39;1000&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2020/03/to3pl4isoehleqolviqulqs4tu.png\&#34; alt=\&#34;请输入图片描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;模糊匹配&lt;br&gt;\n类似于LIKE语句的 &#39;_&#39;（下划线）单字符匹配。模糊匹配单个字符。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;select *\nfrom products\nwhere prod_name regexp &#39;.000&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2020/03/0lv9oi93oegtoo3pm936ms8tfa.png\&#34; alt=\&#34;请输入图片描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;or-匹配\&#34;&gt;OR 匹配&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;select *\nfrom products\nwhere prod_name regexp &#39;1000|2000&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2020/03/7eovvhgj8kh5arqfvblopof7qu.png\&#34; alt=\&#34;请输入图片描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;匹配几个字符之一\&#34;&gt;匹配几个字符之一&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;正确用法&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;select *\nfrom products\nwhere prod_name regexp &#39;[123] ton&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2020/03/tgh3m7dhtuhogoprg59jagi7ke.png\&#34; alt=\&#34;请输入图片描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;错误示例&lt;br&gt;\n正则表达式可以用 &lt;code&gt;[]&lt;/code&gt; 包含内容或者 &lt;code&gt;|&lt;/code&gt; 竖线 表示 &lt;code&gt;或&lt;/code&gt;，但如果使用下面的用法，不能获得正确的结果，因为在最后一个&#39;或&#39;时，MySQL会理解成 &lt;code&gt;3 ton&lt;/code&gt;。得到不同的结果。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;select *\nfrom products\nwhere prod_name regexp &#39;1|2|3 ton&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2020/03/vh736s4prohc8q3e1rah515rci.png\&#34; alt=\&#34;请输入图片描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;匹配范围\&#34;&gt;匹配范围&lt;/h2&gt;\n&lt;h2 id=\&#34;匹配特殊字符\&#34;&gt;匹配特殊字符&lt;/h2&gt;\n&lt;h2 id=\&#34;匹配字符类\&#34;&gt;匹配字符类&lt;/h2&gt;\n&lt;h2 id=\&#34;匹配多个实例\&#34;&gt;匹配多个实例&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-regexp-shi-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL REGEXP 使用&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-03-15 17:28:38&#34;,&#34;dateFormat&#34;:&#34;2020-03-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-regexp-shi-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:99000,&#34;words&#34;:380,&#34;minutes&#34;:2},&#34;description&#34;:&#34;前言\nMySQL的regexp与LIKE语句非常类似，大部分功能都可以相互替补。之前一直没有使用过，最近在阅读《MySQL必知必会》第九章时，看到了这个内容，在此做下笔记记录一下。\n在此之前，首先建立对应的数据表，ddl与dml如下：\ncr...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4\&#34;&gt;常用指令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D\&#34;&gt;基本字符匹配&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#or-%E5%8C%B9%E9%85%8D\&#34;&gt;OR 匹配&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%B9%E9%85%8D%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B9%8B%E4%B8%80\&#34;&gt;匹配几个字符之一&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4\&#34;&gt;匹配范围&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%B9%E9%85%8D%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6\&#34;&gt;匹配特殊字符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB\&#34;&gt;匹配字符类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B\&#34;&gt;匹配多个实例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;merge\&#34;&gt;merge&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;git merge就是合并，指定一个 commit 或者 branch，将其合并到当前 branch 或 commit 来。&lt;/li&gt;\n&lt;li&gt;从 &lt;code&gt;目标commit&lt;/code&gt; 和 &lt;code&gt;当前commit&lt;/code&gt; 的&lt;strong&gt;分叉点起&lt;/strong&gt;，将 &lt;code&gt;目标commit&lt;/code&gt; 上的 &lt;code&gt;所有commit&lt;/code&gt; 一并合并到 &lt;code&gt;当前commit&lt;/code&gt;，并&lt;code&gt;自动生成一个新的commit&lt;/code&gt;。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1581992793896.gif\&#34; alt=\&#34;git merge 示意图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;center&gt;图 - git merge 示意图&lt;/center&gt;\n&lt;h3 id=\&#34;特殊情况如何处理\&#34;&gt;特殊情况，如何处理&lt;/h3&gt;\n&lt;h5 id=\&#34;放弃合并\&#34;&gt;放弃合并&lt;/h5&gt;\n&lt;p&gt;当前处于解决冲突的中间状态， 通过 &lt;code&gt;git merge --abort&lt;/code&gt; 取消合并，回到merge之前的状态。&lt;/p&gt;\n&lt;h5 id=\&#34;head领先于当前commit\&#34;&gt;HEAD领先于当前commit&lt;/h5&gt;\n&lt;p&gt;即&lt;strong&gt;合并之前的commit&lt;/strong&gt;，这是一个无意义操作，Git什么也不会做。空merge。&lt;/p&gt;\n&lt;h5 id=\&#34;head落后于当前commit快速前移\&#34;&gt;HEAD落后于当前commit（快速前移）&lt;/h5&gt;\n&lt;ol&gt;\n&lt;li&gt;在没有其它分支的情况下，Git会把HEAD指向的branch移动到目标commit。&lt;/li&gt;\n&lt;li&gt;当前在HEAD指向master分支，执行 &lt;code&gt;git merge feature1&lt;/code&gt; 后的操作如下图所示：&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1581993447297.gif\&#34; alt=\&#34;合并领先于HEAD的commit\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;center&gt;图 - 合并领先于HEAD的commit&lt;/center&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;专有名词 - （快速前移）&lt;br&gt;\n在 &lt;code&gt;git pull&lt;/code&gt; 经常出现，比如当前master分支本地没有更新，同事推送了新的commit到远程仓库，那么在执行 &lt;code&gt;git pull&lt;/code&gt; 时，&lt;strong&gt;目标commit（远程仓库最新commit）&lt;/strong&gt; 领先于 &lt;strong&gt;当前commit（本地commit）&lt;/strong&gt;，&lt;strong&gt;HEAD会携带本地master分支快速前移&lt;/strong&gt;。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1581994083140.gif\&#34; alt=\&#34;git pull 实现原理\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;center&gt;图 - git pull 实现原理&lt;/center&gt;\n&lt;h2 id=\&#34;add\&#34;&gt;add&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;添加的是文件改动，而不是文件&lt;/strong&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;log\&#34;&gt;log&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;git log -p[--patch]&lt;/code&gt; 查看具体到每个commit的改动细节。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;git log --stat&lt;/code&gt; 查看每个commit改动的文件。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;git show [commitId] [filePath]&lt;/code&gt; 查看当前commit的改动细节（精确到文件）。&lt;/li&gt;\n&lt;li&gt;对比\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;git diff&lt;/code&gt; 查看当前工作区与暂存区的区别。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;git diff --staged[--cached]&lt;/code&gt; 查看当前暂存区与上一条commit的区别。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;git diff HEAD&lt;/code&gt; 查看当前工作区与上一条commit的区别。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;本章命令总结\&#34;&gt;本章命令总结&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;git merge commit/branch&lt;/code&gt; 合并某个提交或分支&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;git merge --abort&lt;/code&gt; 放弃当前合并&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;git add .&lt;/code&gt; 添加某个文件改动到git暂存区&lt;/li&gt;\n&lt;li&gt;git log 的详细操作 &lt;a href=\&#34;#log\&#34;&gt;git log&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;引用声明\&#34;&gt;引用声明&lt;/h2&gt;\n&lt;p&gt;本文内容来自&lt;a href=\&#34;https://juejin.im/book/5a124b29f265da431d3c472e\&#34;&gt;掘金小册-Git 原理详解及实用指南&lt;/a&gt;的学习笔记内容，图片等均来自原作者。此处只作为笔记记录。&lt;br&gt;\n请支持原作者&lt;img src=\&#34;https://imyzt.top/post-images/1581900705687.png\&#34; alt=\&#34;购买信息\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;git-yuan-li-xiang-jie-ji-shi-yong-zhi-nan-mergeaddlog&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Git 原理详解及实用指南 - merge，add，log&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Git 原理详解及实用指南&#34;,&#34;slug&#34;:&#34;Z2IdH6vis&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/Z2IdH6vis/&#34;}],&#34;date&#34;:&#34;2020-02-18 10:04:17&#34;,&#34;dateFormat&#34;:&#34;2020-02-18&#34;,&#34;feature&#34;:&#34;https://imyzt.top/post-images/git-yuan-li-xiang-jie-ji-shi-yong-zhi-nan-mergeaddlog.gif&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/git-yuan-li-xiang-jie-ji-shi-yong-zhi-nan-mergeaddlog/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:119000,&#34;words&#34;:522,&#34;minutes&#34;:2},&#34;description&#34;:&#34;merge\n\ngit merge就是合并，指定一个 commit 或者 branch，将其合并到当前 branch 或 commit 来。\n从 目标commit 和 当前commit 的分叉点起，将 目标commit 上的 所有commit...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#merge\&#34;&gt;merge&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86\&#34;&gt;特殊情况，如何处理&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%BE%E5%BC%83%E5%90%88%E5%B9%B6\&#34;&gt;放弃合并&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#head%E9%A2%86%E5%85%88%E4%BA%8E%E5%BD%93%E5%89%8Dcommit\&#34;&gt;HEAD领先于当前commit&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#head%E8%90%BD%E5%90%8E%E4%BA%8E%E5%BD%93%E5%89%8Dcommit%E5%BF%AB%E9%80%9F%E5%89%8D%E7%A7%BB\&#34;&gt;HEAD落后于当前commit（快速前移）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#add\&#34;&gt;add&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#log\&#34;&gt;log&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E7%AB%A0%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93\&#34;&gt;本章命令总结&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%95%E7%94%A8%E5%A3%B0%E6%98%8E\&#34;&gt;引用声明&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;head\&#34;&gt;HEAD&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;HEAD永远指向当前commit，每个仓库只有一个HEAD，每次提交之后都会向前移动到最新的commit。&lt;/li&gt;\n&lt;li&gt;远程分支HEAD永远指向默认分支（master）。&lt;/li&gt;\n&lt;li&gt;HEAD是Git中独特的引用，它是唯一的。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;branch\&#34;&gt;Branch&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;也是一类引用，HEAD除了直接指向commit之外，也可以&lt;strong&gt;通过指向branch间接指向commit&lt;/strong&gt;。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1581900294211.gif\&#34; alt=\&#34;HEAD通过Branch间接指向Commit\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;center&gt; 图 - HEAD通过Branch间接指向Commit &lt;/center&gt;  \n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;当HEAD指向branch，发生commit时，HEAD会带着branch一起移动。如下图（HEAD携带feature1一起移动。）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1581899709600.gif\&#34; alt=\&#34;HEAD移动示意图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;center&gt; 图 - HEAD移动示意图 &lt;/center&gt;  \n&lt;h2 id=\&#34;push\&#34;&gt;Push&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;将当前 &lt;code&gt;branch&lt;/code&gt; 提交到远程仓库，并将当前 &lt;code&gt;branch&lt;/code&gt; 的所有 &lt;code&gt;commit&lt;/code&gt; 也提交到远程分支。&lt;/li&gt;\n&lt;li&gt;push时，如果是远程仓库不存在的分支，需要指定名称，&lt;code&gt;git push origin branch_name&lt;/code&gt;, 或者通过修改 &lt;code&gt;git config&lt;/code&gt; 的 &lt;code&gt;push.default&lt;/code&gt; 来指定推送时默认分支。&lt;/li&gt;\n&lt;li&gt;push之后上传分支，并不会上传 &lt;code&gt;HEAD&lt;/code&gt;, 远程仓库的 &lt;code&gt;HEAD&lt;/code&gt; 永远指向默认分支（master）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;master\&#34;&gt;master&lt;/h2&gt;\n&lt;p&gt;master是Git中默认的branch，它与其他branch的区别在于：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;新建仓库中第一个commit会被master自动指向。&lt;/li&gt;\n&lt;li&gt;在git clone时，会自动checkout到master（HEAD指向master分支，间接指向master分支的commit）。&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1581900572282.gif\&#34; alt=\&#34;克隆远程仓库流程\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;center&gt; 图 - 克隆远程仓库流程 &lt;/center&gt;  \n&lt;h2 id=\&#34;branch的基本操作\&#34;&gt;branch的基本操作&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;创建： git branch 名称，或 git checkout -b 名称&lt;/li&gt;\n&lt;li&gt;切换：git checkout 名称&lt;/li&gt;\n&lt;li&gt;删除：git branch -d/-D 名称，-D强制删除&lt;/li&gt;\n&lt;li&gt;推送：git push [origin branch_name]，将本地分支推送到远程仓库对应分支&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;本章命令总结\&#34;&gt;本章命令总结&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;git log 查看提交日志&lt;/li&gt;\n&lt;li&gt;git branch &lt;a href=\&#34;#branch%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\&#34;&gt;branch的基本操作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;git commit 提交代码到本地仓库&lt;/li&gt;\n&lt;li&gt;git checkout branch_name 切换分支&lt;/li&gt;\n&lt;li&gt;git clone origin_url 克隆远程仓库到本地仓库&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;git branch、HEAD都是围绕着commit走的；&lt;/li&gt;\n&lt;li&gt;git push的本质是将 &lt;code&gt;当前branch&lt;/code&gt; 位置的（commit）上传到远程仓库，并将它的commit一并提交。&lt;/li&gt;\n&lt;li&gt;HEAD，Branch都是引用，引用的本质就是一个字符串，可以是&lt;strong&gt;一个commit的SHA-1码&lt;/strong&gt;，也可以是&lt;strong&gt;一个branch的branch名&lt;/strong&gt;。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;引用声明\&#34;&gt;引用声明&lt;/h2&gt;\n&lt;p&gt;本文内容来自&lt;a href=\&#34;https://juejin.im/book/5a124b29f265da431d3c472e\&#34;&gt;掘金小册-Git 原理详解及实用指南&lt;/a&gt;的学习笔记内容，图片等均来自原作者。此处只作为笔记记录。&lt;br&gt;\n请支持原作者&lt;img src=\&#34;https://imyzt.top/post-images/1581900705687.png\&#34; alt=\&#34;购买信息\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;git-yuan-li-xiang-jie-ji-shi-yong-zhi-nan-headbranch&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Git 原理详解及实用指南 - HEAD，branch，push&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Git 原理详解及实用指南&#34;,&#34;slug&#34;:&#34;Z2IdH6vis&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/Z2IdH6vis/&#34;}],&#34;date&#34;:&#34;2020-02-17 08:25:11&#34;,&#34;dateFormat&#34;:&#34;2020-02-17&#34;,&#34;feature&#34;:&#34;https://imyzt.top/post-images/git-yuan-li-xiang-jie-ji-shi-yong-zhi-nan-headbranch.png&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/git-yuan-li-xiang-jie-ji-shi-yong-zhi-nan-headbranch/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:123000,&#34;words&#34;:542,&#34;minutes&#34;:3},&#34;description&#34;:&#34;HEAD\n\nHEAD永远指向当前commit，每个仓库只有一个HEAD，每次提交之后都会向前移动到最新的commit。\n远程分支HEAD永远指向默认分支（master）。\nHEAD是Git中独特的引用，它是唯一的。\n\nBranch\n\n也是一...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#head\&#34;&gt;HEAD&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#branch\&#34;&gt;Branch&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#push\&#34;&gt;Push&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#master\&#34;&gt;master&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#branch%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\&#34;&gt;branch的基本操作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E7%AB%A0%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93\&#34;&gt;本章命令总结&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%95%E7%94%A8%E5%A3%B0%E6%98%8E\&#34;&gt;引用声明&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;工具包\&#34;&gt;工具包&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;http://ifeve.com/google-guava/\&#34;&gt;Google Guava&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.hutool.cn/docs/\&#34;&gt;HuTool&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;http://ifeve.com/apache-common/\&#34;&gt;Apache Commons(这玩意估计没人不知道了。)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;工具类\&#34;&gt;工具类&lt;/h1&gt;\n&lt;h2 id=\&#34;antpathmatcher\&#34;&gt;AntPathMatcher&lt;/h2&gt;\n&lt;p&gt;作用：URL路径匹配&lt;/p&gt;\n&lt;p&gt;？匹配一个字符&lt;br&gt;\n*匹配0个或多个字符&lt;br&gt;\n**匹配0个或多个目录&lt;/p&gt;\n&lt;h2 id=\&#34;stopwatch\&#34;&gt;StopWatch&lt;/h2&gt;\n&lt;p&gt;作用：方法耗时计算&lt;/p&gt;\n&lt;p&gt;该类Spring和Guava都有提供，用法大同小异&lt;/p&gt;\n&lt;h2 id=\&#34;beancopier\&#34;&gt;BeanCopier&lt;/h2&gt;\n&lt;p&gt;作用：拷贝bean&lt;/p&gt;\n&lt;p&gt;比Apache和Spring提供的BeanUtils效率好点&lt;/p&gt;\n&lt;p&gt;注意点：&lt;br&gt;\n该方法与lombok提供的&lt;code&gt;@Accessors(chain = true)&lt;/code&gt;注解冲突，在cglib最底层target调用set方法进行参数设置的时候，判断了set方法返回值是否为void，不为void不会进行赋值操作。&lt;br&gt;\n解决方法有2：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;去掉&lt;code&gt;@Accessors(chain = true)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;使用org.springframework.beans.BeanUtils&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;java-kai-fa-gong-ju-tui-jian&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java开发工具推荐&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java developer&#34;,&#34;slug&#34;:&#34;Lix1FDBfB&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/Lix1FDBfB/&#34;}],&#34;date&#34;:&#34;2020-01-20 17:42:36&#34;,&#34;dateFormat&#34;:&#34;2020-01-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-kai-fa-gong-ju-tui-jian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:38000,&#34;words&#34;:169,&#34;minutes&#34;:1},&#34;description&#34;:&#34;工具包\n\nGoogle Guava\nHuTool\nApache Commons(这玩意估计没人不知道了。)\n\n工具类\nAntPathMatcher\n作用：URL路径匹配\n？匹配一个字符\n*匹配0个或多个字符\n**匹配0个或多个目录\nStop...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E5%85%B7%E5%8C%85\&#34;&gt;工具包&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E5%85%B7%E7%B1%BB\&#34;&gt;工具类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#antpathmatcher\&#34;&gt;AntPathMatcher&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#stopwatch\&#34;&gt;StopWatch&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#beancopier\&#34;&gt;BeanCopier&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;事出有因\&#34;&gt;事出有因&lt;/h1&gt;\n&lt;p&gt;今天遇到一个mybatis语法的bug，在此记录一下。&lt;/p&gt;\n&lt;p&gt;业务是前台有一个跟进状态的筛选按钮，与前台约定的参数是Integer类型的0-4, 标志不同的状态，根据不同的参数做不同的过滤。mybatis的语法如下。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;lt;if test=&amp;quot;query.followStatus != null and query.followStatus != &#39;&#39;&amp;quot;&amp;gt;\n    &amp;lt;choose&amp;gt;\n        &amp;lt;!--未跟进--&amp;gt;\n        &amp;lt;when test=&amp;quot;query.followStatus == 0&amp;quot;&amp;gt;\n            AND scfu.id IS NULL\n        &amp;lt;/when&amp;gt;\n        &amp;lt;!--未选择意向--&amp;gt;\n        &amp;lt;when test=&amp;quot;query.followStatus == 4&amp;quot;&amp;gt;\n            AND scfu.intention IS NULL AND scfu.id IS NOT NULL\n        &amp;lt;/when&amp;gt;\n        &amp;lt;!--1,2,3的情况--&amp;gt;\n        &amp;lt;otherwise&amp;gt;\n            AND scfu.intention = #{query.followStatus}\n        &amp;lt;/otherwise&amp;gt;\n    &amp;lt;/choose&amp;gt;\n&amp;lt;/if&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;今天客户反馈了一个bug，该筛选项在前台选中&lt;strong&gt;未跟进&lt;/strong&gt;时，会出现筛选项无效的情况。也就是第一行 &lt;code&gt;if test&lt;/code&gt; 都没有进去，因为进去了的话，最起码什么都不符合的情况都会进入 &lt;code&gt;otherwise&lt;/code&gt; ，所以定位到问题出现在外层 &lt;code&gt;if&lt;/code&gt;。通过搜索发现有人遇到过相似的问题。&lt;/p&gt;\n&lt;h1 id=\&#34;解决方案\&#34;&gt;解决方案&lt;/h1&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.cnblogs.com/EasonJim/p/8075311.html\&#34;&gt;MyBatis参数为Integer型并赋值为0时判断失误的问题解决&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;根据这位博主介绍，mybatis的test语法，在类型为&lt;code&gt;Integer&lt;/code&gt;时，如果值为&lt;code&gt;0&lt;/code&gt;, 会被识别为 &lt;code&gt;&#39;&#39;&lt;/code&gt;(空)， 导致第一个if的后一部分 &lt;code&gt;query.followStatus != &#39;&#39;&lt;/code&gt; 不符合。最终没有进入 &lt;code&gt;if&lt;/code&gt; 的逻辑。解决方法上面的博主已经给出了，我再此贴一下&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;通过or进行二次判断&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;&amp;lt;if test=&amp;quot;status !=null and (status!=&#39;&#39; or status == 0)&amp;quot;&amp;gt;\n    业务逻辑\n&amp;lt;/if&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;对Integer类型去除 != &#39;&#39; 的判断&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;后记\&#34;&gt;后记&lt;/h1&gt;\n&lt;p&gt;另一个常出现的问题，test语法中，布尔值比较需要用 &lt;code&gt;bool == true&lt;/code&gt; 的语法判断，说明：bool（一个布尔值变量）&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mybatis-xml-test-yu-fa-bug&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Mybatis XML test语法bug&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-12-11 11:27:52&#34;,&#34;dateFormat&#34;:&#34;2019-12-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mybatis-xml-test-yu-fa-bug/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:110000,&#34;words&#34;:445,&#34;minutes&#34;:2},&#34;description&#34;:&#34;事出有因\n今天遇到一个mybatis语法的bug，在此记录一下。\n业务是前台有一个跟进状态的筛选按钮，与前台约定的参数是Integer类型的0-4, 标志不同的状态，根据不同的参数做不同的过滤。mybatis的语法如下。\n&amp;lt;if te...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8B%E5%87%BA%E6%9C%89%E5%9B%A0\&#34;&gt;事出有因&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\&#34;&gt;解决方案&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E8%AE%B0\&#34;&gt;后记&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;问题点\&#34;&gt;问题点&lt;/h1&gt;\n&lt;p&gt;Spring默认开启了地址的严格匹配，比如 localhost:8080/api/article/{aid} 能正确访问，但是 localhost:8080**/**/api/article/{aid} 就会造成访问404&lt;/p&gt;\n&lt;h1 id=\&#34;解决方案\&#34;&gt;解决方案&lt;/h1&gt;\n&#34;,&#34;fileName&#34;:&#34;springboot-guan-bi-di-zhi-yan-ge-pi-pei&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;SpringBoot 关闭地址严格匹配&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-11-21 17:03:50&#34;,&#34;dateFormat&#34;:&#34;2019-11-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/springboot-guan-bi-di-zhi-yan-ge-pi-pei/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:11000,&#34;words&#34;:46,&#34;minutes&#34;:1},&#34;description&#34;:&#34;问题点\nSpring默认开启了地址的严格匹配，比如 localhost:8080/api/article/{aid} 能正确访问，但是 localhost:8080**/**/api/article/{aid} 就会造成访问404\n解决方案...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E7%82%B9\&#34;&gt;问题点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\&#34;&gt;解决方案&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;ul&gt;\n&lt;li&gt;.ignore&lt;/li&gt;\n&lt;li&gt;AceJump&lt;/li&gt;\n&lt;li&gt;P3C&lt;/li&gt;\n&lt;li&gt;BaseSupport&lt;/li&gt;\n&lt;li&gt;CamelCase&lt;/li&gt;\n&lt;li&gt;CodeGlance&lt;/li&gt;\n&lt;li&gt;FindBugs-IDEA&lt;/li&gt;\n&lt;li&gt;GsonFormat&lt;/li&gt;\n&lt;li&gt;IdeaVim&lt;/li&gt;\n&lt;li&gt;jrebel-mybatisplus-extension&lt;/li&gt;\n&lt;li&gt;Jrebel&lt;/li&gt;\n&lt;li&gt;Key Promoter X&lt;/li&gt;\n&lt;li&gt;Lombok&lt;/li&gt;\n&lt;li&gt;Maven Helper&lt;/li&gt;\n&lt;li&gt;MybaticCodeHelperPro&lt;/li&gt;\n&lt;li&gt;Nyan Progress Bar&lt;/li&gt;\n&lt;li&gt;POJO TO JSON&lt;/li&gt;\n&lt;li&gt;RestfulToolKit&lt;/li&gt;\n&lt;li&gt;SonarLint&lt;/li&gt;\n&lt;li&gt;Translation&lt;/li&gt;\n&lt;li&gt;Rainbow Brackets&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;idea-cha-jian-lie-biao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;idea 插件列表&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-11-12 09:26:09&#34;,&#34;dateFormat&#34;:&#34;2019-11-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/idea-cha-jian-lie-biao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:12000,&#34;words&#34;:32,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n.ignore\nAceJump\nP3C\nBaseSupport\nCamelCase\nCodeGlance\nFindBugs-IDEA\nGsonFormat\nIdeaVim\njrebel-mybatisplus-extension\nJreb...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;随着业务发展，数据库单表量将会持续增长，当增长到一定大小，是需要对应的处理以解决数据查询越来越慢的问题的。&lt;br&gt;\n一般的扩展方案分为两种，一种是&lt;strong&gt;垂直扩展&lt;/strong&gt;，即增大单机的配置。  另一种则是&lt;strong&gt;水平扩展&lt;/strong&gt;，是将任务分配到多台计算机上。&lt;/p&gt;\n&lt;p&gt;我们的应用系统使用的是SpringBoot+Mybatis-Plus的搭配，由于分表业务比较简单，就没有使用插件，而是使用Mybatis-Plus提供的 &lt;code&gt;DynamicTableNameParser &lt;/code&gt; 处理器直接在程序中做动态路由。&lt;br&gt;\n由于官方文档在此处描述的并不是特别详细，所以写这篇博客作为记录。&lt;/p&gt;\n&lt;h1 id=\&#34;开发\&#34;&gt;开发&lt;/h1&gt;\n&lt;p&gt;分表策略就不在此做说明了，网上已经有非常多不同的处理方式了，在这里主要阐述怎么样使用Mybatis-Plus提供的 &lt;code&gt;ITableNameHandler &lt;/code&gt;  接口将不同表的做出不同处理。&lt;/p&gt;\n&lt;h2 id=\&#34;实现-itablenamehandler-接口\&#34;&gt;实现 ITableNameHandler 接口&lt;/h2&gt;\n&lt;p&gt;首先我们需要实现 &lt;code&gt;ITableNameHandler&lt;/code&gt; 接口，该接口有两个方法(process, dynamicTableName)，process()方法是做表名SQL处理的，该方法有默认实现，它依赖于dynamicTableName()方法，所以我们需要重写的方法便是dynamicTableName()方法&lt;br&gt;\ndynamicTableName()方法有三个入参，metaObject包括了元数据对象，sql是我们即将要执行的SQL，tableName则是我们执行的SQL表名称。我们需要修改的便是tableName。&lt;br&gt;\n下方我的代码逻辑是从DaysContext上下文对象中拿到事先设置的表名动态规则生成的表后缀，拼接上tableName便是我们需要动态路由的表名称了。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Component\npublic class MyDynamicTableNameParser implements ITableNameHandler {\n\n    @Override\n    public String dynamicTableName(MetaObject metaObject, String sql, String tableName) {\n\n        DaysContext.Days days = DaysContext.get();\n\n        // 加上分表逻辑后缀\n        return tableName + &amp;quot;_&amp;quot; + days.getTableSuffix();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;将配置注入到mybatis-plus配置中\&#34;&gt;将配置注入到Mybatis-Plus配置中&lt;/h2&gt;\n&lt;p&gt;接下来需要将我们的动态表名处理器 &lt;code&gt;MyDynamicTableNameParser&lt;/code&gt; 配置到 &lt;code&gt;PaginationInterceptor&lt;/code&gt; 对象中&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Configuration\npublic class MybatisPlusConfig {\n\n    private final MyDynamicTableNameParser myDynamicTableNameParser;\n\n    public MybatisPlusConfig(MyDynamicTableNameParser myDynamicTableNameParser) {\n        this.myDynamicTableNameParser = myDynamicTableNameParser;\n    }\n\n    /**\n     * 分页, 分表插件\n     */\n    @Bean\n    public PaginationInterceptor paginationInterceptorMysql() {\n\n        // 分页\n        PaginationInterceptor page = new PaginationInterceptor();\n        page.setDialectType(&amp;quot;mysql&amp;quot;);\n\n        // 分表\n        dynamicTableNameParser(page);\n\n        return page;\n    }\n\n    /**\n     * 分表\n     */\n    private void dynamicTableNameParser(PaginationInterceptor page) {\n\n        // 为指定表设置动态表名处理器\n        HashMap&amp;lt;String, ITableNameHandler&amp;gt; map = new HashMap&amp;lt;&amp;gt;(2);\n        map.put(&amp;quot;sys_user&amp;quot;, myDynamicTableNameParser);\n        map.put(&amp;quot;sys_logs&amp;quot;, myDynamicTableNameParser);\n\n        // 将需要处理的表添加到动态表名 SQL 解析器\n        DynamicTableNameParser dynamicTableNameParser = new DynamicTableNameParser();\n        dynamicTableNameParser.setTableNameHandlerMap(map);\n\n        // 加入处理器链中\n        List&amp;lt;ISqlParser&amp;gt; iSqlParsers = new ArrayList&amp;lt;&amp;gt;();\n        iSqlParsers.add(dynamicTableNameParser);\n        page.setSqlParserList(iSqlParsers);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在dynamicTableNameParser()方法中，第一个代码块将需要动态路由的表通过K-V的形式配置我们刚编写的路由处理器对象。&lt;br&gt;\n第二个代码块中将我们添加的表名处理器设置到 Mybatis-Plus的 表名处理器 DynamicTableNameParser 中&lt;br&gt;\n第三个代码块将我们配置的表名处理器添加到Mybatis-Plus的处理器链中&lt;br&gt;\n通过上面的配置，我们就能够根据配置的路由规则，将配置的需要路由的表动态拼接上我们生成的后缀名了。&lt;/p&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;框架做了很好的封装，整个过程还是非常顺利的，也顺利通过了测试。写这篇博客做个记录。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;shi-yong-mybatis-plus-dong-tai-biao-ming-sql-jie-xi-qi-shi-xian-mysql-fen-biao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;使用Mybatis-Plus 动态表名 SQL 解析器实现MySQL分表&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-08-21 20:27:18&#34;,&#34;dateFormat&#34;:&#34;2019-08-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/shi-yong-mybatis-plus-dong-tai-biao-ming-sql-jie-xi-qi-shi-xian-mysql-fen-biao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:187000,&#34;words&#34;:807,&#34;minutes&#34;:4},&#34;description&#34;:&#34;前言\n随着业务发展，数据库单表量将会持续增长，当增长到一定大小，是需要对应的处理以解决数据查询越来越慢的问题的。\n一般的扩展方案分为两种，一种是垂直扩展，即增大单机的配置。  另一种则是水平扩展，是将任务分配到多台计算机上。\n我们的应用系统...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%80%E5%8F%91\&#34;&gt;开发&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0-itablenamehandler-%E6%8E%A5%E5%8F%A3\&#34;&gt;实现 ITableNameHandler 接口&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%86%E9%85%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E5%88%B0mybatis-plus%E9%85%8D%E7%BD%AE%E4%B8%AD\&#34;&gt;将配置注入到Mybatis-Plus配置中&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;最近接到一个开发任务,有一个用户操作日志表, 里面包含用户id, 用户最近访问内容和时间. 需要查询到用户列表中每一个用户最近操作的内容&lt;/p&gt;\n&lt;p&gt;我开始想到的是使用 &lt;code&gt;group by&lt;/code&gt; 分组, 然后 &lt;code&gt;order by&lt;/code&gt; 时间字段.  但是由于MySQL的执行顺序是先执行 &lt;code&gt;group&lt;/code&gt; 后执行 &lt;code&gt;order&lt;/code&gt;, 经过group之后的内容已经丢失了时间, 所以无法使用该方法实现. 然后在网上找到一种方式, 是通过 right join 自己, 然后取内容. 但是也比较复杂, 后来找到了一个方式比较简单, 在此记录备忘.&lt;/p&gt;\n&lt;p&gt;其主要逻辑使用了&lt;code&gt;not exists&lt;/code&gt;, 然后通过子查询拿到最新数据, 通过 &lt;code&gt;WHERE t1.user_id = t2.user_id &lt;/code&gt; 建立关联, 其中user_id即为两表之间的关联字段.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT\n\tuser_id,\n\tt1.login_time \nFROM\n\ttb_user_login t1 \nWHERE\n\tNOT EXISTS ( SELECT 1 FROM tb_user_login t2 WHERE t1.user_id = t2.user_id AND t1.login_time &amp;lt; t2.login_time )\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对应的表数据如下:&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/07/453uuuf45si59pvlsp81bb0a5p.png\&#34; alt=\&#34;数据库表内容\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;查询出来的结果如下:&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/07/272meb7mbgh6ir1sem51oi4ed2.png\&#34; alt=\&#34;查询结果\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;更新\&#34;&gt;更新&lt;/h1&gt;\n&lt;p&gt;上面的那种方式有严重的性能问题， 执行一次查询竟然要0.4S， 后来在知乎找到了这篇问题，下面 有挺多方式解决这个问题的。  &lt;a href=\&#34;https://www.zhihu.com/question/20863388\&#34;&gt;知乎链接&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-fen-zu-cha-xun-zui-xin-shu-ju&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL 分组查询最新数据&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-07-23 21:29:02&#34;,&#34;dateFormat&#34;:&#34;2019-07-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-fen-zu-cha-xun-zui-xin-shu-ju/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:73000,&#34;words&#34;:324,&#34;minutes&#34;:2},&#34;description&#34;:&#34;最近接到一个开发任务,有一个用户操作日志表, 里面包含用户id, 用户最近访问内容和时间. 需要查询到用户列表中每一个用户最近操作的内容\n我开始想到的是使用 group by 分组, 然后 order by 时间字段.  但是由于MySQL...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9B%B4%E6%96%B0\&#34;&gt;更新&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;SpringBoot jackson 提供了 &lt;code&gt;default-property-inclusion&lt;/code&gt; 为空时不序列化等功能，但是没有提供如果属性值为null时，修改为空串的功能，公司项目开发业务正好需要这个功能，琢磨了一下找到了修改 &lt;code&gt;MappingJackson2HttpMessageConverter&lt;/code&gt; 改变序列化规则的方法。&lt;/p&gt;\n&lt;p&gt;相应的代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/07/19\n * @description 自定义ObjectMapper, 修改序列化规则, 将String null 修改为 String &#39;&#39;\n */\n@Configuration\npublic class JsonObjectMapper extends ObjectMapper {\n\n    public JsonObjectMapper() {\n        super();\n        this.getSerializerProvider().setNullValueSerializer(new JsonSerializer&amp;lt;Object&amp;gt;() {\n            @Override\n            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n                jsonGenerator.writeString(StringUtils.EMPTY);\n            }\n        });\n    }\n\n    @Bean\n    public MappingJackson2HttpMessageConverter objectMapper(){\n        MappingJackson2HttpMessageConverter converter=new MappingJackson2HttpMessageConverter();\n        converter.setObjectMapper(new JsonObjectMapper());\n        return converter;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;主要逻辑就是继承ObjectMapper，构造器重写父类序列化规则，&lt;code&gt;setNullValueSerializer&lt;/code&gt;方法设置为null的值的序列化规则。&lt;code&gt;jsonGenerator.writeString(StringUtils.EMPTY);&lt;/code&gt; 然后重新创建一个 MappingJackson2HttpMessageConverter ，Jackson序列化时则会按照相关规则序列化。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;springboot-null-zi-duan-xu-lie-hua-shi-xiu-gai-wei-kong-chuan&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;SpringBoot Null字段序列化时修改为空串&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-07-19 10:22:26&#34;,&#34;dateFormat&#34;:&#34;2019-07-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/springboot-null-zi-duan-xu-lie-hua-shi-xiu-gai-wei-kong-chuan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:56000,&#34;words&#34;:220,&#34;minutes&#34;:1},&#34;description&#34;:&#34;SpringBoot jackson 提供了 default-property-inclusion 为空时不序列化等功能，但是没有提供如果属性值为null时，修改为空串的功能，公司项目开发业务正好需要这个功能，琢磨了一下找到了修改 Mapp...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;简单记录&lt;/p&gt;\n&lt;p&gt;MySQL5.6 在服务器出现了报错，具体信息如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;表名&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;错误的具体原因是SELECT子句的字段必须出现在GROUP BY后面，因为数据库设置了&lt;code&gt;sql_mode=only_full_group_by&lt;/code&gt;，解决方法网上已经给出了方案，提供一个链接：&lt;a href=\&#34;https://my.oschina.net/dajianguo/blog/1630970\&#34;&gt;mysql遇见Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggre的问题&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-56-cuo-wu-ji-lu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL 5.6 错误记录&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-07-10 15:57:53&#34;,&#34;dateFormat&#34;:&#34;2019-07-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-56-cuo-wu-ji-lu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:32000,&#34;words&#34;:122,&#34;minutes&#34;:1},&#34;description&#34;:&#34;简单记录\nMySQL5.6 在服务器出现了报错，具体信息如下：\nSELECT list is not in GROUP BY clause and contains nonaggregated column &#39;表名&#39; which is no...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;SpringBoot为我们提供了分页对象 &lt;code&gt;org.springframework.data.domain.Pageable&lt;/code&gt;, 通过配合 &lt;code&gt;org.springframework.data.web.PageableDefault&lt;/code&gt; 注解, 可以自定义分页参数, 排序字段等.&lt;/p&gt;\n&lt;p&gt;今天在使用的过程中, 遇到了一个问题, 前端传任何内容, 后端都会报 对象是接口 的错误. 对应的错误堆栈如下:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.data.domain.Pageable]: Specified class is an interface\n\tat org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:99) ~[spring-beans-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.method.annotation.ModelAttributeMethodProcessor.createAttribute(ModelAttributeMethodProcessor.java:141) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor.createAttribute(ServletModelAttributeMethodProcessor.java:81) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.method.annotation.ModelAttributeMethodProcessor.resolveArgument(ModelAttributeMethodProcessor.java:101) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:158) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:128) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:635) [tomcat-embed-core-8.5.16.jar:8.5.16]\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) [spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:742) [tomcat-embed-core-8.5.16.jar:8.5.16]\n\tat org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:841) [jetty-servlet-9.4.6.v20170531.jar:9.4.6.v20170531]\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650) [jetty-servlet-9.4.6.v20170531.jar:9.4.6.v20170531]\n\tat org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:55) [spring-boot-1.5.6.RELEASE.jar:1.5.6.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1637) [jetty-servlet-9.4.6.v20170531.jar:9.4.6.v20170531]\n\tat top.imyzt.learning.security.demo.web.filter.TimeFilter.doFilter(TimeFilter.java:29) [classes/:na]\n...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;问题解决\&#34;&gt;问题解决&lt;/h1&gt;\n&lt;p&gt;出现这个问题, 是因为没有配置对应的参数解析器的原因, 通过配置Pageable和Sort对象的参数转换器, 可以解决这个问题.&lt;/p&gt;\n&lt;p&gt;编写一个类, 继承 &lt;code&gt;WebMvcConfigurationSupport&lt;/code&gt;, 重写 &lt;code&gt;addArgumentResolvers&lt;/code&gt; 方法, Spring为我们提供了默认的解析器, 我们只需要创建对应的对象即可. 代码如下.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n\n    @Override\n    protected void addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt; argumentResolvers) {\n        PageableHandlerMethodArgumentResolver pageableResolver = new PageableHandlerMethodArgumentResolver();\n        SortHandlerMethodArgumentResolver sortResolver = new SortHandlerMethodArgumentResolver();\n        argumentResolvers.add(pageableResolver);\n        argumentResolvers.add(sortResolver);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;参数解析器\&#34;&gt;参数解析器&lt;/h1&gt;\n&lt;p&gt;关于怎样编写自定义的参数解析器, 可以看我的这篇文章 &lt;a href=\&#34;http://blog.imyzt.top/article/61\&#34;&gt;Spring 自定义参数解析&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;shi-yong-pageable-shi-specified-class-is-an-interface-yi-chang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;使用Pageable时Specified class is an interface异常&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-06-05 14:06:27&#34;,&#34;dateFormat&#34;:&#34;2019-06-05&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/shi-yong-pageable-shi-specified-class-is-an-interface-yi-chang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:256000,&#34;words&#34;:778,&#34;minutes&#34;:5},&#34;description&#34;:&#34;SpringBoot为我们提供了分页对象 org.springframework.data.domain.Pageable, 通过配合 org.springframework.data.web.PageableDefault 注解, 可以自...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3\&#34;&gt;问题解决&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8\&#34;&gt;参数解析器&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;pre&gt;&lt;code&gt;@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket createRestApi() {\n        ParameterBuilder ticketPar = new ParameterBuilder();\n        List&amp;lt;Parameter&amp;gt; pars = new ArrayList&amp;lt;&amp;gt;();\n        ticketPar.name(&amp;quot;token&amp;quot;).description(&amp;quot;授权码&amp;quot;)\n                .modelRef(new ModelRef(&amp;quot;string&amp;quot;)).parameterType(&amp;quot;header&amp;quot;)\n                .required(true).build();\n        pars.add(ticketPar.build());\n        return new Docket(DocumentationType.SWAGGER_2)\n                .globalOperationParameters(pars)\n                .apiInfo(apiInfo())\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(&amp;quot;cn.anytec.demo.sdkclientdemo.controller&amp;quot;))\n                .paths(PathSelectors.any())\n                .build();\n    }\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                //页面标题\n                .title(&amp;quot;ANYTEC Face API&amp;quot;)\n                //创建人\n                .contact(new Contact(&amp;quot;ANYTEC&amp;quot;, &amp;quot;anytec.cn&amp;quot;, &amp;quot;&amp;quot;))\n                //版本号\n                .version(&amp;quot;1.0&amp;quot;)\n                //描述\n                .description(&amp;quot;ANYTEC Face API&amp;quot;)\n                .build();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;springboot-ji-cheng-swagger&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;SpringBoot 集成Swagger&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-06-04 18:23:51&#34;,&#34;dateFormat&#34;:&#34;2019-06-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/springboot-ji-cheng-swagger/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:43000,&#34;words&#34;:122,&#34;minutes&#34;:1},&#34;description&#34;:&#34;@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket createRestApi() {\n        Param...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;通过 &lt;code&gt;@JsonView&lt;/code&gt; 注解， 指定对应对象在对应控制器的不同返回内容.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;JsonView以接口作为区分组， 不同的接口作为其参数可以针对不同类型进行分类区分.&lt;br&gt;\n我们有一个 User 对象， 它有username和password属性， 然后对应两个控制器userList和getUserInfo， 我想在在userList接口时只返回用户的名称列表， 在getUserInfo时，将用户名和密码一起返回。那么可以通过定义两个接口：UserSimpleView和UserDetailView， UserDetailView继承自UserSimpleView，根据Java的继承关系也不难理解，就是当有simple的时候， 是独立的， 当有detail的时候， 会将simple注解了的参数一并展示，描述的可能不是特别好，可以通过代码得到更好的展示。&lt;/p&gt;\n&lt;p&gt;首先，我们在User类中，定义两个接口。分别代表两种展示类别，然后再username字段加上simple接口参数，在password字段加上detail接口参数。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Data\n@Accessors(chain = true)\npublic class User implements Serializable {\n\n    public interface UserSimpleView {}\n    public interface UserDetailView extends UserSimpleView {}\n\n    @JsonView(UserSimpleView.class)\n    private String username;\n    @JsonView(UserDetailView.class)\n    private String password;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后再对应的两个控制器，通过 &lt;code&gt;@JsonView&lt;/code&gt; 注解，和对应对象的属性绑定起来。&lt;br&gt;\n可以看到，我们在getUserList方法上配置了simple接口，代表着它的参数返回中，只会包括usename字段属性值。&lt;br&gt;\n在getInfo方法上，通过配置detail接口，代表着它的返回值中可以包括 &lt;code&gt;User&lt;/code&gt; 对象中的所有使用了 &lt;code&gt;Detail&lt;/code&gt; 接口以及其父接口的参数.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@RestController\n@RequestMapping(&amp;quot;user&amp;quot;)\npublic class UserController {\n\n    @GetMapping\n    @JsonView(User.UserSimpleView.class)\n    public List&amp;lt;User&amp;gt; getUserList(UserQueryCondition condition,\n                              @PageableDefault(size = 20, page = 1, sort = &amp;quot;username,asc&amp;quot;) Pageable pageable) {\n\n        System.out.println(ReflectionToStringBuilder.toString(condition, ToStringStyle.MULTI_LINE_STYLE));\n        System.out.println(pageable);\n\n        return Collections.singletonList(new User().setUsername(&amp;quot;yzt&amp;quot;).setPassword(&amp;quot;xxx&amp;quot;));\n    }\n\n    @GetMapping(&amp;quot;{id:\\\\d+}&amp;quot;)\n    @JsonView(User.UserDetailView.class)\n    public User getInfo(@PathVariable String id) {\n\n        System.out.println(id);\n\n        User user = new User();\n        user.setUsername(&amp;quot;tom&amp;quot;).setPassword(&amp;quot;xxx&amp;quot;);\n        return user;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;接下来通过单元测试的返回值，具体的来看一下效果。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@SpringBootTest\n@RunWith(SpringRunner.class)\npublic class UserControllerTest {\n\n    @Autowired\n    private WebApplicationContext wac;\n    private MockMvc mockMvc;\n\n    @Before\n    public void setup() {\n        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();\n    }\n\n    @Test\n    public void whenQuerySuccess() throws Exception {\n        String contentAsString = mockMvc.perform(get(&amp;quot;/user&amp;quot;)\n                .param(&amp;quot;username&amp;quot;, &amp;quot;yzt&amp;quot;)\n                .param(&amp;quot;age&amp;quot;, &amp;quot;20&amp;quot;)\n                .param(&amp;quot;ageTo&amp;quot;, &amp;quot;30&amp;quot;)\n                .param(&amp;quot;page&amp;quot;, &amp;quot;2&amp;quot;)\n                .param(&amp;quot;size&amp;quot;, &amp;quot;10&amp;quot;)\n                .param(&amp;quot;sort&amp;quot;, &amp;quot;age,desc&amp;quot;)\n                .contentType(MediaType.APPLICATION_JSON_UTF8))\n                .andExpect(status().isOk())\n                .andExpect(jsonPath(&amp;quot;$.length()&amp;quot;).value(1))\n                .andReturn()\n                .getResponse()\n                .getContentAsString();\n        System.out.println(contentAsString);\n\n    }\n\n\n    @Test\n    public void whenGetInfoSuccess() throws Exception {\n        String content = mockMvc.perform(get(&amp;quot;/user/1&amp;quot;)\n                .contentType(MediaType.APPLICATION_JSON_UTF8))\n                .andExpect(status().isOk())\n                .andExpect(jsonPath(&amp;quot;$.username&amp;quot;).value(&amp;quot;tom&amp;quot;))\n                .andReturn()\n                .getResponse()\n                .getContentAsString();\n        System.out.println(content);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对应的返回值如下:&lt;br&gt;\nwhenQuerySuccess接口返回值， 只看到了username参数。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;top.imyzt.learning.security.demo.dto.UserQueryCondition@67b560fe[\n  username=yzt\n  age=20\n  ageTo=30\n]\nPage request [number: 2, size 10, sort: age: DESC]\n[{&amp;quot;username&amp;quot;:&amp;quot;yzt&amp;quot;}]\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;whenGetInfoSuccess接口返回值，可以看到了password参数。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;{&amp;quot;username&amp;quot;:&amp;quot;tom&amp;quot;,&amp;quot;password&amp;quot;:&amp;quot;xxx&amp;quot;}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;至此，博客结束了。有多学了一个骚操作。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;jsonview-zhu-jie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;JsonView注解&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-06-01 17:56:25&#34;,&#34;dateFormat&#34;:&#34;2019-06-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/jsonview-zhu-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:202000,&#34;words&#34;:728,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n通过 @JsonView 注解， 指定对应对象在对应控制器的不同返回内容.\n\nJsonView以接口作为区分组， 不同的接口作为其参数可以针对不同类型进行分类区分.\n我们有一个 User 对象， 它有username和password属性...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;后台运行程序并且打印日志到文件\&#34;&gt;后台运行程序并且打印日志到文件&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;nohup run.sh &amp;gt;out.log 2&amp;gt;&amp;amp;1 &amp;amp;\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;linux-ubuntu-chang-yong-ming-ling-ji&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Linux Ubuntu 常用命令集&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-31 16:18:25&#34;,&#34;dateFormat&#34;:&#34;2019-05-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/linux-ubuntu-chang-yong-ming-ling-ji/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:7000,&#34;words&#34;:26,&#34;minutes&#34;:1},&#34;description&#34;:&#34;后台运行程序并且打印日志到文件\nnohup run.sh &amp;gt;out.log 2&amp;gt;&amp;amp;1 &amp;amp;\n\n&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%B9%B6%E4%B8%94%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E5%88%B0%E6%96%87%E4%BB%B6\&#34;&gt;后台运行程序并且打印日志到文件&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;这是设计模式系列的第一篇文章, 也不知道能写几篇......&lt;/p&gt;\n&lt;h1 id=\&#34;代理模式的理解\&#34;&gt;代理模式的理解&lt;/h1&gt;\n&lt;p&gt;代理模式和装饰器模式很像，可以像装饰器模式一样理解它。&lt;/p&gt;\n&lt;p&gt;代理（Proxy）模式， 提供了对&lt;strong&gt;目标对象&lt;/strong&gt;另外的访问方式，即通过代理访问目标对象。这样的好处是可以在&lt;strong&gt;目标实现&lt;/strong&gt;的基础上，增强额外的功能操作。（扩展对象的功能，不入侵目标对象的代码）。  符合设计模式开闭原则。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2019/05/6ummeouseaj3vpefmjc8c5m9ph.png\&#34; alt=\&#34;代理模式\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;静态代理\&#34;&gt;静态代理&lt;/h1&gt;\n&lt;p&gt;关键： 代理对象要实现与目标对象一样的接口。&lt;/p&gt;\n&lt;p&gt;举例：保存用户的操作，userDao（目标对象）只处理业务相关的保存操作，userDaoProxy（代理对象）负责给保存方法添加事务。&lt;/p&gt;\n&lt;p&gt;优点： 不修改目标对象的前提下, 对目标对象进行扩展&lt;br&gt;\n缺点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;因为代理对象需要和目标对象实现相同的接口, 所以会有很多代理类&lt;/li&gt;\n&lt;li&gt;一旦接口增加方法, 目标对象和代理对象都要维护&lt;/li&gt;\n&lt;li&gt;不可协商，比如UserDao有一个查询一个保存方法，只需要对保存方法进行事务处理。但是&lt;strong&gt;代理对象&lt;/strong&gt;必须也实现查询方法，因为Java的接口必须被子类实现。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;模拟用户操作DAO接口，目标对象和代理对象都需要实现该接口。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public interface IUserDao {\n\n    /**\n     * 保存用户\n     */\n    void save();\n\n    /**\n     * 根据id查询用户\n     * @param id 用户id\n     */\n    void queryUserById(int id);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;目标对象仅包含数据库业务操作，不干涉事务、日志等其它代码&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/5/28\n * @description 目标对象\n */\npublic class UserDao implements IUserDao {\n\n    public void save() {\n        System.out.println(&amp;quot;保存用户&amp;quot;);\n    }\n\n    public void queryUserById(int id) {\n        System.out.printf(&amp;quot;id=%d, 用户详情&amp;quot;, id);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;而代理对象需要对目标对象进行扩展，相同的，实现UserDao接口。具有一个私有成员变量保存着目标对象&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/5/28\n * @description 目标对象的静态代理对象,要与目标对象实现一样的接口\n */\npublic class UserDaoProxy implements IUserDao {\n\n    /**\n     * 保存目标对象\n     */\n    private IUserDao target;\n\n    UserDaoProxy(IUserDao target) {\n        this.target = target;\n    }\n\n    /**\n     * 扩展目标对象的方法, 加上事务\n     */\n    public void save() {\n        PrintUtil.print(&amp;quot;开始事务&amp;quot;);\n\n        target.save();\n\n        PrintUtil.print(&amp;quot;提交事务&amp;quot;);\n    }\n\n    /**\n     * 此方法可见, 静态代理不具备可扩展性. 只需要代理 {@link #save()} 方法时,\n     * 因为接口必须继承, 必须将本方法实现\n     */\n    public void queryUserById(int id) {\n        target.queryUserById(id);\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最后通过测试，展示静态代理是否成功运行&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/5/28\n * @description App\n */\npublic class App {\n\n    public static void main(String[] args) {\n\n        UserDao userDao = new UserDao();\n        // class top.imyzt.learning.dp.proxy.a_static.UserDao\n        System.out.println(userDao.getClass());\n\n        UserDaoProxy userDaoProxy = new UserDaoProxy(userDao);\n        // class top.imyzt.learning.dp.proxy.a_static.UserDaoProxy\n        System.out.println(userDaoProxy.getClass());\n\n        userDaoProxy.save();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;动态代理\&#34;&gt;动态代理&lt;/h1&gt;\n&lt;p&gt;为了解决上面静态代理的问题，随之出现了动态代理。对于动态代理我们熟知的Spring的AOP就是使用了动态代理的方式。&lt;/p&gt;\n&lt;p&gt;优点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;代理对象不需要实现接口&lt;/li&gt;\n&lt;li&gt;代理对象的生成, 是利用JDKAPI, 动态的在内存中构建代理对象(需要我们指定创建代理对象实现的接口类型)&lt;/li&gt;\n&lt;li&gt;动态代理, JDK代理(接口代理), 需要依赖于实现接口的目标对象.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;动态代理分为JDK动态代理和CGLIB代理, 都是通过动态生成字节码技术然后加载字节码到JVM中, 它们的主要区别是:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;JDK代理依赖目标对象实现接口, CGLIB不需要&lt;/li&gt;\n&lt;li&gt;因为CGLIB是继承目标对象, 所以目标对象不能为final类, 而JDK代理不存在这个问题.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;jdk动态代理\&#34;&gt;JDK动态代理&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;java.lang.reflect.Proxy#newProxyInstance(ClassLoader loader,    // 目标对象使用的类加载器\n                                          Class&amp;lt;?&amp;gt;[] interfaces,                           // 目标对象实现的接口的类型\n                                          InvocationHandler h)                             // 事件处理器\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;JDK动态代理：&lt;br&gt;\n代理对象不需要实现接口, 但是目标对象一定要实现接口, 否则不能使用JDK动态代理.&lt;/p&gt;\n&lt;p&gt;这里只是展示一下核心的代理工厂的代码, 更多代码在文末的github链接中有给出. JDK动态代理使用了JDK的反射功能实现.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/5/28\n * @description JDK动态代理工厂\n */\npublic class DynamicProxyFactory&amp;lt;T&amp;gt; {\n\n    private static final Pattern p = Pattern.compile(&amp;quot;(query\\\\w+|find\\\\w+|get\\\\w)&amp;quot;);\n\n    /**\n     * 目标对象\n     */\n    private T target;\n\n    public DynamicProxyFactory(T target) {\n        this.target = target;\n    }\n\n    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)\n    public T getProxyInstance() {\n        return  (T) Proxy.newProxyInstance(\n                target.getClass().getClassLoader(),\n                target.getClass().getInterfaces(),\n                (Object proxy, Method method, Object[] args) -&amp;gt; {\n\n                    Object returnValue;\n\n                    // 模拟Spring 的事务开启开关, 根据方法名判断是否需要开启事务\n                    if (checkMethod(method)) {\n                        // 执行目标对象的方法\n                        return method.invoke(target, args);\n                    }\n\n                    PrintUtil.print(&amp;quot;开始事务&amp;quot;);\n\n                    // 执行目标对象的方法\n                    returnValue = method.invoke(target, args);\n\n                    PrintUtil.print(&amp;quot;结束事务&amp;quot;);\n\n                    return returnValue;\n                });\n    }\n\n\n    /**\n     * 检查方法是否需要开启事务. 根据方法名简单判断\n     * @param method 方法\n     */\n    private boolean checkMethod(Method method) {\n        String name = method.getName();\n        Matcher matcher = p.matcher(name);\n        return matcher.find();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;cglib动态代理\&#34;&gt;CGLIB动态代理&lt;/h2&gt;\n&lt;p&gt;CGLIB可以弥补JDK动态代理不能代理没有实现接口的目标对象的情况, 可以对不实现接口的目标对象进行代理. 需要引入CGLIB的jar包. 这里使用Spring-core包封装的CGLIB即可.&lt;br&gt;\n演示一个CGLIB对象工厂的代理对象, 通过泛型, 如业务没有改变的情况下, 可以重用的代理对象实现.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/5/28\n * @description CglibDynamicFactory\n */\npublic class CglibDynamicFactory&amp;lt;T&amp;gt; implements MethodInterceptor {\n\n    private T target;\n\n    public CglibDynamicFactory(T target) {\n        this.target = target;\n    }\n\n    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)\n    public T getProxyInstance() {\n\n\n        // 1. 工具类\n        Enhancer enhancer = new Enhancer();\n\n        // 2. 设置父类\n        enhancer.setSuperclass(target.getClass());\n\n        // 3. 设置回调函数\n        enhancer.setCallback(this);\n\n        return (T) enhancer.create();\n    }\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n\n        PrintUtil.print(&amp;quot;开始事务&amp;quot;);\n\n        // 执行目标对象的方法\n        Object returnValue = method.invoke(target, args);\n\n        PrintUtil.print(&amp;quot;提交事务&amp;quot;);\n\n        return returnValue;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;she-ji-mo-shi-zhi-dai-li-mo-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;设计模式之代理模式&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-28 11:56:34&#34;,&#34;dateFormat&#34;:&#34;2019-05-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/she-ji-mo-shi-zhi-dai-li-mo-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:360000,&#34;words&#34;:1477,&#34;minutes&#34;:7},&#34;description&#34;:&#34;这是设计模式系列的第一篇文章, 也不知道能写几篇......\n代理模式的理解\n代理模式和装饰器模式很像，可以像装饰器模式一样理解它。\n代理（Proxy）模式， 提供了对目标对象另外的访问方式，即通过代理访问目标对象。这样的好处是可以在目标实...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3\&#34;&gt;代理模式的理解&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86\&#34;&gt;静态代理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\&#34;&gt;动态代理&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\&#34;&gt;JDK动态代理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\&#34;&gt;CGLIB动态代理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;es的安装较简单, 记录一下安装head插件就行了.&lt;/p&gt;\n&lt;p&gt;首先下载es-head的代码. 地址在这里. &lt;a href=\&#34;https://github.com/mobz/elasticsearch-head\&#34;&gt;https://github.com/mobz/elasticsearch-head&lt;/a&gt;&lt;br&gt;\n由于head是一个前端程序, 是有跨域问题的, 需要修改es的配置文件, 增加跨域支持. 修改一下 &lt;code&gt;config/elasticsearch.yml&lt;/code&gt; 文件, 在最底部增加两行:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;http.cors.enables: true\nhttp.cors.allow-origin: &amp;quot;*&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后进入es-head的目录, 运行 &lt;code&gt;npm install&lt;/code&gt; 安装所需依赖, 最后 &lt;code&gt;npm run start&lt;/code&gt; 就可以访问浏览器 9100 端口了.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;elasticsearch-an-zhuang-head-cha-jian&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;ElasticSearch 安装head插件&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-25 18:23:19&#34;,&#34;dateFormat&#34;:&#34;2019-05-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/elasticsearch-an-zhuang-head-cha-jian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:32000,&#34;words&#34;:135,&#34;minutes&#34;:1},&#34;description&#34;:&#34;es的安装较简单, 记录一下安装head插件就行了.\n首先下载es-head的代码. 地址在这里. https://github.com/mobz/elasticsearch-head\n由于head是一个前端程序, 是有跨域问题的, 需要修...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;先说明一下, 这三个注解都可以用在注入对象时使用. 他们两个是javax包下自带的, 一个是由spring提供给我们的.&lt;/p&gt;\n&lt;h1 id=\&#34;autowired\&#34;&gt;@Autowired&lt;/h1&gt;\n&lt;p&gt;先说Autowired, 因为他是我们大多数人经常使用到的, 它是由spring为我们提供的依赖注入的注解,&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;它可以用在变量, 构造器和setter方法上.&lt;/li&gt;\n&lt;li&gt;它是根据 &lt;strong&gt;类型&lt;/strong&gt; 进行装配bean的, 提供一个 &lt;code&gt;required&lt;/code&gt; 参数, 指定为false时, 当无法注入时, 不会报错.&lt;/li&gt;\n&lt;li&gt;它可以配合 &lt;code&gt;@Qualifier&lt;/code&gt; 注解进行使用, 通过它的 &lt;code&gt;value&lt;/code&gt; 参数, 指定注入时需要的bean的 &lt;strong&gt;名称&lt;/strong&gt;, 就可以根据名称进行注入了.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;resource\&#34;&gt;@Resource&lt;/h1&gt;\n&lt;p&gt;这个注解大多数人不常使用, 它是javax包提供的, 基于 JSR250 的注解. 我平时更多的是使用它.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;它可以用在字段或setter方法上.&lt;/li&gt;\n&lt;li&gt;它是根据 &lt;strong&gt;名称&lt;/strong&gt; 进行装配bean的, 提供一个 &lt;code&gt;name&lt;/code&gt; 参数, 但是默认情况下不指定的话, 作用在参数上时会根据参数名注入, 作用在setter方法时, 会根据属性名进行装配, 都无法查找时, 会根据类型进行匹配.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;inject\&#34;&gt;@Inject&lt;/h1&gt;\n&lt;p&gt;这个注解应该大多数人都没见过, 在写文章之前, 我也没见过 😃&lt;br&gt;\n这个注解是遵循 JSR330 规范的, 是由javax包提供的. 这里简单讲解一下(其实就是@Autowired的翻版).&lt;br&gt;\n它可以作用在@Autowired能作用的地方, 并且默认也是根据类型装配, 通过 &lt;code&gt;@Named&lt;/code&gt; 修改为根据 &lt;strong&gt;名称&lt;/strong&gt; 装配.&lt;br&gt;\n它与Autowired不同点在于它没有 &lt;code&gt;required&lt;/code&gt; 参数&lt;/p&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;@Autowired是Spring提供给我们的, @Inject(遵循JSR330规范)和@Resource(遵循JSR250规范)是javax包提供给我们的.&lt;/li&gt;\n&lt;li&gt;@Autowired和@Inject是根据&lt;strong&gt;类型&lt;/strong&gt;装配, @Resource是根据&lt;strong&gt;名称&lt;/strong&gt;装配.&lt;/li&gt;\n&lt;li&gt;@Autowired有required参数, @Inject没有.&lt;/li&gt;\n&lt;li&gt;@Autowired配合@Qualifier可以使用&lt;strong&gt;名称&lt;/strong&gt;装配, @Inject配合@Named可以使用&lt;strong&gt;名称&lt;/strong&gt;装配, @Resource根据名称无法装配时, 会根据类型装配.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;平时使用记住一种就可以了. 一般推荐使用 @Autowired, 毕竟你是用它们的框架.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;autowired-inject-resource-san-ge-zhu-jie-de-zuo-yong-he-qu-bie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;@Autowired, @Inject, @Resource 三个注解的作用和区别&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-25 15:34:17&#34;,&#34;dateFormat&#34;:&#34;2019-05-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/autowired-inject-resource-san-ge-zhu-jie-de-zuo-yong-he-qu-bie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:115000,&#34;words&#34;:539,&#34;minutes&#34;:2},&#34;description&#34;:&#34;前言\n先说明一下, 这三个注解都可以用在注入对象时使用. 他们两个是javax包下自带的, 一个是由spring提供给我们的.\n@Autowired\n先说Autowired, 因为他是我们大多数人经常使用到的, 它是由spring为我们提供...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#autowired\&#34;&gt;@Autowired&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#resource\&#34;&gt;@Resource&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#inject\&#34;&gt;@Inject&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;文章以一个方法一个代码块的方式演示.&lt;/p&gt;\n&lt;h1 id=\&#34;简单几个注解\&#34;&gt;简单几个注解&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;set和get方法&lt;br&gt;\n@Getter / @Setter&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;toString方法&lt;br&gt;\n@ToString&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;equals和hashCode方法&lt;br&gt;\n@EqualsAndHashCode&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Data&lt;br&gt;\n@Data 通常这个方法就够了, 包含上面几个注解.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;全参, 无参&lt;br&gt;\n@AllArgsConstructor, @NoArgsConstructor&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;不能为空&lt;br&gt;\n@NonNull, 作用到属性上是, 如果不赋值会抛空指针&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;日志&lt;br&gt;\n@Slf4j&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;链式调用\&#34;&gt;链式调用&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;通过设置 &lt;code&gt;@Accessors&lt;/code&gt; 的 &lt;code&gt;chain=true&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code&gt;public class LombokTest {\n    public static void main(String[] args) {\n\n        Student student = new Student();\n        \n        student.setName(&amp;quot;yzt&amp;quot;).setAge(22);\n    }\n}\n\n@Data\n@Accessors(chain = true)\nclass Student {\n    private String name;\n    private Integer age;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;静态方法构造器\&#34;&gt;静态方法构造器&lt;/h1&gt;\n&lt;p&gt;通过 &lt;code&gt;@NonNull&lt;/code&gt; 和 &lt;code&gt;@RequiredArgsConstructor(staticName = &amp;quot;ofName&amp;quot;)&lt;/code&gt; 实现.&lt;br&gt;\n在 &lt;code&gt;name&lt;/code&gt; 属性上添加 &lt;code&gt;@NonNull&lt;/code&gt; 注解标识不能为空, 然后通过 &lt;code&gt;RequiredArgsConstructor&lt;/code&gt; 的 &lt;code&gt;staticName &lt;/code&gt; 属性设置静态构造器的名称.&lt;br&gt;\n当然也是可以不使用 &lt;code&gt;@NonNull&lt;/code&gt; 属性的, 标识静态构造器是 &lt;strong&gt;空参&lt;/strong&gt; 的&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;带参数的构造\npublic class LombokTest {\n    public static void main(String[] args) {\n\n        Student student = Student.ofName(&amp;quot;yzt&amp;quot;).setAge(22);\n        System.out.println(student);\n    }\n}\n\n@Data\n@Accessors(chain = true)\n@RequiredArgsConstructor(staticName = &amp;quot;ofName&amp;quot;)\nclass Student {\n    @NonNull\n    private String name;\n    private Integer age;\n}\n\n空参构造\npublic class LombokTest {\n    public static void main(String[] args) {\n\n        Student student = Student.of().setName(&amp;quot;yzt&amp;quot;).setAge(22);\n        System.out.println(student);\n    }\n}\n\n@Data\n@Accessors(chain = true)\n@RequiredArgsConstructor(staticName = &amp;quot;of&amp;quot;)\nclass Student {\n    private String name;\n    private Integer age;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;builder-模式\&#34;&gt;builder 模式&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;public class LombokTest {\n    public static void main(String[] args) {\n\n        Student student = Student.builder().name(&amp;quot;yzt&amp;quot;).age(22).build();\n        System.out.println(student);\n    }\n}\n\n@Data\n@Builder\nclass Student {\n    private String name;\n    private Integer age;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;工具类\&#34;&gt;工具类&lt;/h1&gt;\n&lt;p&gt;&lt;code&gt;@UtilityClass&lt;/code&gt; 注解作用在工具方法上, 会私有构造, 然后为方法添加 &lt;code&gt;static&lt;/code&gt; 关键字. 注意下方我演示的 &lt;code&gt;getIp()&lt;/code&gt; 方法没有添加 &lt;code&gt;static&lt;/code&gt; 关键字也能够调用.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public class LombokTest {\n    public static void main(String[] args) {\n\n        String ip = HttpKit.getIp();\n        System.out.println(ip);\n    }\n}\n\n@UtilityClass\nclass HttpKit {\n\n    public String getIp() {\n        return &amp;quot;127.0.0.1&amp;quot;;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;去除统一前缀\&#34;&gt;去除统一前缀&lt;/h1&gt;\n&lt;p&gt;这个在使用的时候命名一定要使用 &lt;strong&gt;驼峰命名法&lt;/strong&gt;, 不然会出现莫名其妙的问题.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public class LombokTest {\n    public static void main(String[] args) {\n\n        Student student = new Student();\n        student.setName(&amp;quot;yzt&amp;quot;);\n        student.setAge(22);\n        System.out.println(student);\n    }\n}\n\n@Data\n@Accessors(prefix = &amp;quot;f&amp;quot;)\nclass Student {\n    private String fName;\n    private Integer fAge;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;setget-方法不以-setget-开头\&#34;&gt;set/get 方法不以 set/get 开头&lt;/h1&gt;\n&lt;p&gt;就相当于去掉了 set/get 前缀的 set/get 方法. 不推荐使用. 不符合Java规范.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public class LombokTest {\n    public static void main(String[] args) {\n\n        Student student = new Student();\n        student.name(&amp;quot;yzt&amp;quot;);\n        student.age(22);\n        System.out.println(student.name());\n    }\n}\n\n@Data\n@Accessors(fluent = true)\nclass Student {\n    private String name;\n    private Integer age;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;代理方法\&#34;&gt;代理方法&lt;/h1&gt;\n&lt;p&gt;这个说起来有点懵逼, 直接看代码可能更清晰.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public class LombokTest {\n    public static void main(String[] args) {\n\n        User user = new User();\n        user.add(&amp;quot;yzt&amp;quot;);    // 这里其实调用的是 TemplateCollection 的方法\n        user.add(&amp;quot;xxx&amp;quot;);\n        user.add(&amp;quot;yyy&amp;quot;);\n        System.out.println(user);\n        user.remove(&amp;quot;yyy&amp;quot;);\n        System.out.println(user);\n    }\n}\n\n@ToString\nclass User {\n    private interface TemplateCollection {\n        boolean add(String obj);\n        boolean remove(Object obj);\n    }\n\n    @Delegate(types = TemplateCollection.class)\n    private final Collection&amp;lt;String&amp;gt; users = new ArrayList&amp;lt;&amp;gt;();\n}\n\n输出: \nUser(users=[yzt, xxx, yyy])\nUser(users=[yzt, xxx])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;后记\&#34;&gt;后记&lt;/h1&gt;\n&lt;h2 id=\&#34;编译注解到代码\&#34;&gt;编译注解到代码&lt;/h2&gt;\n&lt;p&gt;通过菜单栏的 &lt;code&gt;Refactor -&amp;gt; delombok&lt;/code&gt; 就可以得到源代码了&lt;/p&gt;\n&lt;h2 id=\&#34;关于lombok\&#34;&gt;关于lombok&lt;/h2&gt;\n&lt;p&gt;在 &lt;code&gt;lombok.experimental.*&lt;/code&gt; 包下的是创新型注解. 与Java规范不符合, 有待考证&lt;br&gt;\n在 &lt;code&gt;lombok.*&lt;/code&gt; 包下的放心使用.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;lombok-chang-yong-fang-fa-shi-li&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Lombok 常用方法实例&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-25 12:44:53&#34;,&#34;dateFormat&#34;:&#34;2019-05-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/lombok-chang-yong-fang-fa-shi-li/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:216000,&#34;words&#34;:750,&#34;minutes&#34;:4},&#34;description&#34;:&#34;文章以一个方法一个代码块的方式演示.\n简单几个注解\n\n\nset和get方法\n@Getter / @Setter\n\n\ntoString方法\n@ToString\n\n\nequals和hashCode方法\n@EqualsAndHashCode\n\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E5%8D%95%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3\&#34;&gt;简单几个注解&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8\&#34;&gt;链式调用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%99%A8\&#34;&gt;静态方法构造器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#builder-%E6%A8%A1%E5%BC%8F\&#34;&gt;builder 模式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E5%85%B7%E7%B1%BB\&#34;&gt;工具类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%BB%E9%99%A4%E7%BB%9F%E4%B8%80%E5%89%8D%E7%BC%80\&#34;&gt;去除统一前缀&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#setget-%E6%96%B9%E6%B3%95%E4%B8%8D%E4%BB%A5-setget-%E5%BC%80%E5%A4%B4\&#34;&gt;set/get 方法不以 set/get 开头&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95\&#34;&gt;代理方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E8%AE%B0\&#34;&gt;后记&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E8%AF%91%E6%B3%A8%E8%A7%A3%E5%88%B0%E4%BB%A3%E7%A0%81\&#34;&gt;编译注解到代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8Elombok\&#34;&gt;关于lombok&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;pre&gt;&lt;code&gt;\npublic List&amp;lt;BrokerMessageLog&amp;gt; query4StatusAndTimeoutMessage() {\n    return lambdaQuery().eq(BrokerMessageLog::getStatus, Constant.ORDER_SENDING)\n            .le(BrokerMessageLog::getNextRetry, LocalDateTime.now())\n            .select(BrokerMessageLog.class, tableFieldInfo -&amp;gt; !&amp;quot;name&amp;quot;.equals(tableFieldInfo.getColumn()))\n            .list();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;.select(BrokerMessageLog.class, tableFieldInfo -&amp;gt; !&amp;quot;name&amp;quot;.equals(tableFieldInfo.getColumn()))&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;排除了字段名称为 &lt;code&gt;name&lt;/code&gt; 的字段.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mybatis-plus-cha-xun-shi-pai-chu-mou-yi-lie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Mybatis-Plus查询时排除某一列&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-23 19:35:22&#34;,&#34;dateFormat&#34;:&#34;2019-05-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mybatis-plus-cha-xun-shi-pai-chu-mou-yi-lie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:17000,&#34;words&#34;:53,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\npublic List&amp;lt;BrokerMessageLog&amp;gt; query4StatusAndTimeoutMessage() {\n    return lambdaQuery().eq(BrokerMessageLog::get...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;自动生成serialversionuid\&#34;&gt;自动生成serialVersionUID&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;Ctrl+Alt+S打开设置&lt;/li&gt;\n&lt;li&gt;搜索栏搜索 &lt;code&gt;Inspections&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;选项栏搜索 &lt;code&gt;Serialization issues&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;找到 &lt;code&gt;Serializable class without &#39;SerialVersionUID&#39;&lt;/code&gt;, 勾选&lt;/li&gt;\n&lt;li&gt;应用&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://imyzt.top/upload/2019/05/qlojid2n4ih0dol3fgvmcrip97.jpg\&#34; alt=\&#34;操作图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;对应的实现了 &lt;code&gt;Serializable&lt;/code&gt; 接口的类会报出黄色警告, Alt + Enter 组合键选中 &lt;code&gt;Add SerialVersionUID field&lt;/code&gt; 即可生成.&lt;br&gt;\n&lt;img src=\&#34;http://imyzt.top/upload/2019/05/rhnt03ocvsgslq7ccghg6kr1q5.jpg\&#34; alt=\&#34;操作图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;去除所有无用引用\&#34;&gt;去除所有无用引用&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;Ctrl+Alt+S打开设置&lt;/li&gt;\n&lt;li&gt;勾选图中的 &lt;code&gt;show notification after optimize imports action&lt;/code&gt;, 确认退出设置&lt;/li&gt;\n&lt;li&gt;选中整个项目右键, 点击 &lt;code&gt;optimize imports&lt;/code&gt;, 点击确定即可.&lt;/li&gt;\n&lt;li&gt;在类窗口, Ctrl+Alt+O, 可以单独去除该类的无用导入.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/01/v1m3vtp2tuh7hprrs113leh8lk.png\&#34; alt=\&#34;设置\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2020/01/o2cppdje38grfr90kfr1skeij1.png\&#34; alt=\&#34;设置\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;设置代码提示不缺分大小写\&#34;&gt;设置代码提示不缺分大小写&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/08/q2nfu81mc8jrjogd77h83hb4hf.png\&#34; alt=\&#34;代码提示不缺分大小写\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;鼠标放上提示方法描述\&#34;&gt;鼠标放上提示方法描述&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/08/p2gh6kaa10j9fr70f1l555p7g5.png\&#34; alt=\&#34;鼠标放上提示方法描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;idea-自动导包\&#34;&gt;idea 自动导包&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/12/rdrq59g5oegjep1i54gtb7i4gm.png\&#34; alt=\&#34;自动导包\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;idea-she-zhi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;IDEA 设置&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-23 09:19:57&#34;,&#34;dateFormat&#34;:&#34;2019-05-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/idea-she-zhi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:38000,&#34;words&#34;:164,&#34;minutes&#34;:1},&#34;description&#34;:&#34;自动生成serialVersionUID\n\nCtrl+Alt+S打开设置\n搜索栏搜索 Inspections\n选项栏搜索 Serialization issues\n找到 Serializable class without &#39;SerialV...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90serialversionuid\&#34;&gt;自动生成serialVersionUID&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%BB%E9%99%A4%E6%89%80%E6%9C%89%E6%97%A0%E7%94%A8%E5%BC%95%E7%94%A8\&#34;&gt;去除所有无用引用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E4%B8%8D%E7%BC%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99\&#34;&gt;设置代码提示不缺分大小写&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%BC%A0%E6%A0%87%E6%94%BE%E4%B8%8A%E6%8F%90%E7%A4%BA%E6%96%B9%E6%B3%95%E6%8F%8F%E8%BF%B0\&#34;&gt;鼠标放上提示方法描述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#idea-%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%8C%85\&#34;&gt;idea 自动导包&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;SpringBoot引入yml文件作为配置文件, 可以通过@Value注解获取对应的值, 当然也是可以对值设定默认值的.&lt;br&gt;\n比如在swagger的配置类中, 需要判定swagger是否开启, 我们在yml文件中设定属性如下:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;swagger:\n  enable: ${SWAGGER_ENABLE:false}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过上面的设置, 默认情况下, 属性的值是false, 而当有指令对SWAGGER_ENABLE属性重设之后, 参数值也会跟随改变.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;yaml-wen-jian-mo-ren-zhi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;YAML文件默认值&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-14 10:21:28&#34;,&#34;dateFormat&#34;:&#34;2019-05-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/yaml-wen-jian-mo-ren-zhi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:24000,&#34;words&#34;:113,&#34;minutes&#34;:1},&#34;description&#34;:&#34;SpringBoot引入yml文件作为配置文件, 可以通过@Value注解获取对应的值, 当然也是可以对值设定默认值的.\n比如在swagger的配置类中, 需要判定swagger是否开启, 我们在yml文件中设定属性如下:\nswagger:...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;写一段代码\&#34;&gt;写一段代码&lt;/h1&gt;\n&lt;p&gt;堆内存溢出, 首先我们需要一段能够使堆内存溢出的代码.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;\n\n/**\n * @author imyzt\n * @date 2019/5/7\n * @description Main\n */\npublic class Main {\n    public static void main(String[] args) {\n        ArrayList&amp;lt;Demo&amp;gt; demos = new ArrayList&amp;lt;&amp;gt;();\n        while (true) {\n            demos.add(new Demo());\n        }\n    }\n}\n\n\n/**\n * @author imyzt\n * @date 2019/5/7\n * @description Demo\n */\npublic class Demo {\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过制定堆内存大小, 指定堆内存快照, 可以快速获取一份堆内存溢出信息.可以通过在IDE的 &lt;code&gt;VM options&lt;/code&gt; 设置.&lt;br&gt;\n&lt;code&gt;-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/05/3rgpa4o22agripb5r64c6a3kdn.jpg\&#34; alt=\&#34;堆内存快照\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;这份文件在我们项目的根目录下面. 后缀名是 &lt;code&gt;.hprof&lt;/code&gt;.  我们可以通过eclipse提供的mat工具对堆内存快照进行分析.  &lt;a href=\&#34;https://www.eclipse.org/downloads/download.php?file=/mat/1.8.1/rcp/MemoryAnalyzer-1.8.1.20180910-win32.win32.x86_64.zip\&#34;&gt;mat下载地址&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;接下来就是将我们的快照数据导入到工具中.&lt;br&gt;\n从图中我们可以看到 &lt;strong&gt;Problem Suspect 1&lt;/strong&gt;(可能出现问题的区域)比较大, 总共20M的内存, 15M都有可能出现问题&lt;br&gt;\n从图中分析, 我们看到了95%的内存都被 main thread 占用, 然后点开树发现, 对象占用是最高的,几乎是主线程占用的内存的所有.&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/05/vns1bdk5u6ilvoqqubbrmh6ldp.jpg\&#34; alt=\&#34;内存分析\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;outofmemoryerror-fen-xi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;OutOfMemoryError 分析&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-07 14:57:49&#34;,&#34;dateFormat&#34;:&#34;2019-05-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/outofmemoryerror-fen-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:66000,&#34;words&#34;:276,&#34;minutes&#34;:2},&#34;description&#34;:&#34;写一段代码\n堆内存溢出, 首先我们需要一段能够使堆内存溢出的代码.\nimport java.util.ArrayList;\n\n/**\n * @author imyzt\n * @date 2019/5/7\n * @description Ma...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%99%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81\&#34;&gt;写一段代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;就在今天, 我的服务器重启之后, docker ps突然没法用了, 提示信息如下.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;ubuntu@xxx:~$ docker ps\nCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;提示信息很明显,就是问我docker是否启动, 按道理来说docker应该是服务自拉起的. 既然没有启动肯定是出了问题. 需要进行排查.&lt;br&gt;\n第一步我是直接 systemctl 启动一次, 不过依旧报错.  信息如下:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;ubuntu@xxx:~$ systemctl start docker.service\nJob for docker.service failed because the control process exited with error code. See &amp;quot;systemctl status docker.service&amp;quot; and &amp;quot;journalctl -xe&amp;quot; for details.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;提示信息说启动失败了, 然后叫我 status 查看一下, 命令执行后信息如下:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;ubuntu@xxx:~$ systemctl status docker.service\n● docker.service - Docker Application Container Engine\n   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)\n   Active: failed (Result: start-limit-hit) since 二 2019-05-07 11:26:12 CST; 10s ago\n     Docs: https://docs.docker.com\n  Process: 26461 ExecStart=/usr/bin/dockerd -H fd:// (code=exited, status=2)\n Main PID: 26461 (code=exited, status=2)\n\n5月 07 11:26:12 xxx systemd[1]: docker.service: Main process exited, code=exited, status=2/INVALIDARGUMENT\n5月 07 11:26:12 xxx systemd[1]: Failed to start Docker Application Container Engine.\n5月 07 11:26:12 xxx systemd[1]: docker.service: Unit entered failed state.\n5月 07 11:26:12 xxx systemd[1]: docker.service: Failed with result &#39;exit-code&#39;.\n5月 07 11:26:12 xxx systemd[1]: docker.service: Service hold-off time over, scheduling restart.\n5月 07 11:26:12 xxx systemd[1]: Stopped Docker Application Container Engine.\n5月 07 11:26:12 xxx systemd[1]: docker.service: Start request repeated too quickly.\n5月 07 11:26:12 xxx systemd[1]: Failed to start Docker Application Container Engine.\n5月 07 11:26:12 xxx systemd[1]: docker.service: Unit entered failed state.\n5月 07 11:26:12 xxx systemd[1]: docker.service: Failed with result &#39;start-limit-hit&#39;.\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从提示信息我反正是没看出来太多有用的信息来的, 然后就祭出了搜索大法, 发现和我一样问题的挺多的.  我就直接给我问题解决的链接先.&lt;br&gt;\n&lt;a href=\&#34;https://www.cnblogs.com/dalianmao890710/p/9241752.html\&#34;&gt;博客园&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;根据上面博主的解决方案, 我将 /etc/docker/daemon.json 的文件进行了修改, 文件内容展示在下面如下:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;{                                                                                                                                                                                                                               \n            &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;阿里云仓库加速链接&amp;quot;],\n            &amp;quot;bip&amp;quot;: &amp;quot;10.0.0.1/16&amp;quot;,\n             &amp;quot;graph&amp;quot;: &amp;quot;/mnt/docker-data&amp;quot;,\n             &amp;quot;storage-driver&amp;quot;: &amp;quot;overlay&amp;quot;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;接下来通过 &lt;code&gt;systemctl start docker.service &lt;/code&gt; 启动了一下docker, 问题果然消失了.  上面博主对问题描述的也已经非常清楚,我在此只是做一个引用.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;ocker的engine 基于Device Mapper提供的一种存储驱动,而它又依赖与 devicemapper。于是乎我将它给删除并重启服务，解决了docker无法正常启动的问题。&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-wu-fa-qi-dong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;docker 无法启动&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-07 11:56:00&#34;,&#34;dateFormat&#34;:&#34;2019-05-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/docker-wu-fa-qi-dong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:184000,&#34;words&#34;:642,&#34;minutes&#34;:4},&#34;description&#34;:&#34;就在今天, 我的服务器重启之后, docker ps突然没法用了, 提示信息如下.\nubuntu@xxx:~$ docker ps\nCannot connect to the Docker daemon at unix:///var/run...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;swarm介绍\&#34;&gt;Swarm介绍&lt;/h1&gt;\n&lt;p&gt;Swarm 是 Docker 公司在 2014 年 12 月初发布的一套较为简单的工具,用来管理 Docker 集群,它将一群 Docker 宿主机变成一个单一的,虚拟的主机。Swarm 使用标准的 Docker API接口作为其前端访问入口,换言之,各种形式的 Docker Client(docker client in go, docker_py,docker 等)均可以直接与 Swarm 通信。Swarm 几乎全部用 Go 语言来完成开发。&lt;br&gt;\nSwarm deamon 只是一个调度器(Scheduler)加路由器(router),Swarm 自己不运行容器,它只是接受 docker 客户端发送过来的请求,调度适合的节点来运行容器,这意味着,即使Swarm 由于某些原因挂掉了,集群中的节点也会照常运行,当 Swarm 重新恢复运行之后,它会收集重建集群信息。下面是 Swarm 的结构图:&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/05/umrounlfd2hpeqc5dm7pqhib6p.png\&#34; alt=\&#34;swarm架构图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;环境准备\&#34;&gt;环境准备&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;三台服务器或者虚拟机&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;server01, server02, server03&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;安装了docker&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;搭建集群\&#34;&gt;搭建集群&lt;/h1&gt;\n&lt;h2 id=\&#34;初始化一个manager节点\&#34;&gt;初始化一个manager节点&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;docker提供了init命令用于初始化一个集群, 从输出信息中可以得到对应的work节点的token&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker swarm init \nSwarm initialized: current node (wpx3o9mcpuq79ujpumykjkgt7) is now a manager.\n\nTo add a worker to this swarm, run the following command:\n\n    docker swarm join --token SWMTKN-1-44a0imbc65z7o9fbfj89mxs4xfu7w3pmtfo7s50mt3ues809mr-0xhunq3plzdyhyhebswxuuds8 192.168.10.45:2377\n\nTo add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;在其他服务器输入命令\&#34;&gt;在其他服务器输入命令&lt;/h2&gt;\n&lt;p&gt;在上一步的输出中, 已经包含了其他节点加入该集群的命令.只需要输入即可.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server02:~$ docker swarm join --token SWMTKN-1-44a0imbc65z7o9fbfj89mxs4xfu7w3pmtfo7s50mt3ues809mr-0xhunq3plzdyhyhebswxuuds8 192.168.10.45:2377\nThis node joined a swarm as a worker.\n\nn-tech-admin@server03:~$ docker swarm join --token SWMTKN-1-44a0imbc65z7o9fbfj89mxs4xfu7w3pmtfo7s50mt3ues809mr-0xhunq3plzdyhyhebswxuuds8 192.168.10.45:2377\nThis node joined a swarm as a worker.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;查看docker-network\&#34;&gt;查看docker network&lt;/h2&gt;\n&lt;p&gt;创建集群之后, 我们可以看到network增加了&lt;code&gt;docker_gwbridge&lt;/code&gt;和&lt;code&gt;ingress&lt;/code&gt;两个网络.&lt;br&gt;\nswarm的ingress连接的是ingress网络, 该网络需要通过docker_gwbridge网桥, 借助于docker daemon网桥跟主机进行连接.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker network ls\nNETWORK ID          NAME                         DRIVER              SCOPE\ncdb39c520f0b        bridge                       bridge              local\nfd5e65ece1c7        docker_gwbridge              bridge              local\neb06b54c7e76        host                         host                local\ntbsdc0m2p1le        ingress                      overlay             swarm\nf4e8f15f758b        none                         null                local\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;高可用\&#34;&gt;高可用&lt;/h2&gt;\n&lt;p&gt;docker默认支持高可用, 通过选举将work节点挑选为manager节点. 只需要配置所有节点为manager节点即可.&lt;br&gt;\n首先可以通过docker node ls查看所有的节点信息.可以看到默认情况下&lt;code&gt;MANAGER STATUS&lt;/code&gt;只有server01是一个Leader节点.  其他节点都是普通节点.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\nwpx3o9mcpuq79ujpumykjkgt7 *   server01            Ready               Active              Leader              18.09.3\n1bz3t5imxc9evv4poh9o3o65l     server02            Ready               Active                                  18.09.0\nnuwhcuajlf71q4x23syi7tx06     server03            Ready               Active                                  18.02.0-ce\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过在&lt;code&gt;manager节点&lt;/code&gt;执行 &lt;code&gt;docker node promote 服务器名称&lt;/code&gt;, 可以将其他节点提升为manager节点.&lt;br&gt;\n可以看到执行之后, 另外两个work节点的&lt;code&gt;MANAGER STATUS&lt;/code&gt;也变成了&lt;code&gt;Reachable&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker node promote server02\nNode server02 promoted to a manager in the swarm.\nn-tech-admin@server01:~$ docker node promote server03\nNode server03 promoted to a manager in the swarm.\nn-tech-admin@server01:~$ docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\nwpx3o9mcpuq79ujpumykjkgt7 *   server01            Ready               Active              Leader              18.09.3\n1bz3t5imxc9evv4poh9o3o65l     server02            Ready               Active              Reachable           18.09.0\nnuwhcuajlf71q4x23syi7tx06     server03            Ready               Active              Reachable           18.02.0-ce\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;创建服务\&#34;&gt;创建服务&lt;/h2&gt;\n&lt;p&gt;我们在 &lt;code&gt;manager&lt;/code&gt;创建一个linux服务, 提供一个shell命令让他运行.&lt;br&gt;\n通过执行 &lt;code&gt;service ls&lt;/code&gt;命令, 可以看到刚才运行服务已经成功了.&lt;/p&gt;\n&lt;p&gt;还可以通过 &lt;code&gt;service inspect 服务名&lt;/code&gt; 查看服务的详细信息&lt;br&gt;\n通过 &lt;code&gt;service logs 服务名&lt;/code&gt; 查看服务的详细日志&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service create --name test01 alpine ping baidu.com\nruzuc9hqpyv6dpe6qk8jmlc12\noverall progress: 1 out of 1 tasks \n1/1: running   [==================================================&amp;gt;] \nverify: Service converged\n\n\nn-tech-admin@server01:~$ docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE               PORTS\nruzuc9hqpyv6        test01              replicated          1/1                 alpine:latest       \n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;接下来, 我们继续通过swarm创建一个nginx服务, 执行上面相同的命令, 创建完成后, 通过ls命令查看服务.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service create --name nginx nginx\nn6svunal14gc78uffbzn5rl76\noverall progress: 1 out of 1 tasks \n1/1: running   [==================================================&amp;gt;] \nverify: Service converged\n\nn-tech-admin@server01:~$ docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE               PORTS\nn6svunal14gc        nginx               replicated          1/1                 nginx:latest        \nruzuc9hqpyv6        test01              replicated          1/1                 alpine:latest       \n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;修改服务\&#34;&gt;修改服务&lt;/h2&gt;\n&lt;p&gt;我们发现, nginx没有对外端口, 我们可以通过 update 命令将nginx对外暴露一个端口&lt;br&gt;\n然后我们通过浏览器访问 server01, server02, server03三个服务器, 发现都能够得到正确的响应, 这是因为docker通过虚拟IP的方式帮我们访问到最终提供服务的nginx容器.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service update --publish-add 9967:80 nginx \nnginx\noverall progress: 1 out of 1 tasks \n1/1: running   [==================================================&amp;gt;] \nverify: Service converged\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;服务扩展\&#34;&gt;服务扩展&lt;/h2&gt;\n&lt;p&gt;docker为我们提供了 scale 命令, 可以对服务进行扩容, 我们通过 service scale nginx=3, 将nginx容器扩容到三个, 然后通过ls命令可以看到 &lt;code&gt;REPLICAS&lt;/code&gt; 已经变成了3/3.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service scale nginx=3\nnginx scaled to 3\noverall progress: 3 out of 3 tasks \n1/3: running   [==================================================&amp;gt;] \n2/3: running   [==================================================&amp;gt;] \n3/3: running   [==================================================&amp;gt;] \nverify: Service converged \n\nn-tech-admin@server01:~$ docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE               PORTS\nn6svunal14gc        nginx               replicated          3/3                 nginx:latest        *:9967-&amp;gt;80/tcp\nruzuc9hqpyv6        test01              replicated          1/1                 alpine:latest       \n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;服务间应用连通性\&#34;&gt;服务间应用连通性&lt;/h2&gt;\n&lt;p&gt;通过上面, 我们创建了 test01 服务和 nginx 服务, 然后我们通过 &lt;code&gt;exec -it&lt;/code&gt; 登录到 alpine 的 test01 服务, 通过 &lt;code&gt; ping nginx&lt;/code&gt; 发现不能连通, 说明默认模式下创建的服务, &lt;strong&gt;不具备服务之间的连通性&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;那么, 既然问题提出了, 下面就来说一下怎么解决.&lt;/p&gt;\n&lt;p&gt;首先, 我们创建一个 network, driver使用 overlay, 名字叫做 local-overlay. 如下&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker network create -d overlay local-overlay\n7lg34csui03vtcwie57pshodd\n\nn-tech-admin@server01:~$ docker network ls\nNETWORK ID          NAME                         DRIVER              SCOPE\ncdb39c520f0b        bridge                       bridge              local\nfd5e65ece1c7        docker_gwbridge              bridge              local\n501f1e83da67        harbor_harbor                bridge              local\neb06b54c7e76        host                         host                local\ntbsdc0m2p1le        ingress                      overlay             swarm\n7lg34csui03v        local-overlay                overlay             swarm\nf4e8f15f758b        none                         null                local\n82d08c922135        syncd                        bridge              local\n6b2cd023f92f        syncd-docker_syncd-network   bridge              local\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后我们删除上面创建的两个服务.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE               PORTS\nn6svunal14gc        nginx               replicated          3/3                 nginx:latest        *:9967-&amp;gt;80/tcp\nruzuc9hqpyv6        test01              replicated          1/1                 alpine:latest       \nn-tech-admin@server01:~$ docker service rm nginx test01 \nnginx\ntest01\nn-tech-admin@server01:~$ docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE               PORTS\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;接下来, 我们再次创建两个服务, 不过这次, 我们需要给服务指定网络使用 local-overlay&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~$ docker service create --name nginx --network local-overlay -p 9967:80 nginx\n9mtl0x99t67nxhllfh0ly2m43\noverall progress: 1 out of 1 tasks \n1/1: running   [==================================================&amp;gt;] \nverify: Service converged \n\nn-tech-admin@server01:~$ docker service create --name test02 --network local-overlay alpine ping baidu.com\n7fnhnrzrxu9ih9hpu4ysnfijw\noverall progress: 1 out of 1 tasks \n1/1: running   [==================================================&amp;gt;] \nverify: Service converged \n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后我们进入 test02 服务 的 alpine, 执行上面执行失败的 &lt;code&gt;ping&lt;/code&gt; 和 &lt;code&gt;wget&lt;/code&gt;, 我们发现, 所有的操作都已经能够正确执行了, 这是因为docker的vip为我们做了处理.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server02:~$ docker exec -it aa sh\n/ # ping nginx\nPING nginx (10.0.0.2): 56 data bytes\n64 bytes from 10.0.0.2: seq=0 ttl=64 time=0.105 ms\n64 bytes from 10.0.0.2: seq=1 ttl=64 time=0.100 ms\n64 bytes from 10.0.0.2: seq=2 ttl=64 time=0.070 ms\n^C\n--- nginx ping statistics ---\n3 packets transmitted, 3 packets received, 0% packet loss\nround-trip min/avg/max = 0.070/0.091/0.105 ms\n/ # wget nginx\nConnecting to nginx (10.0.0.2:80)\nindex.html           100% |********************************************************************************************************************************************************************************|   612  0:00:00 ETA\n/ # \n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;剔除集群中服务器\&#34;&gt;剔除集群中服务器&lt;/h2&gt;\n&lt;p&gt;如果想要移除集群中某一个服务器, 首先需要判断它是否是一台管理节点, 如果是管理节点, 首先需要将其降级为普通节点, 然后再执行删除命令&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;降级\ndocker node demote 节点的id\n\n删除\ndocker node rm 节点的id\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;stack\&#34;&gt;stack&lt;/h1&gt;\n&lt;p&gt;docker 为集群部署的一系列操作提供了 &lt;code&gt;stack&lt;/code&gt; 子命令, 方便一次操作.&lt;br&gt;\n首先我们需要准备一个 yml 文件, 里面包含了对服务的配置, 就和 &lt;code&gt;compose&lt;/code&gt; 文件一样, 不过比 compose文件多了一些对服务资源的限制.&lt;br&gt;\n我在这里提供一个文件. &lt;code&gt;external: true&lt;/code&gt;表示该网络已存在的意思.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;version: &amp;quot;3.4&amp;quot;\nservices:\n  alpine:\n    image: alpine\n    command:\n      - &amp;quot;ping&amp;quot;\n      - &amp;quot;www.bing.com&amp;quot;\n    networks:\n      - local-overlay\n    deploy:\n      endpoint_mode: dnsrr\n      replicas: 2\n      restart_policy:\n        condition: on-faliure\n      resources:\n        limits:\n          cpus: &amp;quot;0.1&amp;quot;\n          memory: &amp;quot;50M&amp;quot;\n    depends_on:\n      - nginx\n  nginx:\n    image: nginx\n    networks:\n      - local-overlay\n    ports:\n      - 9967:80\n\nnetworks:\n  local-overlay:\n    external: true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过 &lt;code&gt;stack deploy&lt;/code&gt;命令对服务进行部署. 通过 &lt;code&gt;stack service 服务名&lt;/code&gt; 查看服务详情, 通过 &lt;code&gt;stack ls&lt;/code&gt; 查看有多少个服务.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@server01:~/yzt_test_folder$ docker stack deploy -c service.yml test\nCreating service test_alpine\nCreating service test_nginx\n\nn-tech-admin@server01:~/yzt_test_folder$ docker stack ls\nNAME                SERVICES            ORCHESTRATOR\ntest                2                   Swarm\n\nn-tech-admin@server01:~/yzt_test_folder$ docker stack services test \nID                  NAME                MODE                REPLICAS            IMAGE               PORTS\n3vqmi2loytn6        test_alpine         replicated          2/2                 alpine:latest       \nwp7qiu0nbfol        test_nginx          replicated          1/1                 nginx:latest        *:9967-&amp;gt;80/tcp\n\nn-tech-admin@server01:~/yzt_test_folder$ docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE               PORTS\n3vqmi2loytn6        test_alpine         replicated          2/2                 alpine:latest       \nwp7qiu0nbfol        test_nginx          replicated          1/1                 nginx:latest        *:9967-&amp;gt;80/tcp\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;网络模式\&#34;&gt;网络模式&lt;/h1&gt;\n&lt;p&gt;docker 集群模式下默认使用 &lt;code&gt;vip&lt;/code&gt; 模式, 可以显示的指定使用 &lt;code&gt;dnsrr&lt;/code&gt;模式. 如在 stack 下, 可以在 deploy 子节点指定 &lt;code&gt;endpoint_mode: dnsrr&lt;/code&gt; 来修改网络模式.&lt;/p&gt;\n&lt;p&gt;vip: vip模式中每个服务都有一个固定的ip&lt;br&gt;\ndnsrr: dnsrr模式是没有固定ip的, 通过dns服务解析&lt;/p&gt;\n&lt;p&gt;查看服务的模式可以通过 &lt;code&gt;docker service inspect 服务名&lt;/code&gt;, 然后找到 &lt;code&gt;EndpointSpec&lt;/code&gt;节点即可查看.&lt;/p&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;通篇说了很多, 总结下来也就那么几个命令.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker swarm\ndocker network\ndocker service\ndocker node \ndocker stack\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-swarm-bian-pai-gong-ju&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;docker swarm编排工具&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-05-06 10:39:01&#34;,&#34;dateFormat&#34;:&#34;2019-05-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/docker-swarm-bian-pai-gong-ju/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;11 min read&#34;,&#34;time&#34;:633000,&#34;words&#34;:2257,&#34;minutes&#34;:11},&#34;description&#34;:&#34;Swarm介绍\nSwarm 是 Docker 公司在 2014 年 12 月初发布的一套较为简单的工具,用来管理 Docker 集群,它将一群 Docker 宿主机变成一个单一的,虚拟的主机。Swarm 使用标准的 Docker API接口...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#swarm%E4%BB%8B%E7%BB%8D\&#34;&gt;Swarm介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87\&#34;&gt;环境准备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4\&#34;&gt;搭建集群&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AAmanager%E8%8A%82%E7%82%B9\&#34;&gt;初始化一个manager节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4\&#34;&gt;在其他服务器输入命令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E7%9C%8Bdocker-network\&#34;&gt;查看docker network&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%AB%98%E5%8F%AF%E7%94%A8\&#34;&gt;高可用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1\&#34;&gt;创建服务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9%E6%9C%8D%E5%8A%A1\&#34;&gt;修改服务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95\&#34;&gt;服务扩展&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%8D%E5%8A%A1%E9%97%B4%E5%BA%94%E7%94%A8%E8%BF%9E%E9%80%9A%E6%80%A7\&#34;&gt;服务间应用连通性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%94%E9%99%A4%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9C%8D%E5%8A%A1%E5%99%A8\&#34;&gt;剔除集群中服务器&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#stack\&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F\&#34;&gt;网络模式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;作为技术人员, 平时常有和同事, 朋友讲述的时候, 针对平时常用的符号, 做一个汇总. 以免贻笑大方.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;中划线&lt;br&gt;\n写法: -&lt;br&gt;\n中文: 中划线&lt;br&gt;\n英文: dash&lt;br&gt;\n英文读法: &lt;a href=\&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=zh-CN&amp;amp;text=dash\&#34;&gt;dash-Google Translate&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;下划线&lt;br&gt;\n写法: _&lt;br&gt;\n中文: 中划线&lt;br&gt;\n英文: under score&lt;br&gt;\n英文读法: &lt;a href=\&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=zh-CN&amp;amp;text=under%20score\&#34;&gt;under score-Google Translate&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;反斜杠&lt;br&gt;\n写法: \\ &lt;br&gt;\n中文: 反斜杠&lt;br&gt;\n英文: Backslash&lt;br&gt;\n英文读音: &lt;a href=\&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=zh-CN&amp;amp;text=backslash\&#34;&gt;Backslash-Google Translate&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;斜杠&lt;br&gt;\n写法: /&lt;br&gt;\n中文: 斜杠&lt;br&gt;\n英文: slash&lt;br&gt;\n英文读音: &lt;a href=\&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=en&amp;amp;text=slash\&#34;&gt;slash-Google Translate&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;英文逗号&lt;br&gt;\n写法: .&lt;br&gt;\n中文: 逗号&lt;br&gt;\n英文: comma&lt;br&gt;\n英文读音: &lt;a href=\&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=en&amp;amp;tl=en&amp;amp;text=comma\&#34;&gt;comma-Google Translate&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;英文句号&lt;br&gt;\n写法: .&lt;br&gt;\n中文: 句号&lt;br&gt;\n英文: dot&lt;br&gt;\n英文读音: &lt;a href=\&#34;https://translate.google.cn/?hl=zh-CN&amp;amp;tab=TT#view=home&amp;amp;op=translate&amp;amp;sl=auto&amp;amp;tl=en&amp;amp;text=dot\&#34;&gt;dot-Google Translate&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;如有不对之处, 烦请指正&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;fu-hao-du-fa&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;符号读法&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-18 09:07:22&#34;,&#34;dateFormat&#34;:&#34;2019-04-18&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/fu-hao-du-fa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:38000,&#34;words&#34;:171,&#34;minutes&#34;:1},&#34;description&#34;:&#34;作为技术人员, 平时常有和同事, 朋友讲述的时候, 针对平时常用的符号, 做一个汇总. 以免贻笑大方.\n\n\n中划线\n写法: -\n中文: 中划线\n英文: dash\n英文读法: dash-Google Translate\n\n\n下划线\n写法: _...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;公司一个小demo将vue写的代码打包成apk, 运行在Android上面, apk实则是一个依赖&lt;code&gt;webview&lt;/code&gt;的网页, 所以能够通过和PC端的chrome进行远程调试. 有了PC端的调试, debug会更方便. 下面介绍如何进行操作.&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;打开手机端webview调试&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;code&gt;WebView.setWebContentsDebuggingEnabled(true);　&lt;/code&gt;&lt;/p&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;访问chrome的&lt;code&gt;chrome://inspect/#devices&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;a href=\&#34;http://chrome://inspect/#devices\&#34;&gt;chrome://inspect/#devices&lt;/a&gt;&lt;/p&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;选择要调试的应用. 点击&lt;code&gt;inspect&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/04/t88slb1p0ajl1ovqo8v86k3da7.jpg\&#34; alt=\&#34;调试\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;接下来就可以开开心心的调试运行在Android webview实现的apk了.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;chrome-webview-diao-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;chrome webview调试&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-17 17:35:30&#34;,&#34;dateFormat&#34;:&#34;2019-04-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/chrome-webview-diao-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:27000,&#34;words&#34;:122,&#34;minutes&#34;:1},&#34;description&#34;:&#34;公司一个小demo将vue写的代码打包成apk, 运行在Android上面, apk实则是一个依赖webview的网页, 所以能够通过和PC端的chrome进行远程调试. 有了PC端的调试, debug会更方便. 下面介绍如何进行操作.\n\n...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;问题的起因\&#34;&gt;问题的起因&lt;/h1&gt;\n&lt;p&gt;今天公司的一个小项目需要跑到Android上面，本身是通过token鉴权的，所以移植比较简单。但是在处理 跨域 问题的时候着实给踩了个大坑。&lt;br&gt;\n网上说的重写 &lt;code&gt;addCorsMapping&lt;/code&gt;等方法在一般处理上没有大问题. 但是在统一异常拦截器上面有很大的问题.&lt;br&gt;\nspring提供的跨域, 只是在响应是&lt;code&gt;Controller&lt;/code&gt;时生效, 而统一异常拦截器&lt;code&gt;ControllerAdvice&lt;/code&gt;是通过AOP处理的. 并且我们在很多时候需要通过自己的拦截器, 过滤器处理内容. 所以spring提供的跨域封装, 并不能很好的解决问题. 最后通过自己编写Filter解决了这个问题. 在此做一个小记录, 以后遇到需要跨域的问题时,直接使用此方法, 比使用spring封装的内容要好很多.&lt;/p&gt;\n&lt;p&gt;顺便提一下, 关于跨域时 &lt;code&gt;PUT&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;两个复杂请求的参数处理, 由于这两个请求在发起之前都会发起一个  &lt;code&gt;预请求&lt;/code&gt;, 具体可以看一下 &lt;a href=\&#34;https://segmentfault.com/q/1010000007442799\&#34;&gt;这篇博客&lt;/a&gt;, 如果不做处理的话, PUT请求将得不到参数. 具体处理方法也在下面代码区给出.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;:&lt;br&gt;\n是我太年轻, 统一异常拦截器还是没有办法正常的返回, 最后在统一异常拦截器的response上面加上了Origin的设置. 下面展示代码&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@CrossOrigin\nresponse.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;代码\&#34;&gt;代码&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;@WebFilter\npublic class CorsFilter extends OncePerRequestFilter {\n    private static final String ORIGIN = &amp;quot;Origin&amp;quot;;\n    private static final String HEADERS = &amp;quot;Access-Control-Request-Headers&amp;quot;;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n            throws ServletException, IOException {\n        // 获取请求头中的 &#39;Origin&#39; 信息\n        String origin = request.getHeader(ORIGIN);\n        // 获取请求头中的 &#39;header&#39; 信息\n        String headers = request.getHeader(HEADERS);\n\n        /**\n         * 1.支持任何域名跨域访问\n         * 当 &#39;Access-Control-Allow-Origin&#39; 设置为 &#39;*&#39; 时，不能解决带 Cookie 的跨域\n         */\n        if (!StringUtils.isEmpty(origin)) {\n            response.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;, origin);\n        }\n\n        /**\n         * 2.支持自定义请求头的跨域\n         */\n        if (!StringUtils.isEmpty(headers)) {\n            response.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;, headers);\n        }\n\n        // 3.设置支持带 Cookie 的跨域请求\n        response.setHeader(&amp;quot;Access-Control-Allow-Credentials&amp;quot;, &amp;quot;true&amp;quot;);\n        // 4.设置允许跨域请求的方法形式 &#39;GET&#39;、&#39;DELETE&#39; 等\n        response.setHeader(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;*&amp;quot;);\n        // 5.设置非简单请求的预检命令缓存时间，单位 &#39;s&#39;\n        response.setHeader(&amp;quot;Access-Control-Max-Age&amp;quot;, &amp;quot;1728000&amp;quot;);\n\n        if (&amp;quot;OPTIONS&amp;quot;.equals(request.getMethod())) {\n            response.setStatus(HttpServletResponse.SC_OK);\n        } else {\n            filterChain.doFilter(request, response);\n        }\n\n    }\n}\n\n\n\n针对PUT请求参数的处理\n@Component\npublic class PutFilter extends HttpPutFormContentFilter {\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-boot-cors&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring Boot Cors&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-16 20:07:41&#34;,&#34;dateFormat&#34;:&#34;2019-04-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-boot-cors/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:155000,&#34;words&#34;:630,&#34;minutes&#34;:3},&#34;description&#34;:&#34;问题的起因\n今天公司的一个小项目需要跑到Android上面，本身是通过token鉴权的，所以移植比较简单。但是在处理 跨域 问题的时候着实给踩了个大坑。\n网上说的重写 addCorsMapping等方法在一般处理上没有大问题. 但是在统一异...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E7%9A%84%E8%B5%B7%E5%9B%A0\&#34;&gt;问题的起因&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81\&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在使用springboot-data-redis的时候, 需要自定义序列化和反序列化. 由于经常使用, 所以写在这里留作备用. 序列化方法是从&lt;a href=\&#34;https://blog.csdn.net/moshowgame/article/details/83246363\&#34;&gt;CSDN博客&lt;/a&gt;上面找到的.&lt;/p&gt;\n&lt;p&gt;都是一些很简单的东西, 所以在这里就只做了代码记录, 没有太多文字性的东西.&lt;/p&gt;\n&lt;h1 id=\&#34;引入依赖\&#34;&gt;引入依赖&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;\n&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;1.2.57&amp;lt;/version&amp;gt;\n&amp;lt;/dependency&amp;gt;\n&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;2.9.8&amp;lt;/version&amp;gt;\n&amp;lt;/dependency&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;自定义序列化\&#34;&gt;自定义序列化&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * FastJson2JsonRedisSerializer\n *  Redis使用FastJson序列化\n *  by zhengkai.blog.csdn.net\n *  https://blog.csdn.net/moshowgame/article/details/83246363\n */\npublic class FastJson2JsonRedisSerializer&amp;lt;T&amp;gt; implements RedisSerializer&amp;lt;T&amp;gt; {\n\n    private ObjectMapper objectMapper = new ObjectMapper();\n    private static final Charset DEFAULT_CHARSET = Charset.forName(&amp;quot;UTF-8&amp;quot;);\n\n    private Class&amp;lt;T&amp;gt; clazz;\n\n    static {\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n        //如果遇到反序列化autoType is not support错误，请添加并修改一下包名到bean文件路径\n        // ParserConfig.getGlobalInstance().addAccept(&amp;quot;com.xxxxx.xxx&amp;quot;);\n    }\n\n    public FastJson2JsonRedisSerializer(Class&amp;lt;T&amp;gt; clazz) {\n        super();\n        this.clazz = clazz;\n    }\n\n    @Override\n    public byte[] serialize(T t) throws SerializationException {\n        if (t == null) {\n            return new byte[0];\n        }\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\n    }\n\n    @Override\n    public T deserialize(byte[] bytes) throws SerializationException {\n        if (bytes == null || bytes.length &amp;lt;= 0) {\n            return null;\n        }\n        String str = new String(bytes, DEFAULT_CHARSET);\n\n        return JSON.parseObject(str, clazz);\n    }\n    public void setObjectMapper(ObjectMapper objectMapper) {\n        Assert.notNull(objectMapper, &amp;quot;&#39;objectMapper&#39; must not be null&amp;quot;);\n        this.objectMapper = objectMapper;\n    }\n\n    protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz) {\n        return TypeFactory.defaultInstance().constructType(clazz);\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;设置到redis中\&#34;&gt;设置到redis中&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;@Configuration\n@EnableCaching\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n        RedisTemplate template = new RedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n\n        //使用FastJson2JsonRedisSerializer来序列化和反序列化redis的value值 by zhengkai\n        FastJson2JsonRedisSerializer serializer = new FastJson2JsonRedisSerializer(Object.class);\n\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        serializer.setObjectMapper(mapper);\n\n        template.setValueSerializer(serializer);\n        //使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;tong-yong-de-redis-xu-lie-hua&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;通用的redis序列化&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-16 16:24:08&#34;,&#34;dateFormat&#34;:&#34;2019-04-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/tong-yong-de-redis-xu-lie-hua/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:148000,&#34;words&#34;:466,&#34;minutes&#34;:3},&#34;description&#34;:&#34;在使用springboot-data-redis的时候, 需要自定义序列化和反序列化. 由于经常使用, 所以写在这里留作备用. 序列化方法是从CSDN博客上面找到的.\n都是一些很简单的东西, 所以在这里就只做了代码记录, 没有太多文字性的东...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\&#34;&gt;引入依赖&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96\&#34;&gt;自定义序列化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E7%BD%AE%E5%88%B0redis%E4%B8%AD\&#34;&gt;设置到redis中&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Windows显示文件占用, 贼烦. 原因是在文件夹内运行了adb命令.&lt;/p&gt;\n&lt;p&gt;解决方法:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Ctrl+Shift+Esc 打开任务管理器.&lt;/li&gt;\n&lt;li&gt;选择&lt;code&gt;性能&lt;/code&gt;标签&lt;/li&gt;\n&lt;li&gt;点击最下方的&lt;code&gt;打开资源监视器&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;选择&lt;code&gt;CPU&lt;/code&gt;标签&lt;/li&gt;\n&lt;li&gt;在&lt;code&gt;关联的句柄&lt;/code&gt;中搜索相关文件夹. 找到后右键&lt;code&gt;结束进程&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;附图:&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/04/48j4m621rghe0ocdhndc8otgle.jpg\&#34; alt=\&#34;第2,3步\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/04/0d0t2ubmk4hc9pgu4vt6hnll99.jpg\&#34; alt=\&#34;第4,5步\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;win-wen-jian-zhan-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;win 文件占用&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-16 14:45:25&#34;,&#34;dateFormat&#34;:&#34;2019-04-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/win-wen-jian-zhan-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:18000,&#34;words&#34;:86,&#34;minutes&#34;:1},&#34;description&#34;:&#34;Windows显示文件占用, 贼烦. 原因是在文件夹内运行了adb命令.\n解决方法:\n\nCtrl+Shift+Esc 打开任务管理器.\n选择性能标签\n点击最下方的打开资源监视器\n选择CPU标签\n在关联的句柄中搜索相关文件夹. 找到后右键结束...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;之前就有在公司内网搭建过私有docker仓库，这次接着看这个课程。 将搭建docker仓库的过程记录下来。&lt;/p&gt;\n&lt;h1 id=\&#34;下载镜像\&#34;&gt;下载镜像&lt;/h1&gt;\n&lt;p&gt;首选， 我们从 [docker仓库官网][1] 将docker官方提供的私有仓库的镜像找到, 然后通过 &lt;code&gt;pull&lt;/code&gt; 命令下载下来。&lt;br&gt;\n在仓库首页搜索 &lt;code&gt;regisrty&lt;/code&gt;，第一个就是官方提供的镜像。 找到 tag:2 ，将其复制到命令行界面。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ docker pull registry:2\n2: Pulling from library/registry\nc87736221ed0: Pull complete\n1cc8e0bb44df: Pull complete\n54d33bcb37f5: Pull complete\ne8afc091c171: Pull complete\nb4541f6d3db6: Pull complete\nDigest: sha256:3b00e5438ebd8835bcfa7bf5246445a6b57b9a50473e89c02ecc8e575be3ebb5\nStatus: Downloaded newer image for registry:2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;启动镜像\&#34;&gt;启动镜像&lt;/h1&gt;\n&lt;p&gt;完成镜像的下载之后, 肯定是要运行起来, docker官方给我们提供了启动命令. 通过运行下面的命令, 我们就能够看到私有仓库是运行起来了.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ docker run -d -p 5000:5000 --restart always --name registry registry:2\ndc8e14fcb2028bd1c354750a4647c139ac62d0662651bd3c974cbfd4667a9577\n\n\n$ docker ps|grep registry\ndc8e14fcb202        registry:2                   &amp;quot;/entrypoint.sh /etc…&amp;quot;   47 seconds ago      Up 47 seconds       0.0.0.0:5000-&amp;gt;5000/tcp   registry\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;推送镜像\&#34;&gt;推送镜像&lt;/h1&gt;\n&lt;p&gt;完成上面的操作，一个基本的本地私有的镜像仓库就算搭建完成了， 我们可以通过推送一个镜像到仓库中来测试是否成功。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;首先, 我们查看本地镜像, 找一个较小的alpine版本的jre试一下.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;$ docker images\nREPOSITORY            TAG                 IMAGE ID            CREATED             SIZE\nuser-edge-service     latest              8a4343ae292b        22 minutes ago      472MB\nuser-service          latest              5255cb130cfc        22 minutes ago      463MB\nmessage-service       latest              e8a0aa292277        About an hour ago   932MB\ncourse-edge-service   latest              93cdb20a805f        5 hours ago         470MB\ncourse-service        latest              0347264048f7        6 hours ago         468MB\napi-gateway-zuul      latest              66cde019cbaf        6 hours ago         476MB\npython-base           latest              018c9430d5e1        22 hours ago        932MB\nopenjdk               8-jre-alpine3.9     ce8477c7d086        2 days ago          84.9MB\nopenjdk               8-jre               d55d64383c12        2 weeks ago         443MB\npython                3.6                 2bb3204ab1d1        2 weeks ago         924MB\nregistry              2                   f32a97de94e1        5 weeks ago         25.8MB\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;通过 &lt;code&gt;docker tag&lt;/code&gt; 命令我们将本地的openjdk重新打包成 &lt;code&gt;localhost:5000/openjdk:8-jre-alpine3.9&lt;/code&gt; 镜像. 然后查看我们刚才打包的镜像.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;$ docker tag openjdk:8-jre-alpine3.9 localhost:5000/openjdk:8-jre-alpine3.9\n\n$ docker images|grep localhost:5000\nlocalhost:5000/openjdk   8-jre-alpine3.9     ce8477c7d086        2 days ago          84.9MB\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;最后, 通过 &lt;code&gt;docker push&lt;/code&gt;命令将我们刚才打包的镜像上传至本地仓库.  然后通过 &lt;code&gt;docker pull&lt;/code&gt;命令来验证是否上传成功.&lt;br&gt;\n通过最后打印的 &lt;font color=&#39;red&#39;&gt;Status: Image is up to date &lt;/font&gt; 可以看出我们的镜像已经成功上传并且能够成功下载下来了.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;$ docker push localhost:5000/openjdk:8-jre-alpine3.9\nThe push refers to repository [localhost:5000/openjdk]\naae5c057d1b6: Pushed\ndee6aef5c2b6: Pushed\na464c54f93a9: Pushed\n8-jre-alpine3.9: digest: sha256:922d65ba63c3cccb58c0a03e8bdfa86161c60c2aeb33db85d952d99c54f9662b size: 947\n\n$ docker pull localhost:5000/openjdk:8-jre-alpine3.9\n8-jre-alpine3.9: Pulling from openjdk\nDigest: sha256:922d65ba63c3cccb58c0a03e8bdfa86161c60c2aeb33db85d952d99c54f9662b\nStatus: Image is up to date for localhost:5000/openjdk:8-jre-alpine3.9\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;仓库页面\&#34;&gt;仓库页面&lt;/h1&gt;\n&lt;p&gt;有了上面的操作，我们这只算是完成了一个最基本的仓库功能。 它还没有页面。 在操作上还不是特别符合私有仓库的易用性。所以开源界有很多对 docker registry 做了界面开发， 其中非常不错的一个就是 VMware的 [harbor][2], 不过目前已经由 [goharbor][3] 组织负责维护了. 可以通过访问前面的链接, 下载 [Harbor offline installer][4] 版本. 下载速度还是非常不错的&lt;/p&gt;\n&lt;p&gt;下载完成后对压缩包进行解压. 然后进入harbor的目录修改它的配置文件 &lt;code&gt;harbor.cfg&lt;/code&gt;, 将 &lt;code&gt;hostname&lt;/code&gt; 修改为你想要配置的地址.其它参数上面都加上了注释, 可以具体去看.&lt;br&gt;\n下图我展示了我的配置.&lt;/p&gt;\n&lt;p&gt;![harbor.cfg配置][5]&lt;/p&gt;\n&lt;h2 id=\&#34;安装harbor\&#34;&gt;安装harbor&lt;/h2&gt;\n&lt;p&gt;&lt;font color=&#39;#EE3D11&#39;&gt;[Warning] 用Linux安装&lt;/font&gt;，在安装过程中会踩无数的坑。我再次记录几个。&lt;/p&gt;\n&lt;p&gt;首先我们将 docker-compose.yml 文件中的所有 &lt;code&gt;volumes&lt;/code&gt; 目录前面都加上 &lt;strong&gt;.&lt;/strong&gt;(当前目录), 防止文件乱窜，然后修改 &lt;code&gt;harbor.cfg&lt;/code&gt; 的 &lt;code&gt;secretkey_path=./data&lt;/code&gt;（设置当前目录）&lt;br&gt;\n接下来运行目录下面的 &lt;code&gt;install.sh&lt;/code&gt; 文件. 你会收到各种错误。。。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;错误一&lt;br&gt;\n你可能会收到下面的提示：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;OSError: [Errno 1] Operation not permitted: &#39;/data/secretkey&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;解决方法是将当前目录下面的 &lt;code&gt;data&lt;/code&gt; 目录 &lt;code&gt;chmod 777 data -R&lt;/code&gt;.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;错误二&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;[Step 2]: preparing environment ...\nloaded secret from file: ./data/secretkey\nTraceback (most recent call last):\n  File &amp;quot;./prepare&amp;quot;, line 220, in &amp;lt;module&amp;gt;\n    secret_key = get_secret_key(secretkey_path)\n  File &amp;quot;./prepare&amp;quot;, line 85, in get_secret_key\n    secret_key = _get_secret(path, &amp;quot;secretkey&amp;quot;) \n  File &amp;quot;./prepare&amp;quot;, line 100, in _get_secret\n    mark_file(key_file)\n  File &amp;quot;./prepare&amp;quot;, line 82, in mark_file\n    os.chown(path, uid, gid)\nOSError: [Errno 1] Operation not permitted: &#39;./data/secretkey&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;修改了权限之后还报这个错误的话, 用 sudo 运行 install命令, 基本上问题就不打了. 看到下面的信息, 就说明艰难的过程完成了.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;:heavy_check_mark: ----Harbor has been installed and started successfully.----\n\nNow you should be able to visit the admin portal at http://harbor.mooc.com:10001. \nFor more details, please visit https://github.com/goharbor/harbor .\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;查看harbor界面\&#34;&gt;查看Harbor界面&lt;/h2&gt;\n&lt;p&gt;完成上面的步骤, 我们就可以去访问Harbor的界面了. 默认用户名/密码: admin/Harbor12345&lt;/p&gt;\n&lt;h3 id=\&#34;创建用户\&#34;&gt;创建用户&lt;/h3&gt;\n&lt;p&gt;首先, 我们尝试着创建一个用户. 如图:&lt;/p&gt;\n&lt;p&gt;![创建用户][6]&lt;/p&gt;\n&lt;h3 id=\&#34;推送镜像-2\&#34;&gt;推送镜像&lt;/h3&gt;\n&lt;p&gt;然后, 我们通过对前面使用的openjdk再次打包, 对内容进行发布.推送到刚创建的harbor仓库中..&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;$ docker tag openjdk:8-jre-alpine3.9 harbor.mooc.com:800/micro-service/openjdk:8-jre-alpine3.9\n\n$ docker push harbor.mooc.com:800/micro-service/openjdk:8-jre-alpine3.9\n``\n\n----------\n\n\n  [1]: http://hub.docker.com\n  [2]: https://github.com/goharbor/harbo\n  [3]: https://github.com/goharbor\n  [4]: https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.5.tgz\n  [5]: http://blog.imyzt.top/upload/2019/04/ul8re7m8bmgodr71216uvlelvc.jpg\n  [6]: http://imyzt.top/upload/2019/04/usm33su6nuj6voqufj0l76pkl9.jpg&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;da-jian-docker-si-you-cang-ku&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;搭建docker私有仓库&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-12 16:23:29&#34;,&#34;dateFormat&#34;:&#34;2019-04-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/da-jian-docker-si-you-cang-ku/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:363000,&#34;words&#34;:1338,&#34;minutes&#34;:7},&#34;description&#34;:&#34;前言\n之前就有在公司内网搭建过私有docker仓库，这次接着看这个课程。 将搭建docker仓库的过程记录下来。\n下载镜像\n首选， 我们从 [docker仓库官网][1] 将docker官方提供的私有仓库的镜像找到, 然后通过 pull 命...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F\&#34;&gt;下载镜像&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%AF%E5%8A%A8%E9%95%9C%E5%83%8F\&#34;&gt;启动镜像&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F\&#34;&gt;推送镜像&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%93%E5%BA%93%E9%A1%B5%E9%9D%A2\&#34;&gt;仓库页面&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85harbor\&#34;&gt;安装harbor&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E7%9C%8Bharbor%E7%95%8C%E9%9D%A2\&#34;&gt;查看Harbor界面&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7\&#34;&gt;创建用户&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F-2\&#34;&gt;推送镜像&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;今天在学习docker课程的时候, 按照老师的配置, 怎么都不能访问到 api-gateway-zuul上面docker-compose的8080端口. 后来通过网络上搜索, 发现&lt;a href=\&#34;https://blog.csdn.net/qq_33212500/article/details/79412930\&#34;&gt;这篇文章&lt;/a&gt;的描述, 因为我使用的是 Windows 的 Docker Toolbox, 是在win上面运行了一个linux. 所以不是能够直接 &lt;code&gt;127.0.0.1&lt;/code&gt; 访问得到的. 然后通过访问 &lt;code&gt;192.168.99.100&lt;/code&gt; 得到了内容&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;192.168.99.100&lt;/code&gt;的IP是通过&lt;code&gt;docker-machine ip default&lt;/code&gt;命令获取的&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;win-docker-toolbox-wen-ti&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;win docker toolbox 问题&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-12 13:35:02&#34;,&#34;dateFormat&#34;:&#34;2019-04-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/win-docker-toolbox-wen-ti/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:28000,&#34;words&#34;:122,&#34;minutes&#34;:1},&#34;description&#34;:&#34;今天在学习docker课程的时候, 按照老师的配置, 怎么都不能访问到 api-gateway-zuul上面docker-compose的8080端口. 后来通过网络上搜索, 发现这篇文章的描述, 因为我使用的是 Windows 的 Doc...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;最近在看慕课网上的&lt;code&gt;Docker+Kubernetes(k8s)微服务容器化实战&lt;/code&gt;, 在微服务搭建过程中, 由于老师的一些代码已经过去了一年多了, 很多内容都不适用于现在的版本了, 一路踩坑过来, 今天在redis上面踩了一个坑才走出来, 又踩了另一个MySQL的坑. 在此记录一下解决过程.&lt;/p&gt;\n&lt;h1 id=\&#34;错误详情\&#34;&gt;错误详情&lt;/h1&gt;\n&lt;p&gt;在下方的错误日志, 最后一行&lt;code&gt;SQLErrorCodesFactory&lt;/code&gt;抛出了一个异常, 异常的大致意思就是不知道数据库类型. 然后程序就停在这里了. 导致其他的微服务无法调用, 然后超时了.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  .   ____          _            __ _ _\n /\\\\ / ___&#39;_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  &#39;  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.5.3.RELEASE)\n\n2019-04-10 17:22:13.197  INFO 20916 --- [           main] top.imyzt.user.ServiceApplication        : Starting ServiceApplication on DESKTOP-O8GDJEI with PID 20916 (D:\\dev\\imyzt\\micro-service\\user-thrift-service\\target\\classes started by n-tech in D:\\dev\\imyzt\\micro-service)\n2019-04-10 17:22:13.201  INFO 20916 --- [           main] top.imyzt.user.ServiceApplication        : No active profile set, falling back to default profiles: default\n2019-04-10 17:22:13.247  INFO 20916 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@71e9ebae: startup date [Wed Apr 10 17:22:13 CST 2019]; root of context hierarchy\n2019-04-10 17:22:32.354  INFO 20916 --- [       Thread-4] o.s.b.f.xml.XmlBeanDefinitionReader      : Loading XML bean definitions from class path resource [org/springframework/jdbc/support/sql-error-codes.xml]\n2019-04-10 17:22:32.410  INFO 20916 --- [       Thread-4] o.s.jdbc.support.SQLErrorCodesFactory    : SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase, Hana]\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;解决方法\&#34;&gt;解决方法&lt;/h1&gt;\n&lt;p&gt;通过Google, 出现此问题多为数据库字段和SQL或dao中的不一样造成的.&lt;br&gt;\n原解答: &lt;a href=\&#34;http://www.zhimengzhe.com/shujuku/Oracle/30519.html\&#34;&gt;http://www.zhimengzhe.com/shujuku/Oracle/30519.html&lt;/a&gt;,   如果出现了此类问题, 先在数据库认真排查一下数据库字段是否一致.&lt;br&gt;\n我在排查的过程中是因为我将 &lt;code&gt;TeacherDTO&lt;/code&gt; 对应 数据库&lt;code&gt;pe_teacher&lt;/code&gt;的 &lt;code&gt;stars&lt;/code&gt; 错写成了 &lt;code&gt;starts&lt;/code&gt;, 造成了数据库一直报错, 导致整个服务链路抛异常.&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/04/65pldi4m2aijhoo2q98nrv02ff.jpg\&#34; alt=\&#34;成功后查询课程列表的结果\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;springboot-qi-dong-shu-ju-ku-cuo-wu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;SpringBoot 启动数据库错误&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-10 18:34:24&#34;,&#34;dateFormat&#34;:&#34;2019-04-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/springboot-qi-dong-shu-ju-ku-cuo-wu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:137000,&#34;words&#34;:493,&#34;minutes&#34;:3},&#34;description&#34;:&#34;最近在看慕课网上的Docker+Kubernetes(k8s)微服务容器化实战, 在微服务搭建过程中, 由于老师的一些代码已经过去了一年多了, 很多内容都不适用于现在的版本了, 一路踩坑过来, 今天在redis上面踩了一个坑才走出来, 又踩...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%94%99%E8%AF%AF%E8%AF%A6%E6%83%85\&#34;&gt;错误详情&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\&#34;&gt;解决方法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;纳粹杀共产党时，&lt;br&gt;\n我没有出声&lt;br&gt;\n——因为我不是共产党员；&lt;br&gt;\n接着他们迫害犹太人，&lt;br&gt;\n我没有出声&lt;br&gt;\n——因为我不是犹太人；&lt;br&gt;\n然后他们杀工会成员，&lt;br&gt;\n我没有出声&lt;br&gt;\n——因为我不是工会成员；&lt;br&gt;\n后来他们迫害天主教徒，&lt;br&gt;\n我没有出声&lt;br&gt;\n——因为我是新教徒；&lt;br&gt;\n最后当他们开始对付我的时候，&lt;br&gt;\n已经没有人能站出来为我发声了&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;lesslesswo-mei-you-shuo-hua-greatergreater&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;《我没有说话》&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-04 09:53:16&#34;,&#34;dateFormat&#34;:&#34;2019-04-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/lesslesswo-mei-you-shuo-hua-greatergreater/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:23000,&#34;words&#34;:115,&#34;minutes&#34;:1},&#34;description&#34;:&#34;纳粹杀共产党时，\n我没有出声\n——因为我不是共产党员；\n接着他们迫害犹太人，\n我没有出声\n——因为我不是犹太人；\n然后他们杀工会成员，\n我没有出声\n——因为我不是工会成员；\n后来他们迫害天主教徒，\n我没有出声\n——因为我是新教徒；\n最后当他...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;ol&gt;\n&lt;li&gt;通过端口号找到进程号&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;评论区老哥说win上面没有&lt;code&gt;grep&lt;/code&gt;命令, 由于我用的是&lt;a href=\&#34;https://cmder.net/\&#34;&gt;Cmder&lt;/a&gt;是包含&lt;code&gt;grep&lt;/code&gt;命令的, 在win上面可以使用&lt;code&gt;findstr&lt;/code&gt;用来做内容过滤.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code&gt;netstat -aon|grep 端口号 \ntasklist.exe | findstr 端口号 \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;通过进程号杀掉进程&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;taskkill -PID 进程号 -F \n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;win-chang-yong-ming-ling-ji&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;win 常用命令集&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-03 18:47:03&#34;,&#34;dateFormat&#34;:&#34;2019-04-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/win-chang-yong-ming-ling-ji/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:17000,&#34;words&#34;:78,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n通过端口号找到进程号\n\n\n评论区老哥说win上面没有grep命令, 由于我用的是Cmder是包含grep命令的, 在win上面可以使用findstr用来做内容过滤.\n\nnetstat -aon|grep 端口号 \ntasklist.exe...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;修改 &lt;code&gt;System.out.println()&lt;/code&gt; 的输出内容到文件. (改变System.out的标准输出流)&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;public class ChangeOut {\n    public static void main(String args[]) {\n        try {\n            System.setOut(new PrintStream(new FileOutputStream(&amp;quot;log.txt&amp;quot;)));\n            System.out.println(&amp;quot;Now the output is redirected!&amp;quot;);\n        } catch(Exception e) {}\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;文章来源: &lt;a href=\&#34;https://mp.weixin.qq.com/s/dEuOL9EwhM-fipDxz9KNnw\&#34;&gt;码农每日一题&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;sop&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;SOP&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-03 08:27:08&#34;,&#34;dateFormat&#34;:&#34;2019-04-03&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/sop/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:19000,&#34;words&#34;:66,&#34;minutes&#34;:1},&#34;description&#34;:&#34;修改 System.out.println() 的输出内容到文件. (改变System.out的标准输出流)\npublic class ChangeOut {\n    public static void main(String args[...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;driver-package\&#34;&gt;driver package&lt;/h1&gt;\n&lt;h2 id=\&#34;mysql8\&#34;&gt;MySQL8&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;com.mysql.cj.jdbc.Driver\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;mysql5\&#34;&gt;MySQL5&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;com.mysql.jdbc.Driver\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;jdbc-url\&#34;&gt;JDBC URL&lt;/h1&gt;\n&lt;h2 id=\&#34;mysql8-2\&#34;&gt;MySQL8&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;jdbc:mysql://localhost:3306/test?useSSL=false&amp;amp;serverTimezone=UTC\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;mysql5-2\&#34;&gt;MySQL5&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;jdbc:mysql://localhost:3306/test?user=root&amp;amp;password=&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&amp;amp;autoReconnect=true&amp;amp;failOverReadOnly=false\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-jdbc-url&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL JDBC URL&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-04-01 17:31:40&#34;,&#34;dateFormat&#34;:&#34;2019-04-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-jdbc-url/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:18000,&#34;words&#34;:48,&#34;minutes&#34;:1},&#34;description&#34;:&#34;driver package\nMySQL8\ncom.mysql.cj.jdbc.Driver\n\nMySQL5\ncom.mysql.jdbc.Driver\n\nJDBC URL\nMySQL8\njdbc:mysql://localhost:330...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#driver-package\&#34;&gt;driver package&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#mysql8\&#34;&gt;MySQL8&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#mysql5\&#34;&gt;MySQL5&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jdbc-url\&#34;&gt;JDBC URL&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#mysql8-2\&#34;&gt;MySQL8&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#mysql5-2\&#34;&gt;MySQL5&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;本课程是 &lt;code&gt;docker+kuberneter微服务容器化实战&lt;/code&gt; 系列课程的学习笔记. 用于记录学习过程中遇到的一些问题.&lt;/p&gt;\n&lt;h1 id=\&#34;课程项目架构图\&#34;&gt;课程项目架构图&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/03/su23t24230h6dob41lslrn0jro.png\&#34; alt=\&#34;课程项目架构图1.0\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;thrift\&#34;&gt;thrift&lt;/h1&gt;\n&lt;p&gt;微服务开发过程中必定牵扯的就是服务调用, 课程中使用了 &lt;code&gt;thrift&lt;/code&gt; 和 &lt;code&gt;dubbo&lt;/code&gt; 作服务调用.&lt;br&gt;\nthrift的主要优势就是他是语言无关的, 可以在多语言系统中使用.下面通过课程的讲解, 简单记录一下thrift的使用.&lt;/p&gt;\n&lt;h2 id=\&#34;thrift的安装\&#34;&gt;thrift的安装&lt;/h2&gt;\n&lt;p&gt;在apache官网&lt;a href=\&#34;http://thrift.apache.org/\&#34;&gt;下载thrift&lt;/a&gt;, 将thrift配置到Path变量中.&lt;br&gt;\n在命令行输入 &lt;code&gt;thrift --version&lt;/code&gt;, 如果看到版本信息, 则安装成功.&lt;/p&gt;\n&lt;h2 id=\&#34;thrift的简单使用\&#34;&gt;thrift的简单使用.&lt;/h2&gt;\n&lt;p&gt;thrift的使用也非常简单,&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;首先我们定义好接口.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;echo &#39;开始生成&#39;\n\nthrift --gen py -out ../ message.thrift\n\nthrift --gen java -out ../../message-thrift-service-api/src/main/java message.thrift\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;然后通过运行这个脚本, 就可以得到对应的语言版本的工具类.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;问题解决\&#34;&gt;问题解决&lt;/h1&gt;\n&lt;p&gt;架构图中的&lt;code&gt;信息服务&lt;/code&gt;使用python开发, 由于之前没怎么接触过py, 开发过程中遇到了一些问题.&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;引入包报错, 需要通过pip安装系统需要的thrift包.&lt;br&gt;\n&lt;code&gt;python -m pip install thrift&lt;/code&gt;&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/03/2leg3ss9eajniq7tofsi9hln12.jpg\&#34; alt=\&#34;报错\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;wei-fu-wu-kai-fa-wei-fu-wu-rong-qi-hua-shi-zhan-xi-lie-ke-cheng&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;微服务开发(微服务容器化实战系列课程)&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-27 17:28:11&#34;,&#34;dateFormat&#34;:&#34;2019-03-27&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/wei-fu-wu-kai-fa-wei-fu-wu-rong-qi-hua-shi-zhan-xi-lie-ke-cheng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:68000,&#34;words&#34;:304,&#34;minutes&#34;:2},&#34;description&#34;:&#34;前言\n本课程是 docker+kuberneter微服务容器化实战 系列课程的学习笔记. 用于记录学习过程中遇到的一些问题.\n课程项目架构图\n\nthrift\n微服务开发过程中必定牵扯的就是服务调用, 课程中使用了 thrift 和 dubb...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E5%9B%BE\&#34;&gt;课程项目架构图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#thrift\&#34;&gt;thrift&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#thrift%E7%9A%84%E5%AE%89%E8%A3%85\&#34;&gt;thrift的安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#thrift%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8\&#34;&gt;thrift的简单使用.&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3\&#34;&gt;问题解决&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;原文地址:&lt;a href=\&#34;https://www.cnblogs.com/landiljy/p/5764515.html\&#34;&gt;https://www.cnblogs.com/landiljy/p/5764515.html&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;@PostConstruct说明&lt;/p&gt;\n&lt;p&gt;被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的init()方法。被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。&lt;/p&gt;\n&lt;p&gt;@PreDestroy说明&lt;/p&gt;\n&lt;p&gt;被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前。&lt;/p&gt;\n&lt;p&gt;执行顺序: Constructor &amp;gt;&amp;gt; @Autowired &amp;gt;&amp;gt; @PostConstruct&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;http://ww1.sinaimg.cn/large/005SWfHCgy1g1amxq5d5lj306c0d0glj.jpg\&#34; alt=\&#34;执行顺序\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n图源地址: &lt;a href=\&#34;https://www.jianshu.com/p/98cf7d8b9ec3\&#34;&gt;https://www.jianshu.com/p/98cf7d8b9ec3&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;postconstruct-predestory&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;@PostConstruct, @PreDestory&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-21 19:21:05&#34;,&#34;dateFormat&#34;:&#34;2019-03-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/postconstruct-predestory/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:37000,&#34;words&#34;:161,&#34;minutes&#34;:1},&#34;description&#34;:&#34;原文地址:https://www.cnblogs.com/landiljy/p/5764515.html\n@PostConstruct说明\n被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;原文地址: &lt;a href=\&#34;https://www.cnblogs.com/chenfeng1122/p/6270217.html\&#34;&gt;https://www.cnblogs.com/chenfeng1122/p/6270217.html&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;@Autowired注解和静态方法&lt;/p&gt;\n&lt;p&gt;一、业务场景&lt;/p&gt;\n&lt;p&gt;spring框架应用中有些静态方法需要依赖被容器管理的类，就像这样：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Component\npublic class Test {\n    \n    @Autowired\n    private static UserService userService;\n    \n    public static void test() {\n        userService.test();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样一定会报java.lang.NullPointerException: null异常。&lt;/p&gt;\n&lt;p&gt;二、原理剖析&lt;/p&gt;\n&lt;p&gt;&lt;font color=&#39;red&#39;&gt;静态变量、类变量不是对象的属性，而是一个类的属性，所以静态方法是属于类（class）的，普通方法才是属于实体对象（也就是New出来的对象）的，spring注入是在容器中实例化对象，所以不能使用静态方法。&lt;/font&gt;&lt;/p&gt;\n&lt;p&gt;而使用静态变量、类变量扩大了静态方法的使用范围。静态方法在spring是不推荐使用的，依赖注入的主要目的,是让容器去产生一个对象的实例,然后在整个生命周期中使用他们，同时也让testing工作更加容易。&lt;/p&gt;\n&lt;p&gt;一旦你使用静态方法,就不再需要去产生这个类的实例,这会让testing变得更加困难，同时你也不能为一个给定的类，依靠注入方式去产生多个具有不同的依赖环境的实例，这种static field是隐含共享的，并且是一种global全局状态，spring同样不推荐这样去做。&lt;/p&gt;\n&lt;p&gt;三、解决方法&lt;/p&gt;\n&lt;p&gt;1、将@Autowire加到构造方法上&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Component\npublic class Test {\n    \n    private static UserService userService;\n    \n    @Autowired\n    public Test(UserService userService) {\n        Test.userService = userService;\n    }\n    \n    public static void test() {\n        userService.test();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2、用@PostConstruct注解&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Component\npublic class Test {\n    \n    private static UserService userService;\n    \n    @Autowired\n    private UserService userService2;\n    \n    @PostConstruct\n    public void beforeInit() {\n        userService = userService2;\n    }\n    \n    public static void test() {\n        userService.test();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-autowired-yu-static-method&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring @Autowired与static method&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-21 19:14:07&#34;,&#34;dateFormat&#34;:&#34;2019-03-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-autowired-yu-static-method/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:97000,&#34;words&#34;:411,&#34;minutes&#34;:2},&#34;description&#34;:&#34;原文地址: https://www.cnblogs.com/chenfeng1122/p/6270217.html\n@Autowired注解和静态方法\n一、业务场景\nspring框架应用中有些静态方法需要依赖被容器管理的类，就像这样：\n@C...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;缘起\&#34;&gt;缘起&lt;/h1&gt;\n&lt;p&gt;我们在使用Spring的时候，通常会直接在 Controller 的 handler（自定义的接口）中填写 &lt;code&gt;HttpServletRequest&lt;/code&gt;, &lt;code&gt;HttpServletResponse&lt;/code&gt;, &lt;code&gt;Model&lt;/code&gt;, &lt;code&gt;HttpSession&lt;/code&gt;，并且在方法中使用时对象是可以使用的。&lt;br&gt;\n之前我一直好奇， 这是什么原理。通过这次在学习慕课网的&lt;a href=\&#34;https://coding.imooc.com/class/chapter/168.html\&#34;&gt;Java秒杀系统方案优化 高性能高并发实战&lt;/a&gt; 时，老师的讲解是我终于不是只会用，不知其如何实现了。&lt;/p&gt;\n&lt;h1 id=\&#34;原理\&#34;&gt;原理&lt;/h1&gt;\n&lt;p&gt;Spring给我们使用者预留了一个接口 &lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt;，通过实现这个接口， 覆盖它的 &lt;code&gt;supportsParameter&lt;/code&gt; 和 &lt;code&gt;resolveArgument&lt;/code&gt; 方法, 我们就可以将自己想要的对象在方法入参处自动注入了. Spring官方的名称叫做 &lt;strong&gt;自定义参数解析&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;在学习课程的过程中, 我们很多的方法都需要一个 &lt;code&gt;MiaoshaUser&lt;/code&gt; 对象, 下面我们结合实际需求, 通过代码展示的方式一步一步实现这个看起来很酷的功能.&lt;/p&gt;\n&lt;h1 id=\&#34;给我也整一个\&#34;&gt;给我也整一个&lt;/h1&gt;\n&lt;h2 id=\&#34;第一步\&#34;&gt;第一步&lt;/h2&gt;\n&lt;p&gt;首先我们编写一个 &lt;code&gt;UserArgumentResolver&lt;/code&gt; 类, 使其实现 &lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt; 接口. 并且通过 &lt;code&gt;@Component&lt;/code&gt; 注解将它标记为Spring管理的Bean&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/3/9 16:53\n * @description 实现此方法, 将自动对方法入参包含 {@link MiaoshaUser} 的对象的进行注入\n */\n@Component\npublic class UserArgumentResolver implements HandlerMethodArgumentResolver {\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;第二步\&#34;&gt;第二步&lt;/h2&gt;\n&lt;p&gt;我们需要覆盖它的两个方法&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/3/9 16:53\n * @description 实现此方法, 将自动对方法入参包含 {@link MiaoshaUser} 的对象的进行注入\n */\n@Component\npublic class UserArgumentResolver implements HandlerMethodArgumentResolver {\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        Class &amp;lt;?&amp;gt; parameterType = parameter.getParameterType();\n        return parameterType == MiaoshaUser.class;\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter parameter,\n                                  ModelAndViewContainer mavContainer,\n                                  NativeWebRequest webRequest,\n                                  WebDataBinderFactory binderFactory) {\n        return UserContext.getUser();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;supportsparameter\&#34;&gt;supportsParameter()&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;supportsParameter()&lt;/code&gt; 方法中判断请求参数是否被 &lt;code&gt;HandlerMethodArgumentResolver &lt;/code&gt; 支持, 它的判断依据非常多, 具体可以查看 &lt;code&gt;org.springframework.core.MethodParameter&lt;/code&gt; 的源代码找到合适自己业务的匹配方法. 我这里通过 &lt;code&gt;getParameterType()&lt;/code&gt; 方法获取了参数类型, 只要是参数类型是 &lt;code&gt;MiaoshaUser.class&lt;/code&gt; 的就表示我编写的 &lt;code&gt;UserArgumentResolver &lt;/code&gt; 解析类支持处理该方法入参. 下面开始下一个具体处理方法.&lt;/p&gt;\n&lt;h2 id=\&#34;resolveargument\&#34;&gt;resolveArgument(...)&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;resolveArgument(...)&lt;/code&gt; 方法及自定义参数解析的核心处理方法. Spring通过调用该方法将参数值注入到上面 &lt;code&gt;supportsParameter()&lt;/code&gt; 支持的方法入参上面去.&lt;br&gt;\n我这里的处理方法比较简单, 因为我的用户信息在上一步的拦截器中已经保存在 &lt;code&gt;UserContext&lt;/code&gt; 用户上下文信息中. 所以只需要 &lt;code&gt;getUser()&lt;/code&gt; 即可获取用户信息.&lt;/p&gt;\n&lt;p&gt;在这里备注一下, 我们可以通过 &lt;code&gt;webRequest&lt;/code&gt; 获取到当前请求的Request和Response信息. 代码如下&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\nHttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;通过学习慕课上面的这个项目, 对于我这种没有接触过互联网项目的人来说, 是一个互联网开发扫盲. 里面的很多东西还是非常不错的. 在学习这个项目的过程中. 写了一些小笔记, 不在于实现, 而是一些思路. 项目地址: &lt;a href=\&#34;https://github.com/imyzt/imooc_miaosha\&#34;&gt;github&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-zi-ding-yi-can-shu-jie-xi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring 自定义参数解析&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-21 17:42:02&#34;,&#34;dateFormat&#34;:&#34;2019-03-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-zi-ding-yi-can-shu-jie-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:172000,&#34;words&#34;:764,&#34;minutes&#34;:3},&#34;description&#34;:&#34;缘起\n我们在使用Spring的时候，通常会直接在 Controller 的 handler（自定义的接口）中填写 HttpServletRequest, HttpServletResponse, Model, HttpSession，并且在...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%98%E8%B5%B7\&#34;&gt;缘起&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E7%90%86\&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%99%E6%88%91%E4%B9%9F%E6%95%B4%E4%B8%80%E4%B8%AA\&#34;&gt;给我也整一个&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%B8%80%E6%AD%A5\&#34;&gt;第一步&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%BA%8C%E6%AD%A5\&#34;&gt;第二步&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#supportsparameter\&#34;&gt;supportsParameter()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#resolveargument\&#34;&gt;resolveArgument(...)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;1.0+版本是有的. 在2.0+版本去除了. 官方&lt;a href=\&#34;https://github.com/thymeleaf/thymeleaf/issues/420\&#34;&gt;issues&lt;/a&gt;给出了原因, 是为了优化依赖结构.区分边界.&lt;/p&gt;\n&lt;p&gt;可通过 &lt;code&gt;org.thymeleaf.context.WebContext&lt;/code&gt; 方法得到同样的结果.&lt;/p&gt;\n&lt;p&gt;参考: &lt;a href=\&#34;https://blog.csdn.net/wilsonsong1024/article/details/81535860\&#34;&gt;https://blog.csdn.net/wilsonsong1024/article/details/81535860#2评论&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-boot-20-wu-fa-zhao-dao-springwebcontext&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;spring boot 2.0+ 无法找到SpringWebContext&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-18 17:42:48&#34;,&#34;dateFormat&#34;:&#34;2019-03-18&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-boot-20-wu-fa-zhao-dao-springwebcontext/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:16000,&#34;words&#34;:65,&#34;minutes&#34;:1},&#34;description&#34;:&#34;1.0+版本是有的. 在2.0+版本去除了. 官方issues给出了原因, 是为了优化依赖结构.区分边界.\n可通过 org.thymeleaf.context.WebContext 方法得到同样的结果.\n参考: https://blog.c...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;简单测试\&#34;&gt;简单测试&lt;/h1&gt;\n&lt;p&gt;redis自带了并发测试工具 &lt;code&gt;redis-benchmark&lt;/code&gt;, 只需要携带几个简单的参数就可以完成redis的压力测试.&lt;/p&gt;\n&lt;h2 id=\&#34;并发测试\&#34;&gt;并发测试&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;redis-benchmark.exe -h 127.0.0.1 -p 6379 -c 100 -n 100000\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的命令意思是使用 100 的并发,发起 10w 次请求&lt;/p&gt;\n&lt;h3 id=\&#34;结果分析\&#34;&gt;结果分析&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;====== GET ======                           \n  100000 requests completed in 0.98 seconds \n  100 parallel clients                      \n  3 bytes payload                           \n  keep alive: 1                             \n                                            \n60.40% &amp;lt;= 1 milliseconds                    \n99.66% &amp;lt;= 2 milliseconds                    \n99.88% &amp;lt;= 3 milliseconds                    \n99.99% &amp;lt;= 4 milliseconds                    \n100.00% &amp;lt;= 4 milliseconds                   \n102249.49 requests per second               \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;比如上面的就是执行了 &lt;code&gt;get&lt;/code&gt; 命令, 10w次请求在0.98s 执行完毕. 使用了100个客户端, 每次使用了 3个字节负载&lt;br&gt;\n其中 60.40% 在1ms 执行完毕.....&lt;/p&gt;\n&lt;h2 id=\&#34;大数据测试\&#34;&gt;大数据测试&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;redis-benchmark.exe -h 127.0.0.1 -p 6379 -q -d 200\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面命令的意思是 一次数据包200字节, 结果做简单输出&lt;/p&gt;\n&lt;h3 id=\&#34;结果分析-2\&#34;&gt;结果分析&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;PING_INLINE: 104821.80 requests per second\nPING_BULK: 113895.21 requests per second\nSET: 102459.02 requests per second\nGET: 110253.59 requests per second\nINCR: 110011.00 requests per second\nLPUSH: 91996.32 requests per second\nRPUSH: 94786.73 requests per second\nLPOP: 94428.70 requests per second\nRPOP: 93984.96 requests per second\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中 &lt;code&gt;SET: 102459.02 requests per second&lt;/code&gt; 表示每秒执行了10w+次请求&lt;/p&gt;\n&lt;h2 id=\&#34;部分命令测试\&#34;&gt;部分命令测试&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;redis-benchmark.exe -h 127.0.0.1 -p 6379 -t set,get -q -n 100000\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面命令的意思是对 &lt;code&gt;set,get&lt;/code&gt; 两个命令做 10w 次请求测试, 结果做简单输出&lt;/p&gt;\n&lt;h3 id=\&#34;结果分析-3\&#34;&gt;结果分析&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;SET: 97656.24 requests per second\nGET: 108813.92 requests per second\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中 &lt;code&gt;GET: 108813.92 requests per second&lt;/code&gt; 表示每秒执行了10w+次 &lt;code&gt;get&lt;/code&gt; 操作&lt;/p&gt;\n&lt;h2 id=\&#34;只测试某种命令\&#34;&gt;只测试某种命令&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;redis-benchmark.exe -h 127.0.0.1 -p 6379 -n 100000 -q script load &amp;quot;redis.call(&#39;set&#39;,&#39;name&#39;,&#39;yzt&#39;)&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面命令的意思是只测试 &lt;code&gt;set name yzt&lt;/code&gt; 这一个命令的速度&lt;/p&gt;\n&lt;h3 id=\&#34;结果分析-4\&#34;&gt;结果分析&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;script load redis.call(&#39;set&#39;,&#39;name&#39;,&#39;yzt&#39;): 82644.63 requests per second\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果表示当前命令一秒钟可以完成 8w+ 次操作&lt;/p&gt;\n&lt;h1 id=\&#34;参数详解\&#34;&gt;参数详解&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;-h, -p： 不解释&lt;/li&gt;\n&lt;li&gt;-c： 并发数&lt;/li&gt;\n&lt;li&gt;-n： 请求数&lt;/li&gt;\n&lt;li&gt;-q： 简单结果输出&lt;/li&gt;\n&lt;li&gt;-d 100： 100字节的负载&lt;/li&gt;\n&lt;li&gt;-t set：只测试set&lt;/li&gt;\n&lt;li&gt;script load：只测试某个脚本&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;redis-bing-fa-ce-shi-gong-ju-shi-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;redis并发测试工具使用&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-15 11:18:00&#34;,&#34;dateFormat&#34;:&#34;2019-03-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/redis-bing-fa-ce-shi-gong-ju-shi-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:145000,&#34;words&#34;:518,&#34;minutes&#34;:3},&#34;description&#34;:&#34;简单测试\nredis自带了并发测试工具 redis-benchmark, 只需要携带几个简单的参数就可以完成redis的压力测试.\n并发测试\nredis-benchmark.exe -h 127.0.0.1 -p 6379 -c 100 -...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95\&#34;&gt;简单测试&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95\&#34;&gt;并发测试&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90\&#34;&gt;结果分析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95\&#34;&gt;大数据测试&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90-2\&#34;&gt;结果分析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95\&#34;&gt;部分命令测试&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90-3\&#34;&gt;结果分析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%AA%E6%B5%8B%E8%AF%95%E6%9F%90%E7%A7%8D%E5%91%BD%E4%BB%A4\&#34;&gt;只测试某种命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90-4\&#34;&gt;结果分析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3\&#34;&gt;参数详解&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在有些时候， 我们写 &lt;code&gt;insert into &lt;/code&gt;语句的时候, 需要列出所有的列名, 但是又不想全部手敲, 可以通过下面的SQL语句得到表所有列名,并以逗号分隔.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT\n\tGROUP_CONCAT(COLUMN_NAME SEPARATOR &amp;quot;,&amp;quot;)\nFROM\n\tinformation_schema. COLUMNS\nWHERE\n\tTABLE_SCHEMA = &#39;db_name&#39;\nAND TABLE_NAME = &#39;table_name&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-cha-xun-biao-suo-you-lie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;mysql 查询表所有列&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-14 10:01:51&#34;,&#34;dateFormat&#34;:&#34;2019-03-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-cha-xun-biao-suo-you-lie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:17000,&#34;words&#34;:71,&#34;minutes&#34;:1},&#34;description&#34;:&#34;在有些时候， 我们写 insert into 语句的时候, 需要列出所有的列名, 但是又不想全部手敲, 可以通过下面的SQL语句得到表所有列名,并以逗号分隔.\nSELECT\n\tGROUP_CONCAT(COLUMN_NAME SEPARAT...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;rm删除除去指定文件的剩余所有文件  (rm 反向删除）&lt;/p&gt;\n&lt;h1 id=\&#34;使用\&#34;&gt;使用&lt;/h1&gt;\n&lt;p&gt;使用 &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt; 三个命令完成本次操作.  假如需要删除 &lt;code&gt;/tmp/&lt;/code&gt;下面的所有文件, 排除掉 &lt;code&gt;ab.txt&lt;/code&gt; 文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;n-tech-admin@findface1:~/tmp$ ls\na  ab  abc  abcd  abc.txt  ab.txt  a.txt\nn-tech-admin@findface1:~/tmp$ rm -rf `ls |grep -v &amp;quot;^ab.txt$&amp;quot;`\nn-tech-admin@findface1:~/tmp$ ls\nab.txt\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;解析\&#34;&gt;解析&lt;/h1&gt;\n&lt;p&gt;其中 grep 的 &lt;code&gt;-v&lt;/code&gt; 支持正则表达式, &lt;code&gt;^&lt;/code&gt; 开头 &lt;code&gt;$&lt;/code&gt; 结尾 用于唯一匹配, &lt;code&gt;-rf&lt;/code&gt; 后面的引号是 ` (Esc下面的按键) , 而不是单引号.&lt;br&gt;\n正则稍加改造就可以指定当前目录下所有包含 &lt;code&gt;ab&lt;/code&gt; 字眼的文件或文件夹. 以此类推&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;linux-shan-chu-wen-jian-pai-chu-xx-wen-jian-rm-fan-xiang-shan-chu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Linux 删除文件排除xx文件 (rm反向删除)&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-13 14:29:04&#34;,&#34;dateFormat&#34;:&#34;2019-03-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/linux-shan-chu-wen-jian-pai-chu-xx-wen-jian-rm-fan-xiang-shan-chu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:43000,&#34;words&#34;:174,&#34;minutes&#34;:1},&#34;description&#34;:&#34;rm删除除去指定文件的剩余所有文件  (rm 反向删除）\n使用\n使用 ls, grep, rm 三个命令完成本次操作.  假如需要删除 /tmp/下面的所有文件, 排除掉 ab.txt 文件\nn-tech-admin@findface1:~...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8\&#34;&gt;使用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E6%9E%90\&#34;&gt;解析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;https://www.cnblogs.com/xingzc/p/9414208.html\&#34;&gt;https://www.cnblogs.com/xingzc/p/9414208.html&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;zhuan-zai-spring-cloud-de-ban-ben&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;[转载] Spring Cloud的版本&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-12 09:07:26&#34;,&#34;dateFormat&#34;:&#34;2019-03-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/zhuan-zai-spring-cloud-de-ban-ben/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:3000,&#34;words&#34;:8,&#34;minutes&#34;:1},&#34;description&#34;:&#34;https://www.cnblogs.com/xingzc/p/9414208.html\n&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;今天在写一个很简单的查询语句的时候，因为结果只需要大表中的三四个字段，项目又使用的jpa作为数据框架，所以考虑使用 &lt;code&gt;@Query&lt;/code&gt; 注解自定义SQL，然后遇到了一个报错， 始终没有解决。最终在&lt;a href=\&#34;https://ask.csdn.net/questions/655530\&#34;&gt;CSDN&lt;/a&gt;搜索到一个回答解决了这个小问题.&lt;br&gt;\n在自定义SQL的时候，需要加上 &lt;code&gt;nativeQuery = true&lt;/code&gt; 属性，否则JPA将按照默认的  &lt;code&gt;hql&lt;/code&gt; 执行我们写的原生SQL。&lt;/p&gt;\n&lt;p&gt;错误堆栈：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;2019-03-08 15:36:45.601  INFO 14220 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate Core {5.3.7.Final}\n2019-03-08 15:36:45.603  INFO 14220 --- [           main] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found\n2019-03-08 15:36:45.788  INFO 14220 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.0.4.Final}\n2019-03-08 15:36:45.983  INFO 14220 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2019-03-08 15:36:46.112  INFO 14220 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n2019-03-08 15:36:46.126  INFO 14220 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5InnoDBDialect\n2019-03-08 15:36:47.085  INFO 14220 --- [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit &#39;default&#39;\n2019-03-08 15:36:47.660  INFO 14220 --- [           main] o.h.h.i.QueryTranslatorFactoryInitiator  : HHH000397: Using ASTQueryTranslatorFactory\n2019-03-08 15:36:47.722  WARN 14220 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;dataController&#39; defined in file [D:\\dev\\Ntech\\data\\target\\classes\\cn\\anytec\\data\\controller\\DataController.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;snapServiceImpl&#39;: Unsatisfied dependency expressed through field &#39;personRepository&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;personRepository&#39;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!\n2019-03-08 15:36:47.724  INFO 14220 --- [           main] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &#39;default&#39;\n2019-03-08 15:36:47.727  INFO 14220 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...\n2019-03-08 15:36:47.735  INFO 14220 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.\n2019-03-08 15:36:47.752  INFO 14220 --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]\n2019-03-08 15:36:47.771  INFO 14220 --- [           main] ConditionEvaluationReportLoggingListener : \n\nError starting ApplicationContext. To display the conditions report re-run your application with &#39;debug&#39; enabled.\n2019-03-08 15:36:47.786 ERROR 14220 --- [           main] o.s.boot.SpringApplication               : Application run failed\n\norg.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;dataController&#39; defined in file [D:\\dev\\Ntech\\data\\target\\classes\\cn\\anytec\\data\\controller\\DataController.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;snapServiceImpl&#39;: Unsatisfied dependency expressed through field &#39;personRepository&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;personRepository&#39;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!\n\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:769) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:218) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1325) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1171) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:849) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.context.support.AbstractApplicationContext.__refresh(AbstractApplicationContext.java:549) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.context.support.AbstractApplicationContext.jrLockAndRefresh(AbstractApplicationContext.java:40002) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:41008) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) ~[spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.3.RELEASE.jar:2.1.3.RELEASE]\n\tat cn.anytec.data.DataApplication.main(DataApplication.java:16) [classes/:na]\nCaused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;snapServiceImpl&#39;: Unsatisfied dependency expressed through field &#39;personRepository&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;personRepository&#39;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:596) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:374) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1395) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:592) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1247) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1167) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:857) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:760) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\t... 21 common frames omitted\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;personRepository&#39;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:593) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:277) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1247) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1167) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:593) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\t... 35 common frames omitted\nCaused by: java.lang.IllegalArgumentException: Validation failed for query for method public abstract cn.anytec.data.model.entity.TbPerson cn.anytec.data.repository.PersonRepository.findTbPersonBySdkId(java.lang.String)!\n\tat org.springframework.data.jpa.repository.query.SimpleJpaQuery.validateQuery(SimpleJpaQuery.java:93) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.jpa.repository.query.SimpleJpaQuery.&amp;lt;init&amp;gt;(SimpleJpaQuery.java:63) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.jpa.repository.query.JpaQueryFactory.fromMethodWithQueryString(JpaQueryFactory.java:76) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.jpa.repository.query.JpaQueryFactory.fromQueryAnnotation(JpaQueryFactory.java:56) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$DeclaredQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:139) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:206) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:79) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.lookupQuery(RepositoryFactorySupport.java:566) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.lambda$mapMethodsToQuery$1(RepositoryFactorySupport.java:559) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) ~[na:1.8.0_171]\n\tat java.util.Iterator.forEachRemaining(Iterator.java:116) ~[na:1.8.0_171]\n\tat java.util.Collections$UnmodifiableCollection$1.forEachRemaining(Collections.java:1049) ~[na:1.8.0_171]\n\tat java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801) ~[na:1.8.0_171]\n\tat java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) ~[na:1.8.0_171]\n\tat java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) ~[na:1.8.0_171]\n\tat java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708) ~[na:1.8.0_171]\n\tat java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:1.8.0_171]\n\tat java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499) ~[na:1.8.0_171]\n\tat org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.mapMethodsToQuery(RepositoryFactorySupport.java:561) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.lambda$new$0(RepositoryFactorySupport.java:551) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat java.util.Optional.map(Optional.java:215) ~[na:1.8.0_171]\n\tat org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:551) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:324) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.lambda$afterPropertiesSet$5(RepositoryFactoryBeanSupport.java:297) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.util.Lazy.getNullable(Lazy.java:211) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.util.Lazy.get(Lazy.java:94) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.afterPropertiesSet(RepositoryFactoryBeanSupport.java:300) ~[spring-data-commons-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean.afterPropertiesSet(JpaRepositoryFactoryBean.java:119) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1821) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1758) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\t... 45 common frames omitted\nCaused by: java.lang.IllegalArgumentException: org.hibernate.hql.internal.ast.QuerySyntaxException: tb_person is not mapped [select name,gender,group_id as groupId,id_number as idNumber,sdk_id as sdkId from tb_person where sdk_id = ?1]\n\tat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:138) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:181) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:188) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.internal.AbstractSharedSessionContract.createQuery(AbstractSharedSessionContract.java:713) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.internal.AbstractSessionImpl.createQuery(AbstractSessionImpl.java:23) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_171]\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_171]\n\tat sun.reflect.DelegatingMethodAccessorImpl.__invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_171]\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:45009) ~[na:1.8.0_171]\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:45012) ~[na:1.8.0_171]\n\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_171]\n\tat org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:350) ~[spring-orm-5.1.5.RELEASE.jar:5.1.5.RELEASE]\n\tat com.sun.proxy.$Proxy101.createQuery(Unknown Source) ~[na:na]\n\tat org.springframework.data.jpa.repository.query.SimpleJpaQuery.validateQuery(SimpleJpaQuery.java:87) ~[spring-data-jpa-2.1.5.RELEASE.jar:2.1.5.RELEASE]\n\t... 74 common frames omitted\nCaused by: org.hibernate.hql.internal.ast.QuerySyntaxException: tb_person is not mapped [select name,gender,group_id as groupId,id_number as idNumber,sdk_id as sdkId from tb_person where sdk_id = ?1]\n\tat org.hibernate.hql.internal.ast.QuerySyntaxException.generateQueryException(QuerySyntaxException.java:79) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.QueryException.wrapWithQueryString(QueryException.java:103) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:219) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:143) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.engine.query.spi.HQLQueryPlan.&amp;lt;init&amp;gt;(HQLQueryPlan.java:119) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.engine.query.spi.HQLQueryPlan.&amp;lt;init&amp;gt;(HQLQueryPlan.java:80) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.engine.query.spi.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:153) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.internal.AbstractSharedSessionContract.getQueryPlan(AbstractSharedSessionContract.java:595) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.internal.AbstractSharedSessionContract.createQuery(AbstractSharedSessionContract.java:704) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\t... 84 common frames omitted\nCaused by: org.hibernate.hql.internal.ast.QuerySyntaxException: tb_person is not mapped\n\tat org.hibernate.hql.internal.ast.util.SessionFactoryHelper.requireClassPersister(SessionFactoryHelper.java:169) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.ast.tree.FromElementFactory.addFromElement(FromElementFactory.java:91) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.ast.tree.FromClause.addFromElement(FromClause.java:79) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.ast.HqlSqlWalker.createFromElement(HqlSqlWalker.java:331) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.fromElement(HqlSqlBaseWalker.java:3695) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.fromElementList(HqlSqlBaseWalker.java:3584) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.fromClause(HqlSqlBaseWalker.java:720) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.query(HqlSqlBaseWalker.java:576) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.selectStatement(HqlSqlBaseWalker.java:313) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.antlr.HqlSqlBaseWalker.statement(HqlSqlBaseWalker.java:261) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.ast.QueryTranslatorImpl.analyze(QueryTranslatorImpl.java:271) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\tat org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:191) ~[hibernate-core-5.3.7.Final.jar:5.3.7.Final]\n\t... 90 common frames omitted\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-boot-jpa-query&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring boot JPA @Query&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-08 15:39:16&#34;,&#34;dateFormat&#34;:&#34;2019-03-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-boot-jpa-query/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;20 min read&#34;,&#34;time&#34;:1184000,&#34;words&#34;:3215,&#34;minutes&#34;:20},&#34;description&#34;:&#34;今天在写一个很简单的查询语句的时候，因为结果只需要大表中的三四个字段，项目又使用的jpa作为数据框架，所以考虑使用 @Query 注解自定义SQL，然后遇到了一个报错， 始终没有解决。最终在CSDN搜索到一个回答解决了这个小问题.\n在自定义...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;导包\&#34;&gt;导包&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;\n\t&amp;lt;groupId&amp;gt;org.fusesource&amp;lt;/groupId&amp;gt;\n\t&amp;lt;artifactId&amp;gt;sigar&amp;lt;/artifactId&amp;gt;\n\t&amp;lt;version&amp;gt;1.6.4&amp;lt;/version&amp;gt;\n&amp;lt;/dependency&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;使用\&#34;&gt;使用&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;伪代码&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code&gt;Sigar sigar = new Sigar();\nMem mem =  sigar.getMem();\n\n//计数单位 K\nLong totalMemory = mem.getTotal() / 1024L;\nLong usedMemory = mem.getUsed() / 1024L;\nLong freeMemory = mem.getFree() / 1024L;\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-huo-qu-fu-wu-qi-nei-cun-shu-ju&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;java获取服务器内存数据&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-05 16:45:02&#34;,&#34;dateFormat&#34;:&#34;2019-03-05&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-huo-qu-fu-wu-qi-nei-cun-shu-ju/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:22000,&#34;words&#34;:65,&#34;minutes&#34;:1},&#34;description&#34;:&#34;导包\n&amp;lt;dependency&amp;gt;\n\t&amp;lt;groupId&amp;gt;org.fusesource&amp;lt;/groupId&amp;gt;\n\t&amp;lt;artifactId&amp;gt;sigar&amp;lt;/artifactId&amp;gt;\n\t&amp;lt;ve...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%BC%E5%8C%85\&#34;&gt;导包&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8\&#34;&gt;使用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;mode&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;说明&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;注意&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&#39;r&#39;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;只读&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;文件必须存在&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&#39;w&#39;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;只写&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;文件不存在则创建, 存在则清空内容&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&#39;a&#39;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;追加&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;文件不存在则创建&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&#39;r+&#39; / &#39;w+&#39;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;读写&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&#39;a+&#39;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;追加和读写&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;文件必须存在&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;rb, wb, ab, rb+, wb+, ab+: 二进制方式打开&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;python-da-kai-wen-jian&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;python打开文件&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-02 16:44:28&#34;,&#34;dateFormat&#34;:&#34;2019-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/python-da-kai-wen-jian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:16000,&#34;words&#34;:72,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n\n\nmode\n说明\n注意\n\n\n\n\n&#39;r&#39;\n只读\n文件必须存在\n\n\n&#39;w&#39;\n只写\n文件不存在则创建, 存在则清空内容\n\n\n&#39;a&#39;\n追加\n文件不存在则创建\n\n\n&#39;r+&#39; / &#39;w+&#39;\n读写\n\n\n\n&#39;a+&#39;\n追加和读写\n文件必须存在\n\n\n\nrb...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;访问控制符\&#34;&gt;访问控制符&lt;/h1&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;public&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;protected&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;缺省&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;private&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;同类可见&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;同包子类可见&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;×&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;同包非子类可见&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;×&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;不同包子类可见&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;×&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;×&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;不同包非子类可见&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;√&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;×&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;×&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;×&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h1 id=\&#34;类方法和变量修饰符\&#34;&gt;类,方法和变量修饰符&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;abstract&lt;br&gt;\n表名类或者类中的方法时抽象的&lt;/li&gt;\n&lt;li&gt;class&lt;br&gt;\n声明类&lt;/li&gt;\n&lt;li&gt;extends&lt;br&gt;\n声明继承xx类&lt;/li&gt;\n&lt;li&gt;final&lt;br&gt;\n声明类标识不可继承、方法不可重写&lt;/li&gt;\n&lt;li&gt;implements&lt;br&gt;\n声明实现xx接口&lt;/li&gt;\n&lt;li&gt;interface&lt;br&gt;\n声明接口&lt;/li&gt;\n&lt;li&gt;native&lt;br&gt;\n声明本地方法&lt;/li&gt;\n&lt;li&gt;new&lt;br&gt;\n创建xx类的实例对象&lt;/li&gt;\n&lt;li&gt;static&lt;br&gt;\n表明域或方法是静态的，即该域或方法是属于类的&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;java53-ge-guan-jian-zi-bao-han-2-ge-bao-liu-zi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;JAVA53个关键字(包含2个保留字)&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-02 09:46:01&#34;,&#34;dateFormat&#34;:&#34;2019-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java53-ge-guan-jian-zi-bao-han-2-ge-bao-liu-zi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:31000,&#34;words&#34;:145,&#34;minutes&#34;:1},&#34;description&#34;:&#34;访问控制符\n\n\n\n\npublic\nprotected\n缺省\nprivate\n\n\n\n\n同类可见\n√\n√\n√\n√\n\n\n同包子类可见\n√\n√\n√\n×\n\n\n同包非子类可见\n√\n√\n√\n×\n\n\n不同包子类可见\n√\n√\n×\n×\n\n\n不同包非子类可见\n√...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6\&#34;&gt;访问控制符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%8F%98%E9%87%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6\&#34;&gt;类,方法和变量修饰符&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;钱是一切的根源&lt;br&gt;\n马克思在《资本论》里说：&lt;br&gt;\n如果有20%的利润，资本就会蠢蠢欲动；&lt;br&gt;\n如果有50%的利润，资本就敢于冒险；&lt;br&gt;\n如果有100%的利润，资本就可以冒着绞首的危险；&lt;br&gt;\n如果有300%的利润，资本就敢于践踏人间一切的法律。&lt;/p&gt;\n&lt;p&gt;这段话也可以这样理解：&lt;br&gt;\n20%的利润是人类谎言的界限；&lt;br&gt;\n50%的利润是人类违法的界限；&lt;br&gt;\n100%的利润是人类赴死的界限；&lt;br&gt;\n300%的利润则是人类变成兽的界限；&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;qian-shi-yi-qie-de-gen-yuan&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;钱是一切的根源&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-03-02 09:19:33&#34;,&#34;dateFormat&#34;:&#34;2019-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/qian-shi-yi-qie-de-gen-yuan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:30000,&#34;words&#34;:145,&#34;minutes&#34;:1},&#34;description&#34;:&#34;钱是一切的根源\n马克思在《资本论》里说：\n如果有20%的利润，资本就会蠢蠢欲动；\n如果有50%的利润，资本就敢于冒险；\n如果有100%的利润，资本就可以冒着绞首的危险；\n如果有300%的利润，资本就敢于践踏人间一切的法律。\n这段话也可以这样...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;docker的网络模式\&#34;&gt;docker的网络模式&lt;/h1&gt;\n&lt;p&gt;docker 总共有四种网络模式, 分别是&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;host 模式&lt;/li&gt;\n&lt;li&gt;bridge 模式&lt;/li&gt;\n&lt;li&gt;none 模式&lt;/li&gt;\n&lt;li&gt;container 模式&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;关于docker的网络模式, 在这篇文章中有非常详尽的说明, 就不赘述了. &lt;a href=\&#34;https://www.cnblogs.com/sammyliu/p/5894191.html\&#34;&gt;理解Docker的网络模式&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;为什么需要指定容器ip\&#34;&gt;为什么需要指定容器IP&lt;/h1&gt;\n&lt;p&gt;实际部署中, 我们需要指定IP, 避免IP混乱&lt;/p&gt;\n&lt;h1 id=\&#34;如何实现指定容器ip\&#34;&gt;如何实现指定容器IP&lt;/h1&gt;\n&lt;p&gt;docker的bridge(docker0)网络, 在docker安装时就已经创建好了, 不支持指定容器IP, 所以我们需要再创建一个docker的bridge网络(bridge1), 为其指定子网, 使其支持指定容器IP, 接下来将通过命令演示的方式创建一个支持指定IP的docker bridge网络.&lt;/p&gt;\n&lt;h2 id=\&#34;创建一个驱动为bridge的网络-命名为newbridge\&#34;&gt;创建一个驱动为bridge的网络, 命名为newbridge&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;docker network create --driver bridge --subnet 172.16.12.0/16 --gateway 172.16.1.1 newbridge\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/02/qj8478qriagtjqrqhi7on1m71u.jpg\&#34; alt=\&#34;创建网络\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;查看刚刚创建的网络\&#34;&gt;查看刚刚创建的网络&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;docker network ls\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/02/vf0178qo9ojnio23gtuqu7kuvi.jpg\&#34; alt=\&#34;查看\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;创建容器测试\&#34;&gt;创建容器测试&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;docker run -itd -h test --name test --network newbridge --ip 172.16.12.3 ubuntu\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;验证容器的ip\&#34;&gt;验证容器的ip&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;此命令为查看所有容器ip命令&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code&gt;docker inspect --format=&#39;{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39; $(docker ps -aq)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/02/s9r8oeavpsgmqr1gvpi2ev2sh4.jpg\&#34; alt=\&#34;验证容器ip\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n可以看到容器的ip已经是刚才我们创建容器时指定的ip了. 大功告成.&lt;/p&gt;\n&lt;h1 id=\&#34;引用说明\&#34;&gt;引用说明&lt;/h1&gt;\n&lt;p&gt;文中操作学习自 &lt;a href=\&#34;https://www.jianshu.com/p/b8625ccb5e9c\&#34;&gt;Docker 创建容器时指定容器ip&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-zhi-ding-rong-qi-ip&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;docker 指定容器IP&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-02-28 14:44:50&#34;,&#34;dateFormat&#34;:&#34;2019-02-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/docker-zhi-ding-rong-qi-ip/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:79000,&#34;words&#34;:330,&#34;minutes&#34;:2},&#34;description&#34;:&#34;docker的网络模式\ndocker 总共有四种网络模式, 分别是\n\nhost 模式\nbridge 模式\nnone 模式\ncontainer 模式\n\n关于docker的网络模式, 在这篇文章中有非常详尽的说明, 就不赘述了. 理解Docke...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F\&#34;&gt;docker的网络模式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8ip\&#34;&gt;为什么需要指定容器IP&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8ip\&#34;&gt;如何实现指定容器IP&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E4%B8%BAbridge%E7%9A%84%E7%BD%91%E7%BB%9C-%E5%91%BD%E5%90%8D%E4%B8%BAnewbridge\&#34;&gt;创建一个驱动为bridge的网络, 命名为newbridge&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E7%9C%8B%E5%88%9A%E5%88%9A%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BD%91%E7%BB%9C\&#34;&gt;查看刚刚创建的网络&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E6%B5%8B%E8%AF%95\&#34;&gt;创建容器测试&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%AA%8C%E8%AF%81%E5%AE%B9%E5%99%A8%E7%9A%84ip\&#34;&gt;验证容器的ip&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E\&#34;&gt;引用说明&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;中国人的性情是总喜欢调和折中的，譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶他们就来调和，愿意开窗了。&lt;/p&gt;\n&lt;div style=\&#34;text-align: right\&#34;&gt;——鲁迅 《无声的中国》&lt;/div&gt;&#34;,&#34;fileName&#34;:&#34;wu-sheng-de-zhong-guo&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;无声的中国&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-02-26 16:21:12&#34;,&#34;dateFormat&#34;:&#34;2019-02-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/wu-sheng-de-zhong-guo/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:13000,&#34;words&#34;:68,&#34;minutes&#34;:1},&#34;description&#34;:&#34;中国人的性情是总喜欢调和折中的，譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶他们就来调和，愿意开窗了。\n——鲁迅 《无声的中国》...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;什么是元注解\&#34;&gt;什么是元注解&lt;/h1&gt;\n&lt;p&gt;在java.lang.annotation包下, 提供了四个用来注解注解的元注解, 用于在自定义注解时使用.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;@Documented -- 注解是否包含在javaDoc中&lt;/li&gt;\n&lt;li&gt;@Retention -- 什么时候用该注解&lt;/li&gt;\n&lt;li&gt;@Target -- 注解用在什么地方&lt;/li&gt;\n&lt;li&gt;@Inherited -- 是否允许子类继承该注解&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;documented\&#34;&gt;@Documented&lt;/h1&gt;\n&lt;p&gt;一个简单的Annotations注解标记, 标识是否将注解加入到Java文档中.&lt;/p&gt;\n&lt;h1 id=\&#34;retention\&#34;&gt;@Retention&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;定义该注解的生命周期&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;RetentionPolicy.SOURCE  在编译阶段丢弃, 注解在编译之后就不会再有任何意义, 不会写入字节码文件. @Override, @SupperssWarnings都属于该生命周期.&lt;/li&gt;\n&lt;li&gt;RetentionPolicy.CLASS 在类加载的时候丢弃, 在字节码处理过程中有用, &lt;strong&gt;默认使用该生命周期&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;RetentionPolicy.RUNTIME 始终不会丢弃, 运行期也保留该注解, 可以使用反射读取该注解的信息, &lt;strong&gt;自定义注解时常使用该生命周期&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;target\&#34;&gt;@Target&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;定义该注解用在什么地方, 默认可以用在所有地方&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;ElementType.TYPE -- 用于描述类&lt;/li&gt;\n&lt;li&gt;ElementType.METHOD -- 用于描述方法&lt;/li&gt;\n&lt;li&gt;ElementType.FIELD -- 用于描述成员变量, 对象, 属性(包括enum)&lt;/li&gt;\n&lt;li&gt;ElementType.PACKAGE -- 用于描述包&lt;/li&gt;\n&lt;li&gt;ElementType.CONSTRUCTOR -- 用于描述构造函数&lt;/li&gt;\n&lt;li&gt;ElementType.LOCAL_VARIABLE -- 用于描述局部变量&lt;/li&gt;\n&lt;li&gt;ElementType.PARAMETER -- 用于描述类, 接口(包括注解类型)或enum声明&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;inherited\&#34;&gt;@Inherited&lt;/h1&gt;\n&lt;p&gt;@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。&lt;/p&gt;\n&lt;h1 id=\&#34;栗子\&#34;&gt;栗子&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;@Documented\n@Retention(value = RetentionPolicy.RUNTIME)\n@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})\n@Inherited\n@interface AnnotationTest{\n    String value() default &amp;quot;&amp;quot;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;yuan-zhu-jie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;元注解&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-02-26 16:09:54&#34;,&#34;dateFormat&#34;:&#34;2019-02-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/yuan-zhu-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:94000,&#34;words&#34;:418,&#34;minutes&#34;:2},&#34;description&#34;:&#34;什么是元注解\n在java.lang.annotation包下, 提供了四个用来注解注解的元注解, 用于在自定义注解时使用.\n\n@Documented -- 注解是否包含在javaDoc中\n@Retention -- 什么时候用该注解\n@Ta...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E6%B3%A8%E8%A7%A3\&#34;&gt;什么是元注解&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#documented\&#34;&gt;@Documented&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#retention\&#34;&gt;@Retention&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#target\&#34;&gt;@Target&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#inherited\&#34;&gt;@Inherited&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%97%E5%AD%90\&#34;&gt;栗子&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;前言\&#34;&gt;前言&lt;/h1&gt;\n&lt;p&gt;前后端分离作为现在的大趋势，公司也开始了整合评估现有项目，打算对现有项目做前后端分离配置， 现阶段主要打算使用 &lt;code&gt;NGINX&lt;/code&gt; 做前端静态的HTTP请求服务器，还包括对 &lt;code&gt;WebSocket&lt;/code&gt; 内容的转发，当然还包括最主要的后台服务的负载均衡。&lt;/p&gt;\n&lt;h1 id=\&#34;nginx配置\&#34;&gt;nginx配置&lt;/h1&gt;\n&lt;p&gt;在nginx.conf中配置了 &lt;code&gt;include /etc/nginx/sites-enabled&lt;/code&gt; 所以在 &lt;code&gt;sites-enabled&lt;/code&gt; 下面编写配置信息.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;map $http_upgrade $connection_upgrade {  \n\tdefault upgrade;  \n\t&#39;&#39; close;  \n}  \nupstream muti_instance_43{\n#\tserver 192.168.10.62:9999 weight=10;\n\tserver 192.168.10.62:9999;\n#\tserver 192.168.10.213:9997 weight=2;\n\tkeepalive 200;\n}\n\nserver {\n\tlisten 0.0.0.0:10070;\n\tsendfile off;\n\n\n\tproxy_set_header Host $http_host;\n\tproxy_set_header X-Real-IP $remote_addr;\n\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\tproxy_set_header X-Forwarded-Proto $scheme;\n#\tresolver 114.114.114.114 223.5.5.5 valid=3600s;\n        resolver_timeout 3s;\n\n\tproxy_http_version 1.1;\n\tproxy_set_header Connection &amp;quot;&amp;quot;;\n\n\t#root /data/securityUI/static/;\n\n\n\tlocation  / { \n                #add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;\n\t\t#add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET&#39;;\n\t\t#add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization&#39;;\n\t\t#add_header &#39;Access-Control-Expose-Headers&#39; &#39;Content-Length,Content-Range&#39;;\n\t\t#add_header &#39;Access-Control-Max-Age&#39; 2592000;\n\t\tclient_max_body_size    15g;\n\t\t#dav_access user:rw group:rw all:rw;\n\t\t#dav_methods PUT DELETE MKCOL COPY MOVE;\n\n\t\t#create_full_put_path on;\n\n\t\t#autoindex off;\n\t\t#autoindex_exact_size off;\n\t\t#autoindex_localtime on;\n\t\t#charset utf-8;\n\t\tif ($request_uri ~* /.) {\n\t\t\tproxy_pass http://muti_instance_43;\n\t\t\tbreak;\n\t\t\t#root /data/securityUI/static/;\n                \t#index index.html index.htm;\n\t\n\t\t}\n\t\troot /data/securityUI/static/;\n                index login.html;\n\t}\n\n\tlocation ^~ /static/offlineMap/ {\n\t\talias /data/securityUI/map/;\n\t\t#proxy_pass http://map_server;\n\t}\n\n\tlocation  /static/ {\n\n\t\tclient_max_body_size 15g;\n\t\talias /data/securityUI/static/;\n\t\tallow all;\n\n\t}\n\tlocation ^~ /index {\n\t\talias /data/securityUI/static/;\n\t\tindex index.html;\n\n\t}\n\n\tlocation ^~ /gee/ {\n\t\tproxy_pass http://muti_instance_43;\n\t\tproxy_set_header Upgrade $http_upgrade;\n\t\tproxy_set_header Connection &amp;quot;upgrade&amp;quot;;\n\t\tproxy_http_version 1.1;\n\t\tproxy_set_header        Host            $host;\n\t\tproxy_set_header        X-Real-IP       $remote_addr;\n\t\tproxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n\n\t}\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;配置中最关键的点在 &lt;code&gt;location  / {}&lt;/code&gt; 节点, 其中的 &lt;code&gt;if&lt;/code&gt; 判断, 如果是访问的 &lt;code&gt;ip:port/xxx&lt;/code&gt; 带了任何内容, 就会转发到 &lt;code&gt;muti_instance_43&lt;/code&gt; 中, 如果没有带内容(即访问的首页), 就会将其转发到配置好了的静态首页面.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;qian-hou-duan-fen-chi-shi-yong-nginx-zuo-fu-wu-zhuan-fa&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;前后端分离使用NGINX做服务转发&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-02-23 16:37:25&#34;,&#34;dateFormat&#34;:&#34;2019-02-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/qian-hou-duan-fen-chi-shi-yong-nginx-zuo-fu-wu-zhuan-fa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:130000,&#34;words&#34;:430,&#34;minutes&#34;:3},&#34;description&#34;:&#34;前言\n前后端分离作为现在的大趋势，公司也开始了整合评估现有项目，打算对现有项目做前后端分离配置， 现阶段主要打算使用 NGINX 做前端静态的HTTP请求服务器，还包括对 WebSocket 内容的转发，当然还包括最主要的后台服务的负载均衡...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nginx%E9%85%8D%E7%BD%AE\&#34;&gt;nginx配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;什么是efk\&#34;&gt;什么是EFK&lt;/h1&gt;\n&lt;p&gt;这里引用一下 &lt;a href=\&#34;https://www.cnblogs.com/xishuai/p/elk-elasticsearch-kibana.html\&#34;&gt;ELK 架构之 Elasticsearch 和 Kibana 安装配置&lt;/a&gt; 一文对ELK的介绍，详细内容在文中都有介绍，我主要将其从实体机安装转向在Docker-compose服务编排，EFK与ELK大同小异.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;ELK 是三个开源软件的缩写，分别为：Elasticsearch、Logstash 以及 Kibana，它们都是开源软件。不过现在还新增了一个 Beats，它是一个轻量级的日志收集处理工具（Agent），Beats 占用资源少，适合于在各个服务器上搜集日志后传输给 Logstash，官方也推荐此工具，目前由于原本的 ELK Stack 成员中加入了 Beats 工具所以已改名为 Elastic Stack。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;elasticsearch搭建\&#34;&gt;ElasticSearch搭建&lt;/h1&gt;\n&lt;p&gt;ElasticSearch的安装需要替换配置文件的以下几个点&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;network.host: 0.0.0.0 #所有地址都能够访问  \nhttp.port: 9200 #端口  \nhttp.cors.enabled: true \n http.cors.allow-origin: &amp;quot;*&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;问题解决\&#34;&gt;问题解决&lt;/h2&gt;\n&lt;p&gt;在配置ElasticSearch时容易出现以下几点错误, 在此讲解以下如何解决:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;见图1-[ElasticSearch问题]&lt;br&gt;\n原因：这是在因为系统不支持SecComp，而ES5.2.0默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。&lt;br&gt;\n解决：在elasticsearch.yml中配置bootstrap.system_call_filter为false，注意要在Memory下面:&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;bootstrap.memory_lock: false\nbootstrap.system_call_filter: false\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;见图1-[ElasticSearch问题]第二个红框&lt;br&gt;\n出现此问题只需要修改了 &lt;strong&gt;宿主机&lt;/strong&gt; 系统的max_map_count参数即可.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;vim /etc/sysctl.conf\nvm.max_map_count=655360\nsysctl -p\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;img src=\&#34;http://imyzt.top/upload/2019/02/61os9j93kshnvr88rcb91ufbfv.png\&#34; alt=\&#34;ElasticSearch问题\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n图1-[ElasticSearch问题]&lt;/p&gt;\n&lt;h1 id=\&#34;logstash搭建\&#34;&gt;Logstash搭建&lt;/h1&gt;\n&lt;p&gt;Logstash的安装需要替换配置文件的以下几点&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;server.port: 5601 \nserver.host: &amp;quot;0.0.0.0&amp;quot; \nelasticsearch.url: &amp;quot;http://elasticsearch:9200&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;kibana搭建\&#34;&gt;Kibana搭建&lt;/h1&gt;\n&lt;p&gt;配置一个filebeat的服务接收端&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;input {\n beats {\n   port =&amp;gt; 10515\n  }\n}\noutput {\n    elasticsearch {\n      hosts =&amp;gt; [&amp;quot;127.0.0.1:9200&amp;quot;]\n      # 注释不能被解析,线上删除.此处做讲解\n      # %{[fields][logtype]} 对应filebeat配置文件, 只需在此配置, 写入ElasticSearch的索引就可以主动创建和filebeat相关的索引\n      index =&amp;gt; &amp;quot;%{[fields][logtype]}-%{+YYYY.MM.dd}&amp;quot;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;filebeat搭建\&#34;&gt;filebeat搭建&lt;/h1&gt;\n&lt;p&gt;filebeat作为 &lt;code&gt;日志探测器&lt;/code&gt; 需要配置一个日志探测配置文件, 可以是log4j的网络传输, 也可以是系统的某个目录.配置文件下图讲解的非常细致&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/02/sv179ptptkg8ppujgiuu8gqhcv.png\&#34; alt=\&#34;filebeat.conf\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;还需要做如下修改:&lt;br&gt;\n注释掉默认开启的 ElasticSearch&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/02/7rglj7vc94i6tp56sd54tlgelp.png\&#34; alt=\&#34;注释掉es配置\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;开启默认未开启的 logstash, 指定logstash地址, 指定主机名而非localhost&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/02/2dqcnm00jmgqcqq5vaarpuicfe.png\&#34; alt=\&#34;开启logstash配置\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;容器编排\&#34;&gt;容器编排&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;version: &#39;2&#39;\n\nservices: \n  elasticsearch:  \n    image: docker.elastic.co/elasticsearch/elasticsearch:6.6.0\n    volumes: \n      - ./es/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml\n      - ./es/data:/usr/share/elasticsearch/data\n      - ./es/logs:/path/to/logs\n    ports: \n      - &#39;9200:9200&#39;\n      - &#39;9300:9300&#39;\n    environment:\n      - &amp;quot;bootstrap.memory_lock=true&amp;quot;\n      - &amp;quot;ES_JAVA_OPTS=-Xmx1g -Xms1g&amp;quot;\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    networks:\n      - efk\n  logstash:\n    image: docker.elastic.co/logstash/logstash:6.6.0\n    volumes:\n      - ./logstash/logstash.yml:/usr/share/logstash/config/logstash.yml\n      - ./logstash/logstash-sample.conf:/usr/share/logstash/config/logstash-sample.conf\n      - ./logstash/pipeline:/usr/share/logstash/pipeline\n      - ./logstash/pattern:/usr/share/logstash/pattern\n    ports:\n      - &amp;quot;5044:5044&amp;quot;\n      - &amp;quot;10515:10515&amp;quot;\n    environment:\n      - &amp;quot;LS_JAVA_OPTS=-Xmx1g -Xms1g&amp;quot;\n    command: logstash -f /usr/share/logstash/config/logstash-sample.conf\n    networks:\n      - efk\n    depends_on:\n      - elasticsearch\n  kibana:\n    image: docker.elastic.co/kibana/kibana:6.6.0\n    volumes:\n      - ./kibana/kibana.yml:/usr/share/kibana/config/kibana.yml\n    ports:\n      - &amp;quot;5601:5601&amp;quot;\n    networks:\n      - efk\n    depends_on:\n      - elasticsearch\n\nnetworks:\n  efk:\n    driver: bridge\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;efk-ri-zhi-xi-tong-da-jian&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;EFK日志系统搭建&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-02-23 15:26:59&#34;,&#34;dateFormat&#34;:&#34;2019-02-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/efk-ri-zhi-xi-tong-da-jian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:206000,&#34;words&#34;:771,&#34;minutes&#34;:4},&#34;description&#34;:&#34;什么是EFK\n这里引用一下 ELK 架构之 Elasticsearch 和 Kibana 安装配置 一文对ELK的介绍，详细内容在文中都有介绍，我主要将其从实体机安装转向在Docker-compose服务编排，EFK与ELK大同小异.\n\nE...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFefk\&#34;&gt;什么是EFK&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#elasticsearch%E6%90%AD%E5%BB%BA\&#34;&gt;ElasticSearch搭建&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3\&#34;&gt;问题解决&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#logstash%E6%90%AD%E5%BB%BA\&#34;&gt;Logstash搭建&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#kibana%E6%90%AD%E5%BB%BA\&#34;&gt;Kibana搭建&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#filebeat%E6%90%AD%E5%BB%BA\&#34;&gt;filebeat搭建&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92\&#34;&gt;容器编排&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;介绍\&#34;&gt;介绍&lt;/h1&gt;\n&lt;p&gt;容器主要包括了三个数据库MongoDB，MySQL，Redis，一个消息中间件RabbitMQ。security程序依赖三个数据库，security-rabbit依赖RabbitMQ，最后forward-nginx依赖于security程序。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/02/2qhouu9b3gi8erig24vba8tfnb.jpg\&#34; alt=\&#34;图解\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;\n# 容器编排\nversion: &amp;quot;3&amp;quot;\nservices:\n  security:\n    image: anytec/security:0.0.1\n    container_name: anytec-security\n    expose:\n      - &amp;quot;9999&amp;quot;\n    networks:\n      - docker-server\n    depends_on:\n      - mysql\n      - mongodb\n      - redis\n      - rabbitmq\n    restart: always\n    deploy:\n      replicas: 1\n      update_config:\n        parallelism: 2\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n  security-rabbitmq:\n    image: anytec/security-rabbitmq:0.0.1\n    container_name: anytec-security-rabbitmq\n    expose:\n      - &amp;quot;9998&amp;quot;\n    networks:\n      - docker-server\n    depends_on:\n      - rabbitmq\n      - security\n    restart: always\n    deploy:\n      replicas: 1\n      update_config:\n        parallelism: 2\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n  forward-nginx:\n    image: nginx:latest\n    container_name: anytec-forward-nginx\n    ports:\n      - &amp;quot;10070:10070&amp;quot;\n    networks:\n      - docker-server\n    depends_on:\n      - security\n    restart: always\n    deploy:\n      replicas: 1\n      update_config:\n        parallelism: 2\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n    volumes:\n      - /anytec/docker-server/forward-nginx/sites-enabled:/etc/nginx/sites-enabled/\n      - /data/securityUI:/data/securityUI\n      - /anytec/docker-server/forward-nginx/conf:/etc/nginx/\n  rabbitmq:\n    image: anytec/rabbitmq:3.6.15\n    container_name: anytec-rabbitmq\n    expose:\n      - &amp;quot;5672&amp;quot;\n    ports:\n      - &amp;quot;15672:15672&amp;quot;\n    networks:\n      - docker-server\n    environment:\n     - RABBITMQ_DEFAULT_USER=admin\n     - RABBITMQ_DEFAULT_PASS=ntech\n     - RABBITMQ_USER admin\n     - ENV RABBITMQ_PASSWORD ntech\n     - RABBITMQ_CONFIG_FILE=/etc/rabbitmq/rabbitmq.config\n     - RABBITMQ_ERLANG_COOKIE=CURIOAPPLICATION\n    restart: always\n    deploy:\n      replicas: 1\n      update_config:\n        parallelism: 2\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n  mongodb:\n    image: mongo:latest\n    container_name: anytec-mongodb\n    expose:\n      - &amp;quot;27017&amp;quot;\n    networks:\n      - docker-server\n    restart: always\n    #environment:\n      #MONGO_INITDB_ROOT_PASSWORD: ntech\n      #MONGO_INITDB_ROOT_USERNAME: root\n    volumes:\n      - /anytec/docker-server/mongodb/data:/data/db\n      - /anytec/docker-server/mongodb/conf/mongodb.conf:/etc/mongodb.conf \n    deploy:\n      replicas: 1\n      update_config:\n        parallelism: 2\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n  redis:\n    image: redis\n    container_name: anytec-redis\n    expose:\n      - &amp;quot;6379&amp;quot;\n    networks:\n      - docker-server\n    volumes:\n      - /anytec/docker-server/redis/data:/data\n      - /anytec/docker-server/redis/conf:/usr/local/etc/redis/\n    command: [&#39;redis-server&#39;, &#39;/usr/local/etc/redis/redis.conf&#39;]\n    restart: always\n    deploy:\n      replicas: 1\n      update_config:\n        parallelism: 2\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n  mysql:\n    image: anytec/mysql:5.7\n    container_name: anytec-mysql\n    expose:\n     - &amp;quot;3306&amp;quot;\n    networks:\n     - docker-server\n    environment:\n      MYSQL_ROOT_PASSWORD: ntech\n      MYSQL_ROOT_HOST: &#39;%&#39;\n      MYSQL_DATABASE: securitydb\n    volumes:\n      - /anytec/docker-server/mysql/data:/var/lib/mysql\n    restart: always\n    deploy:\n      replicas: 1\n      update_config:\n        parallelism: 2\n        delay: 10s\n      restart_policy:\n        condition: on-failure\nnetworks:\n  docker-server:\n    driver: bridge\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;pu-tong-rong-qi-bian-pai&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;普通容器编排&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-02-23 10:49:33&#34;,&#34;dateFormat&#34;:&#34;2019-02-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/pu-tong-rong-qi-bian-pai/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:139000,&#34;words&#34;:393,&#34;minutes&#34;:3},&#34;description&#34;:&#34;介绍\n容器主要包括了三个数据库MongoDB，MySQL，Redis，一个消息中间件RabbitMQ。security程序依赖三个数据库，security-rabbit依赖RabbitMQ，最后forward-nginx依赖于securit...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8B%E7%BB%8D\&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;synchronized的两种用法\&#34;&gt;synchronized的两种用法&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;对象锁&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;包括方法锁(默认锁对象为&lt;strong&gt;this&lt;/strong&gt;当前实例对象)和同步代码块锁(自己指定锁对象)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;类锁&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;指synchronized修饰 &lt;strong&gt;static方法&lt;/strong&gt; 或指定锁对象为 &lt;strong&gt;Class对象&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;对象锁\&#34;&gt;对象锁&lt;/h1&gt;\n&lt;h2 id=\&#34;同步代码块\&#34;&gt;同步代码块&lt;/h2&gt;\n&lt;h3 id=\&#34;使用-this-锁定代码块\&#34;&gt;使用 this 锁定代码块&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;public class SynchronizedObjectCodeBlock2 implements Runnable {\n\n    static SynchronizedObjectCodeBlock2 codeBlock2 = new SynchronizedObjectCodeBlock2();\n\n    @Override\n    public void run() {\n\n        synchronized (this) {\n            System.out.println(&amp;quot;我是lock2, 我叫&amp;quot; + Thread.currentThread().getName());\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + &amp;quot;, lock2 部分执行结束&amp;quot;);\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        Thread thread1 = new Thread(codeBlock2);\n        Thread thread2 = new Thread(codeBlock2);\n\n        thread1.start();\n        thread2.start();\n\n        while (thread1.isAlive() || thread2.isAlive()) {\n\n        }\n\n        System.out.println(&amp;quot;finished&amp;quot;);\n\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;最终运行结果&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;我是lock2, 我叫Thread-0\nThread-0, lock2 部分执行结束\n我是lock2, 我叫Thread-1\nThread-1, lock2 部分执行结束\nfinished\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;使用-自定义锁对象\&#34;&gt;使用 自定义锁对象&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;public class SynchronizedObjectCodeBlock2 implements Runnable {\n\n    static SynchronizedObjectCodeBlock2 codeBlock2 = new SynchronizedObjectCodeBlock2();\n\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n\n    @Override\n    public void run() {\n\n        synchronized (lock1) {\n            System.out.println(&amp;quot;我是lock1, 我叫&amp;quot; + Thread.currentThread().getName());\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + &amp;quot;, lock1 部分执行结束&amp;quot;);\n        }\n\n        synchronized (lock2) {\n            System.out.println(&amp;quot;我是lock2, 我叫&amp;quot; + Thread.currentThread().getName());\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + &amp;quot;, lock2 部分执行结束&amp;quot;);\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        Thread thread1 = new Thread(codeBlock2);\n        Thread thread2 = new Thread(codeBlock2);\n\n        thread1.start();\n        thread2.start();\n\n        while (thread1.isAlive() || thread2.isAlive()) {\n\n        }\n\n        System.out.println(&amp;quot;finished&amp;quot;);\n\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果，可以看出来加粗部分， thread-0和thread-1同时执行和同时结束，因为两个线程使用的不是同一把锁。&lt;/p&gt;\n&lt;p&gt;我是lock1, 我叫Thread-0&lt;br&gt;\nThread-0, lock1 部分执行结束&lt;br&gt;\n&lt;strong&gt;我是lock2, 我叫Thread-0&lt;br&gt;\n我是lock1, 我叫Thread-1&lt;/strong&gt;&lt;br&gt;\n&lt;strong&gt;Thread-1, lock1 部分执行结束&lt;br&gt;\nThread-0, lock2 部分执行结束&lt;/strong&gt;&lt;br&gt;\n我是lock2, 我叫Thread-1&lt;br&gt;\nThread-1, lock2 部分执行结束&lt;br&gt;\nfinished&lt;/p&gt;\n&lt;h2 id=\&#34;方法锁\&#34;&gt;方法锁&lt;/h2&gt;\n&lt;h3 id=\&#34;代码展示\&#34;&gt;代码展示&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;public class SynchronizedObjectMethod3 implements Runnable {\n\n    public static void main(String[] args) {\n\n        SynchronizedObjectMethod3 objectMethod3 = new SynchronizedObjectMethod3();\n\n        Thread thread1 = new Thread(objectMethod3);\n        Thread thread2 = new Thread(objectMethod3);\n\n        thread1.start();\n        thread2.start();\n    }\n\n    @Override\n    public void run() {\n        method();\n    }\n\n    public synchronized void method() {\n        System.out.println(&amp;quot;对象锁的方法修饰符形式, threadName=&amp;quot; + Thread.currentThread().getName());\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + &amp;quot;运行结束&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;运行结果\&#34;&gt;运行结果:&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;使用synchronized修饰一个成员方法, 该方法会根据实例依次执行.&lt;br&gt;\n对象锁的方法修饰符形式, threadName=Thread-0&lt;br&gt;\nThread-0运行结束&lt;br&gt;\n对象锁的方法修饰符形式, threadName=Thread-1&lt;br&gt;\nThread-1运行结束&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;类锁\&#34;&gt;类锁&lt;/h1&gt;\n&lt;h2 id=\&#34;概念\&#34;&gt;概念:&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;只有一个Class对象: Java类可能会有很多个实例对象, 但是只有一个Class对象&lt;/li&gt;\n&lt;li&gt;本质: 所谓的类锁, 实质上是Class对象的锁而已&lt;/li&gt;\n&lt;li&gt;用法和效果: 类锁只能在同一时刻被同一对象拥有&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;同步一个全局方法\&#34;&gt;同步一个全局方法&lt;/h2&gt;\n&lt;h3 id=\&#34;代码展示-2\&#34;&gt;代码展示&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;public class SynchronizedClassStatic4 implements Runnable {\n\n    static SynchronizedClassStatic4 instance1 = new SynchronizedClassStatic4();\n    static SynchronizedClassStatic4 instance2 = new SynchronizedClassStatic4();\n\n    @Override\n    public void run() {\n        method();\n    }\n\n    public static synchronized void method() {\n        System.out.println(&amp;quot;我是类锁的第一种形式: static形式, 我叫 &amp;quot; + Thread.currentThread().getName());\n        try {\n            TimeUnit.SECONDS.sleep(3);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + &amp;quot;运行结束&amp;quot;);\n    }\n\n    public static void main(String[] args) {\n\n        Thread thread1 = new Thread(instance1);\n        Thread thread2 = new Thread(instance2);\n\n        thread1.start();\n        thread2.start();\n\n        while (thread1.isAlive() || thread2.isAlive()) {\n\n        }\n\n        System.out.println(&amp;quot;finished&amp;quot;);\n\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;运行结果-2\&#34;&gt;运行结果:&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;使用synchronized修饰一个全局方法(static修饰), synchronized默认使用类作为锁对象&lt;br&gt;\n我是类锁的第一种形式: static形式, 我叫 Thread-0&lt;br&gt;\nThread-0运行结束&lt;br&gt;\n我是类锁的第一种形式: static形式, 我叫 Thread-1&lt;br&gt;\nThread-1运行结束&lt;br&gt;\nfinished&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;类锁同步一个代码块\&#34;&gt;类锁同步一个代码块&lt;/h2&gt;\n&lt;h3 id=\&#34;代码展示-3\&#34;&gt;代码展示&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;public class SynchronizedClassClass5 implements Runnable {\n\n    static SynchronizedClassClass5 instance1 = new SynchronizedClassClass5();\n    static SynchronizedClassClass5 instance2 = new SynchronizedClassClass5();\n\n    @Override\n    public void run() {\n        method();\n    }\n\n    private void method() {\n        synchronized(SynchronizedClassClass5.class) {\n            System.out.println(&amp;quot;类锁的第二种表现形式, synchronized(*.class)的形式, 这是&amp;quot; + Thread.currentThread().getName());\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + &amp;quot;运行结束&amp;quot;);\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Thread thread1 = new Thread(instance1);\n        Thread thread2 = new Thread(instance2);\n\n        thread1.start();\n        thread2.start();\n\n        while (thread1.isAlive() || thread2.isAlive()) {\n\n        }\n\n        System.out.println(&amp;quot;finished&amp;quot;);\n\n    }\n\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;运行结果-3\&#34;&gt;运行结果:&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;尽管Thread使用的不同的instance对象, 但是使用了*.class类锁之后, 代码也会按照期望值运行.&lt;br&gt;\n类锁的第二种表现形式, synchronized(&lt;em&gt;.class)的形式, 这是Thread-0&lt;br&gt;\nThread-0运行结束&lt;br&gt;\n类锁的第二种表现形式, synchronized(&lt;/em&gt;.class)的形式, 这是Thread-1&lt;br&gt;\nThread-1运行结束&lt;br&gt;\nfinished&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;synchronized&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;synchronized&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-02-14 18:43:28&#34;,&#34;dateFormat&#34;:&#34;2019-02-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/synchronized/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:304000,&#34;words&#34;:1070,&#34;minutes&#34;:6},&#34;description&#34;:&#34;synchronized的两种用法\n\n对象锁\n\n\n包括方法锁(默认锁对象为this当前实例对象)和同步代码块锁(自己指定锁对象)\n\n\n类锁\n\n\n指synchronized修饰 static方法 或指定锁对象为 Class对象\n\n对象锁\n同步...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#synchronized%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95\&#34;&gt;synchronized的两种用法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E8%B1%A1%E9%94%81\&#34;&gt;对象锁&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97\&#34;&gt;同步代码块&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8-this-%E9%94%81%E5%AE%9A%E4%BB%A3%E7%A0%81%E5%9D%97\&#34;&gt;使用 this 锁定代码块&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%81%E5%AF%B9%E8%B1%A1\&#34;&gt;使用 自定义锁对象&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%95%E9%94%81\&#34;&gt;方法锁&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA\&#34;&gt;代码展示&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C\&#34;&gt;运行结果:&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E9%94%81\&#34;&gt;类锁&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E5%BF%B5\&#34;&gt;概念:&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95\&#34;&gt;同步一个全局方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA-2\&#34;&gt;代码展示&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-2\&#34;&gt;运行结果:&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E9%94%81%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97\&#34;&gt;类锁同步一个代码块&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA-3\&#34;&gt;代码展示&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-3\&#34;&gt;运行结果:&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;什么是spring-autoconfig\&#34;&gt;什么是Spring AutoConfig&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added. For example, if HSQLDB is on your classpath, and you have not manually configured any database connection beans, then Spring Boot auto-configures an in-memory database.&lt;br&gt;\nYou need to opt-in to auto-configuration by adding the &lt;code&gt;@EnableAutoConfiguration &lt;/code&gt; or &lt;code&gt;@SpringBootApplication&lt;/code&gt; annotations to one of your &lt;code&gt;@Configuration&lt;/code&gt; classes.&lt;br&gt;\n引用自: &lt;a href=\&#34;https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html\&#34;&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;怎样编写springboot2-autoconfig\&#34;&gt;怎样编写SpringBoot2 AutoConfig&lt;/h1&gt;\n&lt;p&gt;使用自动配置&lt;code&gt;HttpClient&lt;/code&gt;作为例子.&lt;/p&gt;\n&lt;h2 id=\&#34;编写一个属性配置类\&#34;&gt;编写一个属性配置类&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;@ConfigurationProperties(prefix = &amp;quot;spring.httpclient&amp;quot;)\n@Data\npublic class HttpClientProperties {\n    private Integer connectTimeOut = 1000;\n    private Integer socketTimeOut = 10000;\n    private String agent = &amp;quot;agent&amp;quot;;\n    private Integer maxConnPerRoute = 10;\n    private Integer maxConnTotal = 50;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 的 &lt;code&gt;prefix&lt;/code&gt; 提示Spring在启动时将配置文件中 &lt;code&gt;spring.httpclient&lt;/code&gt; 的与本类属性相对应的属性自动加载进来.&lt;br&gt;\n&lt;code&gt;@Data&lt;/code&gt; 是lombok的注解.&lt;/p&gt;\n&lt;h2 id=\&#34;编写自动配置核心类\&#34;&gt;编写自动配置核心类&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;@Configuration\n@ConditionalOnClass({HttpClient.class})\n@EnableConfigurationProperties(HttpClientProperties.class)\npublic class HttpClientAutoConfiguration {\n\n    private final HttpClientProperties properties;\n\n    public HttpClientAutoConfiguration(HttpClientProperties properties) {\n        this.properties = properties;\n    }\n\n\n    /**\n     * httpclient bean的定义\n     * @return Http Client\n     *\n     * ConditionalOnMissingBean -&amp;gt; 当用户未定义的时候才会创建\n     */\n    @Bean\n    @ConditionalOnMissingBean(HttpClient.class)\n    public HttpClient httpClient() {\n        RequestConfig requestConfig = RequestConfig.custom()\n                .setConnectTimeout(properties.getConnectTimeOut())\n                .setSocketTimeout(properties.getSocketTimeOut())\n                .build();\n        return HttpClientBuilder.create()\n                .setDefaultRequestConfig(requestConfig)\n                .setUserAgent(properties.getAgent())\n                .setMaxConnPerRoute(properties.getMaxConnPerRoute())\n                .setMaxConnTotal(properties.getMaxConnTotal())\n                // 防止重试\n                .setConnectionReuseStrategy(new NoConnectionReuseStrategy())\n                .build();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;@Configuration： 将本类标识为SpringBoot的Java配置类&lt;/li&gt;\n&lt;li&gt;@ConditionalOnClass({HttpClient.class})： 只有在HttpClient.class存在时才会加载java config&lt;/li&gt;\n&lt;li&gt;@EnableConfigurationProperties(HttpClientProperties.class)：本类加载时注入 &lt;code&gt;HttpClientProperties&lt;/code&gt; 属性配置的bean&lt;/li&gt;\n&lt;li&gt;httpClient()的@ConditionalOnMissingBean(HttpClient.class)：只有当没有创建HttpClient bean的时候，才会执行 httpClient()方法创建一个HttpClient bean&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;使spring感知自动配置类\&#34;&gt;使Spring感知自动配置类.&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;在 &lt;code&gt;spring-boot-autoconfigure&lt;/code&gt; 的 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 中, 编写了非常多的开源软件的自动配置类. 而如果我们自己编写自动配置类. 有以下几种方式：&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;方式一\&#34;&gt;方式一&lt;/h2&gt;\n&lt;p&gt;autoconfig在本项目的 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 目录下，不需要其他配置, 可以直接通过 &lt;code&gt;@AutoWired&lt;/code&gt; 注入 &lt;code&gt;HttpClient&lt;/code&gt;，如：&lt;br&gt;\n···&lt;br&gt;\n@RunWith(SpringRunner.class)&lt;br&gt;\n@SpringBootTest&lt;br&gt;\npublic class HouseApplicationTests {&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Autowired\nprivate HttpClient httpClient;\n\n@Test\npublic void contextLoads() throws IOException {\n\tString toString = httpClient.execute(new HttpGet(&amp;quot;http://www.imyzt.top&amp;quot;)).getEntity().toString();\n\tSystem.out.println(toString);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;br&gt;\n···&lt;/p&gt;\n&lt;h2 id=\&#34;方式二\&#34;&gt;方式二&lt;/h2&gt;\n&lt;p&gt;autoconfig不在本项目的 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 目录下，可以有两种方式自动配置：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;在本项目的resources下编写 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 文件.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ntop1.imyzt.autoconfig.HttpClientAutoConfiguration\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;[推荐] 编写 &lt;code&gt;@EnableHttpClient&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Import(HttpClientAutoConfiguration.class)\npublic @interface EnableHttpClient {\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在启动类上加上注解, 即可开启HttpClient配置.&lt;/p&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;教程是在学习慕课网上的 &lt;a href=\&#34;https://coding.imooc.com/class/174.html\&#34;&gt;Java从单体到微服务打造房产销售平台&lt;/a&gt; 时学习到的, 在此博客做一个总结, 以便后面复习.&lt;/p&gt;\n&lt;p&gt;上述代码在我的 &lt;a href=\&#34;https://github.com/imyzt/houses\&#34;&gt;Github&lt;/a&gt; 上可以找到.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;springboot2-bian-xie-zi-ding-yi-autoconfig&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;SpringBoot2 编写自定义AutoConfig&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-31 10:29:18&#34;,&#34;dateFormat&#34;:&#34;2019-01-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/springboot2-bian-xie-zi-ding-yi-autoconfig/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:176000,&#34;words&#34;:626,&#34;minutes&#34;:3},&#34;description&#34;:&#34;什么是Spring AutoConfig\n\nSpring Boot auto-configuration attempts to automatically configure your Spring application based o...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AFspring-autoconfig\&#34;&gt;什么是Spring AutoConfig&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%8E%E6%A0%B7%E7%BC%96%E5%86%99springboot2-autoconfig\&#34;&gt;怎样编写SpringBoot2 AutoConfig&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%B1%BB\&#34;&gt;编写一个属性配置类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%A0%B8%E5%BF%83%E7%B1%BB\&#34;&gt;编写自动配置核心类&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BFspring%E6%84%9F%E7%9F%A5%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB\&#34;&gt;使Spring感知自动配置类.&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E5%BC%8F%E4%B8%80\&#34;&gt;方式一&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E5%BC%8F%E4%BA%8C\&#34;&gt;方式二&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;该站是我通过Gridea搭建的小站。感谢&lt;a href=\&#34;https://gridea.dev/\&#34;&gt;Gridea&lt;/a&gt;&lt;br&gt;\n通过CloudFlare提供的免费服务，加速了本网站的访问，&lt;a href=\&#34;https://imyzt.top/post/shi-yong-cloudflare-jia-su-github-pages/\&#34;&gt;使用Cloudflare加速Github Pages&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;p&gt;我叫杨镇涛，是一名Java程序员。&lt;br&gt;\n现阶段本职工作是Java服务端开发, 平时会花一些时间做 Kubernetes 方面的学习研究。&lt;/p&gt;\n&lt;h2 id=\&#34;兴趣爱好\&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;\n&lt;p&gt;爬山，徒步&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/imyzt\&#34;&gt;github.com/imyzt&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-25 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/about/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:26000,&#34;words&#34;:121,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n该站是我通过Gridea搭建的小站。感谢Gridea\n通过CloudFlare提供的免费服务，加速了本网站的访问，使用Cloudflare加速Github Pages\n👨‍💻 ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD\&#34;&gt;⛹ 兴趣爱好&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;本篇接着上篇来, 继续学习java8新特性&lt;br&gt;\n&lt;a href=\&#34;http://blog.didispace.com/books/java8-tutorial/\&#34;&gt;Java 8 简明教程&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;map\&#34;&gt;Map&lt;/h1&gt;\n&lt;h1 id=\&#34;putifabsent\&#34;&gt;putIfAbsent&lt;/h1&gt;\n&lt;h2 id=\&#34;代码展示\&#34;&gt;代码展示&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; hashMap = new LinkedHashMap&amp;lt;&amp;gt;();\n\nhashMap.put(&amp;quot;val_1&amp;quot;, 1);\nhashMap.put(&amp;quot;val_2&amp;quot;, 2L);\nhashMap.put(&amp;quot;val_3&amp;quot;, null);\n\n\nSystem.out.println(hashMap);\n\nObject val_1 = hashMap.putIfAbsent(&amp;quot;val_1&amp;quot;, 111);\nSystem.out.println(val_1);\nObject val_3 = hashMap.putIfAbsent(&amp;quot;val_3&amp;quot;, 3);\nSystem.out.println(val_3);\nObject val_4 = hashMap.putIfAbsent(&amp;quot;val_4&amp;quot;, 4);\nSystem.out.println(val_4);\n\nSystem.out.println(hashMap);\n\n输出: \n{val_1=1, val_2=2, val_3=null}\n1\nnull\nnull\n{val_1=1, val_2=2, val_3=3, val_4=4}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;对比\&#34;&gt;对比&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;在之前如果我们存储一个key时, 需要判断是否存在, 不存在时添加. 我们需要先判断再添加. 在jdk1.8之后, 我们只需要 &lt;code&gt;putIfAbsent(k,v)&lt;/code&gt; 方法就可以完成.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code&gt;if (!hashMap.containsKey(&amp;quot;val_3&amp;quot;)) {\n    hashMap.put(&amp;quot;val_3&amp;quot;, &amp;quot;val_3&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;方法详解\&#34;&gt;方法详解&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;hashMap.putIfAbsent(&amp;quot;val_1&amp;quot;, 111);&lt;/code&gt;, 存在key时, 如果 &lt;strong&gt;value != null&lt;/strong&gt;, 不替换, 返回原本存储的 value&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;hashMap.putIfAbsent(&amp;quot;val_3&amp;quot;, 3);&lt;/code&gt;, 存在key时, 如果 &lt;strong&gt;value == null&lt;/strong&gt;, 替换value, 返回 &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;hashMap.putIfAbsent(&amp;quot;val_4&amp;quot;, 4);&lt;/code&gt;, 不存在key时, 直接put进去.&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;java-8-guide-e4&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 8 Guide E4&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;}],&#34;date&#34;:&#34;2019-01-21 10:46:24&#34;,&#34;dateFormat&#34;:&#34;2019-01-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-8-guide-e4/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:76000,&#34;words&#34;:256,&#34;minutes&#34;:2},&#34;description&#34;:&#34;\n本篇接着上篇来, 继续学习java8新特性\nJava 8 简明教程\n\nMap\nputIfAbsent\n代码展示\nMap&amp;lt;String, Object&amp;gt; hashMap = new LinkedHashMap&amp;lt;&amp;gt;()...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#map\&#34;&gt;Map&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#putifabsent\&#34;&gt;putIfAbsent&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA\&#34;&gt;代码展示&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E6%AF%94\&#34;&gt;对比&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3\&#34;&gt;方法详解&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;本篇接着上篇来, 继续学习java8新特性&lt;br&gt;\n&lt;a href=\&#34;http://blog.didispace.com/books/java8-tutorial/\&#34;&gt;Java 8 简明教程&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;stream-介绍\&#34;&gt;Stream 介绍&lt;/h1&gt;\n&lt;p&gt;Stream (流) 操作算是对集合的大大增强, 很多之前很复杂需要很多代码量的逻辑在此终结.&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;一个Collection(集合)可以通过调用 &lt;code&gt;stream()&lt;/code&gt; 和 &lt;code&gt;parallelStream()&lt;/code&gt; 两个方法获得 &lt;code&gt;stream&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;stream()方法返回一个 &lt;code&gt;顺序流&lt;/code&gt;, 所有的操作必须等待上一步的完成.&lt;/li&gt;\n&lt;li&gt;parallelStream()方法返回一个 &lt;code&gt;并行流&lt;/code&gt;, 操作会更高效, 考虑业务使用不同的流.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;流的操作分为 &lt;code&gt;中间操作&lt;/code&gt; 和 &lt;code&gt;终止操作&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;中间操作: 对流的处理还在进行中, 不会中指当前流. 可以返回一个流进行其他操作. 就像StringBuffer的append()一样&lt;/li&gt;\n&lt;li&gt;终止操作: 对流的处理将会终结, 当前流将不能继续使用.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;中间操作\&#34;&gt;中间操作&lt;/h1&gt;\n&lt;h2 id=\&#34;filter\&#34;&gt;Filter&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;Stream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Filter接收一个 &lt;code&gt;Predicate&amp;lt;? super T&amp;gt;&lt;/code&gt; 接口的参数进行过滤操作&lt;/p&gt;\n&lt;h2 id=\&#34;sorted\&#34;&gt;Sorted&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;Stream&amp;lt;T&amp;gt; sorted(Comparator&amp;lt;? super T&amp;gt; comparator);  \nStream&amp;lt;T&amp;gt; sorted();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;sorted()方法自然排序. 即调用对象本身的compareTo()方法排序.&lt;br&gt;\nsorted(Comparator&amp;lt;? super T&amp;gt; comparator);  接受一个 Comparator对象进行排序&lt;/p&gt;\n&lt;h2 id=\&#34;map\&#34;&gt;Map&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper);\nIntStream mapToInt(ToIntFunction&amp;lt;? super T&amp;gt; mapper);\nLongStream mapToLong(ToLongFunction&amp;lt;? super T&amp;gt; mapper);\nDoubleStream mapToDouble(ToDoubleFunction&amp;lt;? super T&amp;gt; mapper);\n&amp;lt;U&amp;gt; Stream&amp;lt;U&amp;gt; mapToObj(IntFunction&amp;lt;? extends U&amp;gt; mapper);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;map有上述几个方法, 可以转换为指定的类型, 方法参数都是接受一个 &lt;code&gt;xxxFunction&lt;/code&gt; 的转换器.  下面有一个演示.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;list.stream()\n        .filter(s -&amp;gt; s.startsWith(&amp;quot;1&amp;quot;))\n        .sorted(String::compareTo)\n        .mapToInt(Integer::valueOf)\n        .mapToObj(String::valueOf)\n        .mapToLong(Long::valueOf);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;终止操作\&#34;&gt;终止操作&lt;/h1&gt;\n&lt;h2 id=\&#34;match\&#34;&gt;Match&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;boolean anyMatch(Predicate&amp;lt;? super T&amp;gt; predicate);\nboolean allMatch(Predicate&amp;lt;? super T&amp;gt; predicate);\nboolean noneMatch(Predicate&amp;lt;? super T&amp;gt; predicate);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Match方法有三个, 都接受一个 &lt;code&gt;Predicate&lt;/code&gt; 条件来决定返回true or false&lt;/p&gt;\n&lt;h2 id=\&#34;count\&#34;&gt;Count&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;long count();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;count()计算集合大小, 这个方法很简单.&lt;/p&gt;\n&lt;h2 id=\&#34;reduce\&#34;&gt;Reduce&lt;/h2&gt;\n&lt;p&gt;有了Map, 那肯定是有Reduce, 不过Reduce是一个终止操作. 它接收一个 &lt;code&gt;xxxOperator&lt;/code&gt; 的操作函数.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&amp;lt;U&amp;gt; U reduce(U identity,\n                 BiFunction&amp;lt;U, ? super T, U&amp;gt; accumulator,\n                 BinaryOperator&amp;lt;U&amp;gt; combiner);\nT reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);\nOptional&amp;lt;T&amp;gt; reduce(BinaryOperator&amp;lt;T&amp;gt; accumulator);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下面有一个操作的演示.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;list.stream()\n        .sorted((s1, s2) -&amp;gt; s1.compareTo(s2) &amp;gt; 0 ? -1 : 0)\n        .reduce((i, j) -&amp;gt; i + &amp;quot;#&amp;quot; + j)\n        .ifPresent(System.out::println);\n\nSystem.out.println(&amp;quot;---------------------------&amp;quot;);\nfinal String join = &amp;quot;#&amp;quot;;\nString joinReduce = list.stream()\n        .reduce(join, (s1, s2) -&amp;gt; s1 + join + s2);\nSystem.out.println(joinReduce);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;所有操作的代码\&#34;&gt;所有操作的代码&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {\n\n    ArrayList &amp;lt;String&amp;gt; list = new ArrayList &amp;lt;&amp;gt;();\n    list.add(&amp;quot;11&amp;quot;);\n    list.add(&amp;quot;12&amp;quot;);\n    list.add(&amp;quot;13&amp;quot;);\n    list.add(&amp;quot;14&amp;quot;);\n\n    Comparator&amp;lt;String&amp;gt; comparator = String::compareTo;\n    Predicate&amp;lt;String&amp;gt; predicate = s -&amp;gt; s.startsWith(&amp;quot;1&amp;quot;);\n    IntUnaryOperator intUnaryOperator = i -&amp;gt; i + 1;\n    ToIntFunction&amp;lt;String&amp;gt; toIntFunction = Integer::valueOf;\n    IntConsumer consumer = System.out::println;\n\n    list.stream()\n            .filter(predicate)\n            .sorted(comparator)\n            .mapToInt(toIntFunction)\n            .map(intUnaryOperator)\n            .forEach(consumer);\n\n\n    boolean anyMatch = list.stream()\n            .filter(s -&amp;gt; s.startsWith(&amp;quot;1&amp;quot;))\n            .sorted(String::compareTo)\n            .mapToInt(Integer::valueOf)\n            .mapToObj(String::valueOf)\n            .mapToLong(Long::valueOf)\n            .anyMatch(i -&amp;gt; i &amp;gt; 10);\n    System.out.println(anyMatch);\n\n    long count = list.stream().count();\n    System.out.println(count);\n\n    list.stream()\n            .sorted((s1, s2) -&amp;gt; s1.compareTo(s2) &amp;gt; 0 ? -1 : 0)\n            .reduce((i, j) -&amp;gt; i + &amp;quot;#&amp;quot; + j)\n            .ifPresent(System.out::println);\n\n    System.out.println(&amp;quot;---------------------------&amp;quot;);\n    final String join = &amp;quot;#&amp;quot;;\n    String joinReduce = list.stream()\n            .reduce(join, (s1, s2) -&amp;gt; s1 + join + s2);\n    System.out.println(joinReduce);\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-8-guide-e3&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 8 Guide E3&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;}],&#34;date&#34;:&#34;2019-01-18 14:36:47&#34;,&#34;dateFormat&#34;:&#34;2019-01-18&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-8-guide-e3/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:237000,&#34;words&#34;:802,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n本篇接着上篇来, 继续学习java8新特性\nJava 8 简明教程\n\nStream 介绍\nStream (流) 操作算是对集合的大大增强, 很多之前很复杂需要很多代码量的逻辑在此终结.\n\n一个Collection(集合)可以通过调用 st...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#stream-%E4%BB%8B%E7%BB%8D\&#34;&gt;Stream 介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C\&#34;&gt;中间操作&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#filter\&#34;&gt;Filter&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sorted\&#34;&gt;Sorted&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#map\&#34;&gt;Map&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C\&#34;&gt;终止操作&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#match\&#34;&gt;Match&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#count\&#34;&gt;Count&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#reduce\&#34;&gt;Reduce&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BB%A3%E7%A0%81\&#34;&gt;所有操作的代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;本篇接着上篇来, 继续学习java8新特性&lt;br&gt;\n&lt;a href=\&#34;http://blog.didispace.com/books/java8-tutorial/\&#34;&gt;Java 8 简明教程&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;自定义一个函数式接口\&#34;&gt;自定义一个函数式接口&lt;/h1&gt;\n&lt;h2 id=\&#34;代码展示\&#34;&gt;代码展示&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/1/17 18:23\n * @description 自定义函数式接口\n */\npublic class FunctionInterfaceDemo {\n    public static void main(String[] args) {\n\n        Person&amp;lt;Boolean&amp;gt; person = Objects::nonNull;\n        Boolean aaa = person.say(&amp;quot;aaa&amp;quot;);\n        System.out.println(&amp;quot;传入的信息是否不为空: &amp;quot; + aaa);\n\n        Person&amp;lt;String&amp;gt; person1 = (msg) -&amp;gt; &amp;quot;Hello &amp;quot;+msg;\n        String say = person1.say(&amp;quot;World&amp;quot;);\n        System.out.println(say);\n    }\n}\n\n@FunctionalInterface\ninterface Person&amp;lt;T extends Object&amp;gt; {\n    T say(String msg);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;讲解\&#34;&gt;讲解&lt;/h2&gt;\n&lt;p&gt;&lt;em&gt;代&lt;/em&gt; 码中定义了一个接口 &lt;strong&gt;Person&lt;/strong&gt;, 接口上使用了 &lt;strong&gt;@FunctionalInterface&lt;/strong&gt; 注解, 接口泛型Object是一个约束, 在这里只是演示. 实际场景中可以写需要被约束的父类.&lt;br&gt;\n&lt;em&gt;使&lt;/em&gt; 用的时候, 实例 &lt;strong&gt;person&lt;/strong&gt; 的泛型是 &lt;strong&gt;Boolean&lt;/strong&gt; 布尔类型, 所以在表达式的右边, 也就是具体的实现上我调用了Objects的nonNull方法.  &lt;strong&gt;::&lt;/strong&gt; 表达式可以直接引用对象的方法.&lt;br&gt;\n&lt;em&gt;实&lt;/em&gt; 例 &lt;strong&gt;person1&lt;/strong&gt; 的泛型是 &lt;strong&gt;String&lt;/strong&gt;  字符串类型, 所以在表达式的右边可以定义对 &lt;strong&gt;say(String msg)&lt;/strong&gt;  中msg的操作, 然后调用say()方法时就会执行上述操作.&lt;/p&gt;\n&lt;h2 id=\&#34;结果输出\&#34;&gt;结果输出&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;传入的信息是否不为空: true\nHello World\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;内置函数式接口\&#34;&gt;内置函数式接口&lt;/h1&gt;\n&lt;p&gt;Java8内置了很多函数式接口便于我们使用；&lt;br&gt;\n当然,我们也可以自定义函数式接口通过**@FunctionalInterface**注解声明.&lt;br&gt;\njava.util.function下的接口最多支持到二元运算。有了这些接口，我们就可以省去创建接口的功夫，而直接使用lambda了。&lt;br&gt;\nNilary 零元，Unary 一元，Binary 二元，Ternary 三元，Quaternary 四元。对于一个算子来说，一个参数，就是一元运算；2个参数就是二元运算。&lt;/p&gt;\n&lt;h2 id=\&#34;predicate\&#34;&gt;Predicate&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Predicate是一个布尔类型的函数，该函数只有一个输入参数。&lt;br&gt;\nPredicate接口包含了多种默认方法，用于处理复杂的逻辑动词（and, or，negate）&lt;br&gt;\n摘抄自 &lt;a href=\&#34;http://blog.didispace.com/books/java8-tutorial/ch1.html\&#34;&gt;http://blog.didispace.com/books/java8-tutorial/ch1.html&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code&gt;Predicate&amp;lt;String&amp;gt; predicate = (a) -&amp;gt; a.startsWith(&amp;quot;a&amp;quot;);\nPredicate&amp;lt;String&amp;gt; predicate2 = Objects::nonNull;\n\nboolean test = predicate.negate().and(predicate2).test(&amp;quot;abc&amp;quot;);\nSystem.out.println(test);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;consumer\&#34;&gt;Consumer&lt;/h2&gt;\n&lt;p&gt;Consumer 消费target type。参数 T，无返回值（void）。&lt;br&gt;\nConsumer可以理解为一个消费者, 因为他没有返回值, 只接收一个参数, 按照重写的方法执行完成后即完成操作.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Consumer&amp;lt;String&amp;gt; consumer = System.out::println;\nconsumer.accept(&amp;quot;hello world&amp;quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;function\&#34;&gt;Function&lt;/h2&gt;\n&lt;p&gt;Function 对target type做转换。参数T，返回R。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Predicate&amp;lt;String&amp;gt; predicate = s -&amp;gt; null != s &amp;amp;&amp;amp; s.startsWith(v26);\n\nFunction&amp;lt;String, String&amp;gt; function = s -&amp;gt; predicate.test(pageInfo) ?\nsdkHttpKit.ipPort().append(s).toString() :\nsdkHttpKit.uri().append(&amp;quot;face/meta/&amp;quot;).append(URLUtil.encode(meta)).toString();\n\nString url = function.apply(pageInfo);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;supplier\&#34;&gt;Supplier&lt;/h2&gt;\n&lt;p&gt;Supplier 供应target，可以理解为target的factory。无参，返回T。&lt;br&gt;\nSupplier 可以理解为工厂类, 通过下面的演示可以看出它能够创建对象.不过我看了别人的博客, 理解为这个方法可以将耗时的操作放进去. 在没有调用get()方法之前, 是不会执行的.可以降低系统运行时间.&lt;br&gt;\nMain.java&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Supplier&amp;lt;People&amp;gt; supplier = People::new;\n// 在需要的时候可以调用get()方法获得一个新的People对象.\nPeople people = supplier.get();\npeople.hello();\n\n输出: hello\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;People.java&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;class People {\n    void hello() {\n        System.out.println(&amp;quot;hello&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;unaryoperator\&#34;&gt;UnaryOperator&lt;/h2&gt;\n&lt;p&gt;UnaryOperator 一元运算。继承Function接口。参数T，返回T。&lt;br&gt;\nUnaryOperator 可以理解为对参数T进行处理.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;UnaryOperator&amp;lt;String&amp;gt; unaryOperator = s -&amp;gt; s + &amp;quot;___&amp;quot;;\nSystem.out.println(unaryOperator.apply(&amp;quot;hello&amp;quot;));\n\n输出: hello___\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;binaryoperator\&#34;&gt;BinaryOperator&lt;/h2&gt;\n&lt;p&gt;BinaryOperator 二元运算。参数 T,返回R。&lt;br&gt;\nBinaryOperator为UnaryOperator的二元运算, 它接收两个T参数, 返回的也是T参数, 可以理解对两个参数的条件操作&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;BiPredicate&amp;lt;String, String&amp;gt; biPredicate =\n    (s1, s2) -&amp;gt; s1.startsWith(&amp;quot;s1&amp;quot;) &amp;amp;&amp;amp; s2.endsWith(&amp;quot;s2&amp;quot;);\n\nBinaryOperator&amp;lt;String&amp;gt; binaryOperator =\n    // 当条件满足时, 执行三目运算的第一个操作. 否则第二个操作执行.\n    (s1, s2) -&amp;gt; biPredicate.test(s1, s2) ?\n    s2 + &amp;quot;_&amp;quot; + s1 : s1 + &amp;quot;_&amp;quot; + s2;\n        \nSystem.out.println(binaryOperator.apply(&amp;quot;s1&amp;quot; , &amp;quot;s2&amp;quot;));\n\n输出: s2_s1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;comparator\&#34;&gt;Comparator&lt;/h2&gt;\n&lt;p&gt;这个可以用来做比较. 在上一篇已经有使用过了. 此处添加一点演示代码&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Supplier&amp;lt;People&amp;gt; supplier = People::new;\n\nPeople people1 = supplier.get();\npeople1.setPeopleId(10);\nPeople people2 = supplier.get();\npeople2.setPeopleId(100);\n\nComparator&amp;lt;People&amp;gt; comparator1 = Comparator.comparing(People::getPeopleId);\nSystem.out.println(comparator1.compare(people2, people1));\n\nComparator&amp;lt;People&amp;gt; comparator2 = (p1, p2) -&amp;gt; p1.getPeopleId() &amp;gt; p2.getPeopleId() ? 1 : 0;\nSystem.out.println(comparator2.compare(people1, people2));\n\n第一个输出: 1  \n第二个输出: 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;binary\&#34;&gt;Binary&lt;/h2&gt;\n&lt;p&gt;Consumer、Function、Predicate分别还对应了Bi的函数式接口。&lt;br&gt;\n它们的操作与对应的一元运算也是大同小异, 只是参数多了一个. 就不细讲了&lt;br&gt;\n对应的也就是二元运算函数。分别是&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;BiConsumer&amp;lt;T, U&amp;gt;  接收T对象和U对象，不返回值&lt;/li&gt;\n&lt;li&gt;BiPredicate&amp;lt;T, U&amp;gt; 接收T对象和U对象，返回boolean&lt;/li&gt;\n&lt;li&gt;BiFunction&amp;lt;T, U, R&amp;gt; 接收T对象和U对象，返回R对象&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;接口一大堆, 我所理解的&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Consumer, BiConsumer: 消费&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Predicate, BiPredicate: 条件判断&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Function, BiFunction, UnaryOperator, BinaryOperator: 参数处理&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Supplier: 工厂&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;java-8-guide-e2&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 8 Guide E2&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;}],&#34;date&#34;:&#34;2019-01-17 18:36:08&#34;,&#34;dateFormat&#34;:&#34;2019-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-8-guide-e2/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:328000,&#34;words&#34;:1249,&#34;minutes&#34;:6},&#34;description&#34;:&#34;\n本篇接着上篇来, 继续学习java8新特性\nJava 8 简明教程\n\n自定义一个函数式接口\n代码展示\n/**\n * @author imyzt\n * @date 2019/1/17 18:23\n * @description 自定义函数式...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\&#34;&gt;自定义一个函数式接口&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA\&#34;&gt;代码展示&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%B2%E8%A7%A3\&#34;&gt;讲解&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA\&#34;&gt;结果输出&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\&#34;&gt;内置函数式接口&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#predicate\&#34;&gt;Predicate&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#consumer\&#34;&gt;Consumer&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#function\&#34;&gt;Function&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#supplier\&#34;&gt;Supplier&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#unaryoperator\&#34;&gt;UnaryOperator&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#binaryoperator\&#34;&gt;BinaryOperator&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#comparator\&#34;&gt;Comparator&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#binary\&#34;&gt;Binary&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;文章系学习java8新特性\&#34;&gt;文章系学习Java8新特性&lt;/h1&gt;\n&lt;p&gt;教程地址: &lt;a href=\&#34;http://blog.didispace.com/books/java8-tutorial/\&#34;&gt;Java8简明教程&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;在接口中定义默认方法\&#34;&gt;在接口中定义默认方法&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;通过static修饰, 该方法不可被重写.&lt;/li&gt;\n&lt;li&gt;通过default修饰, 该方法不仅仅默认实现, 还可以被实现类重写&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;示例代码\&#34;&gt;示例代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * Created by imyzt on 2019/1/17 10:59\n * 可以在接口中定义默认方法\n */\npublic interface Formula {\n\n    double calculate(int a);\n\n    default double sqrt(int a) {\n        return Math.sqrt(a);\n    }\n\n    static int abs (int b) {\n        return Math.abs(b);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Formula formula = new Formula() {\n            @Override\n            public double calculate(int a) {\n                return sqrt(a * 1000);\n            }\n        };\n\n        double calculate = formula.calculate(1);\n        System.out.println(calculate);              //31.622776601683793\n\n        double sqrt = formula.sqrt(1000);\n        System.out.println(sqrt);                   //31.622776601683793\n\n        int abs = Formula.abs(1000);\n        System.out.println(abs);                    //1000\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;lambda表达式\&#34;&gt;Lambda表达式&lt;/h1&gt;\n&lt;p&gt;Lambda表达式是java8最大的更新了, 使得一些操作十分简单明了.&lt;/p&gt;\n&lt;h2 id=\&#34;不使用lambda表达式进行集合排序\&#34;&gt;不使用lambda表达式进行集合排序&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; names = Arrays.asList(&amp;quot;peter&amp;quot;, &amp;quot;anna&amp;quot;, &amp;quot;mike&amp;quot;, &amp;quot;xenia&amp;quot;);\nCollections.sort(names, new Comparator &amp;lt;String&amp;gt;() {\n    @Override\n    public int compare(String a, String b) {\n        return b.compareTo(a);\n    }\n});        \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;使用lambda表达式进行集合排序\&#34;&gt;使用Lambda表达式进行集合排序&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt; Collections.sort(names, (String a, String b) -&amp;gt; {\n     return b.compareTo(a);\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;不过，还可以省去返回值的表述&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;Collections.sort(names, (String a, String b) -&amp;gt; b.compareTo(a));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;Lambda可以自动识别类型, 因此我们可以删除掉类型声明&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;Collections.sort(names, (a, b) -&amp;gt; b.compareTo(a));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;当然, 也可以将具体动作简化&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;Collections.sort(names, Comparator.reverseOrder());\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;最后, java8的jdk集合中实现了sort方法, 因此我们可以用最后这句话来实现集合的排序&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;names.sort(Comparator.reverseOrder());\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-8-guide-e1&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java 8 Guide E1&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java_New_Future&#34;,&#34;slug&#34;:&#34;d0y-MXsof&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/d0y-MXsof/&#34;}],&#34;date&#34;:&#34;2019-01-17 11:21:18&#34;,&#34;dateFormat&#34;:&#34;2019-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-8-guide-e1/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:107000,&#34;words&#34;:380,&#34;minutes&#34;:2},&#34;description&#34;:&#34;文章系学习Java8新特性\n教程地址: Java8简明教程\n在接口中定义默认方法\n\n通过static修饰, 该方法不可被重写.\n通过default修饰, 该方法不仅仅默认实现, 还可以被实现类重写\n\n示例代码\n/**\n * Created ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E7%AB%A0%E7%B3%BB%E5%AD%A6%E4%B9%A0java8%E6%96%B0%E7%89%B9%E6%80%A7\&#34;&gt;文章系学习Java8新特性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95\&#34;&gt;在接口中定义默认方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\&#34;&gt;示例代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\&#34;&gt;Lambda表达式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8D%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F\&#34;&gt;不使用lambda表达式进行集合排序&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F\&#34;&gt;使用Lambda表达式进行集合排序&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;常用aop代理形式\&#34;&gt;常用AOP代理形式&lt;/h1&gt;\n&lt;p&gt;AOP常见有静态代理和动态代理&lt;br&gt;\n静态代理代表为AspectJ；&lt;br&gt;\n动态代理有jdk动态代理， cglib动态代理。&lt;/p&gt;\n&lt;h1 id=\&#34;静态代理\&#34;&gt;静态代理&lt;/h1&gt;\n&lt;p&gt;AspectJ是静态代理的增强， 即编译时生成代理类， 也成为编译时增强。性能较好。 不过由于需要特定的编译器进行处理。&lt;/p&gt;\n&lt;h1 id=\&#34;动态代理\&#34;&gt;动态代理&lt;/h1&gt;\n&lt;p&gt;动态代理是每次运行的时候生成代理AOP代理类，不会修改字节码文件。代理对象创建在内存中。&lt;br&gt;\n由于是在运行的时候生成代理，故性能稍差一点。&lt;/p&gt;\n&lt;h1 id=\&#34;jdk动态代理实例\&#34;&gt;JDK动态代理实例&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\n/**\n * @author imyzt\n * @date 2019/1/17 9:51\n * @description JDK动态代理演示\n */\npublic class JdkDynamicProxyDemo {\n\n    public static void main(String[] args) {\n\n        // 创建需要被代理的实例对象\n        JdkDynamicProxyClass jdkDynamicProxyClass = new JdkDynamicProxyClass();\n\n        JdkDynamicProxyInvocationHandler invocationHandler =\n                new JdkDynamicProxyInvocationHandler(jdkDynamicProxyClass);\n\n        // 增强代理类\n        // Proxy.newProxyInstance();\n        JdkDynamicProxyInterface proxyInstance = (JdkDynamicProxyInterface) Proxy.newProxyInstance(\n                jdkDynamicProxyClass.getClass().getClassLoader(),\n                jdkDynamicProxyClass.getClass().getInterfaces(),\n                invocationHandler);\n\n        // 执行被增强的方法\n        proxyInstance.proxyMethod();\n    }\n\n}\n\ninterface JdkDynamicProxyInterface {\n    void proxyMethod();\n}\n\nclass JdkDynamicProxyClass implements JdkDynamicProxyInterface {\n\n    @Override\n    public void proxyMethod() {\n        System.out.println(&amp;quot;JDK Dynamic Proxy Method is running&amp;quot;);\n    }\n}\n\nclass JdkDynamicProxyInvocationHandler implements InvocationHandler {\n\n    private Object target;\n\n    public JdkDynamicProxyInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        String name = method.getName();\n\n        System.out.println(&amp;quot;execute before JDK Dynamic Method = &amp;quot; + name);\n        Object invoke = method.invoke(target, args);\n        System.out.println(&amp;quot;execute after JDK Dynamic Method = &amp;quot; + name);\n\n        return invoke;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果展示&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/01/snshnohgkuidrpn93pkdtlpeji.jpg\&#34; alt=\&#34;JDK动态代理\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;cglib-动态代理\&#34;&gt;CGLIB 动态代理&lt;/h1&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @author imyzt\n * @date 2019/1/17 10:05\n * @description CGLIB 动态代理演示\n */\npublic class CglibDynamicProxyDemo {\n\n    public static void main(String[] args) {\n\n        CglibDynamicProxy cglibDynamicProxy = new CglibDynamicProxy();\n\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(CglibDynamicClass.class);\n        enhancer.setCallback(cglibDynamicProxy);\n\n        CglibDynamicClass cglibDynamicClass = (CglibDynamicClass) enhancer.create();\n\n        String yyy = cglibDynamicClass.proxyMethod(&amp;quot;yyy&amp;quot;);\n\n        System.out.println(yyy);\n\n\n    }\n}\nclass CglibDynamicClass {\n    public String proxyMethod(String message){\n        System.out.println(&amp;quot;hello! you say &amp;quot; + message);\n        return message;\n    }\n}\nclass CglibDynamicProxy implements MethodInterceptor {\n\n    @Override\n    public Object intercept(Object proxyClass, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n\n        String name = method.getName();\n\n        System.out.println(&amp;quot;execute before CGLIB Dynamic Method = &amp;quot; + name);\n        Object invoke = **methodProxy.invokeSuper**(proxyClass, args);\n        System.out.println(&amp;quot;execute after CGLIB Dynamic Method = &amp;quot; + name);\n\n        return invoke;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果展示&lt;br&gt;\n&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/01/5g7aind0nsj9noqhbc3c69qd48.jpg\&#34; alt=\&#34;请输入图片描述\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;spring-aop\&#34;&gt;Spring AOP&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Spring AOP在使用的时候会判断，如果需要代理的类实现了接口， 则会使用JDK代理，如果没有实现接口， 则使用CGLIB代理。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;JDK动态代理通过反射来接收被代理的类&lt;/strong&gt;，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。&lt;br&gt;\n如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类（通过修改字节码来实现代理）。&lt;br&gt;\n注意，&lt;strong&gt;CGLIB是通过继承的方式做的动态代理&lt;/strong&gt;，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。&lt;/p&gt;\n&lt;p&gt;文章中部分内容转载自掘金-&lt;a href=\&#34;https://juejin.im/post/5c3e9c37f265da61263862f1\&#34;&gt;年糕妈妈技术团队&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;spring-aop-shi-xian&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Spring AOP 实现&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-17 10:39:02&#34;,&#34;dateFormat&#34;:&#34;2019-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/spring-aop-shi-xian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:192000,&#34;words&#34;:708,&#34;minutes&#34;:4},&#34;description&#34;:&#34;常用AOP代理形式\nAOP常见有静态代理和动态代理\n静态代理代表为AspectJ；\n动态代理有jdk动态代理， cglib动态代理。\n静态代理\nAspectJ是静态代理的增强， 即编译时生成代理类， 也成为编译时增强。性能较好。 不过由于需...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E7%94%A8aop%E4%BB%A3%E7%90%86%E5%BD%A2%E5%BC%8F\&#34;&gt;常用AOP代理形式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86\&#34;&gt;静态代理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\&#34;&gt;动态代理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B\&#34;&gt;JDK动态代理实例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\&#34;&gt;CGLIB 动态代理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#spring-aop\&#34;&gt;Spring AOP&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;创建一个实体关系\&#34;&gt;创建一个实体关系&lt;/h2&gt;\n&lt;p&gt;File -&amp;gt; New Model -&amp;gt; Model types -&amp;gt; Physical Data Model -&amp;gt; Physical Diagram&lt;/p&gt;\n&lt;h2 id=\&#34;修改code-不随着name一起改变\&#34;&gt;修改code 不随着name一起改变&lt;/h2&gt;\n&lt;p&gt;Tools -&amp;gt; General Options -&amp;gt; Dialog 取消勾选 Name to Code mirroring&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://blog.imyzt.top/upload/2019/01/38686k222qhk9p85h3rjbe39r4.png\&#34; alt=\&#34;文章配图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;powerdesigner-chang-yong-bei-wang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;PowerDesigner常用备忘&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-04 09:28:45&#34;,&#34;dateFormat&#34;:&#34;2019-01-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/powerdesigner-chang-yong-bei-wang/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:13000,&#34;words&#34;:47,&#34;minutes&#34;:1},&#34;description&#34;:&#34;创建一个实体关系\nFile -&amp;gt; New Model -&amp;gt; Model types -&amp;gt; Physical Data Model -&amp;gt; Physical Diagram\n修改code 不随着name一起改变\nTool...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB\&#34;&gt;创建一个实体关系&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9code-%E4%B8%8D%E9%9A%8F%E7%9D%80name%E4%B8%80%E8%B5%B7%E6%94%B9%E5%8F%98\&#34;&gt;修改code 不随着name一起改变&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;原文链接\&#34;&gt;原文链接&lt;/h2&gt;\n&lt;p&gt;CSDN:  &lt;a href=\&#34;https://blog.csdn.net/qq_35030994/article/details/80871279\&#34;&gt;https://blog.csdn.net/qq_35030994/article/details/80871279&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;修改了以下内容\&#34;&gt;修改了以下内容&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;将定时扫描过期Key的任务使用Spring注解&lt;code&gt;@Scheduled&lt;/code&gt;的cron实现&lt;/li&gt;\n&lt;li&gt;将Cache改变为支持泛型，调整为单例模式。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;cache源代码\&#34;&gt;Cache源代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;package cn.anytec.cloud.bus.utils;\n\nimport cn.anytec.cloud.bus.service.ScheduledService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Cache缓存\n * @author imyzt\n */\npublic class Cache&amp;lt;K, V&amp;gt; {\n\n    private static Logger LOGGER = LoggerFactory.getLogger(Cache.class);\n\n    /**\n     * 缓存最大个数\n     */\n    private static final Integer CACHE_MAX_NUMBER = Constant.DEFAULT_CACHE_MAX_NUMBER;\n    /**\n     * 当前缓存个数\n     */\n    private static Integer CURRENT_SIZE = 0;\n    /**\n     * 缓存对象\n     */\n    private final Map&amp;lt;K, CacheObj&amp;lt;V&amp;gt;&amp;gt; CACHE_OBJECT_MAP = new ConcurrentHashMap&amp;lt;&amp;gt;();\n    /**\n     * 这个记录了缓存使用的最后一次的记录，最近使用的在最前面\n     */\n    private final List&amp;lt;K&amp;gt; CACHE_USE_LOG_LIST = new LinkedList&amp;lt;&amp;gt;();\n\n    /**\n     * 默认Key\n     */\n    private final String DEFAULT_VALUE = &amp;quot;DEFAULT_VALUE&amp;quot;;\n\n    private Cache() { }\n    private static Cache cache = new Cache();\n\n    public static Cache defaultCache() {\n        return cache;\n    }\n\n    /**\n     * 设置缓存\n     */\n    public void set(K cacheKey, V cacheValue, long cacheTime) {\n        Long ttlTime = null;\n        if (cacheTime &amp;lt;= 0L) {\n            if (cacheTime == -1L) {\n                ttlTime = -1L;\n            } else {\n                return;\n            }\n        }\n        checkSize();\n        saveCacheUseLog(cacheKey);\n        CURRENT_SIZE = CURRENT_SIZE + 1;\n        if (ttlTime == null) {\n            ttlTime = System.currentTimeMillis() + cacheTime;\n        }\n        CacheObj&amp;lt;V&amp;gt; cacheObj = new CacheObj(cacheValue, ttlTime);\n        CACHE_OBJECT_MAP.put(cacheKey, cacheObj);\n        LOGGER.info(&amp;quot;have set key :&amp;quot; + cacheKey);\n    }\n\n    /**\n     * 设置缓存\n     */\n    public void set(K cacheKey, V cacheValue) {\n        set(cacheKey, cacheValue, -1L);\n    }\n\n    /**\n     * 设置缓存\n     */\n    public void set(K cacheKey, long cacheTime) {\n        set(cacheKey, (V) DEFAULT_VALUE, cacheTime);\n    }\n\n    /**\n     * 获取缓存\n     */\n    public Object get(K cacheKey) {\n        if (checkCache(cacheKey)) {\n            saveCacheUseLog(cacheKey);\n            return CACHE_OBJECT_MAP.get(cacheKey).getCacheValue();\n        }\n        return null;\n    }\n\n    /**\n     * 是否包含某一个Key值\n     * @param cacheKey\n     * @return\n     */\n    public  boolean containsKey(K cacheKey) {\n        return checkCache(cacheKey);\n    }\n\n    /**\n     * 删除所有缓存\n     */\n    public void clear() {\n        LOGGER.info(&amp;quot;have clean all key !&amp;quot;);\n        CACHE_OBJECT_MAP.clear();\n        CURRENT_SIZE = 0;\n    }\n\n    /**\n     * 删除某个缓存\n     */\n    public void del(K cacheKey) {\n        Object cacheValue = CACHE_OBJECT_MAP.remove(cacheKey);\n        if (cacheValue != null) {\n            LOGGER.info(&amp;quot;have delete key :&amp;quot; + cacheKey);\n            CURRENT_SIZE = CURRENT_SIZE - 1;\n        }\n    }\n\n    /**\n     * 判断缓存在不在,过没过期\n     */\n    private boolean checkCache(K cacheKey) {\n        CacheObj cacheObj = CACHE_OBJECT_MAP.get(cacheKey);\n        if (cacheObj == null) {\n            return false;\n        }\n        if (cacheObj.getTtlTime() == -1L) {\n            return true;\n        }\n        if (cacheObj.getTtlTime() &amp;lt; System.currentTimeMillis()) {\n            del(cacheKey);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * 删除最近最久未使用的缓存\n     */\n    private void deleteLRU() {\n        LOGGER.info(&amp;quot;delete Least recently used run!&amp;quot;);\n        K cacheKey = CACHE_USE_LOG_LIST.remove(CACHE_USE_LOG_LIST.size() - 1);\n        del(cacheKey);\n    }\n\n    /**\n     * 删除过期的缓存\n     * 禁止手动调用! 由定时任务定时拉起\n     * @see ScheduledService#deleteTimeOut()\n     */\n    public void deleteTimeOut() {\n        LOGGER.info(&amp;quot;delete time out run!&amp;quot;);\n        List&amp;lt;K&amp;gt; deleteKeyList = new LinkedList&amp;lt;&amp;gt;();\n        for(Map.Entry&amp;lt;K, CacheObj&amp;lt;V&amp;gt;&amp;gt; entry : CACHE_OBJECT_MAP.entrySet()) {\n            if (entry.getValue().getTtlTime() &amp;lt; System.currentTimeMillis() &amp;amp;&amp;amp; entry.getValue().getTtlTime() != -1L) {\n                deleteKeyList.add(entry.getKey());\n            }\n        }\n\n        for (K deleteKey : deleteKeyList) {\n            del(deleteKey);\n        }\n        LOGGER.info(&amp;quot;delete cache count is :&amp;quot; + deleteKeyList.size());\n\n    }\n\n    /**\n     * 检查大小\n     * 当当前大小如果已经达到最大大小\n     * 首先删除过期缓存，如果过期缓存删除过后还是达到最大缓存数目\n     * 删除最久未使用缓存\n     */\n    private  void checkSize() {\n        if (CURRENT_SIZE &amp;gt;= CACHE_MAX_NUMBER) {\n            deleteTimeOut();\n        }\n        if (CURRENT_SIZE &amp;gt;= CACHE_MAX_NUMBER) {\n            deleteLRU();\n        }\n    }\n\n    /**\n     * 保存缓存的使用记录\n     */\n    private synchronized void saveCacheUseLog(K cacheKey) {\n        CACHE_USE_LOG_LIST.remove(cacheKey);\n        CACHE_USE_LOG_LIST.add(0, cacheKey);\n    }\n\n    public  void showUtilsInfo() {\n        System.out.println(&amp;quot;cache max count is :&amp;quot; + CACHE_MAX_NUMBER);\n        System.out.println(&amp;quot;cache current count is :&amp;quot; + CURRENT_SIZE);\n        System.out.println(&amp;quot;cache object map is :&amp;quot; + CACHE_OBJECT_MAP.toString());\n        System.out.println(&amp;quot;cache use log list is :&amp;quot; + CACHE_USE_LOG_LIST.toString());\n\n    }\n\n}\n\nclass CacheObj&amp;lt;V&amp;gt; {\n    /**\n     * 缓存对象\n     */\n    private V cacheValue;\n    /**\n     * 缓存过期时间\n     */\n    private Long ttlTime;\n\n    CacheObj(V cacheValue, Long ttlTime) {\n        this.cacheValue = cacheValue;\n        this.ttlTime = ttlTime;\n    }\n\n    Object getCacheValue() {\n        return cacheValue;\n    }\n\n    Long getTtlTime() {\n        return ttlTime;\n    }\n\n    @Override\n    public String toString() {\n        return &amp;quot;CacheObj{&amp;quot; +\n                &amp;quot;cacheValue=&amp;quot; + cacheValue +\n                &amp;quot;, ttlTime=&amp;quot; + ttlTime +\n                &#39;}&#39;;\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;定时任务\&#34;&gt;定时任务&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;@Component\npublic class ScheduledService {\n\n    @Scheduled(cron = &amp;quot;${bus.cache-delete-cycle}&amp;quot;)\n    public void deleteTimeOut() {\n        Cache.defaultCache().deleteTimeOut();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-shi-xian-dai-ding-shi-xiao-guo-de-cache&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java实现带定时效果的Cache&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-12-17 15:27:02&#34;,&#34;dateFormat&#34;:&#34;2018-12-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-shi-xian-dai-ding-shi-xiao-guo-de-cache/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:248000,&#34;words&#34;:779,&#34;minutes&#34;:5},&#34;description&#34;:&#34;原文链接\nCSDN:  https://blog.csdn.net/qq_35030994/article/details/80871279\n修改了以下内容\n\n将定时扫描过期Key的任务使用Spring注解@Scheduled的cron实现...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E6%96%87%E9%93%BE%E6%8E%A5\&#34;&gt;原文链接&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9%E4%BA%86%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9\&#34;&gt;修改了以下内容&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cache%E6%BA%90%E4%BB%A3%E7%A0%81\&#34;&gt;Cache源代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\&#34;&gt;定时任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;\n✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/getgridea/gridea\&#34;&gt;Github&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;https://gridea.dev/\&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;http://fehey.com/\&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;特性\&#34;&gt;特性👇&lt;/h2&gt;\n&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;\n&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;\n&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;\n&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;\n&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;\n&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;\n&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=\&#34;https://github.com/gitalk/gitalk\&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=\&#34;https://github.com/SukkaW/DisqusJS\&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;\n&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;\n&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;\n&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;\n&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;\n&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;\n&lt;p&gt;😘 Enjoy~&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;hello-gridea&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;\n✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Hello Gridea&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Gridea&#34;,&#34;slug&#34;:&#34;SX_IG-Y0t&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/SX_IG-Y0t/&#34;}],&#34;date&#34;:&#34;2018-12-12 00:00:00&#34;,&#34;dateFormat&#34;:&#34;2018-12-12&#34;,&#34;feature&#34;:&#34;https://imyzt.top/post-images/hello-gridea.png&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/hello-gridea/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:62000,&#34;words&#34;:298,&#34;minutes&#34;:2},&#34;description&#34;:&#34;👏  欢迎使用 Gridea ！\n✍️  Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...\n\nGithub\nGridea 主页\n示例网站\n特性👇\n📝  你可以使用最酷的 Markdo...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%89%B9%E6%80%A7\&#34;&gt;特性👇&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;p&gt;自从百家号发布后，使用百度搜索内容，前几条全部都是百家号的抄袭文章。使用体验非常不爽。&lt;/p&gt;\n&lt;h2 id=\&#34;寻找解决方法\&#34;&gt;寻找解决方法&lt;/h2&gt;\n&lt;p&gt;前段时间看到有人用&lt;a href=\&#34;https://tampermonkey.net/\&#34;&gt;油猴&lt;/a&gt;写了一个&lt;a href=\&#34;https://greasyfork.org/zh-CN/scripts/13468-ac-csdn%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80-csdn%E8%87%AA%E5%8A%A8%E8%AF%84%E8%AE%BA\&#34;&gt;自动展开CSDN【阅读全文】&lt;/a&gt;的脚本，大有启发，然后用油猴写了几句非常简单的js脚本，结合&lt;a href=\&#34;https://www.baidu.com/gaoji/advanced.html\&#34;&gt;百度高级搜索&lt;/a&gt;的 &lt;code&gt;-()&lt;/code&gt; 命令，解决了这个烦恼许久问题。&lt;/p&gt;\n&lt;p&gt;代码如下，导入油猴即可使用（非常简单，主要提供了思路，路过大神勿喷）：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// ==UserScript==\n// @author        imyzt\n// @namespace     http://imyzt.top/28\n// @version       1.0\n// @name          exclude baijiahao\n// @namespace     http://imyzt.top\n// @description   屏蔽百家号\n// @include       https://www.baidu.com/*\n// ==/UserScript==\n\n// 文本框的值\nvar wd = document.getElementById(&#39;kw&#39;).value;\n// 当输入框中有值或者 文本框不包含-(baijiahao)字眼时, 执行变更, 然后刷新页面\nif (wd !== &#39;&#39; &amp;amp;&amp;amp; wd.indexOf(&#39;-(baijiahao)&#39;) == -1) {\n    changeValAndReload(wd)\n}\n\n// 监听在文本框加入内容的事件\n$(&#39;#kw&#39;).on(&#39;change&#39;, function() {\n    var value = document.getElementById(&#39;kw&#39;).value;\n    var rep = value.replace(&amp;quot;-(baijiahao)&amp;quot;,&amp;quot;&amp;quot;);\n    changeValAndReload(rep)\n});\n\n// 修改值\nfunction changeValAndReload(val) {\n    document.getElementById(&#39;kw&#39;).value = val + &#39; -(baijiahao)&#39;;\n    document.getElementById(&#39;su&#39;).click()\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;授人以渔\&#34;&gt;授人以渔&lt;/h2&gt;\n&lt;p&gt;油猴的脚本更多就是JavaScript的操作，如果需要学习，可以 &lt;a href=\&#34;http://old.sebug.net/paper/books/greasemonkey/\&#34;&gt;点击这里&lt;/a&gt;, 前往学习.&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ping-bi-bai-jia-hao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;屏蔽百家号&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-12-08 17:37:22&#34;,&#34;dateFormat&#34;:&#34;2018-12-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/ping-bi-bai-jia-hao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:75000,&#34;words&#34;:309,&#34;minutes&#34;:2},&#34;description&#34;:&#34;前言\n自从百家号发布后，使用百度搜索内容，前几条全部都是百家号的抄袭文章。使用体验非常不爽。\n寻找解决方法\n前段时间看到有人用油猴写了一个自动展开CSDN【阅读全文】的脚本，大有启发，然后用油猴写了几句非常简单的js脚本，结合百度高级搜索的...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%BB%E6%89%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\&#34;&gt;寻找解决方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%88%E4%BA%BA%E4%BB%A5%E6%B8%94\&#34;&gt;授人以渔&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;起因\&#34;&gt;起因&lt;/h2&gt;\n&lt;p&gt;公司搭建了自己的代码仓库，使用的gitlab，需要将github上面的代码迁移至本地gitlab仓库。&lt;/p&gt;\n&lt;h2 id=\&#34;思路\&#34;&gt;思路&lt;/h2&gt;\n&lt;p&gt;1.在公司代码库建立一个新的代码库&lt;br&gt;\n2. 修改本地代码库的git remote地址&lt;br&gt;\n3. 提交代码到新的gitlab代码库&lt;/p&gt;\n&lt;h2 id=\&#34;操作\&#34;&gt;操作&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;因为公司使用git提交流程,需要先设置公司主仓库为上游，然后fetch，merge完成提交。所以还修改了git upstream地址。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;先在gitlab上面新建主仓库，使用自己的账号fork主仓库代码。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;本地修改git remote地址。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;git remote remove origin # 删除远程仓库别名  \ngit remote remove upstream # 删除上游仓库别名  \ngit remote add origin git@....... # 添加新的仓库地址  \ngit remote add upstream git@...... # 添加新的上游仓库地址  \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;\n&lt;p&gt;拉取上游和远程仓库&lt;br&gt;\ngit pull origin master # 拉取远程仓库&lt;br&gt;\ngit fetch upstream  # fetch源分支的新版本到本地, 也就是更新upstream主仓库的代码.&lt;br&gt;\ngit merge upstream/master  # 合并主仓库更新的内容&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;提交本地未提交代码&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;git add . # 提交所有未提交内容到缓存区  \ngit commit -m &#39;xxxx&#39; # 为本次提交撰写评论信息&amp;lt;fort clolr=&#39;red&#39;&amp;gt;! 必须&amp;lt;/fort&amp;gt;  \ngit push origin master # 提交代码到远程仓库  \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;5\&#34;&gt;\n&lt;li&gt;在gitlab界面提交PR请求.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;遇到的问题\&#34;&gt;遇到的问题&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;在上述第三步操作时，遇到了问题，错误信息如下：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;$ git pull upstream   \nremote: HTTP Basic: Access denied   \nfatal: Authentication failed for &#39;git仓库地址&#39;   \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;错误原因：访问被拒绝，本地最好配置ssh连接，不要使用http拉取。gitlab都有密码的。&lt;/p&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;在进行git push时遇到的问题，错误信息如下：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;$ git push origin master   \nTo git仓库地址 \n ! [rejected]        master -&amp;gt; master (fetch first)  \nerror: failed to push some refs to &#39;git仓库地址&#39;   \nhint: Updates were rejected because the remote contains work that you do   \nhint: not have locally. This is usually caused by another repository pushing   \nhint: to the same ref. You may want to first integrate the remote changes   \nhint: (e.g., &#39;git pull ...&#39;) before pushing again.   \nhint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.   \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;错误原因：本地代码相对于远程仓库不是最新的代码，需要使用git pull origin xxx  先拉取最新代码&lt;/p&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;在进行git pull时又遇到了问题.错误信息如下:&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;$ git pull origin master  \nFrom git仓库地址  \n * branch            master     -&amp;gt; FETCH_HEAD    \nfatal: refusing to merge unrelated histories  \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;错误原因：因为我们是在gitlab新建了一个仓库，然后将本地本身是github的代码提交过去，git提示我们不能将两个完全不相干的仓库合并。&lt;br&gt;\n解决方法就是加上·--allow-unrelated-histories·参数，参数含义是：&lt;strong&gt;强制&lt;/strong&gt;将两个不相干的仓库合并。&lt;br&gt;\n&lt;fort clolr=&#39;red&#39;&gt;! 此操作风险较大，必须保证gitlab新仓库没有代码，不然合并过程中可能出现冲突&lt;/fort&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;p&gt;至此，迁移仓库的不完美解决方案就算完成了。&lt;/p&gt;\n&lt;p&gt;上述只是git操作中的沧海一粟，只有通过不断的学习，才能进步。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ji-lu-cong-github-qian-yi-dao-gitlabfei-zui-you-jie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;记录从Github迁移到Gitlab(非最优解)&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-11-29 18:27:48&#34;,&#34;dateFormat&#34;:&#34;2018-11-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/ji-lu-cong-github-qian-yi-dao-gitlabfei-zui-you-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:183000,&#34;words&#34;:749,&#34;minutes&#34;:4},&#34;description&#34;:&#34;起因\n公司搭建了自己的代码仓库，使用的gitlab，需要将github上面的代码迁移至本地gitlab仓库。\n思路\n1.在公司代码库建立一个新的代码库\n2. 修改本地代码库的git remote地址\n3. 提交代码到新的gitlab代码库\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B5%B7%E5%9B%A0\&#34;&gt;起因&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%9D%E8%B7%AF\&#34;&gt;思路&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%93%8D%E4%BD%9C\&#34;&gt;操作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;遇到的问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;发现问题\&#34;&gt;发现问题&lt;/h2&gt;\n&lt;p&gt;今天在将项目打包放在线上后，遇到了一个问题，错误堆栈如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;java.io.FileNotFoundException: /tmp/tomcat.3411451253170172517.9998/work/Tomcat/localhost/ROOT/upload_95a9f6c4_32ff_4372_a19b_c447216971a3_00000017.tmp (No such file or directory)\n\tat java.io.FileInputStream.open0(Native Method)\n\tat java.io.FileInputStream.open(FileInputStream.java:195)\n\tat java.io.FileInputStream.&amp;lt;init&amp;gt;(FileInputStream.java:138)\n\tat org.apache.tomcat.util.http.fileupload.disk.DiskFileItem.getInputStream(DiskFileItem.java:194)\n\tat org.apache.catalina.core.ApplicationPart.getInputStream(ApplicationPart.java:100)\n\tat org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile.getInputStream(StandardMultipartHttpServletRequest.java:250)\n\tat cn.anytec.anguan.util.SpringAsyncUtil.analyseDataPersistence(SpringAsyncUtil.java:33)\n\tat cn.anytec.anguan.util.SpringAsyncUtil$$FastClassBySpringCGLIB$$9155c306.invoke(&amp;lt;generated&amp;gt;)\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\n\tat org.springframework.aop.interceptor.AsyncExecutionInterceptor.lambda$invoke$0(AsyncExecutionInterceptor.java:115)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.lang.Thread.run(Thread.java:748)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;分析问题\&#34;&gt;分析问题&lt;/h2&gt;\n&lt;p&gt;代码逻辑主要是将摄像头传递过来的图片进行保存，在开发机win上面没有问题，并且在Linux线上，&lt;strong&gt;第一次报错&lt;/strong&gt;，&lt;strong&gt;第二次不会报错&lt;/strong&gt;，成功运行。&lt;/p&gt;\n&lt;h2 id=\&#34;寻找解决方案\&#34;&gt;寻找解决方案&lt;/h2&gt;\n&lt;p&gt;问题比较离奇，遂Google寻找解决方案。&lt;/p&gt;\n&lt;p&gt;发现已经有大神遇到过此问题，并且给出了完整的解决方案和错误原理分析。&lt;br&gt;\n链接：&lt;a href=\&#34;https://blog.csdn.net/superlover_/article/details/80895946\&#34;&gt;superlovelei&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;解决方案及总结\&#34;&gt;解决方案及总结&lt;/h2&gt;\n&lt;p&gt;虽然大神已经给出了原因，我再次再做一次表述吧。&lt;br&gt;\n在Linux系统中，通过java -jar 运行的项目，会在操作系统的 &lt;code&gt;/tmp/tomcat...&lt;/code&gt; 目录下新建一个目录，上传的文件都会先临时存放在此，而由于linux的系统机制，如果&lt;strong&gt;超过10天&lt;/strong&gt;没有操作过此文件目录，会将目录删除，所以如果当前linux主机第一次运行上传相关的程序或者很久（超过10天）没有操作过此临时目录，就会出现报错。&lt;/p&gt;\n&lt;p&gt;而通过配置springboot的yml文件，修改server的配置文件，手动指定临时目录（不会被机制删除的路径），此问题就迎刃而解。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;server:\n  tomcat:\n    basedir: /tmp\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;java-jar-qi-dong-springboot-xian-shang-bao-cuo-filenotfoundexception&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;java -jar 启动Springboot线上报错FileNotFoundException&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-11-29 17:03:11&#34;,&#34;dateFormat&#34;:&#34;2018-11-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/java-jar-qi-dong-springboot-xian-shang-bao-cuo-filenotfoundexception/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:131000,&#34;words&#34;:501,&#34;minutes&#34;:3},&#34;description&#34;:&#34;发现问题\n今天在将项目打包放在线上后，遇到了一个问题，错误堆栈如下：\njava.io.FileNotFoundException: /tmp/tomcat.3411451253170172517.9998/work/Tomcat/local...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98\&#34;&gt;发现问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98\&#34;&gt;分析问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%BB%E6%89%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\&#34;&gt;寻找解决方案&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%8F%8A%E6%80%BB%E7%BB%93\&#34;&gt;解决方案及总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;教程的主要内容\&#34;&gt;教程的主要内容&lt;/h3&gt;\n&lt;p&gt;MongoDB的基础概念，数据库、集合的创建、基础的增删改查、高级查询的聚合管道&lt;/p&gt;\n&lt;h3 id=\&#34;mongodb是什么它有什么优势为什么要用它\&#34;&gt;MongoDB是什么？它有什么优势（为什么要用它）？&lt;/h3&gt;\n&lt;h4 id=\&#34;mongodb是什么\&#34;&gt;MongoDB是什么：&lt;/h4&gt;\n&lt;p&gt;MongoDB是一款为web应用程序和互联网基础设施设计的数据库管理系统。是&lt;strong&gt;NoSQL&lt;/strong&gt;类型的数据库。同时也是最像关系型数据库的非关系型数据库。&lt;/p&gt;\n&lt;h4 id=\&#34;为什么要用mongodb\&#34;&gt;为什么要用MongoDB：&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;MongoDB提出的是文档、集合的概念，使用BSON（类JSON）作为其数据模型结构，其结构是面向对象的而不是二维表，存储一个用户在MongoDB中是这样子的。&lt;/p&gt;\n&lt;p&gt;{&lt;br&gt;\nusername: &#39;imyzt&#39;,&lt;br&gt;\npassword: &#39;123&#39;&lt;br&gt;\n}&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;使用这样的数据模型，使得MongoDB能在生产环境中提供高读写的能力，吞吐量较于mysql等SQL数据库大大增强。&lt;/p&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;\n&lt;p&gt;易伸缩，自动故障转移。易伸缩指的是提供了分片能力，能对数据集进行分片，数据的存储压力分摊给多台服务器。自动故障转移是副本集的概念，MongoDB能检测主节点是否存活，当失活时能自动提升从节点为主节点，达到故障转移。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;数据模型因为是面向对象的，所以可以表示丰富的、有层级的数据结构，比如博客系统中能把“评论”直接嵌入“文章“的文档中，而不必像myqsl一样创建三张表来描述这样的关系。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;mongodb-xue-xi-bi-ji-ru-men&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MongoDB学习笔记(入门)&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-11-01 16:05:35&#34;,&#34;dateFormat&#34;:&#34;2018-11-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mongodb-xue-xi-bi-ji-ru-men/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:79000,&#34;words&#34;:380,&#34;minutes&#34;:2},&#34;description&#34;:&#34;教程的主要内容\nMongoDB的基础概念，数据库、集合的创建、基础的增删改查、高级查询的聚合管道\nMongoDB是什么？它有什么优势（为什么要用它）？\nMongoDB是什么：\nMongoDB是一款为web应用程序和互联网基础设施设计的数据库...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%99%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9\&#34;&gt;教程的主要内容&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#mongodb%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83\&#34;&gt;MongoDB是什么？它有什么优势（为什么要用它）？&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#mongodb%E6%98%AF%E4%BB%80%E4%B9%88\&#34;&gt;MongoDB是什么：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8mongodb\&#34;&gt;为什么要用MongoDB：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;前言\&#34;&gt;前言&lt;/h3&gt;\n&lt;p&gt;今天在掘金看到了一篇关于SQL优化的文章(&lt;a href=\&#34;https://juejin.im/post/5bcc2935f265da0ac66987c9?utm_source=gold_browser_extension\&#34;&gt;原文在此&lt;/a&gt;)，了解到了Explain工具。本文则是对Explain工具的学习和总结。&lt;/p&gt;\n&lt;h3 id=\&#34;sql语句性能分析工具explain\&#34;&gt;SQL语句性能分析工具Explain&lt;/h3&gt;\n&lt;p&gt;Explain的作用是生成一个QEP（查询执行计划），可以帮助我们在不真正执行SQL的情况下，就能看到SQL怎样执行。&lt;/p&gt;\n&lt;p&gt;执行以下语句：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;EXPLAIN SELECT * FROM t_options WHERE `name` IS NOT NULL GROUP BY `name`   \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;得到如下结果：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://www.imyzt.top/upload/2018/10/q15jvjiuliifcpsncbsdvqpipk.jpg\&#34; alt=\&#34;SQL执行结果\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;对于返回信息，主要关注点在如下几个字段：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;Type&lt;br&gt;\nALL是全表扫描，效率低；其它的index、range、const、ref、system则是比较好的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Possible_keys&lt;br&gt;\n可能被用到的索引&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Key&lt;br&gt;\n查询过程中用到的索引，当为null时，表示没有使用索引，通常是不好的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;ken_len&lt;br&gt;\n索引字段最大可能使用的长度，也叫索引基数。索引基数越大，表示可能查询的行数越多，查询效率越低。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Rows&lt;br&gt;\nMySQL估计的需要扫描的行数，只是估计，越多表示查询的行数越大，自然越慢。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Extra&lt;br&gt;\n显示上述信息之外的其它信息，非常重要。其主要有一下返回结果。&lt;/p&gt;\n&lt;p&gt;Usingindex&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;表明此查询使用了覆盖索引(CoveringIndex)，即通过索引就能返回结果，无需访问表。（覆盖索引是一种非常优秀的索引，其使用见http://blog.csdn.net/hzy38324/article/details/44857721）\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;若没显示&amp;quot;Usingindex&amp;quot;表示读取了表数据。&lt;br&gt;\nUsingindex condition&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;    可能会使用索引    \n\nUsingwhere    \n\n    表示 MySQL 服务器先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。效率较慢。\nUsingfilesort    \n\n    表示Mysql会按查询所需的顺序对结果进行排序，这时就会出现 Usingfilesort 。排序自然会增加查询时间，导致效率变慢。解决方法是利用索引进行排序。若查询所需的排序与使用的索引的排序一致，因为索引是已排序的，因此按索引的顺序读取结果返回，此时就不会出现Using filesort。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;关于“Using index” 和 “Using index condition”的区别，笔者参考了一下&lt;a href=\&#34;http://stackoverflow.com/questions/1687548/mysql-explain-using-index-vs-using-index-condition\&#34;&gt;stackoverflow&lt;/a&gt;上的一篇文章&lt;br&gt;\n简单的说&lt;br&gt;\nUsing index就是一定使用索引，这种索引成为覆盖索引，Using index condition则是在必要的时候才使用索引&lt;br&gt;\n怎样才能让Usingindex condition变成Using index，答案自然是创建一个覆盖索引，同样，笔者将会在之后章节介绍覆盖索引如何创建。&lt;/p&gt;\n&lt;p&gt;参考链接： &lt;a href=\&#34;https://blog.csdn.net/hzy38324/article/details/44921299\&#34;&gt;CSDN&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-sql-yu-ju-zhi-xing-xiao-lu-fen-xi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;MySQL SQL语句执行效率分析&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;数据库&#34;,&#34;slug&#34;:&#34;_LPtQMqgT&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://imyzt.top/tag/_LPtQMqgT/&#34;}],&#34;date&#34;:&#34;2018-10-29 14:35:58&#34;,&#34;dateFormat&#34;:&#34;2018-10-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/mysql-sql-yu-ju-zhi-xing-xiao-lu-fen-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:141000,&#34;words&#34;:646,&#34;minutes&#34;:3},&#34;description&#34;:&#34;前言\n今天在掘金看到了一篇关于SQL优化的文章(原文在此)，了解到了Explain工具。本文则是对Explain工具的学习和总结。\nSQL语句性能分析工具Explain\nExplain的作用是生成一个QEP（查询执行计划），可以帮助我们在不...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sql%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7explain\&#34;&gt;SQL语句性能分析工具Explain&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;七娘山介绍\&#34;&gt;七娘山介绍&lt;/h3&gt;\n&lt;p&gt;七娘山位于龙岗区南澳镇新大村，是大鹏半岛南岛的主要山峰，是深圳市内山脉中仅次于梧桐山的第二高峰。它有七个山峰，主峰海拔高度867米。传说有七个仙女下凡到山上游玩而得名。在抗日战争时期东江纵队曾在山北鸡公秃村办兵工厂，并在山下种过粮食。&lt;/p&gt;\n&lt;h3 id=\&#34;活动时间\&#34;&gt;活动时间&lt;/h3&gt;\n&lt;p&gt;2018年11月24日 - 2018年11月25日&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;行程不是固定的，大家讨论后决定时间。此时间只做参考。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;山车地点\&#34;&gt;山车地点&lt;/h3&gt;\n&lt;p&gt;深圳市地铁三号线爱联地铁站&lt;/p&gt;\n&lt;h3 id=\&#34;出行方式\&#34;&gt;出行方式&lt;/h3&gt;\n&lt;p&gt;打车前往&lt;/p&gt;\n&lt;h3 id=\&#34;预计费用\&#34;&gt;预计费用&lt;/h3&gt;\n&lt;p&gt;150/人，不包含烧烤等餐饮。&lt;/p&gt;\n&lt;h3 id=\&#34;天气预报\&#34;&gt;天气预报&lt;/h3&gt;\n&lt;p&gt;深圳天气：&lt;a href=\&#34;http://www.weather.com.cn/html/weather/101280601.shtml\&#34;&gt;http://www.weather.com.cn/html/weather/101280601.shtml&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;行程及路线安排\&#34;&gt;行程及路线安排&lt;/h3&gt;\n&lt;h5 id=\&#34;路线一\&#34;&gt;路线一&lt;/h5&gt;\n&lt;ul&gt;\n&lt;li&gt;第一天&lt;strong&gt;中午&lt;/strong&gt;市内爱联站集合，打车前往到杨梅坑（预计1小时13分钟，见附图四），然后在杨梅坑腐败一天，杨梅坑5KM处鹿嘴山庄是《美人鱼》拍摄取景地，杨梅坑附近还有著名的露天烧烤。&lt;/li&gt;\n&lt;li&gt;第二天早上出发按照&lt;a href=\&#34;http://www.foooooot.com/trip/863749/\&#34;&gt;轨迹一&lt;/a&gt;（见附图五）开始登山。下午三点左右就能到大鹏半岛地质公园。然后选择公交或打车回到市内。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;选择大鹏半岛地质公园为下山点，回程较为便利。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;路线二\&#34;&gt;路线二&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;第一天同路线一。&lt;/li&gt;\n&lt;li&gt;第二天早上出发按照&lt;a href=\&#34;http://www.foooooot.com/trip/119446/\&#34;&gt;轨迹二&lt;/a&gt;（见附图六）开始登山。预计下午两点左右就能回到深圳东冲海岸。欣赏一下大海景后选择公交或打车回到市内。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;东冲为深圳最美海岸，可以欣赏海景。但是东冲作为深圳最后一个没有省级公路的村，做为下山点可能回程不是特别便利。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;路线三\&#34;&gt;路线三&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;第一天&lt;strong&gt;上午&lt;/strong&gt;市内爱联站集合，打车前往大鹏半岛地质公园（预计1小时9分钟，见附图五），然后按照&lt;a href=\&#34;http://www.foooooot.com/trip/127325/\&#34;&gt;轨迹三&lt;/a&gt;(见附图八)开始登山，当天晚上能到杨梅坑。然后可以选择&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;继续腐败，然后露营，BBQ。第二天通过打车或公交从杨梅坑返回市内。&lt;/li&gt;\n&lt;li&gt;下山后返回市内。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;此路线轨迹类似于路线一，但是大有不同。此路线走的山脊线，攀登较为容易。大部分地段已铺石台阶。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;路线四\&#34;&gt;路线四&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;第一天同路线一。&lt;/li&gt;\n&lt;li&gt;第二天早上出发按照&lt;a href=\&#34;http://www.foooooot.com/trip/258524/\&#34;&gt;轨迹四&lt;/a&gt;（见附图九）开始登山。预计中午能到地质公园。然后选择公交或打车回到市内。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;路线比较短，耗时少。走的另一座山谷，风景不必路线一差。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;线路对比\&#34;&gt;线路对比&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;路线距离：线路一（14.3 公里） &amp;gt; 线路三（12.9 公里） &amp;gt;  线路二（13 公里）  &amp;gt; 路线四(7.6 公里)&lt;/li&gt;\n&lt;li&gt;耗时对比：线路一（2天）== 线路二（2天） &amp;gt; 线路四（2天） &amp;gt; 线路三(1天或2天)&lt;/li&gt;\n&lt;li&gt;难度级别：线路一 &amp;gt; 线路三 &amp;gt; 线路二 &amp;gt; 路线四&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;个人装备\&#34;&gt;个人装备&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;普通装备：双肩背包、手机、雨具；&lt;/li&gt;\n&lt;li&gt;服装：徒步鞋或者军胶、长袖衣裤、太阳帽、手套、毛巾；&lt;/li&gt;\n&lt;li&gt;食品：一餐干粮、3升以上饮用水、功能饮料、榨菜、水果等零食；&lt;/li&gt;\n&lt;li&gt;药品：蛇药、马蜂药、创可贴、蚊怕水、个人特殊品 、十滴水、霍香正气水等防暑用品；&lt;/li&gt;\n&lt;li&gt;其他：头灯、手电、垃圾袋（自己带走垃圾）、个人证件 、少量现金；&lt;/li&gt;\n&lt;li&gt;露营装备：帐篷，睡袋（15度以下），防潮垫。&lt;/li&gt;\n&lt;li&gt;务必购买户外运动保险，保险不是万能的，但少了保险是万万不能的！建议买一份保险做一个有责任心的人&lt;br&gt;\n&lt;font color=&#39;red&#39;&gt;活动自愿，风险自担，雨天顺延&lt;/font&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;注意事项\&#34;&gt;注意事项&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;本次活动无领队，属约伴同行，共同学习 。&lt;/li&gt;\n&lt;li&gt;请报名前做好功课，了解线路的行程线（下撤路线）、难度和强度再决定是否参加。&lt;/li&gt;\n&lt;li&gt;活动所有集体行为全部AA。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;免责声明\&#34;&gt;免责声明&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;本活动为非盈利性质的自助游活动并有一定的危险性，凡报名参加者均视为具有完全民事行为能力人，参加者须对自己的安全负责；凡报名者均视为已接受放弃损害赔偿 。&lt;/li&gt;\n&lt;li&gt;本次活动约伴人与同行驴友均为无偿提供活动的援助、支持者。如在活动中发生人身损害后果，赔偿责任领队不承担，由受损害人依据法律规定和本领队声明依法解决。&lt;/li&gt;\n&lt;li&gt;凡报名者均视为接受声明。代他人报名者，被代报名参加者如遭受人身损害，赔偿责任约伴人同样不承担。&lt;/li&gt;\n&lt;li&gt;本声明中关于免除领队赔偿责任之约定效力，同样及于同行的副领队.协助.财务。&lt;/li&gt;\n&lt;li&gt;启程后，本声明将自动生效并表明你接受本声明，否则，请在启程前退出本次活动。&lt;/li&gt;\n&lt;li&gt;任何法律纠纷在出发地所在法院处理。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;攻略参考文档\&#34;&gt;攻略参考文档&lt;/h2&gt;\n&lt;p&gt;8264：&lt;a href=\&#34;http://bbs.8264.com/thread-2113100-1-1.html\&#34;&gt;http://bbs.8264.com/thread-2113100-1-1.html&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;附图\&#34;&gt;附图&lt;/h2&gt;\n&lt;h4 id=\&#34;附图三七娘山地图\&#34;&gt;附图三：七娘山地图&lt;/h4&gt;\n&lt;p&gt;&lt;img src=\&#34;http://imyzt.top/upload/2018/10/7kg9dntqimi5tolgdafebtjghr.jpg\&#34; alt=\&#34;七娘山地图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1699751313457.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;附图四爱联站-杨梅坑\&#34;&gt;附图四：爱联站-杨梅坑&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;http://www.imyzt.top/upload/2018/11/on0a1d4g1kjjarv9tkjoslugtk.jpg\&#34; alt=\&#34;爱联站-杨梅坑\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;附图五-轨迹一\&#34;&gt;附图五： 轨迹一&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;http://www.imyzt.top/upload/2018/11/ttvmvifde8hljqiepu5up78icp.jpg\&#34; alt=\&#34;轨迹一\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;附图六-轨迹二\&#34;&gt;附图六： 轨迹二&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;http://www.imyzt.top/upload/2018/11/uafoe9dan4ib4ogsgqcaop03gt.jpg\&#34; alt=\&#34;轨迹二\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;附图七-爱联站-地质公园\&#34;&gt;附图七： 爱联站-地质公园&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;http://www.imyzt.top/upload/2018/11/00d0175vgqgs7o6qavuv9njgr7.jpg\&#34; alt=\&#34;爱联站-地质公园\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;附图八轨迹三\&#34;&gt;附图八：轨迹三&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;http://www.imyzt.top/upload/2018/11/s79uqfkb62ihqrkqj94cmior2h.jpg\&#34; alt=\&#34;轨迹三\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;附图九轨迹四\&#34;&gt;附图九：轨迹四&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;http://www.imyzt.top/upload/2018/11/0s5kuudcfsia9rlueao34btqgn.jpg\&#34; alt=\&#34;轨迹四\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;deng-shan-zu-dui&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;登山组队&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-10-29 12:05:37&#34;,&#34;dateFormat&#34;:&#34;2018-10-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/deng-shan-zu-dui/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:281000,&#34;words&#34;:1363,&#34;minutes&#34;:5},&#34;description&#34;:&#34;七娘山介绍\n七娘山位于龙岗区南澳镇新大村，是大鹏半岛南岛的主要山峰，是深圳市内山脉中仅次于梧桐山的第二高峰。它有七个山峰，主峰海拔高度867米。传说有七个仙女下凡到山上游玩而得名。在抗日战争时期东江纵队曾在山北鸡公秃村办兵工厂，并在山下种过...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%83%E5%A8%98%E5%B1%B1%E4%BB%8B%E7%BB%8D\&#34;&gt;七娘山介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B4%BB%E5%8A%A8%E6%97%B6%E9%97%B4\&#34;&gt;活动时间&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%B1%E8%BD%A6%E5%9C%B0%E7%82%B9\&#34;&gt;山车地点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BA%E8%A1%8C%E6%96%B9%E5%BC%8F\&#34;&gt;出行方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%84%E8%AE%A1%E8%B4%B9%E7%94%A8\&#34;&gt;预计费用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5\&#34;&gt;天气预报&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A1%8C%E7%A8%8B%E5%8F%8A%E8%B7%AF%E7%BA%BF%E5%AE%89%E6%8E%92\&#34;&gt;行程及路线安排&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%AF%E7%BA%BF%E4%B8%80\&#34;&gt;路线一&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%AF%E7%BA%BF%E4%BA%8C\&#34;&gt;路线二&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%AF%E7%BA%BF%E4%B8%89\&#34;&gt;路线三&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%AF%E7%BA%BF%E5%9B%9B\&#34;&gt;路线四&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E8%B7%AF%E5%AF%B9%E6%AF%94\&#34;&gt;线路对比&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%AA%E4%BA%BA%E8%A3%85%E5%A4%87\&#34;&gt;个人装备&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\&#34;&gt;注意事项&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E\&#34;&gt;免责声明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%94%BB%E7%95%A5%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3\&#34;&gt;攻略参考文档&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%84%E5%9B%BE\&#34;&gt;附图&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%84%E5%9B%BE%E4%B8%89%E4%B8%83%E5%A8%98%E5%B1%B1%E5%9C%B0%E5%9B%BE\&#34;&gt;附图三：七娘山地图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%84%E5%9B%BE%E5%9B%9B%E7%88%B1%E8%81%94%E7%AB%99-%E6%9D%A8%E6%A2%85%E5%9D%91\&#34;&gt;附图四：爱联站-杨梅坑&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%84%E5%9B%BE%E4%BA%94-%E8%BD%A8%E8%BF%B9%E4%B8%80\&#34;&gt;附图五： 轨迹一&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%84%E5%9B%BE%E5%85%AD-%E8%BD%A8%E8%BF%B9%E4%BA%8C\&#34;&gt;附图六： 轨迹二&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%84%E5%9B%BE%E4%B8%83-%E7%88%B1%E8%81%94%E7%AB%99-%E5%9C%B0%E8%B4%A8%E5%85%AC%E5%9B%AD\&#34;&gt;附图七： 爱联站-地质公园&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%84%E5%9B%BE%E5%85%AB%E8%BD%A8%E8%BF%B9%E4%B8%89\&#34;&gt;附图八：轨迹三&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%84%E5%9B%BE%E4%B9%9D%E8%BD%A8%E8%BF%B9%E5%9B%9B\&#34;&gt;附图九：轨迹四&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1699755949931.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;关于我\&#34;&gt;关于我&lt;/h2&gt;\n&lt;p&gt;我叫杨镇涛，是一名Java程序员。&lt;br&gt;\n现阶段本职工作是Java服务端开发, 平时会花一些时间做 Kubernetes 以及 Spring Cloud 方面的学习研究.&lt;/p&gt;\n&lt;h2 id=\&#34;关于项目\&#34;&gt;关于项目&lt;/h2&gt;\n&lt;p&gt;项目fork 自 &lt;a href=\&#34;https://github.com/ZHENFENG13\&#34;&gt;ZHENFENG13&lt;/a&gt; 大神的 &lt;a href=\&#34;https://github.com/ZHENFENG13/My-Blog\&#34;&gt;My-Blog&lt;/a&gt;， 我对它做了一些私人订制。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Mybatis -&amp;gt; Mybatis Plus&lt;/li&gt;\n&lt;li&gt;实体类使用lombok&lt;/li&gt;\n&lt;li&gt;...&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;开源\&#34;&gt;开源&lt;/h2&gt;\n&lt;p&gt;感谢原作者 tale 的项目， 也感谢 &lt;a href=\&#34;https://github.com/ZHENFENG13\&#34;&gt;ZHENFENG13&lt;/a&gt; 将其改版为Spring版本。&lt;br&gt;\n我的修改版本在我的 &lt;a href=\&#34;https://github.com/imyzt/My-Blog\&#34;&gt;Github&lt;/a&gt; 上。有问题欢迎留言。&lt;/p&gt;\n&lt;h2 id=\&#34;写在最后\&#34;&gt;写在最后&lt;/h2&gt;\n&lt;p&gt;WeChat&lt;br&gt;\n&lt;img src=\&#34;https://imyzt.top/post-images/1699755922644.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;hello-world&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Hello World&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-10-26 15:41:02&#34;,&#34;dateFormat&#34;:&#34;2018-10-26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/hello-world/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:29000,&#34;words&#34;:131,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n关于我\n我叫杨镇涛，是一名Java程序员。\n现阶段本职工作是Java服务端开发, 平时会花一些时间做 Kubernetes 以及 Spring Cloud 方面的学习研究.\n关于项目\n项目fork 自 ZHENFENG13 大神的 My-...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%88%91\&#34;&gt;关于我&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE\&#34;&gt;关于项目&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%80%E6%BA%90\&#34;&gt;开源&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\&#34;&gt;写在最后&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;这是我的个人博客,正在建设中...&lt;br&gt;\n欢迎你的来访.&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://imyzt.top/post-images/1699755680060.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;ni-hao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;你好&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2018-10-20 13:40:51&#34;,&#34;dateFormat&#34;:&#34;2018-10-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://imyzt.top/post/ni-hao/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:3000,&#34;words&#34;:19,&#34;minutes&#34;:1},&#34;description&#34;:&#34;这是我的个人博客,正在建设中...\n欢迎你的来访.\n\n...&#34;,&#34;toc&#34;:&#34;&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->


</html>